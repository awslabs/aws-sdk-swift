// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptPortfolioShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case portfolioShareType = "PortfolioShareType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let portfolioShareType = self.portfolioShareType {
            try encodeContainer.encode(portfolioShareType.rawValue, forKey: .portfolioShareType)
        }
    }
}

extension AcceptPortfolioShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AcceptPortfolioShareInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The type of shared portfolios to accept. The default is to accept imported portfolios.
    ///
    /// * AWS_ORGANIZATIONS - Accept portfolios shared by the management account of your organization.
    ///
    /// * IMPORTED - Accept imported portfolios.
    ///
    /// * AWS_SERVICECATALOG - Not supported. (Throws ResourceNotFoundException.)
    ///
    ///
    /// For example, aws servicecatalog accept-portfolio-share --portfolio-id "port-2qwzkwxt3y5fk" --portfolio-share-type AWS_ORGANIZATIONS
    public var portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?

    public init(
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.portfolioShareType = portfolioShareType
    }
}

struct AcceptPortfolioShareInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?
}

extension AcceptPortfolioShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case portfolioShareType = "PortfolioShareType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let portfolioShareTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PortfolioShareType.self, forKey: .portfolioShareType)
        portfolioShareType = portfolioShareTypeDecoded
    }
}

extension AcceptPortfolioShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AcceptPortfolioShareOutput: Swift.Equatable {

    public init() { }
}

enum AcceptPortfolioShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes.AccessLevelFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.AccessLevelFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// The access level to use to filter results.
    public struct AccessLevelFilter: Swift.Equatable {
        /// The access level.
        ///
        /// * Account - Filter results based on the account.
        ///
        /// * Role - Filter results based on the federated role of the specified user.
        ///
        /// * User - Filter results based on the specified user.
        public var key: ServiceCatalogClientTypes.AccessLevelFilterKey?
        /// The user to which the access level applies. The only supported value is self.
        public var value: Swift.String?

        public init(
            key: ServiceCatalogClientTypes.AccessLevelFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum AccessLevelFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case role
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessLevelFilterKey] {
            return [
                .account,
                .role,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "Account"
            case .role: return "Role"
            case .user: return "User"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessLevelFilterKey(rawValue: rawValue) ?? AccessLevelFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum AccessStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case underChange
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessStatus] {
            return [
                .disabled,
                .enabled,
                .underChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .underChange: return "UNDER_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessStatus(rawValue: rawValue) ?? AccessStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssociateBudgetWithResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension AssociateBudgetWithResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateBudgetWithResourceInput: Swift.Equatable {
    /// The name of the budget you want to associate.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The resource identifier. Either a portfolio-id or a product-id.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        budgetName: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.budgetName = budgetName
        self.resourceId = resourceId
    }
}

struct AssociateBudgetWithResourceInputBody: Swift.Equatable {
    let budgetName: Swift.String?
    let resourceId: Swift.String?
}

extension AssociateBudgetWithResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension AssociateBudgetWithResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateBudgetWithResourceOutput: Swift.Equatable {

    public init() { }
}

enum AssociateBudgetWithResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociatePrincipalWithPortfolioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case principalARN = "PrincipalARN"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let principalARN = self.principalARN {
            try encodeContainer.encode(principalARN, forKey: .principalARN)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

extension AssociatePrincipalWithPortfolioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociatePrincipalWithPortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The ARN of the principal (user, role, or group). If the PrincipalType is IAM, the supported value is a fully defined [IAM Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns). If the PrincipalType is IAM_PATTERN, the supported value is an IAM ARN without an AccountID in the following format: arn:partition:iam:::resource-type/resource-id The ARN resource-id can be either:
    ///
    /// * A fully formed resource-id. For example, arn:aws:iam:::role/resource-name or arn:aws:iam:::role/resource-path/resource-name
    ///
    /// * A wildcard ARN. The wildcard ARN accepts IAM_PATTERN values with a "*" or "?" in the resource-id segment of the ARN. For example arn:partition:service:::resource-type/resource-path/resource-name. The new symbols are exclusive to the resource-path and resource-name and cannot replace the resource-type or other ARN values. The ARN path and principal name allow unlimited wildcard characters.
    ///
    ///
    /// Examples of an acceptable wildcard ARN:
    ///
    /// * arn:aws:iam:::role/ResourceName_*
    ///
    /// * arn:aws:iam:::role/*/ResourceName_?
    ///
    ///
    /// Examples of an unacceptable wildcard ARN:
    ///
    /// * arn:aws:iam:::*/ResourceName
    ///
    ///
    /// You can associate multiple IAM_PATTERNs even if the account has no principal with that name. The "?" wildcard character matches zero or one of any character. This is similar to ".?" in regular regex context. The "*" wildcard character matches any number of any characters. This is similar to ".*" in regular regex context. In the IAM Principal ARN format (arn:partition:iam:::resource-type/resource-path/resource-name), valid resource-type values include user/, group/, or role/. The "?" and "*" characters are allowed only after the resource-type in the resource-id segment. You can use special characters anywhere within the resource-id. The "*" character also matches the "/" character, allowing paths to be formed within the resource-id. For example, arn:aws:iam:::role/*/ResourceName_? matches both arn:aws:iam:::role/pathA/pathB/ResourceName_1 and arn:aws:iam:::role/pathA/ResourceName_1.
    /// This member is required.
    public var principalARN: Swift.String?
    /// The principal type. The supported value is IAM if you use a fully defined Amazon Resource Name (ARN), or IAM_PATTERN if you use an ARN with no accountID, with or without wildcard characters.
    /// This member is required.
    public var principalType: ServiceCatalogClientTypes.PrincipalType?

    public init(
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        principalARN: Swift.String? = nil,
        principalType: ServiceCatalogClientTypes.PrincipalType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.principalARN = principalARN
        self.principalType = principalType
    }
}

struct AssociatePrincipalWithPortfolioInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let principalARN: Swift.String?
    let principalType: ServiceCatalogClientTypes.PrincipalType?
}

extension AssociatePrincipalWithPortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case principalARN = "PrincipalARN"
        case principalType = "PrincipalType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let principalARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalARN)
        principalARN = principalARNDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension AssociatePrincipalWithPortfolioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociatePrincipalWithPortfolioOutput: Swift.Equatable {

    public init() { }
}

enum AssociatePrincipalWithPortfolioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateProductWithPortfolioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case sourcePortfolioId = "SourcePortfolioId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let sourcePortfolioId = self.sourcePortfolioId {
            try encodeContainer.encode(sourcePortfolioId, forKey: .sourcePortfolioId)
        }
    }
}

extension AssociateProductWithPortfolioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateProductWithPortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the source portfolio.
    public var sourcePortfolioId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productId: Swift.String? = nil,
        sourcePortfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.productId = productId
        self.sourcePortfolioId = sourcePortfolioId
    }
}

struct AssociateProductWithPortfolioInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let productId: Swift.String?
    let portfolioId: Swift.String?
    let sourcePortfolioId: Swift.String?
}

extension AssociateProductWithPortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case sourcePortfolioId = "SourcePortfolioId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let sourcePortfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePortfolioId)
        sourcePortfolioId = sourcePortfolioIdDecoded
    }
}

extension AssociateProductWithPortfolioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateProductWithPortfolioOutput: Swift.Equatable {

    public init() { }
}

enum AssociateProductWithPortfolioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateServiceActionWithProvisioningArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let serviceActionId = self.serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

extension AssociateServiceActionWithProvisioningArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateServiceActionWithProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product identifier. For example, prod-abcdzk7xy33qa.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
        self.serviceActionId = serviceActionId
    }
}

struct AssociateServiceActionWithProvisioningArtifactInputBody: Swift.Equatable {
    let productId: Swift.String?
    let provisioningArtifactId: Swift.String?
    let serviceActionId: Swift.String?
    let acceptLanguage: Swift.String?
}

extension AssociateServiceActionWithProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension AssociateServiceActionWithProvisioningArtifactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateServiceActionWithProvisioningArtifactOutput: Swift.Equatable {

    public init() { }
}

enum AssociateServiceActionWithProvisioningArtifactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateTagOptionWithResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagOptionId = "TagOptionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagOptionId = self.tagOptionId {
            try encodeContainer.encode(tagOptionId, forKey: .tagOptionId)
        }
    }
}

extension AssociateTagOptionWithResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateTagOptionWithResourceInput: Swift.Equatable {
    /// The resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The TagOption identifier.
    /// This member is required.
    public var tagOptionId: Swift.String?

    public init(
        resourceId: Swift.String? = nil,
        tagOptionId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
        self.tagOptionId = tagOptionId
    }
}

struct AssociateTagOptionWithResourceInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagOptionId: Swift.String?
}

extension AssociateTagOptionWithResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagOptionId = "TagOptionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagOptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagOptionId)
        tagOptionId = tagOptionIdDecoded
    }
}

extension AssociateTagOptionWithResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateTagOptionWithResourceOutput: Swift.Equatable {

    public init() { }
}

enum AssociateTagOptionWithResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchAssociateServiceActionWithProvisioningArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case serviceActionAssociations = "ServiceActionAssociations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let serviceActionAssociations = serviceActionAssociations {
            var serviceActionAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceActionAssociations)
            for serviceactionassociation0 in serviceActionAssociations {
                try serviceActionAssociationsContainer.encode(serviceactionassociation0)
            }
        }
    }
}

extension BatchAssociateServiceActionWithProvisioningArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchAssociateServiceActionWithProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// One or more associations, each consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.
    /// This member is required.
    public var serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]?

    public init(
        acceptLanguage: Swift.String? = nil,
        serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.serviceActionAssociations = serviceActionAssociations
    }
}

struct BatchAssociateServiceActionWithProvisioningArtifactInputBody: Swift.Equatable {
    let serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]?
    let acceptLanguage: Swift.String?
}

extension BatchAssociateServiceActionWithProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case serviceActionAssociations = "ServiceActionAssociations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionAssociationsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ServiceActionAssociation?].self, forKey: .serviceActionAssociations)
        var serviceActionAssociationsDecoded0:[ServiceCatalogClientTypes.ServiceActionAssociation]? = nil
        if let serviceActionAssociationsContainer = serviceActionAssociationsContainer {
            serviceActionAssociationsDecoded0 = [ServiceCatalogClientTypes.ServiceActionAssociation]()
            for structure0 in serviceActionAssociationsContainer {
                if let structure0 = structure0 {
                    serviceActionAssociationsDecoded0?.append(structure0)
                }
            }
        }
        serviceActionAssociations = serviceActionAssociationsDecoded0
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchAssociateServiceActionWithProvisioningArtifactOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedServiceActionAssociations = output.failedServiceActionAssociations
        } else {
            self.failedServiceActionAssociations = nil
        }
    }
}

public struct BatchAssociateServiceActionWithProvisioningArtifactOutput: Swift.Equatable {
    /// An object that contains a list of errors, along with information to help you identify the self-service action.
    public var failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]?

    public init(
        failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]? = nil
    )
    {
        self.failedServiceActionAssociations = failedServiceActionAssociations
    }
}

struct BatchAssociateServiceActionWithProvisioningArtifactOutputBody: Swift.Equatable {
    let failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]?
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedServiceActionAssociations = "FailedServiceActionAssociations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedServiceActionAssociationsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.FailedServiceActionAssociation?].self, forKey: .failedServiceActionAssociations)
        var failedServiceActionAssociationsDecoded0:[ServiceCatalogClientTypes.FailedServiceActionAssociation]? = nil
        if let failedServiceActionAssociationsContainer = failedServiceActionAssociationsContainer {
            failedServiceActionAssociationsDecoded0 = [ServiceCatalogClientTypes.FailedServiceActionAssociation]()
            for structure0 in failedServiceActionAssociationsContainer {
                if let structure0 = structure0 {
                    failedServiceActionAssociationsDecoded0?.append(structure0)
                }
            }
        }
        failedServiceActionAssociations = failedServiceActionAssociationsDecoded0
    }
}

enum BatchAssociateServiceActionWithProvisioningArtifactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDisassociateServiceActionFromProvisioningArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case serviceActionAssociations = "ServiceActionAssociations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let serviceActionAssociations = serviceActionAssociations {
            var serviceActionAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceActionAssociations)
            for serviceactionassociation0 in serviceActionAssociations {
                try serviceActionAssociationsContainer.encode(serviceactionassociation0)
            }
        }
    }
}

extension BatchDisassociateServiceActionFromProvisioningArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// One or more associations, each consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.
    /// This member is required.
    public var serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]?

    public init(
        acceptLanguage: Swift.String? = nil,
        serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.serviceActionAssociations = serviceActionAssociations
    }
}

struct BatchDisassociateServiceActionFromProvisioningArtifactInputBody: Swift.Equatable {
    let serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]?
    let acceptLanguage: Swift.String?
}

extension BatchDisassociateServiceActionFromProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case serviceActionAssociations = "ServiceActionAssociations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionAssociationsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ServiceActionAssociation?].self, forKey: .serviceActionAssociations)
        var serviceActionAssociationsDecoded0:[ServiceCatalogClientTypes.ServiceActionAssociation]? = nil
        if let serviceActionAssociationsContainer = serviceActionAssociationsContainer {
            serviceActionAssociationsDecoded0 = [ServiceCatalogClientTypes.ServiceActionAssociation]()
            for structure0 in serviceActionAssociationsContainer {
                if let structure0 = structure0 {
                    serviceActionAssociationsDecoded0?.append(structure0)
                }
            }
        }
        serviceActionAssociations = serviceActionAssociationsDecoded0
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDisassociateServiceActionFromProvisioningArtifactOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedServiceActionAssociations = output.failedServiceActionAssociations
        } else {
            self.failedServiceActionAssociations = nil
        }
    }
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactOutput: Swift.Equatable {
    /// An object that contains a list of errors, along with information to help you identify the self-service action.
    public var failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]?

    public init(
        failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]? = nil
    )
    {
        self.failedServiceActionAssociations = failedServiceActionAssociations
    }
}

struct BatchDisassociateServiceActionFromProvisioningArtifactOutputBody: Swift.Equatable {
    let failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]?
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedServiceActionAssociations = "FailedServiceActionAssociations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedServiceActionAssociationsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.FailedServiceActionAssociation?].self, forKey: .failedServiceActionAssociations)
        var failedServiceActionAssociationsDecoded0:[ServiceCatalogClientTypes.FailedServiceActionAssociation]? = nil
        if let failedServiceActionAssociationsContainer = failedServiceActionAssociationsContainer {
            failedServiceActionAssociationsDecoded0 = [ServiceCatalogClientTypes.FailedServiceActionAssociation]()
            for structure0 in failedServiceActionAssociationsContainer {
                if let structure0 = structure0 {
                    failedServiceActionAssociationsDecoded0?.append(structure0)
                }
            }
        }
        failedServiceActionAssociations = failedServiceActionAssociationsDecoded0
    }
}

enum BatchDisassociateServiceActionFromProvisioningArtifactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes.BudgetDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a budget.
    public struct BudgetDetail: Swift.Equatable {
        /// Name of the associated budget.
        public var budgetName: Swift.String?

        public init(
            budgetName: Swift.String? = nil
        )
        {
            self.budgetName = budgetName
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ChangeAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case modify
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeAction] {
            return [
                .add,
                .modify,
                .remove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .modify: return "MODIFY"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeAction(rawValue: rawValue) ?? ChangeAction.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.CloudWatchDashboard: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a CloudWatch dashboard.
    public struct CloudWatchDashboard: Swift.Equatable {
        /// The name of the CloudWatch dashboard.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ServiceCatalogClientTypes.CodeStarParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactPath = "ArtifactPath"
        case branch = "Branch"
        case connectionArn = "ConnectionArn"
        case repository = "Repository"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactPath = self.artifactPath {
            try encodeContainer.encode(artifactPath, forKey: .artifactPath)
        }
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let repository = self.repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let artifactPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactPath)
        artifactPath = artifactPathDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// The subtype containing details about the Codestar connection Type.
    public struct CodeStarParameters: Swift.Equatable {
        /// The absolute path wehre the artifact resides within the repo and branch, formatted as "folder/file.json."
        /// This member is required.
        public var artifactPath: Swift.String?
        /// The specific branch where the artifact resides.
        /// This member is required.
        public var branch: Swift.String?
        /// The CodeStar ARN, which is the connection between Service Catalog and the external repository.
        /// This member is required.
        public var connectionArn: Swift.String?
        /// The specific repository where the products artifact-to-be-synced resides, formatted as "Account/Repo."
        /// This member is required.
        public var repository: Swift.String?

        public init(
            artifactPath: Swift.String? = nil,
            branch: Swift.String? = nil,
            connectionArn: Swift.String? = nil,
            repository: Swift.String? = nil
        )
        {
            self.artifactPath = artifactPath
            self.branch = branch
            self.connectionArn = connectionArn
            self.repository = repository
        }
    }

}

extension ServiceCatalogClientTypes.ConstraintDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintId = "ConstraintId"
        case description = "Description"
        case owner = "Owner"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraintId = self.constraintId {
            try encodeContainer.encode(constraintId, forKey: .constraintId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraintId)
        constraintId = constraintIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a constraint.
    public struct ConstraintDetail: Swift.Equatable {
        /// The identifier of the constraint.
        public var constraintId: Swift.String?
        /// The description of the constraint.
        public var description: Swift.String?
        /// The owner of the constraint.
        public var owner: Swift.String?
        /// The identifier of the portfolio the product resides in. The constraint applies only to the instance of the product that lives within this portfolio.
        public var portfolioId: Swift.String?
        /// The identifier of the product the constraint applies to. Note that a constraint applies to a specific instance of a product within a certain portfolio.
        public var productId: Swift.String?
        /// The type of constraint.
        ///
        /// * LAUNCH
        ///
        /// * NOTIFICATION
        ///
        /// * STACKSET
        ///
        /// * TEMPLATE
        public var type: Swift.String?

        public init(
            constraintId: Swift.String? = nil,
            description: Swift.String? = nil,
            owner: Swift.String? = nil,
            portfolioId: Swift.String? = nil,
            productId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.constraintId = constraintId
            self.description = description
            self.owner = owner
            self.portfolioId = portfolioId
            self.productId = productId
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes.ConstraintSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Summary information about a constraint.
    public struct ConstraintSummary: Swift.Equatable {
        /// The description of the constraint.
        public var description: Swift.String?
        /// The type of constraint.
        ///
        /// * LAUNCH
        ///
        /// * NOTIFICATION
        ///
        /// * STACKSET
        ///
        /// * TEMPLATE
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum CopyOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case copytags
        case sdkUnknown(Swift.String)

        public static var allCases: [CopyOption] {
            return [
                .copytags,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .copytags: return "CopyTags"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CopyOption(rawValue: rawValue) ?? CopyOption.sdkUnknown(rawValue)
        }
    }
}

extension CopyProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case copyOptions = "CopyOptions"
        case idempotencyToken = "IdempotencyToken"
        case sourceProductArn = "SourceProductArn"
        case sourceProvisioningArtifactIdentifiers = "SourceProvisioningArtifactIdentifiers"
        case targetProductId = "TargetProductId"
        case targetProductName = "TargetProductName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let copyOptions = copyOptions {
            var copyOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .copyOptions)
            for copyoption0 in copyOptions {
                try copyOptionsContainer.encode(copyoption0.rawValue)
            }
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let sourceProductArn = self.sourceProductArn {
            try encodeContainer.encode(sourceProductArn, forKey: .sourceProductArn)
        }
        if let sourceProvisioningArtifactIdentifiers = sourceProvisioningArtifactIdentifiers {
            var sourceProvisioningArtifactIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceProvisioningArtifactIdentifiers)
            for sourceprovisioningartifactpropertiesmap0 in sourceProvisioningArtifactIdentifiers {
                var sourceprovisioningartifactpropertiesmap0Container = sourceProvisioningArtifactIdentifiersContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, sourceProvisioningArtifactPropertiesMap1) in sourceprovisioningartifactpropertiesmap0 {
                    try sourceprovisioningartifactpropertiesmap0Container.encode(sourceProvisioningArtifactPropertiesMap1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let targetProductId = self.targetProductId {
            try encodeContainer.encode(targetProductId, forKey: .targetProductId)
        }
        if let targetProductName = self.targetProductName {
            try encodeContainer.encode(targetProductName, forKey: .targetProductName)
        }
    }
}

extension CopyProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CopyProductInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The copy options. If the value is CopyTags, the tags from the source product are copied to the target product.
    public var copyOptions: [ServiceCatalogClientTypes.CopyOption]?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the source product.
    /// This member is required.
    public var sourceProductArn: Swift.String?
    /// The identifiers of the provisioning artifacts (also known as versions) of the product to copy. By default, all provisioning artifacts are copied.
    public var sourceProvisioningArtifactIdentifiers: [[Swift.String:Swift.String]]?
    /// The identifier of the target product. By default, a new product is created.
    public var targetProductId: Swift.String?
    /// A name for the target product. The default is the name of the source product.
    public var targetProductName: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        copyOptions: [ServiceCatalogClientTypes.CopyOption]? = nil,
        idempotencyToken: Swift.String? = nil,
        sourceProductArn: Swift.String? = nil,
        sourceProvisioningArtifactIdentifiers: [[Swift.String:Swift.String]]? = nil,
        targetProductId: Swift.String? = nil,
        targetProductName: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.copyOptions = copyOptions
        self.idempotencyToken = idempotencyToken
        self.sourceProductArn = sourceProductArn
        self.sourceProvisioningArtifactIdentifiers = sourceProvisioningArtifactIdentifiers
        self.targetProductId = targetProductId
        self.targetProductName = targetProductName
    }
}

struct CopyProductInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let sourceProductArn: Swift.String?
    let targetProductId: Swift.String?
    let targetProductName: Swift.String?
    let sourceProvisioningArtifactIdentifiers: [[Swift.String:Swift.String]]?
    let copyOptions: [ServiceCatalogClientTypes.CopyOption]?
    let idempotencyToken: Swift.String?
}

extension CopyProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case copyOptions = "CopyOptions"
        case idempotencyToken = "IdempotencyToken"
        case sourceProductArn = "SourceProductArn"
        case sourceProvisioningArtifactIdentifiers = "SourceProvisioningArtifactIdentifiers"
        case targetProductId = "TargetProductId"
        case targetProductName = "TargetProductName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let sourceProductArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceProductArn)
        sourceProductArn = sourceProductArnDecoded
        let targetProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetProductId)
        targetProductId = targetProductIdDecoded
        let targetProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetProductName)
        targetProductName = targetProductNameDecoded
        let sourceProvisioningArtifactIdentifiersContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .sourceProvisioningArtifactIdentifiers)
        var sourceProvisioningArtifactIdentifiersDecoded0:[[Swift.String:Swift.String]]? = nil
        if let sourceProvisioningArtifactIdentifiersContainer = sourceProvisioningArtifactIdentifiersContainer {
            sourceProvisioningArtifactIdentifiersDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in sourceProvisioningArtifactIdentifiersContainer {
                var sourceProvisioningArtifactIdentifiersContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    sourceProvisioningArtifactIdentifiersContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, provisioningartifactpropertyvalue1) in map0 {
                        if let provisioningartifactpropertyvalue1 = provisioningartifactpropertyvalue1 {
                            sourceProvisioningArtifactIdentifiersContainerDecoded0?[key1] = provisioningartifactpropertyvalue1
                        }
                    }
                }
                if let sourceProvisioningArtifactIdentifiersContainerDecoded0 = sourceProvisioningArtifactIdentifiersContainerDecoded0 {
                    sourceProvisioningArtifactIdentifiersDecoded0?.append(sourceProvisioningArtifactIdentifiersContainerDecoded0)
                }
            }
        }
        sourceProvisioningArtifactIdentifiers = sourceProvisioningArtifactIdentifiersDecoded0
        let copyOptionsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.CopyOption?].self, forKey: .copyOptions)
        var copyOptionsDecoded0:[ServiceCatalogClientTypes.CopyOption]? = nil
        if let copyOptionsContainer = copyOptionsContainer {
            copyOptionsDecoded0 = [ServiceCatalogClientTypes.CopyOption]()
            for enum0 in copyOptionsContainer {
                if let enum0 = enum0 {
                    copyOptionsDecoded0?.append(enum0)
                }
            }
        }
        copyOptions = copyOptionsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CopyProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CopyProductOutputBody = try responseDecoder.decode(responseBody: data)
            self.copyProductToken = output.copyProductToken
        } else {
            self.copyProductToken = nil
        }
    }
}

public struct CopyProductOutput: Swift.Equatable {
    /// The token to use to track the progress of the operation.
    public var copyProductToken: Swift.String?

    public init(
        copyProductToken: Swift.String? = nil
    )
    {
        self.copyProductToken = copyProductToken
    }
}

struct CopyProductOutputBody: Swift.Equatable {
    let copyProductToken: Swift.String?
}

extension CopyProductOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyProductToken = "CopyProductToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyProductTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .copyProductToken)
        copyProductToken = copyProductTokenDecoded
    }
}

enum CopyProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum CopyProductStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CopyProductStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CopyProductStatus(rawValue: rawValue) ?? CopyProductStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateConstraintInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case parameters = "Parameters"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

extension CreateConstraintInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConstraintInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The description of the constraint.
    public var description: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The constraint parameters, in JSON format. The syntax depends on the constraint type as follows: LAUNCH You are required to specify either the RoleArn or the LocalRoleName but can't use both. Specify the RoleArn property as follows: {"RoleArn" : "arn:aws:iam::123456789012:role/LaunchRole"} Specify the LocalRoleName property as follows: {"LocalRoleName": "SCBasicLaunchRole"} If you specify the LocalRoleName property, when an account uses the launch constraint, the IAM role with that name in the account will be used. This allows launch-role constraints to be account-agnostic so the administrator can create fewer resources per shared account. The given role name must exist in the account used to create the launch constraint and the account of the user who launches a product with this launch constraint. You cannot have both a LAUNCH and a STACKSET constraint. You also cannot have more than one LAUNCH constraint on a product and portfolio. NOTIFICATION Specify the NotificationArns property as follows: {"NotificationArns" : ["arn:aws:sns:us-east-1:123456789012:Topic"]} RESOURCE_UPDATE Specify the TagUpdatesOnProvisionedProduct property as follows: {"Version":"2.0","Properties":{"TagUpdateOnProvisionedProduct":"String"}} The TagUpdatesOnProvisionedProduct property accepts a string value of ALLOWED or NOT_ALLOWED. STACKSET Specify the Parameters property as follows: {"Version": "String", "Properties": {"AccountList": [ "String" ], "RegionList": [ "String" ], "AdminRole": "String", "ExecutionRole": "String"}} You cannot have both a LAUNCH and a STACKSET constraint. You also cannot have more than one STACKSET constraint on a product and portfolio. Products with a STACKSET constraint will launch an CloudFormation stack set. TEMPLATE Specify the Rules property. For more information, see [Template Constraint Rules](http://docs.aws.amazon.com/servicecatalog/latest/adminguide/reference-template_constraint_rules.html).
    /// This member is required.
    public var parameters: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The type of constraint.
    ///
    /// * LAUNCH
    ///
    /// * NOTIFICATION
    ///
    /// * RESOURCE_UPDATE
    ///
    /// * STACKSET
    ///
    /// * TEMPLATE
    /// This member is required.
    public var type: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        description: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        parameters: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productId: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.idempotencyToken = idempotencyToken
        self.parameters = parameters
        self.portfolioId = portfolioId
        self.productId = productId
        self.type = type
    }
}

struct CreateConstraintInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let productId: Swift.String?
    let parameters: Swift.String?
    let type: Swift.String?
    let description: Swift.String?
    let idempotencyToken: Swift.String?
}

extension CreateConstraintInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case parameters = "Parameters"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateConstraintOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConstraintOutputBody = try responseDecoder.decode(responseBody: data)
            self.constraintDetail = output.constraintDetail
            self.constraintParameters = output.constraintParameters
            self.status = output.status
        } else {
            self.constraintDetail = nil
            self.constraintParameters = nil
            self.status = nil
        }
    }
}

public struct CreateConstraintOutput: Swift.Equatable {
    /// Information about the constraint.
    public var constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    /// The constraint parameters.
    public var constraintParameters: Swift.String?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init(
        constraintDetail: ServiceCatalogClientTypes.ConstraintDetail? = nil,
        constraintParameters: Swift.String? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.constraintDetail = constraintDetail
        self.constraintParameters = constraintParameters
        self.status = status
    }
}

struct CreateConstraintOutputBody: Swift.Equatable {
    let constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    let constraintParameters: Swift.String?
    let status: ServiceCatalogClientTypes.Status?
}

extension CreateConstraintOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintDetail = "ConstraintDetail"
        case constraintParameters = "ConstraintParameters"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ConstraintDetail.self, forKey: .constraintDetail)
        constraintDetail = constraintDetailDecoded
        let constraintParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraintParameters)
        constraintParameters = constraintParametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateConstraintOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePortfolioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case providerName = "ProviderName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePortfolioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The description of the portfolio.
    public var description: Swift.String?
    /// The name to use for display purposes.
    /// This member is required.
    public var displayName: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The name of the portfolio provider.
    /// This member is required.
    public var providerName: Swift.String?
    /// One or more tags.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        acceptLanguage: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        providerName: Swift.String? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.displayName = displayName
        self.idempotencyToken = idempotencyToken
        self.providerName = providerName
        self.tags = tags
    }
}

struct CreatePortfolioInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let providerName: Swift.String?
    let tags: [ServiceCatalogClientTypes.Tag]?
    let idempotencyToken: Swift.String?
}

extension CreatePortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case providerName = "ProviderName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreatePortfolioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePortfolioOutputBody = try responseDecoder.decode(responseBody: data)
            self.portfolioDetail = output.portfolioDetail
            self.tags = output.tags
        } else {
            self.portfolioDetail = nil
            self.tags = nil
        }
    }
}

public struct CreatePortfolioOutput: Swift.Equatable {
    /// Information about the portfolio.
    public var portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    /// Information about the tags associated with the portfolio.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.portfolioDetail = portfolioDetail
        self.tags = tags
    }
}

struct CreatePortfolioOutputBody: Swift.Equatable {
    let portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    let tags: [ServiceCatalogClientTypes.Tag]?
}

extension CreatePortfolioOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioDetail = "PortfolioDetail"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PortfolioDetail.self, forKey: .portfolioDetail)
        portfolioDetail = portfolioDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreatePortfolioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePortfolioShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
        case sharePrincipals = "SharePrincipals"
        case shareTagOptions = "ShareTagOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let organizationNode = self.organizationNode {
            try encodeContainer.encode(organizationNode, forKey: .organizationNode)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let sharePrincipals = self.sharePrincipals {
            try encodeContainer.encode(sharePrincipals, forKey: .sharePrincipals)
        }
        if let shareTagOptions = self.shareTagOptions {
            try encodeContainer.encode(shareTagOptions, forKey: .shareTagOptions)
        }
    }
}

extension CreatePortfolioShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePortfolioShareInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The Amazon Web Services account ID. For example, 123456789012.
    public var accountId: Swift.String?
    /// The organization node to whom you are going to share. When you pass OrganizationNode, it creates PortfolioShare for all of the Amazon Web Services accounts that are associated to the OrganizationNode. The output returns a PortfolioShareToken, which enables the administrator to monitor the status of the PortfolioShare creation process.
    public var organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// Enables or disables Principal sharing when creating the portfolio share. If this flag is not provided, principal sharing is disabled. When you enable Principal Name Sharing for a portfolio share, the share recipient account end users with a principal that matches any of the associated IAM patterns can provision products from the portfolio. Once shared, the share recipient can view associations of PrincipalType: IAM_PATTERN on their portfolio. You can create the principals in the recipient account before or after creating the share.
    public var sharePrincipals: Swift.Bool?
    /// Enables or disables TagOptions  sharing when creating the portfolio share. If this flag is not provided, TagOptions sharing is disabled.
    public var shareTagOptions: Swift.Bool?

    public init(
        acceptLanguage: Swift.String? = nil,
        accountId: Swift.String? = nil,
        organizationNode: ServiceCatalogClientTypes.OrganizationNode? = nil,
        portfolioId: Swift.String? = nil,
        sharePrincipals: Swift.Bool? = nil,
        shareTagOptions: Swift.Bool? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accountId = accountId
        self.organizationNode = organizationNode
        self.portfolioId = portfolioId
        self.sharePrincipals = sharePrincipals
        self.shareTagOptions = shareTagOptions
    }
}

struct CreatePortfolioShareInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let accountId: Swift.String?
    let organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    let shareTagOptions: Swift.Bool?
    let sharePrincipals: Swift.Bool?
}

extension CreatePortfolioShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
        case sharePrincipals = "SharePrincipals"
        case shareTagOptions = "ShareTagOptions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationNodeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.OrganizationNode.self, forKey: .organizationNode)
        organizationNode = organizationNodeDecoded
        let shareTagOptionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .shareTagOptions)
        shareTagOptions = shareTagOptionsDecoded
        let sharePrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharePrincipals)
        sharePrincipals = sharePrincipalsDecoded
    }
}

extension CreatePortfolioShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePortfolioShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.portfolioShareToken = output.portfolioShareToken
        } else {
            self.portfolioShareToken = nil
        }
    }
}

public struct CreatePortfolioShareOutput: Swift.Equatable {
    /// The portfolio shares a unique identifier that only returns if the portfolio is shared to an organization node.
    public var portfolioShareToken: Swift.String?

    public init(
        portfolioShareToken: Swift.String? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
    }
}

struct CreatePortfolioShareOutputBody: Swift.Equatable {
    let portfolioShareToken: Swift.String?
}

extension CreatePortfolioShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
    }
}

enum CreatePortfolioShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case distributor = "Distributor"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case owner = "Owner"
        case productType = "ProductType"
        case provisioningArtifactParameters = "ProvisioningArtifactParameters"
        case sourceConnection = "SourceConnection"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributor = self.distributor {
            try encodeContainer.encode(distributor, forKey: .distributor)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let provisioningArtifactParameters = self.provisioningArtifactParameters {
            try encodeContainer.encode(provisioningArtifactParameters, forKey: .provisioningArtifactParameters)
        }
        if let sourceConnection = self.sourceConnection {
            try encodeContainer.encode(sourceConnection, forKey: .sourceConnection)
        }
        if let supportDescription = self.supportDescription {
            try encodeContainer.encode(supportDescription, forKey: .supportDescription)
        }
        if let supportEmail = self.supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportUrl = self.supportUrl {
            try encodeContainer.encode(supportUrl, forKey: .supportUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProductInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The description of the product.
    public var description: Swift.String?
    /// The distributor of the product.
    public var distributor: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The name of the product.
    /// This member is required.
    public var name: Swift.String?
    /// The owner of the product.
    /// This member is required.
    public var owner: Swift.String?
    /// The type of product.
    /// This member is required.
    public var productType: ServiceCatalogClientTypes.ProductType?
    /// The configuration of the provisioning artifact.
    public var provisioningArtifactParameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties?
    /// Specifies connection details for the created product and syncs the product to the connection source artifact. This automatically manages the product's artifacts based on changes to the source. The SourceConnection parameter consists of the following sub-fields.
    ///
    /// * Type
    ///
    /// * ConnectionParamters
    public var sourceConnection: ServiceCatalogClientTypes.SourceConnection?
    /// The support information about the product.
    public var supportDescription: Swift.String?
    /// The contact email for product support.
    public var supportEmail: Swift.String?
    /// The contact URL for product support. ^https?:\/\// / is the pattern used to validate SupportUrl.
    public var supportUrl: Swift.String?
    /// One or more tags.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        acceptLanguage: Swift.String? = nil,
        description: Swift.String? = nil,
        distributor: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        productType: ServiceCatalogClientTypes.ProductType? = nil,
        provisioningArtifactParameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties? = nil,
        sourceConnection: ServiceCatalogClientTypes.SourceConnection? = nil,
        supportDescription: Swift.String? = nil,
        supportEmail: Swift.String? = nil,
        supportUrl: Swift.String? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.distributor = distributor
        self.idempotencyToken = idempotencyToken
        self.name = name
        self.owner = owner
        self.productType = productType
        self.provisioningArtifactParameters = provisioningArtifactParameters
        self.sourceConnection = sourceConnection
        self.supportDescription = supportDescription
        self.supportEmail = supportEmail
        self.supportUrl = supportUrl
        self.tags = tags
    }
}

struct CreateProductInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let name: Swift.String?
    let owner: Swift.String?
    let description: Swift.String?
    let distributor: Swift.String?
    let supportDescription: Swift.String?
    let supportEmail: Swift.String?
    let supportUrl: Swift.String?
    let productType: ServiceCatalogClientTypes.ProductType?
    let tags: [ServiceCatalogClientTypes.Tag]?
    let provisioningArtifactParameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties?
    let idempotencyToken: Swift.String?
    let sourceConnection: ServiceCatalogClientTypes.SourceConnection?
}

extension CreateProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case distributor = "Distributor"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case owner = "Owner"
        case productType = "ProductType"
        case provisioningArtifactParameters = "ProvisioningArtifactParameters"
        case sourceConnection = "SourceConnection"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributor)
        distributor = distributorDecoded
        let supportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportDescription)
        supportDescription = supportDescriptionDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportUrl)
        supportUrl = supportUrlDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let provisioningArtifactParametersDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactProperties.self, forKey: .provisioningArtifactParameters)
        provisioningArtifactParameters = provisioningArtifactParametersDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let sourceConnectionDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SourceConnection.self, forKey: .sourceConnection)
        sourceConnection = sourceConnectionDecoded
    }
}

extension CreateProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProductOutputBody = try responseDecoder.decode(responseBody: data)
            self.productViewDetail = output.productViewDetail
            self.provisioningArtifactDetail = output.provisioningArtifactDetail
            self.tags = output.tags
        } else {
            self.productViewDetail = nil
            self.provisioningArtifactDetail = nil
            self.tags = nil
        }
    }
}

public struct CreateProductOutput: Swift.Equatable {
    /// Information about the product view.
    public var productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    /// Information about the provisioning artifact.
    public var provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    /// Information about the tags associated with the product.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        productViewDetail: ServiceCatalogClientTypes.ProductViewDetail? = nil,
        provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.productViewDetail = productViewDetail
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.tags = tags
    }
}

struct CreateProductOutputBody: Swift.Equatable {
    let productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    let provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    let tags: [ServiceCatalogClientTypes.Tag]?
}

extension CreateProductOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productViewDetail = "ProductViewDetail"
        case provisioningArtifactDetail = "ProvisioningArtifactDetail"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewDetail.self, forKey: .productViewDetail)
        productViewDetail = productViewDetailDecoded
        let provisioningArtifactDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactDetail.self, forKey: .provisioningArtifactDetail)
        provisioningArtifactDetail = provisioningArtifactDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProvisionedProductPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case planName = "PlanName"
        case planType = "PlanType"
        case productId = "ProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningParameters = "ProvisioningParameters"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for notificationarn0 in notificationArns {
                try notificationArnsContainer.encode(notificationarn0)
            }
        }
        if let pathId = self.pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let planName = self.planName {
            try encodeContainer.encode(planName, forKey: .planName)
        }
        if let planType = self.planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisionedProductName = self.provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningParameters = provisioningParameters {
            var provisioningParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .provisioningParameters)
            for updateprovisioningparameter0 in provisioningParameters {
                try provisioningParametersContainer.encode(updateprovisioningparameter0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateProvisionedProductPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProvisionedProductPlanInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.
    public var notificationArns: [Swift.String]?
    /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use [ListLaunchPaths].
    public var pathId: Swift.String?
    /// The name of the plan.
    /// This member is required.
    public var planName: Swift.String?
    /// The plan type.
    /// This member is required.
    public var planType: ServiceCatalogClientTypes.ProvisionedProductPlanType?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// A user-friendly name for the provisioned product. This value must be unique for the Amazon Web Services account and cannot be updated after the product is provisioned.
    /// This member is required.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?
    /// Parameters specified by the administrator that are required for provisioning the product.
    public var provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
    /// One or more tags. If the plan is for an existing provisioned product, the product must have a RESOURCE_UPDATE constraint with TagUpdatesOnProvisionedProduct set to ALLOWED to allow tag updates.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        notificationArns: [Swift.String]? = nil,
        pathId: Swift.String? = nil,
        planName: Swift.String? = nil,
        planType: ServiceCatalogClientTypes.ProvisionedProductPlanType? = nil,
        productId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.notificationArns = notificationArns
        self.pathId = pathId
        self.planName = planName
        self.planType = planType
        self.productId = productId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningParameters = provisioningParameters
        self.tags = tags
    }
}

struct CreateProvisionedProductPlanInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let planName: Swift.String?
    let planType: ServiceCatalogClientTypes.ProvisionedProductPlanType?
    let notificationArns: [Swift.String]?
    let pathId: Swift.String?
    let productId: Swift.String?
    let provisionedProductName: Swift.String?
    let provisioningArtifactId: Swift.String?
    let provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
    let idempotencyToken: Swift.String?
    let tags: [ServiceCatalogClientTypes.Tag]?
}

extension CreateProvisionedProductPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case planName = "PlanName"
        case planType = "PlanType"
        case productId = "ProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningParameters = "ProvisioningParameters"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let planNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planName)
        planName = planNameDecoded
        let planTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let notificationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[Swift.String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [Swift.String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let pathIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.UpdateProvisioningParameter?].self, forKey: .provisioningParameters)
        var provisioningParametersDecoded0:[ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil
        if let provisioningParametersContainer = provisioningParametersContainer {
            provisioningParametersDecoded0 = [ServiceCatalogClientTypes.UpdateProvisioningParameter]()
            for structure0 in provisioningParametersContainer {
                if let structure0 = structure0 {
                    provisioningParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningParameters = provisioningParametersDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProvisionedProductPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProvisionedProductPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.planId = output.planId
            self.planName = output.planName
            self.provisionProductId = output.provisionProductId
            self.provisionedProductName = output.provisionedProductName
            self.provisioningArtifactId = output.provisioningArtifactId
        } else {
            self.planId = nil
            self.planName = nil
            self.provisionProductId = nil
            self.provisionedProductName = nil
            self.provisioningArtifactId = nil
        }
    }
}

public struct CreateProvisionedProductPlanOutput: Swift.Equatable {
    /// The plan identifier.
    public var planId: Swift.String?
    /// The name of the plan.
    public var planName: Swift.String?
    /// The product identifier.
    public var provisionProductId: Swift.String?
    /// The user-friendly name of the provisioned product.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact.
    public var provisioningArtifactId: Swift.String?

    public init(
        planId: Swift.String? = nil,
        planName: Swift.String? = nil,
        provisionProductId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.planId = planId
        self.planName = planName
        self.provisionProductId = provisionProductId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct CreateProvisionedProductPlanOutputBody: Swift.Equatable {
    let planName: Swift.String?
    let planId: Swift.String?
    let provisionProductId: Swift.String?
    let provisionedProductName: Swift.String?
    let provisioningArtifactId: Swift.String?
}

extension CreateProvisionedProductPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case planId = "PlanId"
        case planName = "PlanName"
        case provisionProductId = "ProvisionProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let planNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planName)
        planName = planNameDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planId)
        planId = planIdDecoded
        let provisionProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionProductId)
        provisionProductId = provisionProductIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
    }
}

enum CreateProvisionedProductPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProvisioningArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case parameters = "Parameters"
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

extension CreateProvisioningArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The configuration for the provisioning artifact.
    /// This member is required.
    public var parameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        parameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.parameters = parameters
        self.productId = productId
    }
}

struct CreateProvisioningArtifactInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let productId: Swift.String?
    let parameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties?
    let idempotencyToken: Swift.String?
}

extension CreateProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case parameters = "Parameters"
        case productId = "ProductId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactProperties.self, forKey: .parameters)
        parameters = parametersDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateProvisioningArtifactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProvisioningArtifactOutputBody = try responseDecoder.decode(responseBody: data)
            self.info = output.info
            self.provisioningArtifactDetail = output.provisioningArtifactDetail
            self.status = output.status
        } else {
            self.info = nil
            self.provisioningArtifactDetail = nil
            self.status = nil
        }
    }
}

public struct CreateProvisioningArtifactOutput: Swift.Equatable {
    /// Specify the template source with one of the following options, but not both. Keys accepted: [ LoadTemplateFromURL, ImportFromPhysicalId ]. Use the URL of the CloudFormation template in Amazon S3 or GitHub in JSON format. LoadTemplateFromURL Use the URL of the CloudFormation template in Amazon S3 or GitHub in JSON format. ImportFromPhysicalId Use the physical id of the resource that contains the template; currently supports CloudFormation stack ARN.
    public var info: [Swift.String:Swift.String]?
    /// Information about the provisioning artifact.
    public var provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init(
        info: [Swift.String:Swift.String]? = nil,
        provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.info = info
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.status = status
    }
}

struct CreateProvisioningArtifactOutputBody: Swift.Equatable {
    let provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    let info: [Swift.String:Swift.String]?
    let status: ServiceCatalogClientTypes.Status?
}

extension CreateProvisioningArtifactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case info = "Info"
        case provisioningArtifactDetail = "ProvisioningArtifactDetail"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactDetail.self, forKey: .provisioningArtifactDetail)
        provisioningArtifactDetail = provisioningArtifactDetailDecoded
        let infoContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .info)
        var infoDecoded0: [Swift.String:Swift.String]? = nil
        if let infoContainer = infoContainer {
            infoDecoded0 = [Swift.String:Swift.String]()
            for (key0, provisioningartifactinfovalue0) in infoContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    infoDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        info = infoDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateProvisioningArtifactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServiceActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case definition = "Definition"
        case definitionType = "DefinitionType"
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .definition)
            for (dictKey0, serviceActionDefinitionMap0) in definition {
                try definitionContainer.encode(serviceActionDefinitionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let definitionType = self.definitionType {
            try encodeContainer.encode(definitionType.rawValue, forKey: .definitionType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateServiceActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServiceActionInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The self-service action definition. Can be one of the following: Name The name of the Amazon Web Services Systems Manager document (SSM document). For example, AWS-RestartEC2Instance. If you are using a shared SSM document, you must provide the ARN instead of the name. Version The Amazon Web Services Systems Manager automation document version. For example, "Version": "1" AssumeRole The Amazon Resource Name (ARN) of the role that performs the self-service actions on your behalf. For example, "AssumeRole": "arn:aws:iam::12345678910:role/ActionRole". To reuse the provisioned product launch role, set to "AssumeRole": "LAUNCH_ROLE". Parameters The list of parameters in JSON format. For example: [{\"Name\":\"InstanceId\",\"Type\":\"TARGET\"}] or [{\"Name\":\"InstanceId\",\"Type\":\"TEXT_VALUE\"}].
    /// This member is required.
    public var definition: [Swift.String:Swift.String]?
    /// The service action definition type. For example, SSM_AUTOMATION.
    /// This member is required.
    public var definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType?
    /// The self-service action description.
    public var description: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The self-service action name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        definition: [Swift.String:Swift.String]? = nil,
        definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType? = nil,
        description: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.definition = definition
        self.definitionType = definitionType
        self.description = description
        self.idempotencyToken = idempotencyToken
        self.name = name
    }
}

struct CreateServiceActionInputBody: Swift.Equatable {
    let name: Swift.String?
    let definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType?
    let definition: [Swift.String:Swift.String]?
    let description: Swift.String?
    let acceptLanguage: Swift.String?
    let idempotencyToken: Swift.String?
}

extension CreateServiceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case definition = "Definition"
        case definitionType = "DefinitionType"
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let definitionTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionDefinitionType.self, forKey: .definitionType)
        definitionType = definitionTypeDecoded
        let definitionContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .definition)
        var definitionDecoded0: [Swift.String:Swift.String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [Swift.String:Swift.String]()
            for (key0, serviceactiondefinitionvalue0) in definitionContainer {
                if let serviceactiondefinitionvalue0 = serviceactiondefinitionvalue0 {
                    definitionDecoded0?[key0] = serviceactiondefinitionvalue0
                }
            }
        }
        definition = definitionDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateServiceActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceActionDetail = output.serviceActionDetail
        } else {
            self.serviceActionDetail = nil
        }
    }
}

public struct CreateServiceActionOutput: Swift.Equatable {
    /// An object containing information about the self-service action.
    public var serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?

    public init(
        serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail? = nil
    )
    {
        self.serviceActionDetail = serviceActionDetail
    }
}

struct CreateServiceActionOutputBody: Swift.Equatable {
    let serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?
}

extension CreateServiceActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceActionDetail = "ServiceActionDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionDetail.self, forKey: .serviceActionDetail)
        serviceActionDetail = serviceActionDetailDecoded
    }
}

enum CreateServiceActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTagOptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

extension CreateTagOptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTagOptionInput: Swift.Equatable {
    /// The TagOption key.
    /// This member is required.
    public var key: Swift.String?
    /// The TagOption value.
    /// This member is required.
    public var value: Swift.String?

    public init(
        key: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

struct CreateTagOptionInputBody: Swift.Equatable {
    let key: Swift.String?
    let value: Swift.String?
}

extension CreateTagOptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CreateTagOptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTagOptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.tagOptionDetail = output.tagOptionDetail
        } else {
            self.tagOptionDetail = nil
        }
    }
}

public struct CreateTagOptionOutput: Swift.Equatable {
    /// Information about the TagOption.
    public var tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?

    public init(
        tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail? = nil
    )
    {
        self.tagOptionDetail = tagOptionDetail
    }
}

struct CreateTagOptionOutputBody: Swift.Equatable {
    let tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?
}

extension CreateTagOptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagOptionDetail = "TagOptionDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagOptionDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.TagOptionDetail.self, forKey: .tagOptionDetail)
        tagOptionDetail = tagOptionDetailDecoded
    }
}

enum CreateTagOptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConstraintInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteConstraintInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConstraintInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The identifier of the constraint.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DeleteConstraintInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
}

extension DeleteConstraintInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteConstraintOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConstraintOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConstraintOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePortfolioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeletePortfolioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DeletePortfolioInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
}

extension DeletePortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeletePortfolioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePortfolioOutput: Swift.Equatable {

    public init() { }
}

enum DeletePortfolioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePortfolioShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let organizationNode = self.organizationNode {
            try encodeContainer.encode(organizationNode, forKey: .organizationNode)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
    }
}

extension DeletePortfolioShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePortfolioShareInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The Amazon Web Services account ID.
    public var accountId: Swift.String?
    /// The organization node to whom you are going to stop sharing.
    public var organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        accountId: Swift.String? = nil,
        organizationNode: ServiceCatalogClientTypes.OrganizationNode? = nil,
        portfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accountId = accountId
        self.organizationNode = organizationNode
        self.portfolioId = portfolioId
    }
}

struct DeletePortfolioShareInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let accountId: Swift.String?
    let organizationNode: ServiceCatalogClientTypes.OrganizationNode?
}

extension DeletePortfolioShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationNodeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.OrganizationNode.self, forKey: .organizationNode)
        organizationNode = organizationNodeDecoded
    }
}

extension DeletePortfolioShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePortfolioShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.portfolioShareToken = output.portfolioShareToken
        } else {
            self.portfolioShareToken = nil
        }
    }
}

public struct DeletePortfolioShareOutput: Swift.Equatable {
    /// The portfolio share unique identifier. This will only be returned if delete is made to an organization node.
    public var portfolioShareToken: Swift.String?

    public init(
        portfolioShareToken: Swift.String? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
    }
}

struct DeletePortfolioShareOutputBody: Swift.Equatable {
    let portfolioShareToken: Swift.String?
}

extension DeletePortfolioShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
    }
}

enum DeletePortfolioShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProductInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DeleteProductInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
}

extension DeleteProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProductOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProvisionedProductPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case ignoreErrors = "IgnoreErrors"
        case planId = "PlanId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let ignoreErrors = self.ignoreErrors {
            try encodeContainer.encode(ignoreErrors, forKey: .ignoreErrors)
        }
        if let planId = self.planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
    }
}

extension DeleteProvisionedProductPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProvisionedProductPlanInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// If set to true, Service Catalog stops managing the specified provisioned product even if it cannot delete the underlying resources.
    public var ignoreErrors: Swift.Bool?
    /// The plan identifier.
    /// This member is required.
    public var planId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        ignoreErrors: Swift.Bool? = nil,
        planId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.ignoreErrors = ignoreErrors
        self.planId = planId
    }
}

struct DeleteProvisionedProductPlanInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let planId: Swift.String?
    let ignoreErrors: Swift.Bool?
}

extension DeleteProvisionedProductPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case ignoreErrors = "IgnoreErrors"
        case planId = "PlanId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planId)
        planId = planIdDecoded
        let ignoreErrorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignoreErrors)
        ignoreErrors = ignoreErrorsDecoded
    }
}

extension DeleteProvisionedProductPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProvisionedProductPlanOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProvisionedProductPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProvisioningArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }
}

extension DeleteProvisioningArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct DeleteProvisioningArtifactInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let productId: Swift.String?
    let provisioningArtifactId: Swift.String?
}

extension DeleteProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
    }
}

extension DeleteProvisioningArtifactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProvisioningArtifactOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProvisioningArtifactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteServiceActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceActionInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DeleteServiceActionInputBody: Swift.Equatable {
    let id: Swift.String?
    let acceptLanguage: Swift.String?
}

extension DeleteServiceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension DeleteServiceActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteServiceActionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteServiceActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTagOptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteTagOptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTagOptionInput: Swift.Equatable {
    /// The TagOption identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteTagOptionInputBody: Swift.Equatable {
}

extension DeleteTagOptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTagOptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTagOptionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTagOptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConstraintInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DescribeConstraintInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConstraintInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The identifier of the constraint.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DescribeConstraintInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
}

extension DescribeConstraintInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeConstraintOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConstraintOutputBody = try responseDecoder.decode(responseBody: data)
            self.constraintDetail = output.constraintDetail
            self.constraintParameters = output.constraintParameters
            self.status = output.status
        } else {
            self.constraintDetail = nil
            self.constraintParameters = nil
            self.status = nil
        }
    }
}

public struct DescribeConstraintOutput: Swift.Equatable {
    /// Information about the constraint.
    public var constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    /// The constraint parameters.
    public var constraintParameters: Swift.String?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init(
        constraintDetail: ServiceCatalogClientTypes.ConstraintDetail? = nil,
        constraintParameters: Swift.String? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.constraintDetail = constraintDetail
        self.constraintParameters = constraintParameters
        self.status = status
    }
}

struct DescribeConstraintOutputBody: Swift.Equatable {
    let constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    let constraintParameters: Swift.String?
    let status: ServiceCatalogClientTypes.Status?
}

extension DescribeConstraintOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintDetail = "ConstraintDetail"
        case constraintParameters = "ConstraintParameters"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ConstraintDetail.self, forKey: .constraintDetail)
        constraintDetail = constraintDetailDecoded
        let constraintParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraintParameters)
        constraintParameters = constraintParametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

enum DescribeConstraintOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCopyProductStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case copyProductToken = "CopyProductToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let copyProductToken = self.copyProductToken {
            try encodeContainer.encode(copyProductToken, forKey: .copyProductToken)
        }
    }
}

extension DescribeCopyProductStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCopyProductStatusInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The token for the copy product operation. This token is returned by [CopyProduct].
    /// This member is required.
    public var copyProductToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        copyProductToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.copyProductToken = copyProductToken
    }
}

struct DescribeCopyProductStatusInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let copyProductToken: Swift.String?
}

extension DescribeCopyProductStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case copyProductToken = "CopyProductToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let copyProductTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .copyProductToken)
        copyProductToken = copyProductTokenDecoded
    }
}

extension DescribeCopyProductStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCopyProductStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.copyProductStatus = output.copyProductStatus
            self.statusDetail = output.statusDetail
            self.targetProductId = output.targetProductId
        } else {
            self.copyProductStatus = nil
            self.statusDetail = nil
            self.targetProductId = nil
        }
    }
}

public struct DescribeCopyProductStatusOutput: Swift.Equatable {
    /// The status of the copy product operation.
    public var copyProductStatus: ServiceCatalogClientTypes.CopyProductStatus?
    /// The status message.
    public var statusDetail: Swift.String?
    /// The identifier of the copied product.
    public var targetProductId: Swift.String?

    public init(
        copyProductStatus: ServiceCatalogClientTypes.CopyProductStatus? = nil,
        statusDetail: Swift.String? = nil,
        targetProductId: Swift.String? = nil
    )
    {
        self.copyProductStatus = copyProductStatus
        self.statusDetail = statusDetail
        self.targetProductId = targetProductId
    }
}

struct DescribeCopyProductStatusOutputBody: Swift.Equatable {
    let copyProductStatus: ServiceCatalogClientTypes.CopyProductStatus?
    let targetProductId: Swift.String?
    let statusDetail: Swift.String?
}

extension DescribeCopyProductStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyProductStatus = "CopyProductStatus"
        case statusDetail = "StatusDetail"
        case targetProductId = "TargetProductId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyProductStatusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.CopyProductStatus.self, forKey: .copyProductStatus)
        copyProductStatus = copyProductStatusDecoded
        let targetProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetProductId)
        targetProductId = targetProductIdDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
    }
}

enum DescribeCopyProductStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePortfolioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DescribePortfolioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DescribePortfolioInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
}

extension DescribePortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribePortfolioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePortfolioOutputBody = try responseDecoder.decode(responseBody: data)
            self.budgets = output.budgets
            self.portfolioDetail = output.portfolioDetail
            self.tagOptions = output.tagOptions
            self.tags = output.tags
        } else {
            self.budgets = nil
            self.portfolioDetail = nil
            self.tagOptions = nil
            self.tags = nil
        }
    }
}

public struct DescribePortfolioOutput: Swift.Equatable {
    /// Information about the associated budgets.
    public var budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    /// Information about the portfolio.
    public var portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    /// Information about the TagOptions associated with the portfolio.
    public var tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]?
    /// Information about the tags associated with the portfolio.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        budgets: [ServiceCatalogClientTypes.BudgetDetail]? = nil,
        portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail? = nil,
        tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.budgets = budgets
        self.portfolioDetail = portfolioDetail
        self.tagOptions = tagOptions
        self.tags = tags
    }
}

struct DescribePortfolioOutputBody: Swift.Equatable {
    let portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    let tags: [ServiceCatalogClientTypes.Tag]?
    let tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]?
    let budgets: [ServiceCatalogClientTypes.BudgetDetail]?
}

extension DescribePortfolioOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgets = "Budgets"
        case portfolioDetail = "PortfolioDetail"
        case tagOptions = "TagOptions"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PortfolioDetail.self, forKey: .portfolioDetail)
        portfolioDetail = portfolioDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let tagOptionsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.TagOptionDetail?].self, forKey: .tagOptions)
        var tagOptionsDecoded0:[ServiceCatalogClientTypes.TagOptionDetail]? = nil
        if let tagOptionsContainer = tagOptionsContainer {
            tagOptionsDecoded0 = [ServiceCatalogClientTypes.TagOptionDetail]()
            for structure0 in tagOptionsContainer {
                if let structure0 = structure0 {
                    tagOptionsDecoded0?.append(structure0)
                }
            }
        }
        tagOptions = tagOptionsDecoded0
        let budgetsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.BudgetDetail?].self, forKey: .budgets)
        var budgetsDecoded0:[ServiceCatalogClientTypes.BudgetDetail]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [ServiceCatalogClientTypes.BudgetDetail]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
    }
}

enum DescribePortfolioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePortfolioShareStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portfolioShareToken = self.portfolioShareToken {
            try encodeContainer.encode(portfolioShareToken, forKey: .portfolioShareToken)
        }
    }
}

extension DescribePortfolioShareStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePortfolioShareStatusInput: Swift.Equatable {
    /// The token for the portfolio share operation. This token is returned either by CreatePortfolioShare or by DeletePortfolioShare.
    /// This member is required.
    public var portfolioShareToken: Swift.String?

    public init(
        portfolioShareToken: Swift.String? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
    }
}

struct DescribePortfolioShareStatusInputBody: Swift.Equatable {
    let portfolioShareToken: Swift.String?
}

extension DescribePortfolioShareStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
    }
}

extension DescribePortfolioShareStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePortfolioShareStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.organizationNodeValue = output.organizationNodeValue
            self.portfolioId = output.portfolioId
            self.portfolioShareToken = output.portfolioShareToken
            self.shareDetails = output.shareDetails
            self.status = output.status
        } else {
            self.organizationNodeValue = nil
            self.portfolioId = nil
            self.portfolioShareToken = nil
            self.shareDetails = nil
            self.status = nil
        }
    }
}

public struct DescribePortfolioShareStatusOutput: Swift.Equatable {
    /// Organization node identifier. It can be either account id, organizational unit id or organization id.
    public var organizationNodeValue: Swift.String?
    /// The portfolio identifier.
    public var portfolioId: Swift.String?
    /// The token for the portfolio share operation. For example, share-6v24abcdefghi.
    public var portfolioShareToken: Swift.String?
    /// Information about the portfolio share operation.
    public var shareDetails: ServiceCatalogClientTypes.ShareDetails?
    /// Status of the portfolio share operation.
    public var status: ServiceCatalogClientTypes.ShareStatus?

    public init(
        organizationNodeValue: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        portfolioShareToken: Swift.String? = nil,
        shareDetails: ServiceCatalogClientTypes.ShareDetails? = nil,
        status: ServiceCatalogClientTypes.ShareStatus? = nil
    )
    {
        self.organizationNodeValue = organizationNodeValue
        self.portfolioId = portfolioId
        self.portfolioShareToken = portfolioShareToken
        self.shareDetails = shareDetails
        self.status = status
    }
}

struct DescribePortfolioShareStatusOutputBody: Swift.Equatable {
    let portfolioShareToken: Swift.String?
    let portfolioId: Swift.String?
    let organizationNodeValue: Swift.String?
    let status: ServiceCatalogClientTypes.ShareStatus?
    let shareDetails: ServiceCatalogClientTypes.ShareDetails?
}

extension DescribePortfolioShareStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationNodeValue = "OrganizationNodeValue"
        case portfolioId = "PortfolioId"
        case portfolioShareToken = "PortfolioShareToken"
        case shareDetails = "ShareDetails"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let organizationNodeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationNodeValue)
        organizationNodeValue = organizationNodeValueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
        let shareDetailsDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ShareDetails.self, forKey: .shareDetails)
        shareDetails = shareDetailsDecoded
    }
}

enum DescribePortfolioShareStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum DescribePortfolioShareType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case organization
        case organizationalUnit
        case organizationMemberAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [DescribePortfolioShareType] {
            return [
                .account,
                .organization,
                .organizationalUnit,
                .organizationMemberAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .organization: return "ORGANIZATION"
            case .organizationalUnit: return "ORGANIZATIONAL_UNIT"
            case .organizationMemberAccount: return "ORGANIZATION_MEMBER_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DescribePortfolioShareType(rawValue: rawValue) ?? DescribePortfolioShareType.sdkUnknown(rawValue)
        }
    }
}

extension DescribePortfolioSharesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension DescribePortfolioSharesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePortfolioSharesInput: Swift.Equatable {
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The unique identifier of the portfolio for which shares will be retrieved.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The type of portfolio share to summarize. This field acts as a filter on the type of portfolio share, which can be one of the following: 1. ACCOUNT - Represents an external account to account share. 2. ORGANIZATION - Represents a share to an organization. This share is available to every account in the organization. 3. ORGANIZATIONAL_UNIT - Represents a share to an organizational unit. 4. ORGANIZATION_MEMBER_ACCOUNT - Represents a share to an account in the organization.
    /// This member is required.
    public var type: ServiceCatalogClientTypes.DescribePortfolioShareType?

    public init(
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        type: ServiceCatalogClientTypes.DescribePortfolioShareType? = nil
    )
    {
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
        self.type = type
    }
}

struct DescribePortfolioSharesInputBody: Swift.Equatable {
    let portfolioId: Swift.String?
    let type: ServiceCatalogClientTypes.DescribePortfolioShareType?
    let pageToken: Swift.String?
    let pageSize: Swift.Int?
}

extension DescribePortfolioSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.DescribePortfolioShareType.self, forKey: .type)
        type = typeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension DescribePortfolioSharesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePortfolioSharesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.portfolioShareDetails = output.portfolioShareDetails
        } else {
            self.nextPageToken = nil
            self.portfolioShareDetails = nil
        }
    }
}

public struct DescribePortfolioSharesOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Summaries about each of the portfolio shares.
    public var portfolioShareDetails: [ServiceCatalogClientTypes.PortfolioShareDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        portfolioShareDetails: [ServiceCatalogClientTypes.PortfolioShareDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioShareDetails = portfolioShareDetails
    }
}

struct DescribePortfolioSharesOutputBody: Swift.Equatable {
    let nextPageToken: Swift.String?
    let portfolioShareDetails: [ServiceCatalogClientTypes.PortfolioShareDetail]?
}

extension DescribePortfolioSharesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case portfolioShareDetails = "PortfolioShareDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let portfolioShareDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.PortfolioShareDetail?].self, forKey: .portfolioShareDetails)
        var portfolioShareDetailsDecoded0:[ServiceCatalogClientTypes.PortfolioShareDetail]? = nil
        if let portfolioShareDetailsContainer = portfolioShareDetailsContainer {
            portfolioShareDetailsDecoded0 = [ServiceCatalogClientTypes.PortfolioShareDetail]()
            for structure0 in portfolioShareDetailsContainer {
                if let structure0 = structure0 {
                    portfolioShareDetailsDecoded0?.append(structure0)
                }
            }
        }
        portfolioShareDetails = portfolioShareDetailsDecoded0
    }
}

enum DescribePortfolioSharesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProductAsAdminInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
        case sourcePortfolioId = "SourcePortfolioId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourcePortfolioId = self.sourcePortfolioId {
            try encodeContainer.encode(sourcePortfolioId, forKey: .sourcePortfolioId)
        }
    }
}

extension DescribeProductAsAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProductAsAdminInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    public var id: Swift.String?
    /// The product name.
    public var name: Swift.String?
    /// The unique identifier of the shared portfolio that the specified product is associated with. You can provide this parameter to retrieve the shared TagOptions associated with the product. If this parameter is provided and if TagOptions sharing is enabled in the portfolio share, the API returns both local and shared TagOptions associated with the product. Otherwise only local TagOptions will be returned.
    public var sourcePortfolioId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sourcePortfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.name = name
        self.sourcePortfolioId = sourcePortfolioId
    }
}

struct DescribeProductAsAdminInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let sourcePortfolioId: Swift.String?
}

extension DescribeProductAsAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
        case sourcePortfolioId = "SourcePortfolioId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourcePortfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePortfolioId)
        sourcePortfolioId = sourcePortfolioIdDecoded
    }
}

extension DescribeProductAsAdminOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProductAsAdminOutputBody = try responseDecoder.decode(responseBody: data)
            self.budgets = output.budgets
            self.productViewDetail = output.productViewDetail
            self.provisioningArtifactSummaries = output.provisioningArtifactSummaries
            self.tagOptions = output.tagOptions
            self.tags = output.tags
        } else {
            self.budgets = nil
            self.productViewDetail = nil
            self.provisioningArtifactSummaries = nil
            self.tagOptions = nil
            self.tags = nil
        }
    }
}

public struct DescribeProductAsAdminOutput: Swift.Equatable {
    /// Information about the associated budgets.
    public var budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    /// Information about the product view.
    public var productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    /// Information about the provisioning artifacts (also known as versions) for the specified product.
    public var provisioningArtifactSummaries: [ServiceCatalogClientTypes.ProvisioningArtifactSummary]?
    /// Information about the TagOptions associated with the product.
    public var tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]?
    /// Information about the tags associated with the product.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        budgets: [ServiceCatalogClientTypes.BudgetDetail]? = nil,
        productViewDetail: ServiceCatalogClientTypes.ProductViewDetail? = nil,
        provisioningArtifactSummaries: [ServiceCatalogClientTypes.ProvisioningArtifactSummary]? = nil,
        tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.budgets = budgets
        self.productViewDetail = productViewDetail
        self.provisioningArtifactSummaries = provisioningArtifactSummaries
        self.tagOptions = tagOptions
        self.tags = tags
    }
}

struct DescribeProductAsAdminOutputBody: Swift.Equatable {
    let productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    let provisioningArtifactSummaries: [ServiceCatalogClientTypes.ProvisioningArtifactSummary]?
    let tags: [ServiceCatalogClientTypes.Tag]?
    let tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]?
    let budgets: [ServiceCatalogClientTypes.BudgetDetail]?
}

extension DescribeProductAsAdminOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgets = "Budgets"
        case productViewDetail = "ProductViewDetail"
        case provisioningArtifactSummaries = "ProvisioningArtifactSummaries"
        case tagOptions = "TagOptions"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewDetail.self, forKey: .productViewDetail)
        productViewDetail = productViewDetailDecoded
        let provisioningArtifactSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifactSummary?].self, forKey: .provisioningArtifactSummaries)
        var provisioningArtifactSummariesDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifactSummary]? = nil
        if let provisioningArtifactSummariesContainer = provisioningArtifactSummariesContainer {
            provisioningArtifactSummariesDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifactSummary]()
            for structure0 in provisioningArtifactSummariesContainer {
                if let structure0 = structure0 {
                    provisioningArtifactSummariesDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactSummaries = provisioningArtifactSummariesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let tagOptionsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.TagOptionDetail?].self, forKey: .tagOptions)
        var tagOptionsDecoded0:[ServiceCatalogClientTypes.TagOptionDetail]? = nil
        if let tagOptionsContainer = tagOptionsContainer {
            tagOptionsDecoded0 = [ServiceCatalogClientTypes.TagOptionDetail]()
            for structure0 in tagOptionsContainer {
                if let structure0 = structure0 {
                    tagOptionsDecoded0?.append(structure0)
                }
            }
        }
        tagOptions = tagOptionsDecoded0
        let budgetsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.BudgetDetail?].self, forKey: .budgets)
        var budgetsDecoded0:[ServiceCatalogClientTypes.BudgetDetail]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [ServiceCatalogClientTypes.BudgetDetail]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
    }
}

enum DescribeProductAsAdminOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DescribeProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProductInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    public var id: Swift.String?
    /// The product name.
    public var name: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.name = name
    }
}

struct DescribeProductInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
}

extension DescribeProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProductOutputBody = try responseDecoder.decode(responseBody: data)
            self.budgets = output.budgets
            self.launchPaths = output.launchPaths
            self.productViewSummary = output.productViewSummary
            self.provisioningArtifacts = output.provisioningArtifacts
        } else {
            self.budgets = nil
            self.launchPaths = nil
            self.productViewSummary = nil
            self.provisioningArtifacts = nil
        }
    }
}

public struct DescribeProductOutput: Swift.Equatable {
    /// Information about the associated budgets.
    public var budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    /// Information about the associated launch paths.
    public var launchPaths: [ServiceCatalogClientTypes.LaunchPath]?
    /// Summary information about the product view.
    public var productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
    /// Information about the provisioning artifacts for the specified product.
    public var provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]?

    public init(
        budgets: [ServiceCatalogClientTypes.BudgetDetail]? = nil,
        launchPaths: [ServiceCatalogClientTypes.LaunchPath]? = nil,
        productViewSummary: ServiceCatalogClientTypes.ProductViewSummary? = nil,
        provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]? = nil
    )
    {
        self.budgets = budgets
        self.launchPaths = launchPaths
        self.productViewSummary = productViewSummary
        self.provisioningArtifacts = provisioningArtifacts
    }
}

struct DescribeProductOutputBody: Swift.Equatable {
    let productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
    let provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]?
    let budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    let launchPaths: [ServiceCatalogClientTypes.LaunchPath]?
}

extension DescribeProductOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgets = "Budgets"
        case launchPaths = "LaunchPaths"
        case productViewSummary = "ProductViewSummary"
        case provisioningArtifacts = "ProvisioningArtifacts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummaryDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewSummary.self, forKey: .productViewSummary)
        productViewSummary = productViewSummaryDecoded
        let provisioningArtifactsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifact?].self, forKey: .provisioningArtifacts)
        var provisioningArtifactsDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifact]? = nil
        if let provisioningArtifactsContainer = provisioningArtifactsContainer {
            provisioningArtifactsDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifact]()
            for structure0 in provisioningArtifactsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifacts = provisioningArtifactsDecoded0
        let budgetsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.BudgetDetail?].self, forKey: .budgets)
        var budgetsDecoded0:[ServiceCatalogClientTypes.BudgetDetail]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [ServiceCatalogClientTypes.BudgetDetail]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
        let launchPathsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.LaunchPath?].self, forKey: .launchPaths)
        var launchPathsDecoded0:[ServiceCatalogClientTypes.LaunchPath]? = nil
        if let launchPathsContainer = launchPathsContainer {
            launchPathsDecoded0 = [ServiceCatalogClientTypes.LaunchPath]()
            for structure0 in launchPathsContainer {
                if let structure0 = structure0 {
                    launchPathsDecoded0?.append(structure0)
                }
            }
        }
        launchPaths = launchPathsDecoded0
    }
}

enum DescribeProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProductViewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DescribeProductViewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProductViewInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product view identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DescribeProductViewInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
}

extension DescribeProductViewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeProductViewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProductViewOutputBody = try responseDecoder.decode(responseBody: data)
            self.productViewSummary = output.productViewSummary
            self.provisioningArtifacts = output.provisioningArtifacts
        } else {
            self.productViewSummary = nil
            self.provisioningArtifacts = nil
        }
    }
}

public struct DescribeProductViewOutput: Swift.Equatable {
    /// Summary information about the product.
    public var productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
    /// Information about the provisioning artifacts for the product.
    public var provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]?

    public init(
        productViewSummary: ServiceCatalogClientTypes.ProductViewSummary? = nil,
        provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]? = nil
    )
    {
        self.productViewSummary = productViewSummary
        self.provisioningArtifacts = provisioningArtifacts
    }
}

struct DescribeProductViewOutputBody: Swift.Equatable {
    let productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
    let provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]?
}

extension DescribeProductViewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productViewSummary = "ProductViewSummary"
        case provisioningArtifacts = "ProvisioningArtifacts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummaryDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewSummary.self, forKey: .productViewSummary)
        productViewSummary = productViewSummaryDecoded
        let provisioningArtifactsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifact?].self, forKey: .provisioningArtifacts)
        var provisioningArtifactsDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifact]? = nil
        if let provisioningArtifactsContainer = provisioningArtifactsContainer {
            provisioningArtifactsDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifact]()
            for structure0 in provisioningArtifactsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifacts = provisioningArtifactsDecoded0
    }
}

enum DescribeProductViewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProvisionedProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DescribeProvisionedProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// DescribeProvisionedProductAPI input structure. AcceptLanguage - [Optional] The language code for localization. Id - [Optional] The provisioned product identifier. Name - [Optional] Another provisioned product identifier. Customers must provide either Id or Name.
public struct DescribeProvisionedProductInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The provisioned product identifier. You must provide the name or ID, but not both. If you do not provide a name or ID, or you provide both name and ID, an InvalidParametersException will occur.
    public var id: Swift.String?
    /// The name of the provisioned product. You must provide the name or ID, but not both. If you do not provide a name or ID, or you provide both name and ID, an InvalidParametersException will occur.
    public var name: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.name = name
    }
}

struct DescribeProvisionedProductInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
}

extension DescribeProvisionedProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeProvisionedProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProvisionedProductOutputBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchDashboards = output.cloudWatchDashboards
            self.provisionedProductDetail = output.provisionedProductDetail
        } else {
            self.cloudWatchDashboards = nil
            self.provisionedProductDetail = nil
        }
    }
}

public struct DescribeProvisionedProductOutput: Swift.Equatable {
    /// Any CloudWatch dashboards that were created when provisioning the product.
    public var cloudWatchDashboards: [ServiceCatalogClientTypes.CloudWatchDashboard]?
    /// Information about the provisioned product.
    public var provisionedProductDetail: ServiceCatalogClientTypes.ProvisionedProductDetail?

    public init(
        cloudWatchDashboards: [ServiceCatalogClientTypes.CloudWatchDashboard]? = nil,
        provisionedProductDetail: ServiceCatalogClientTypes.ProvisionedProductDetail? = nil
    )
    {
        self.cloudWatchDashboards = cloudWatchDashboards
        self.provisionedProductDetail = provisionedProductDetail
    }
}

struct DescribeProvisionedProductOutputBody: Swift.Equatable {
    let provisionedProductDetail: ServiceCatalogClientTypes.ProvisionedProductDetail?
    let cloudWatchDashboards: [ServiceCatalogClientTypes.CloudWatchDashboard]?
}

extension DescribeProvisionedProductOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchDashboards = "CloudWatchDashboards"
        case provisionedProductDetail = "ProvisionedProductDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductDetail.self, forKey: .provisionedProductDetail)
        provisionedProductDetail = provisionedProductDetailDecoded
        let cloudWatchDashboardsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.CloudWatchDashboard?].self, forKey: .cloudWatchDashboards)
        var cloudWatchDashboardsDecoded0:[ServiceCatalogClientTypes.CloudWatchDashboard]? = nil
        if let cloudWatchDashboardsContainer = cloudWatchDashboardsContainer {
            cloudWatchDashboardsDecoded0 = [ServiceCatalogClientTypes.CloudWatchDashboard]()
            for structure0 in cloudWatchDashboardsContainer {
                if let structure0 = structure0 {
                    cloudWatchDashboardsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchDashboards = cloudWatchDashboardsDecoded0
    }
}

enum DescribeProvisionedProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProvisionedProductPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case planId = "PlanId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let planId = self.planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
    }
}

extension DescribeProvisionedProductPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProvisionedProductPlanInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The plan identifier.
    /// This member is required.
    public var planId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        planId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.planId = planId
    }
}

struct DescribeProvisionedProductPlanInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let planId: Swift.String?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
}

extension DescribeProvisionedProductPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case planId = "PlanId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planId)
        planId = planIdDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension DescribeProvisionedProductPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProvisionedProductPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.provisionedProductPlanDetails = output.provisionedProductPlanDetails
            self.resourceChanges = output.resourceChanges
        } else {
            self.nextPageToken = nil
            self.provisionedProductPlanDetails = nil
            self.resourceChanges = nil
        }
    }
}

public struct DescribeProvisionedProductPlanOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the plan.
    public var provisionedProductPlanDetails: ServiceCatalogClientTypes.ProvisionedProductPlanDetails?
    /// Information about the resource changes that will occur when the plan is executed.
    public var resourceChanges: [ServiceCatalogClientTypes.ResourceChange]?

    public init(
        nextPageToken: Swift.String? = nil,
        provisionedProductPlanDetails: ServiceCatalogClientTypes.ProvisionedProductPlanDetails? = nil,
        resourceChanges: [ServiceCatalogClientTypes.ResourceChange]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProductPlanDetails = provisionedProductPlanDetails
        self.resourceChanges = resourceChanges
    }
}

struct DescribeProvisionedProductPlanOutputBody: Swift.Equatable {
    let provisionedProductPlanDetails: ServiceCatalogClientTypes.ProvisionedProductPlanDetails?
    let resourceChanges: [ServiceCatalogClientTypes.ResourceChange]?
    let nextPageToken: Swift.String?
}

extension DescribeProvisionedProductPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case provisionedProductPlanDetails = "ProvisionedProductPlanDetails"
        case resourceChanges = "ResourceChanges"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductPlanDetailsDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductPlanDetails.self, forKey: .provisionedProductPlanDetails)
        provisionedProductPlanDetails = provisionedProductPlanDetailsDecoded
        let resourceChangesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ResourceChange?].self, forKey: .resourceChanges)
        var resourceChangesDecoded0:[ServiceCatalogClientTypes.ResourceChange]? = nil
        if let resourceChangesContainer = resourceChangesContainer {
            resourceChangesDecoded0 = [ServiceCatalogClientTypes.ResourceChange]()
            for structure0 in resourceChangesContainer {
                if let structure0 = structure0 {
                    resourceChangesDecoded0?.append(structure0)
                }
            }
        }
        resourceChanges = resourceChangesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum DescribeProvisionedProductPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProvisioningArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case includeProvisioningArtifactParameters = "IncludeProvisioningArtifactParameters"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case verbose = "Verbose"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let includeProvisioningArtifactParameters = self.includeProvisioningArtifactParameters {
            try encodeContainer.encode(includeProvisioningArtifactParameters, forKey: .includeProvisioningArtifactParameters)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = self.provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
        if let verbose = self.verbose {
            try encodeContainer.encode(verbose, forKey: .verbose)
        }
    }
}

extension DescribeProvisioningArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// Indicates if the API call response does or does not include additional details about the provisioning parameters.
    public var includeProvisioningArtifactParameters: Swift.Bool?
    /// The product identifier.
    public var productId: Swift.String?
    /// The product name.
    public var productName: Swift.String?
    /// The identifier of the provisioning artifact.
    public var provisioningArtifactId: Swift.String?
    /// The provisioning artifact name.
    public var provisioningArtifactName: Swift.String?
    /// Indicates whether a verbose level of detail is enabled.
    public var verbose: Swift.Bool?

    public init(
        acceptLanguage: Swift.String? = nil,
        includeProvisioningArtifactParameters: Swift.Bool? = nil,
        productId: Swift.String? = nil,
        productName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningArtifactName: Swift.String? = nil,
        verbose: Swift.Bool? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.includeProvisioningArtifactParameters = includeProvisioningArtifactParameters
        self.productId = productId
        self.productName = productName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.verbose = verbose
    }
}

struct DescribeProvisioningArtifactInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let provisioningArtifactId: Swift.String?
    let productId: Swift.String?
    let provisioningArtifactName: Swift.String?
    let productName: Swift.String?
    let verbose: Swift.Bool?
    let includeProvisioningArtifactParameters: Swift.Bool?
}

extension DescribeProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case includeProvisioningArtifactParameters = "IncludeProvisioningArtifactParameters"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case verbose = "Verbose"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let verboseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .verbose)
        verbose = verboseDecoded
        let includeProvisioningArtifactParametersDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeProvisioningArtifactParameters)
        includeProvisioningArtifactParameters = includeProvisioningArtifactParametersDecoded
    }
}

extension DescribeProvisioningArtifactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProvisioningArtifactOutputBody = try responseDecoder.decode(responseBody: data)
            self.info = output.info
            self.provisioningArtifactDetail = output.provisioningArtifactDetail
            self.provisioningArtifactParameters = output.provisioningArtifactParameters
            self.status = output.status
        } else {
            self.info = nil
            self.provisioningArtifactDetail = nil
            self.provisioningArtifactParameters = nil
            self.status = nil
        }
    }
}

public struct DescribeProvisioningArtifactOutput: Swift.Equatable {
    /// The URL of the CloudFormation template in Amazon S3 or GitHub in JSON format.
    public var info: [Swift.String:Swift.String]?
    /// Information about the provisioning artifact.
    public var provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    /// Information about the parameters used to provision the product.
    public var provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init(
        info: [Swift.String:Swift.String]? = nil,
        provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail? = nil,
        provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.info = info
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.provisioningArtifactParameters = provisioningArtifactParameters
        self.status = status
    }
}

struct DescribeProvisioningArtifactOutputBody: Swift.Equatable {
    let provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    let info: [Swift.String:Swift.String]?
    let status: ServiceCatalogClientTypes.Status?
    let provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]?
}

extension DescribeProvisioningArtifactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case info = "Info"
        case provisioningArtifactDetail = "ProvisioningArtifactDetail"
        case provisioningArtifactParameters = "ProvisioningArtifactParameters"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactDetail.self, forKey: .provisioningArtifactDetail)
        provisioningArtifactDetail = provisioningArtifactDetailDecoded
        let infoContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .info)
        var infoDecoded0: [Swift.String:Swift.String]? = nil
        if let infoContainer = infoContainer {
            infoDecoded0 = [Swift.String:Swift.String]()
            for (key0, provisioningartifactinfovalue0) in infoContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    infoDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        info = infoDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let provisioningArtifactParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifactParameter?].self, forKey: .provisioningArtifactParameters)
        var provisioningArtifactParametersDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifactParameter]? = nil
        if let provisioningArtifactParametersContainer = provisioningArtifactParametersContainer {
            provisioningArtifactParametersDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifactParameter]()
            for structure0 in provisioningArtifactParametersContainer {
                if let structure0 = structure0 {
                    provisioningArtifactParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactParameters = provisioningArtifactParametersDecoded0
    }
}

enum DescribeProvisioningArtifactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProvisioningParametersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pathId = self.pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let pathName = self.pathName {
            try encodeContainer.encode(pathName, forKey: .pathName)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = self.provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
    }
}

extension DescribeProvisioningParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProvisioningParametersInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use [ListLaunchPaths]. You must provide the name or ID, but not both.
    public var pathId: Swift.String?
    /// The name of the path. You must provide the name or ID, but not both.
    public var pathName: Swift.String?
    /// The product identifier. You must provide the product name or ID, but not both.
    public var productId: Swift.String?
    /// The name of the product. You must provide the name or ID, but not both.
    public var productName: Swift.String?
    /// The identifier of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactId: Swift.String?
    /// The name of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactName: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pathId: Swift.String? = nil,
        pathName: Swift.String? = nil,
        productId: Swift.String? = nil,
        productName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningArtifactName: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pathId = pathId
        self.pathName = pathName
        self.productId = productId
        self.productName = productName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
    }
}

struct DescribeProvisioningParametersInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let productId: Swift.String?
    let productName: Swift.String?
    let provisioningArtifactId: Swift.String?
    let provisioningArtifactName: Swift.String?
    let pathId: Swift.String?
    let pathName: Swift.String?
}

extension DescribeProvisioningParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let pathNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathName)
        pathName = pathNameDecoded
    }
}

extension DescribeProvisioningParametersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProvisioningParametersOutputBody = try responseDecoder.decode(responseBody: data)
            self.constraintSummaries = output.constraintSummaries
            self.provisioningArtifactOutputKeys = output.provisioningArtifactOutputKeys
            self.provisioningArtifactOutputs = output.provisioningArtifactOutputs
            self.provisioningArtifactParameters = output.provisioningArtifactParameters
            self.provisioningArtifactPreferences = output.provisioningArtifactPreferences
            self.tagOptions = output.tagOptions
            self.usageInstructions = output.usageInstructions
        } else {
            self.constraintSummaries = nil
            self.provisioningArtifactOutputKeys = nil
            self.provisioningArtifactOutputs = nil
            self.provisioningArtifactParameters = nil
            self.provisioningArtifactPreferences = nil
            self.tagOptions = nil
            self.usageInstructions = nil
        }
    }
}

public struct DescribeProvisioningParametersOutput: Swift.Equatable {
    /// Information about the constraints used to provision the product.
    public var constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]?
    /// A list of the keys and descriptions of the outputs. These outputs can be referenced from a provisioned product launched from this provisioning artifact.
    public var provisioningArtifactOutputKeys: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]?
    /// The output of the provisioning artifact.
    @available(*, deprecated, message: "This property is deprecated and returns the Id and Description of the Provisioning Artifact. Use ProvisioningArtifactOutputKeys instead to get the Keys and Descriptions of the outputs.")
    public var provisioningArtifactOutputs: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]?
    /// Information about the parameters used to provision the product.
    public var provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]?
    /// An object that contains information about preferences, such as Regions and accounts, for the provisioning artifact.
    public var provisioningArtifactPreferences: ServiceCatalogClientTypes.ProvisioningArtifactPreferences?
    /// Information about the TagOptions associated with the resource.
    public var tagOptions: [ServiceCatalogClientTypes.TagOptionSummary]?
    /// Any additional metadata specifically related to the provisioning of the product. For example, see the Version field of the CloudFormation template.
    public var usageInstructions: [ServiceCatalogClientTypes.UsageInstruction]?

    public init(
        constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]? = nil,
        provisioningArtifactOutputKeys: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]? = nil,
        provisioningArtifactOutputs: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]? = nil,
        provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]? = nil,
        provisioningArtifactPreferences: ServiceCatalogClientTypes.ProvisioningArtifactPreferences? = nil,
        tagOptions: [ServiceCatalogClientTypes.TagOptionSummary]? = nil,
        usageInstructions: [ServiceCatalogClientTypes.UsageInstruction]? = nil
    )
    {
        self.constraintSummaries = constraintSummaries
        self.provisioningArtifactOutputKeys = provisioningArtifactOutputKeys
        self.provisioningArtifactOutputs = provisioningArtifactOutputs
        self.provisioningArtifactParameters = provisioningArtifactParameters
        self.provisioningArtifactPreferences = provisioningArtifactPreferences
        self.tagOptions = tagOptions
        self.usageInstructions = usageInstructions
    }
}

struct DescribeProvisioningParametersOutputBody: Swift.Equatable {
    let provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]?
    let constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]?
    let usageInstructions: [ServiceCatalogClientTypes.UsageInstruction]?
    let tagOptions: [ServiceCatalogClientTypes.TagOptionSummary]?
    let provisioningArtifactPreferences: ServiceCatalogClientTypes.ProvisioningArtifactPreferences?
    let provisioningArtifactOutputs: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]?
    let provisioningArtifactOutputKeys: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]?
}

extension DescribeProvisioningParametersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintSummaries = "ConstraintSummaries"
        case provisioningArtifactOutputKeys = "ProvisioningArtifactOutputKeys"
        case provisioningArtifactOutputs = "ProvisioningArtifactOutputs"
        case provisioningArtifactParameters = "ProvisioningArtifactParameters"
        case provisioningArtifactPreferences = "ProvisioningArtifactPreferences"
        case tagOptions = "TagOptions"
        case usageInstructions = "UsageInstructions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifactParameter?].self, forKey: .provisioningArtifactParameters)
        var provisioningArtifactParametersDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifactParameter]? = nil
        if let provisioningArtifactParametersContainer = provisioningArtifactParametersContainer {
            provisioningArtifactParametersDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifactParameter]()
            for structure0 in provisioningArtifactParametersContainer {
                if let structure0 = structure0 {
                    provisioningArtifactParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactParameters = provisioningArtifactParametersDecoded0
        let constraintSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ConstraintSummary?].self, forKey: .constraintSummaries)
        var constraintSummariesDecoded0:[ServiceCatalogClientTypes.ConstraintSummary]? = nil
        if let constraintSummariesContainer = constraintSummariesContainer {
            constraintSummariesDecoded0 = [ServiceCatalogClientTypes.ConstraintSummary]()
            for structure0 in constraintSummariesContainer {
                if let structure0 = structure0 {
                    constraintSummariesDecoded0?.append(structure0)
                }
            }
        }
        constraintSummaries = constraintSummariesDecoded0
        let usageInstructionsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.UsageInstruction?].self, forKey: .usageInstructions)
        var usageInstructionsDecoded0:[ServiceCatalogClientTypes.UsageInstruction]? = nil
        if let usageInstructionsContainer = usageInstructionsContainer {
            usageInstructionsDecoded0 = [ServiceCatalogClientTypes.UsageInstruction]()
            for structure0 in usageInstructionsContainer {
                if let structure0 = structure0 {
                    usageInstructionsDecoded0?.append(structure0)
                }
            }
        }
        usageInstructions = usageInstructionsDecoded0
        let tagOptionsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.TagOptionSummary?].self, forKey: .tagOptions)
        var tagOptionsDecoded0:[ServiceCatalogClientTypes.TagOptionSummary]? = nil
        if let tagOptionsContainer = tagOptionsContainer {
            tagOptionsDecoded0 = [ServiceCatalogClientTypes.TagOptionSummary]()
            for structure0 in tagOptionsContainer {
                if let structure0 = structure0 {
                    tagOptionsDecoded0?.append(structure0)
                }
            }
        }
        tagOptions = tagOptionsDecoded0
        let provisioningArtifactPreferencesDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactPreferences.self, forKey: .provisioningArtifactPreferences)
        provisioningArtifactPreferences = provisioningArtifactPreferencesDecoded
        let provisioningArtifactOutputsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifactOutput?].self, forKey: .provisioningArtifactOutputs)
        var provisioningArtifactOutputsDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifactOutput]? = nil
        if let provisioningArtifactOutputsContainer = provisioningArtifactOutputsContainer {
            provisioningArtifactOutputsDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifactOutput]()
            for structure0 in provisioningArtifactOutputsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactOutputsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactOutputs = provisioningArtifactOutputsDecoded0
        let provisioningArtifactOutputKeysContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifactOutput?].self, forKey: .provisioningArtifactOutputKeys)
        var provisioningArtifactOutputKeysDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifactOutput]? = nil
        if let provisioningArtifactOutputKeysContainer = provisioningArtifactOutputKeysContainer {
            provisioningArtifactOutputKeysDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifactOutput]()
            for structure0 in provisioningArtifactOutputKeysContainer {
                if let structure0 = structure0 {
                    provisioningArtifactOutputKeysDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactOutputKeys = provisioningArtifactOutputKeysDecoded0
    }
}

enum DescribeProvisioningParametersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRecordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

extension DescribeRecordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRecordInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The record identifier of the provisioned product. This identifier is returned by the request operation.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct DescribeRecordInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
    let pageToken: Swift.String?
    let pageSize: Swift.Int?
}

extension DescribeRecordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension DescribeRecordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRecordOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.recordDetail = output.recordDetail
            self.recordOutputs = output.recordOutputs
        } else {
            self.nextPageToken = nil
            self.recordDetail = nil
            self.recordOutputs = nil
        }
    }
}

public struct DescribeRecordOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the product.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?
    /// Information about the product created as the result of a request. For example, the output for a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.
    public var recordOutputs: [ServiceCatalogClientTypes.RecordOutput]?

    public init(
        nextPageToken: Swift.String? = nil,
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil,
        recordOutputs: [ServiceCatalogClientTypes.RecordOutput]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.recordDetail = recordDetail
        self.recordOutputs = recordOutputs
    }
}

struct DescribeRecordOutputBody: Swift.Equatable {
    let recordDetail: ServiceCatalogClientTypes.RecordDetail?
    let recordOutputs: [ServiceCatalogClientTypes.RecordOutput]?
    let nextPageToken: Swift.String?
}

extension DescribeRecordOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case recordDetail = "RecordDetail"
        case recordOutputs = "RecordOutputs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
        let recordOutputsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.RecordOutput?].self, forKey: .recordOutputs)
        var recordOutputsDecoded0:[ServiceCatalogClientTypes.RecordOutput]? = nil
        if let recordOutputsContainer = recordOutputsContainer {
            recordOutputsDecoded0 = [ServiceCatalogClientTypes.RecordOutput]()
            for structure0 in recordOutputsContainer {
                if let structure0 = structure0 {
                    recordOutputsDecoded0?.append(structure0)
                }
            }
        }
        recordOutputs = recordOutputsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum DescribeRecordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeServiceActionExecutionParametersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case provisionedProductId = "ProvisionedProductId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let provisionedProductId = self.provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let serviceActionId = self.serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

extension DescribeServiceActionExecutionParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeServiceActionExecutionParametersInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The identifier of the provisioned product.
    /// This member is required.
    public var provisionedProductId: Swift.String?
    /// The self-service action identifier.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.provisionedProductId = provisionedProductId
        self.serviceActionId = serviceActionId
    }
}

struct DescribeServiceActionExecutionParametersInputBody: Swift.Equatable {
    let provisionedProductId: Swift.String?
    let serviceActionId: Swift.String?
    let acceptLanguage: Swift.String?
}

extension DescribeServiceActionExecutionParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case provisionedProductId = "ProvisionedProductId"
        case serviceActionId = "ServiceActionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension DescribeServiceActionExecutionParametersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeServiceActionExecutionParametersOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceActionParameters = output.serviceActionParameters
        } else {
            self.serviceActionParameters = nil
        }
    }
}

public struct DescribeServiceActionExecutionParametersOutput: Swift.Equatable {
    /// The parameters of the self-service action.
    public var serviceActionParameters: [ServiceCatalogClientTypes.ExecutionParameter]?

    public init(
        serviceActionParameters: [ServiceCatalogClientTypes.ExecutionParameter]? = nil
    )
    {
        self.serviceActionParameters = serviceActionParameters
    }
}

struct DescribeServiceActionExecutionParametersOutputBody: Swift.Equatable {
    let serviceActionParameters: [ServiceCatalogClientTypes.ExecutionParameter]?
}

extension DescribeServiceActionExecutionParametersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceActionParameters = "ServiceActionParameters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ExecutionParameter?].self, forKey: .serviceActionParameters)
        var serviceActionParametersDecoded0:[ServiceCatalogClientTypes.ExecutionParameter]? = nil
        if let serviceActionParametersContainer = serviceActionParametersContainer {
            serviceActionParametersDecoded0 = [ServiceCatalogClientTypes.ExecutionParameter]()
            for structure0 in serviceActionParametersContainer {
                if let structure0 = structure0 {
                    serviceActionParametersDecoded0?.append(structure0)
                }
            }
        }
        serviceActionParameters = serviceActionParametersDecoded0
    }
}

enum DescribeServiceActionExecutionParametersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeServiceActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DescribeServiceActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeServiceActionInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The self-service action identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DescribeServiceActionInputBody: Swift.Equatable {
    let id: Swift.String?
    let acceptLanguage: Swift.String?
}

extension DescribeServiceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension DescribeServiceActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeServiceActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceActionDetail = output.serviceActionDetail
        } else {
            self.serviceActionDetail = nil
        }
    }
}

public struct DescribeServiceActionOutput: Swift.Equatable {
    /// Detailed information about the self-service action.
    public var serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?

    public init(
        serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail? = nil
    )
    {
        self.serviceActionDetail = serviceActionDetail
    }
}

struct DescribeServiceActionOutputBody: Swift.Equatable {
    let serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?
}

extension DescribeServiceActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceActionDetail = "ServiceActionDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionDetail.self, forKey: .serviceActionDetail)
        serviceActionDetail = serviceActionDetailDecoded
    }
}

enum DescribeServiceActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTagOptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeTagOptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeTagOptionInput: Swift.Equatable {
    /// The TagOption identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeTagOptionInputBody: Swift.Equatable {
}

extension DescribeTagOptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTagOptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTagOptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.tagOptionDetail = output.tagOptionDetail
        } else {
            self.tagOptionDetail = nil
        }
    }
}

public struct DescribeTagOptionOutput: Swift.Equatable {
    /// Information about the TagOption.
    public var tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?

    public init(
        tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail? = nil
    )
    {
        self.tagOptionDetail = tagOptionDetail
    }
}

struct DescribeTagOptionOutputBody: Swift.Equatable {
    let tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?
}

extension DescribeTagOptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagOptionDetail = "TagOptionDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagOptionDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.TagOptionDetail.self, forKey: .tagOptionDetail)
        tagOptionDetail = tagOptionDetailDecoded
    }
}

enum DescribeTagOptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableAWSOrganizationsAccessInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DisableAWSOrganizationsAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableAWSOrganizationsAccessInput: Swift.Equatable {

    public init() { }
}

struct DisableAWSOrganizationsAccessInputBody: Swift.Equatable {
}

extension DisableAWSOrganizationsAccessInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisableAWSOrganizationsAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisableAWSOrganizationsAccessOutput: Swift.Equatable {

    public init() { }
}

enum DisableAWSOrganizationsAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateBudgetFromResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DisassociateBudgetFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateBudgetFromResourceInput: Swift.Equatable {
    /// The name of the budget you want to disassociate.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The resource identifier you want to disassociate from. Either a portfolio-id or a product-id.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        budgetName: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.budgetName = budgetName
        self.resourceId = resourceId
    }
}

struct DisassociateBudgetFromResourceInputBody: Swift.Equatable {
    let budgetName: Swift.String?
    let resourceId: Swift.String?
}

extension DisassociateBudgetFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DisassociateBudgetFromResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateBudgetFromResourceOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateBudgetFromResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociatePrincipalFromPortfolioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case principalARN = "PrincipalARN"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let principalARN = self.principalARN {
            try encodeContainer.encode(principalARN, forKey: .principalARN)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

extension DisassociatePrincipalFromPortfolioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociatePrincipalFromPortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The ARN of the principal (user, role, or group). This field allows an ARN with no accountID with or without wildcard characters if PrincipalType is IAM_PATTERN.
    /// This member is required.
    public var principalARN: Swift.String?
    /// The supported value is IAM if you use a fully defined ARN, or IAM_PATTERN if you specify an IAM ARN with no AccountId, with or without wildcard characters.
    public var principalType: ServiceCatalogClientTypes.PrincipalType?

    public init(
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        principalARN: Swift.String? = nil,
        principalType: ServiceCatalogClientTypes.PrincipalType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.principalARN = principalARN
        self.principalType = principalType
    }
}

struct DisassociatePrincipalFromPortfolioInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let principalARN: Swift.String?
    let principalType: ServiceCatalogClientTypes.PrincipalType?
}

extension DisassociatePrincipalFromPortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case principalARN = "PrincipalARN"
        case principalType = "PrincipalType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let principalARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalARN)
        principalARN = principalARNDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension DisassociatePrincipalFromPortfolioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociatePrincipalFromPortfolioOutput: Swift.Equatable {

    public init() { }
}

enum DisassociatePrincipalFromPortfolioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateProductFromPortfolioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

extension DisassociateProductFromPortfolioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateProductFromPortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.productId = productId
    }
}

struct DisassociateProductFromPortfolioInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let productId: Swift.String?
    let portfolioId: Swift.String?
}

extension DisassociateProductFromPortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
    }
}

extension DisassociateProductFromPortfolioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateProductFromPortfolioOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateProductFromPortfolioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateServiceActionFromProvisioningArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let serviceActionId = self.serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

extension DisassociateServiceActionFromProvisioningArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateServiceActionFromProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product identifier. For example, prod-abcdzk7xy33qa.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
        self.serviceActionId = serviceActionId
    }
}

struct DisassociateServiceActionFromProvisioningArtifactInputBody: Swift.Equatable {
    let productId: Swift.String?
    let provisioningArtifactId: Swift.String?
    let serviceActionId: Swift.String?
    let acceptLanguage: Swift.String?
}

extension DisassociateServiceActionFromProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension DisassociateServiceActionFromProvisioningArtifactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateServiceActionFromProvisioningArtifactOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateServiceActionFromProvisioningArtifactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateTagOptionFromResourceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DisassociateTagOptionFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateTagOptionFromResourceInput: Swift.Equatable {
    /// The resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The TagOption identifier.
    /// This member is required.
    public var tagOptionId: Swift.String?

    public init(
        resourceId: Swift.String? = nil,
        tagOptionId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
        self.tagOptionId = tagOptionId
    }
}

struct DisassociateTagOptionFromResourceInputBody: Swift.Equatable {
}

extension DisassociateTagOptionFromResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTagOptionFromResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateTagOptionFromResourceOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateTagOptionFromResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DuplicateResourceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DuplicateResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource is a duplicate.
public struct DuplicateResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateResourceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DuplicateResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EnableAWSOrganizationsAccessInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension EnableAWSOrganizationsAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableAWSOrganizationsAccessInput: Swift.Equatable {

    public init() { }
}

struct EnableAWSOrganizationsAccessInputBody: Swift.Equatable {
}

extension EnableAWSOrganizationsAccessInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension EnableAWSOrganizationsAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct EnableAWSOrganizationsAccessOutput: Swift.Equatable {

    public init() { }
}

enum EnableAWSOrganizationsAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes.EngineWorkflowResourceIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uniqueTag = "UniqueTag"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uniqueTag = self.uniqueTag {
            try encodeContainer.encode(uniqueTag, forKey: .uniqueTag)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uniqueTagDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.UniqueTagResourceIdentifier.self, forKey: .uniqueTag)
        uniqueTag = uniqueTagDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// The ID for the provisioned product resources that are part of a resource group.
    public struct EngineWorkflowResourceIdentifier: Swift.Equatable {
        /// The unique key-value pair for a tag that identifies provisioned product resources.
        public var uniqueTag: ServiceCatalogClientTypes.UniqueTagResourceIdentifier?

        public init(
            uniqueTag: ServiceCatalogClientTypes.UniqueTagResourceIdentifier? = nil
        )
        {
            self.uniqueTag = uniqueTag
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum EngineWorkflowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [EngineWorkflowStatus] {
            return [
                .failed,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EngineWorkflowStatus(rawValue: rawValue) ?? EngineWorkflowStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum EvaluationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationType] {
            return [
                .dynamic,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dynamic: return "DYNAMIC"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationType(rawValue: rawValue) ?? EvaluationType.sdkUnknown(rawValue)
        }
    }
}

extension ExecuteProvisionedProductPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case planId = "PlanId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let planId = self.planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
    }
}

extension ExecuteProvisionedProductPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExecuteProvisionedProductPlanInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The plan identifier.
    /// This member is required.
    public var planId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        planId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.planId = planId
    }
}

struct ExecuteProvisionedProductPlanInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let planId: Swift.String?
    let idempotencyToken: Swift.String?
}

extension ExecuteProvisionedProductPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case planId = "PlanId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planId)
        planId = planIdDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension ExecuteProvisionedProductPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExecuteProvisionedProductPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct ExecuteProvisionedProductPlanOutput: Swift.Equatable {
    /// Information about the result of provisioning the product.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init(
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct ExecuteProvisionedProductPlanOutputBody: Swift.Equatable {
    let recordDetail: ServiceCatalogClientTypes.RecordDetail?
}

extension ExecuteProvisionedProductPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

enum ExecuteProvisionedProductPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExecuteProvisionedProductServiceActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case executeToken = "ExecuteToken"
        case parameters = "Parameters"
        case provisionedProductId = "ProvisionedProductId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let executeToken = self.executeToken {
            try encodeContainer.encode(executeToken, forKey: .executeToken)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, executionParameterMap0) in parameters {
                var executionParameterMap0Container = parametersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for executionparametervalue1 in executionParameterMap0 {
                    try executionParameterMap0Container.encode(executionparametervalue1)
                }
            }
        }
        if let provisionedProductId = self.provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let serviceActionId = self.serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

extension ExecuteProvisionedProductServiceActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExecuteProvisionedProductServiceActionInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// An idempotency token that uniquely identifies the execute request.
    /// This member is required.
    public var executeToken: Swift.String?
    /// A map of all self-service action parameters and their values. If a provided parameter is of a special type, such as TARGET, the provided value will override the default value generated by Service Catalog. If the parameters field is not provided, no additional parameters are passed and default values will be used for any special parameters such as TARGET.
    public var parameters: [Swift.String:[Swift.String]]?
    /// The identifier of the provisioned product.
    /// This member is required.
    public var provisionedProductId: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        executeToken: Swift.String? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        provisionedProductId: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.executeToken = executeToken
        self.parameters = parameters
        self.provisionedProductId = provisionedProductId
        self.serviceActionId = serviceActionId
    }
}

struct ExecuteProvisionedProductServiceActionInputBody: Swift.Equatable {
    let provisionedProductId: Swift.String?
    let serviceActionId: Swift.String?
    let executeToken: Swift.String?
    let acceptLanguage: Swift.String?
    let parameters: [Swift.String:[Swift.String]]?
}

extension ExecuteProvisionedProductServiceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case executeToken = "ExecuteToken"
        case parameters = "Parameters"
        case provisionedProductId = "ProvisionedProductId"
        case serviceActionId = "ServiceActionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let executeTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executeToken)
        executeToken = executeTokenDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, executionparametervaluelist0) in parametersContainer {
                var executionparametervaluelist0Decoded0: [Swift.String]? = nil
                if let executionparametervaluelist0 = executionparametervaluelist0 {
                    executionparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in executionparametervaluelist0 {
                        if let string1 = string1 {
                            executionparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = executionparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension ExecuteProvisionedProductServiceActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExecuteProvisionedProductServiceActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct ExecuteProvisionedProductServiceActionOutput: Swift.Equatable {
    /// An object containing detailed information about the result of provisioning the product.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init(
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct ExecuteProvisionedProductServiceActionOutputBody: Swift.Equatable {
    let recordDetail: ServiceCatalogClientTypes.RecordDetail?
}

extension ExecuteProvisionedProductServiceActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

enum ExecuteProvisionedProductServiceActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes.ExecutionParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValues = "DefaultValues"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValues = defaultValues {
            var defaultValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultValues)
            for executionparametervalue0 in defaultValues {
                try defaultValuesContainer.encode(executionparametervalue0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let defaultValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .defaultValues)
        var defaultValuesDecoded0:[Swift.String]? = nil
        if let defaultValuesContainer = defaultValuesContainer {
            defaultValuesDecoded0 = [Swift.String]()
            for string0 in defaultValuesContainer {
                if let string0 = string0 {
                    defaultValuesDecoded0?.append(string0)
                }
            }
        }
        defaultValues = defaultValuesDecoded0
    }
}

extension ServiceCatalogClientTypes {
    /// Details of an execution parameter value that is passed to a self-service action when executed on a provisioned product.
    public struct ExecutionParameter: Swift.Equatable {
        /// The default values for the execution parameter.
        public var defaultValues: [Swift.String]?
        /// The name of the execution parameter.
        public var name: Swift.String?
        /// The execution parameter type.
        public var type: Swift.String?

        public init(
            defaultValues: [Swift.String]? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.defaultValues = defaultValues
            self.name = name
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes.FailedServiceActionAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let serviceActionId = self.serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionAssociationErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// An object containing information about the error, along with identifying information about the self-service action and its associations.
    public struct FailedServiceActionAssociation: Swift.Equatable {
        /// The error code. Valid values are listed below.
        public var errorCode: ServiceCatalogClientTypes.ServiceActionAssociationErrorCode?
        /// A text description of the error.
        public var errorMessage: Swift.String?
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        public var productId: Swift.String?
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        public var provisioningArtifactId: Swift.String?
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        public var serviceActionId: Swift.String?

        public init(
            errorCode: ServiceCatalogClientTypes.ServiceActionAssociationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            productId: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            serviceActionId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.serviceActionId = serviceActionId
        }
    }

}

extension GetAWSOrganizationsAccessStatusInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetAWSOrganizationsAccessStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAWSOrganizationsAccessStatusInput: Swift.Equatable {

    public init() { }
}

struct GetAWSOrganizationsAccessStatusInputBody: Swift.Equatable {
}

extension GetAWSOrganizationsAccessStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAWSOrganizationsAccessStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAWSOrganizationsAccessStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessStatus = output.accessStatus
        } else {
            self.accessStatus = nil
        }
    }
}

public struct GetAWSOrganizationsAccessStatusOutput: Swift.Equatable {
    /// The status of the portfolio share feature.
    public var accessStatus: ServiceCatalogClientTypes.AccessStatus?

    public init(
        accessStatus: ServiceCatalogClientTypes.AccessStatus? = nil
    )
    {
        self.accessStatus = accessStatus
    }
}

struct GetAWSOrganizationsAccessStatusOutputBody: Swift.Equatable {
    let accessStatus: ServiceCatalogClientTypes.AccessStatus?
}

extension GetAWSOrganizationsAccessStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessStatus = "AccessStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessStatusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.AccessStatus.self, forKey: .accessStatus)
        accessStatus = accessStatusDecoded
    }
}

enum GetAWSOrganizationsAccessStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProvisionedProductOutputsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case outputKeys = "OutputKeys"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let outputKeys = outputKeys {
            var outputKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputKeys)
            for outputkey0 in outputKeys {
                try outputKeysContainer.encode(outputkey0)
            }
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let provisionedProductId = self.provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductName = self.provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
    }
}

extension GetProvisionedProductOutputsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetProvisionedProductOutputsInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The list of keys that the API should return with their values. If none are provided, the API will return all outputs of the provisioned product.
    public var outputKeys: [Swift.String]?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The identifier of the provisioned product that you want the outputs from.
    public var provisionedProductId: Swift.String?
    /// The name of the provisioned product that you want the outputs from.
    public var provisionedProductName: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        outputKeys: [Swift.String]? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.outputKeys = outputKeys
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
    }
}

struct GetProvisionedProductOutputsInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let provisionedProductId: Swift.String?
    let provisionedProductName: Swift.String?
    let outputKeys: [Swift.String]?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
}

extension GetProvisionedProductOutputsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case outputKeys = "OutputKeys"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let outputKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outputKeys)
        var outputKeysDecoded0:[Swift.String]? = nil
        if let outputKeysContainer = outputKeysContainer {
            outputKeysDecoded0 = [Swift.String]()
            for string0 in outputKeysContainer {
                if let string0 = string0 {
                    outputKeysDecoded0?.append(string0)
                }
            }
        }
        outputKeys = outputKeysDecoded0
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension GetProvisionedProductOutputsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProvisionedProductOutputsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.outputs = output.outputs
        } else {
            self.nextPageToken = nil
            self.outputs = nil
        }
    }
}

public struct GetProvisionedProductOutputsOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the product created as the result of a request. For example, the output for a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.
    public var outputs: [ServiceCatalogClientTypes.RecordOutput]?

    public init(
        nextPageToken: Swift.String? = nil,
        outputs: [ServiceCatalogClientTypes.RecordOutput]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.outputs = outputs
    }
}

struct GetProvisionedProductOutputsOutputBody: Swift.Equatable {
    let outputs: [ServiceCatalogClientTypes.RecordOutput]?
    let nextPageToken: Swift.String?
}

extension GetProvisionedProductOutputsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case outputs = "Outputs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.RecordOutput?].self, forKey: .outputs)
        var outputsDecoded0:[ServiceCatalogClientTypes.RecordOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ServiceCatalogClientTypes.RecordOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum GetProvisionedProductOutputsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportAsProvisionedProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case physicalId = "PhysicalId"
        case productId = "ProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let physicalId = self.physicalId {
            try encodeContainer.encode(physicalId, forKey: .physicalId)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisionedProductName = self.provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }
}

extension ImportAsProvisionedProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportAsProvisionedProductInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The unique identifier of the resource to be imported. It only currently supports CloudFormation stack IDs.
    /// This member is required.
    public var physicalId: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The user-friendly name of the provisioned product. The value must be unique for the Amazon Web Services account. The name cannot be updated after the product is provisioned.
    /// This member is required.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        physicalId: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.physicalId = physicalId
        self.productId = productId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct ImportAsProvisionedProductInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let productId: Swift.String?
    let provisioningArtifactId: Swift.String?
    let provisionedProductName: Swift.String?
    let physicalId: Swift.String?
    let idempotencyToken: Swift.String?
}

extension ImportAsProvisionedProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case physicalId = "PhysicalId"
        case productId = "ProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let physicalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalId)
        physicalId = physicalIdDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension ImportAsProvisionedProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportAsProvisionedProductOutputBody = try responseDecoder.decode(responseBody: data)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct ImportAsProvisionedProductOutput: Swift.Equatable {
    /// Information about a request operation.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init(
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct ImportAsProvisionedProductOutputBody: Swift.Equatable {
    let recordDetail: ServiceCatalogClientTypes.RecordDetail?
}

extension ImportAsProvisionedProductOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

enum ImportAsProvisionedProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InvalidParametersException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParametersExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more parameters provided to the operation are not valid.
public struct InvalidParametersException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParametersException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParametersExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParametersExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An attempt was made to modify a resource that is in a state that is not valid. Check your resources to ensure that they are in valid states before retrying the operation.
public struct InvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceCatalogClientTypes.LastSync: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastSuccessfulSyncProvisioningArtifactId = "LastSuccessfulSyncProvisioningArtifactId"
        case lastSuccessfulSyncTime = "LastSuccessfulSyncTime"
        case lastSyncStatus = "LastSyncStatus"
        case lastSyncStatusMessage = "LastSyncStatusMessage"
        case lastSyncTime = "LastSyncTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastSuccessfulSyncProvisioningArtifactId = self.lastSuccessfulSyncProvisioningArtifactId {
            try encodeContainer.encode(lastSuccessfulSyncProvisioningArtifactId, forKey: .lastSuccessfulSyncProvisioningArtifactId)
        }
        if let lastSuccessfulSyncTime = self.lastSuccessfulSyncTime {
            try encodeContainer.encodeTimestamp(lastSuccessfulSyncTime, format: .epochSeconds, forKey: .lastSuccessfulSyncTime)
        }
        if let lastSyncStatus = self.lastSyncStatus {
            try encodeContainer.encode(lastSyncStatus.rawValue, forKey: .lastSyncStatus)
        }
        if let lastSyncStatusMessage = self.lastSyncStatusMessage {
            try encodeContainer.encode(lastSyncStatusMessage, forKey: .lastSyncStatusMessage)
        }
        if let lastSyncTime = self.lastSyncTime {
            try encodeContainer.encodeTimestamp(lastSyncTime, format: .epochSeconds, forKey: .lastSyncTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastSyncTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSyncTime)
        lastSyncTime = lastSyncTimeDecoded
        let lastSyncStatusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.LastSyncStatus.self, forKey: .lastSyncStatus)
        lastSyncStatus = lastSyncStatusDecoded
        let lastSyncStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSyncStatusMessage)
        lastSyncStatusMessage = lastSyncStatusMessageDecoded
        let lastSuccessfulSyncTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSuccessfulSyncTime)
        lastSuccessfulSyncTime = lastSuccessfulSyncTimeDecoded
        let lastSuccessfulSyncProvisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSuccessfulSyncProvisioningArtifactId)
        lastSuccessfulSyncProvisioningArtifactId = lastSuccessfulSyncProvisioningArtifactIdDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Provides details about the product's connection sync and contains the following sub-fields.
    ///
    /// * LastSyncTime
    ///
    /// * LastSyncStatus
    ///
    /// * LastSyncStatusMessage
    ///
    /// * LastSuccessfulSyncTime
    ///
    /// * LastSuccessfulSyncProvisioningArtifactID
    public struct LastSync: Swift.Equatable {
        /// The ProvisioningArtifactID of the ProvisioningArtifact created from the latest successful sync.
        public var lastSuccessfulSyncProvisioningArtifactId: Swift.String?
        /// The time of the latest successful sync from the source repo artifact to the Service Catalog product.
        public var lastSuccessfulSyncTime: ClientRuntime.Date?
        /// The current status of the sync. Responses include SUCCEEDED or FAILED.
        public var lastSyncStatus: ServiceCatalogClientTypes.LastSyncStatus?
        /// The sync's status message.
        public var lastSyncStatusMessage: Swift.String?
        /// The time of the last attempted sync from the repository to the Service Catalog product.
        public var lastSyncTime: ClientRuntime.Date?

        public init(
            lastSuccessfulSyncProvisioningArtifactId: Swift.String? = nil,
            lastSuccessfulSyncTime: ClientRuntime.Date? = nil,
            lastSyncStatus: ServiceCatalogClientTypes.LastSyncStatus? = nil,
            lastSyncStatusMessage: Swift.String? = nil,
            lastSyncTime: ClientRuntime.Date? = nil
        )
        {
            self.lastSuccessfulSyncProvisioningArtifactId = lastSuccessfulSyncProvisioningArtifactId
            self.lastSuccessfulSyncTime = lastSuccessfulSyncTime
            self.lastSyncStatus = lastSyncStatus
            self.lastSyncStatusMessage = lastSyncStatusMessage
            self.lastSyncTime = lastSyncTime
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum LastSyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LastSyncStatus] {
            return [
                .failed,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastSyncStatus(rawValue: rawValue) ?? LastSyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.LaunchPath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// A launch path object.
    public struct LaunchPath: Swift.Equatable {
        /// The identifier of the launch path.
        public var id: Swift.String?
        /// The name of the launch path.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension ServiceCatalogClientTypes.LaunchPathSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintSummaries = "ConstraintSummaries"
        case id = "Id"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraintSummaries = constraintSummaries {
            var constraintSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .constraintSummaries)
            for constraintsummary0 in constraintSummaries {
                try constraintSummariesContainer.encode(constraintsummary0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let constraintSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ConstraintSummary?].self, forKey: .constraintSummaries)
        var constraintSummariesDecoded0:[ServiceCatalogClientTypes.ConstraintSummary]? = nil
        if let constraintSummariesContainer = constraintSummariesContainer {
            constraintSummariesDecoded0 = [ServiceCatalogClientTypes.ConstraintSummary]()
            for structure0 in constraintSummariesContainer {
                if let structure0 = structure0 {
                    constraintSummariesDecoded0?.append(structure0)
                }
            }
        }
        constraintSummaries = constraintSummariesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Summary information about a product path for a user.
    public struct LaunchPathSummary: Swift.Equatable {
        /// The constraints on the portfolio-product relationship.
        public var constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]?
        /// The identifier of the product path.
        public var id: Swift.String?
        /// The name of the portfolio that contains the product.
        public var name: Swift.String?
        /// The tags associated with this product path.
        public var tags: [ServiceCatalogClientTypes.Tag]?

        public init(
            constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [ServiceCatalogClientTypes.Tag]? = nil
        )
        {
            self.constraintSummaries = constraintSummaries
            self.id = id
            self.name = name
            self.tags = tags
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The current limits of the service would have been exceeded by this operation. Decrease your resource use or increase your service limits and retry the operation.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAcceptedPortfolioSharesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioShareType = "PortfolioShareType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioShareType = self.portfolioShareType {
            try encodeContainer.encode(portfolioShareType.rawValue, forKey: .portfolioShareType)
        }
    }
}

extension ListAcceptedPortfolioSharesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAcceptedPortfolioSharesInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The type of shared portfolios to list. The default is to list imported portfolios.
    ///
    /// * AWS_ORGANIZATIONS - List portfolios accepted and shared via organizational sharing by the management account or delegated administrator of your organization.
    ///
    /// * AWS_SERVICECATALOG - Deprecated type.
    ///
    /// * IMPORTED - List imported portfolios that have been accepted and shared through account-to-account sharing.
    public var portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioShareType = portfolioShareType
    }
}

struct ListAcceptedPortfolioSharesInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let pageToken: Swift.String?
    let pageSize: Swift.Int?
    let portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?
}

extension ListAcceptedPortfolioSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioShareType = "PortfolioShareType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let portfolioShareTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PortfolioShareType.self, forKey: .portfolioShareType)
        portfolioShareType = portfolioShareTypeDecoded
    }
}

extension ListAcceptedPortfolioSharesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAcceptedPortfolioSharesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.portfolioDetails = output.portfolioDetails
        } else {
            self.nextPageToken = nil
            self.portfolioDetails = nil
        }
    }
}

public struct ListAcceptedPortfolioSharesOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the portfolios.
    public var portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioDetails = portfolioDetails
    }
}

struct ListAcceptedPortfolioSharesOutputBody: Swift.Equatable {
    let portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?
    let nextPageToken: Swift.String?
}

extension ListAcceptedPortfolioSharesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case portfolioDetails = "PortfolioDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.PortfolioDetail?].self, forKey: .portfolioDetails)
        var portfolioDetailsDecoded0:[ServiceCatalogClientTypes.PortfolioDetail]? = nil
        if let portfolioDetailsContainer = portfolioDetailsContainer {
            portfolioDetailsDecoded0 = [ServiceCatalogClientTypes.PortfolioDetail]()
            for structure0 in portfolioDetailsContainer {
                if let structure0 = structure0 {
                    portfolioDetailsDecoded0?.append(structure0)
                }
            }
        }
        portfolioDetails = portfolioDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListAcceptedPortfolioSharesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBudgetsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ListBudgetsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBudgetsForResourceInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.resourceId = resourceId
    }
}

struct ListBudgetsForResourceInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let resourceId: Swift.String?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
}

extension ListBudgetsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListBudgetsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBudgetsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.budgets = output.budgets
            self.nextPageToken = output.nextPageToken
        } else {
            self.budgets = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListBudgetsForResourceOutput: Swift.Equatable {
    /// Information about the associated budgets.
    public var budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?

    public init(
        budgets: [ServiceCatalogClientTypes.BudgetDetail]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.budgets = budgets
        self.nextPageToken = nextPageToken
    }
}

struct ListBudgetsForResourceOutputBody: Swift.Equatable {
    let budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    let nextPageToken: Swift.String?
}

extension ListBudgetsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgets = "Budgets"
        case nextPageToken = "NextPageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.BudgetDetail?].self, forKey: .budgets)
        var budgetsDecoded0:[ServiceCatalogClientTypes.BudgetDetail]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [ServiceCatalogClientTypes.BudgetDetail]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListBudgetsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConstraintsForPortfolioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

extension ListConstraintsForPortfolioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListConstraintsForPortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The product identifier.
    public var productId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
        self.productId = productId
    }
}

struct ListConstraintsForPortfolioInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let productId: Swift.String?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
}

extension ListConstraintsForPortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListConstraintsForPortfolioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConstraintsForPortfolioOutputBody = try responseDecoder.decode(responseBody: data)
            self.constraintDetails = output.constraintDetails
            self.nextPageToken = output.nextPageToken
        } else {
            self.constraintDetails = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListConstraintsForPortfolioOutput: Swift.Equatable {
    /// Information about the constraints.
    public var constraintDetails: [ServiceCatalogClientTypes.ConstraintDetail]?
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?

    public init(
        constraintDetails: [ServiceCatalogClientTypes.ConstraintDetail]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.constraintDetails = constraintDetails
        self.nextPageToken = nextPageToken
    }
}

struct ListConstraintsForPortfolioOutputBody: Swift.Equatable {
    let constraintDetails: [ServiceCatalogClientTypes.ConstraintDetail]?
    let nextPageToken: Swift.String?
}

extension ListConstraintsForPortfolioOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintDetails = "ConstraintDetails"
        case nextPageToken = "NextPageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ConstraintDetail?].self, forKey: .constraintDetails)
        var constraintDetailsDecoded0:[ServiceCatalogClientTypes.ConstraintDetail]? = nil
        if let constraintDetailsContainer = constraintDetailsContainer {
            constraintDetailsDecoded0 = [ServiceCatalogClientTypes.ConstraintDetail]()
            for structure0 in constraintDetailsContainer {
                if let structure0 = structure0 {
                    constraintDetailsDecoded0?.append(structure0)
                }
            }
        }
        constraintDetails = constraintDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListConstraintsForPortfolioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLaunchPathsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

extension ListLaunchPathsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLaunchPathsInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.productId = productId
    }
}

struct ListLaunchPathsInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let productId: Swift.String?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
}

extension ListLaunchPathsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListLaunchPathsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLaunchPathsOutputBody = try responseDecoder.decode(responseBody: data)
            self.launchPathSummaries = output.launchPathSummaries
            self.nextPageToken = output.nextPageToken
        } else {
            self.launchPathSummaries = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListLaunchPathsOutput: Swift.Equatable {
    /// Information about the launch path.
    public var launchPathSummaries: [ServiceCatalogClientTypes.LaunchPathSummary]?
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?

    public init(
        launchPathSummaries: [ServiceCatalogClientTypes.LaunchPathSummary]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.launchPathSummaries = launchPathSummaries
        self.nextPageToken = nextPageToken
    }
}

struct ListLaunchPathsOutputBody: Swift.Equatable {
    let launchPathSummaries: [ServiceCatalogClientTypes.LaunchPathSummary]?
    let nextPageToken: Swift.String?
}

extension ListLaunchPathsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchPathSummaries = "LaunchPathSummaries"
        case nextPageToken = "NextPageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchPathSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.LaunchPathSummary?].self, forKey: .launchPathSummaries)
        var launchPathSummariesDecoded0:[ServiceCatalogClientTypes.LaunchPathSummary]? = nil
        if let launchPathSummariesContainer = launchPathSummariesContainer {
            launchPathSummariesDecoded0 = [ServiceCatalogClientTypes.LaunchPathSummary]()
            for structure0 in launchPathSummariesContainer {
                if let structure0 = structure0 {
                    launchPathSummariesDecoded0?.append(structure0)
                }
            }
        }
        launchPathSummaries = launchPathSummariesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListLaunchPathsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOrganizationPortfolioAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case organizationNodeType = "OrganizationNodeType"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let organizationNodeType = self.organizationNodeType {
            try encodeContainer.encode(organizationNodeType.rawValue, forKey: .organizationNodeType)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
    }
}

extension ListOrganizationPortfolioAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOrganizationPortfolioAccessInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The organization node type that will be returned in the output.
    ///
    /// * ORGANIZATION - Organization that has access to the portfolio.
    ///
    /// * ORGANIZATIONAL_UNIT - Organizational unit that has access to the portfolio within your organization.
    ///
    /// * ACCOUNT - Account that has access to the portfolio within your organization.
    /// This member is required.
    public var organizationNodeType: ServiceCatalogClientTypes.OrganizationNodeType?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier. For example, port-2abcdext3y5fk.
    /// This member is required.
    public var portfolioId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        organizationNodeType: ServiceCatalogClientTypes.OrganizationNodeType? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.organizationNodeType = organizationNodeType
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
    }
}

struct ListOrganizationPortfolioAccessInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let organizationNodeType: ServiceCatalogClientTypes.OrganizationNodeType?
    let pageToken: Swift.String?
    let pageSize: Swift.Int?
}

extension ListOrganizationPortfolioAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case organizationNodeType = "OrganizationNodeType"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let organizationNodeTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.OrganizationNodeType.self, forKey: .organizationNodeType)
        organizationNodeType = organizationNodeTypeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListOrganizationPortfolioAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOrganizationPortfolioAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.organizationNodes = output.organizationNodes
        } else {
            self.nextPageToken = nil
            self.organizationNodes = nil
        }
    }
}

public struct ListOrganizationPortfolioAccessOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Displays information about the organization nodes.
    public var organizationNodes: [ServiceCatalogClientTypes.OrganizationNode]?

    public init(
        nextPageToken: Swift.String? = nil,
        organizationNodes: [ServiceCatalogClientTypes.OrganizationNode]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.organizationNodes = organizationNodes
    }
}

struct ListOrganizationPortfolioAccessOutputBody: Swift.Equatable {
    let organizationNodes: [ServiceCatalogClientTypes.OrganizationNode]?
    let nextPageToken: Swift.String?
}

extension ListOrganizationPortfolioAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case organizationNodes = "OrganizationNodes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationNodesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.OrganizationNode?].self, forKey: .organizationNodes)
        var organizationNodesDecoded0:[ServiceCatalogClientTypes.OrganizationNode]? = nil
        if let organizationNodesContainer = organizationNodesContainer {
            organizationNodesDecoded0 = [ServiceCatalogClientTypes.OrganizationNode]()
            for structure0 in organizationNodesContainer {
                if let structure0 = structure0 {
                    organizationNodesDecoded0?.append(structure0)
                }
            }
        }
        organizationNodes = organizationNodesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListOrganizationPortfolioAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPortfolioAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case organizationParentId = "OrganizationParentId"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let organizationParentId = self.organizationParentId {
            try encodeContainer.encode(organizationParentId, forKey: .organizationParentId)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
    }
}

extension ListPortfolioAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPortfolioAccessInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The ID of an organization node the portfolio is shared with. All children of this node with an inherited portfolio share will be returned.
    public var organizationParentId: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        organizationParentId: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.organizationParentId = organizationParentId
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
    }
}

struct ListPortfolioAccessInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let organizationParentId: Swift.String?
    let pageToken: Swift.String?
    let pageSize: Swift.Int?
}

extension ListPortfolioAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case organizationParentId = "OrganizationParentId"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let organizationParentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationParentId)
        organizationParentId = organizationParentIdDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListPortfolioAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPortfolioAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountIds = output.accountIds
            self.nextPageToken = output.nextPageToken
        } else {
            self.accountIds = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListPortfolioAccessOutput: Swift.Equatable {
    /// Information about the Amazon Web Services accounts with access to the portfolio.
    public var accountIds: [Swift.String]?
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.nextPageToken = nextPageToken
    }
}

struct ListPortfolioAccessOutputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let nextPageToken: Swift.String?
}

extension ListPortfolioAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case nextPageToken = "NextPageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListPortfolioAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPortfoliosForProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

extension ListPortfoliosForProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPortfoliosForProductInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.productId = productId
    }
}

struct ListPortfoliosForProductInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let productId: Swift.String?
    let pageToken: Swift.String?
    let pageSize: Swift.Int?
}

extension ListPortfoliosForProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListPortfoliosForProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPortfoliosForProductOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.portfolioDetails = output.portfolioDetails
        } else {
            self.nextPageToken = nil
            self.portfolioDetails = nil
        }
    }
}

public struct ListPortfoliosForProductOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the portfolios.
    public var portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioDetails = portfolioDetails
    }
}

struct ListPortfoliosForProductOutputBody: Swift.Equatable {
    let portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?
    let nextPageToken: Swift.String?
}

extension ListPortfoliosForProductOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case portfolioDetails = "PortfolioDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.PortfolioDetail?].self, forKey: .portfolioDetails)
        var portfolioDetailsDecoded0:[ServiceCatalogClientTypes.PortfolioDetail]? = nil
        if let portfolioDetailsContainer = portfolioDetailsContainer {
            portfolioDetailsDecoded0 = [ServiceCatalogClientTypes.PortfolioDetail]()
            for structure0 in portfolioDetailsContainer {
                if let structure0 = structure0 {
                    portfolioDetailsDecoded0?.append(structure0)
                }
            }
        }
        portfolioDetails = portfolioDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListPortfoliosForProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPortfoliosInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

extension ListPortfoliosInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPortfoliosInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct ListPortfoliosInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let pageToken: Swift.String?
    let pageSize: Swift.Int?
}

extension ListPortfoliosInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListPortfoliosOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPortfoliosOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.portfolioDetails = output.portfolioDetails
        } else {
            self.nextPageToken = nil
            self.portfolioDetails = nil
        }
    }
}

public struct ListPortfoliosOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the portfolios.
    public var portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioDetails = portfolioDetails
    }
}

struct ListPortfoliosOutputBody: Swift.Equatable {
    let portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?
    let nextPageToken: Swift.String?
}

extension ListPortfoliosOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case portfolioDetails = "PortfolioDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.PortfolioDetail?].self, forKey: .portfolioDetails)
        var portfolioDetailsDecoded0:[ServiceCatalogClientTypes.PortfolioDetail]? = nil
        if let portfolioDetailsContainer = portfolioDetailsContainer {
            portfolioDetailsDecoded0 = [ServiceCatalogClientTypes.PortfolioDetail]()
            for structure0 in portfolioDetailsContainer {
                if let structure0 = structure0 {
                    portfolioDetailsDecoded0?.append(structure0)
                }
            }
        }
        portfolioDetails = portfolioDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListPortfoliosOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPrincipalsForPortfolioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
    }
}

extension ListPrincipalsForPortfolioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPrincipalsForPortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
    }
}

struct ListPrincipalsForPortfolioInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
}

extension ListPrincipalsForPortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListPrincipalsForPortfolioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPrincipalsForPortfolioOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.principals = output.principals
        } else {
            self.nextPageToken = nil
            self.principals = nil
        }
    }
}

public struct ListPrincipalsForPortfolioOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// The PrincipalARNs and corresponding PrincipalTypes associated with the portfolio.
    public var principals: [ServiceCatalogClientTypes.Principal]?

    public init(
        nextPageToken: Swift.String? = nil,
        principals: [ServiceCatalogClientTypes.Principal]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.principals = principals
    }
}

struct ListPrincipalsForPortfolioOutputBody: Swift.Equatable {
    let principals: [ServiceCatalogClientTypes.Principal]?
    let nextPageToken: Swift.String?
}

extension ListPrincipalsForPortfolioOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case principals = "Principals"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Principal?].self, forKey: .principals)
        var principalsDecoded0:[ServiceCatalogClientTypes.Principal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [ServiceCatalogClientTypes.Principal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListPrincipalsForPortfolioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProvisionedProductPlansInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionProductId = "ProvisionProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accessLevelFilter = self.accessLevelFilter {
            try encodeContainer.encode(accessLevelFilter, forKey: .accessLevelFilter)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let provisionProductId = self.provisionProductId {
            try encodeContainer.encode(provisionProductId, forKey: .provisionProductId)
        }
    }
}

extension ListProvisionedProductPlansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProvisionedProductPlansInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The access level to use to obtain results. The default is User.
    public var accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The product identifier.
    public var provisionProductId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        provisionProductId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.provisionProductId = provisionProductId
    }
}

struct ListProvisionedProductPlansInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let provisionProductId: Swift.String?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
    let accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
}

extension ListProvisionedProductPlansInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionProductId = "ProvisionProductId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionProductId)
        provisionProductId = provisionProductIdDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let accessLevelFilterDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.AccessLevelFilter.self, forKey: .accessLevelFilter)
        accessLevelFilter = accessLevelFilterDecoded
    }
}

extension ListProvisionedProductPlansOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProvisionedProductPlansOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.provisionedProductPlans = output.provisionedProductPlans
        } else {
            self.nextPageToken = nil
            self.provisionedProductPlans = nil
        }
    }
}

public struct ListProvisionedProductPlansOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the plans.
    public var provisionedProductPlans: [ServiceCatalogClientTypes.ProvisionedProductPlanSummary]?

    public init(
        nextPageToken: Swift.String? = nil,
        provisionedProductPlans: [ServiceCatalogClientTypes.ProvisionedProductPlanSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProductPlans = provisionedProductPlans
    }
}

struct ListProvisionedProductPlansOutputBody: Swift.Equatable {
    let provisionedProductPlans: [ServiceCatalogClientTypes.ProvisionedProductPlanSummary]?
    let nextPageToken: Swift.String?
}

extension ListProvisionedProductPlansOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case provisionedProductPlans = "ProvisionedProductPlans"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductPlansContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisionedProductPlanSummary?].self, forKey: .provisionedProductPlans)
        var provisionedProductPlansDecoded0:[ServiceCatalogClientTypes.ProvisionedProductPlanSummary]? = nil
        if let provisionedProductPlansContainer = provisionedProductPlansContainer {
            provisionedProductPlansDecoded0 = [ServiceCatalogClientTypes.ProvisionedProductPlanSummary]()
            for structure0 in provisionedProductPlansContainer {
                if let structure0 = structure0 {
                    provisionedProductPlansDecoded0?.append(structure0)
                }
            }
        }
        provisionedProductPlans = provisionedProductPlansDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListProvisionedProductPlansOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProvisioningArtifactsForServiceActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let serviceActionId = self.serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

extension ListProvisioningArtifactsForServiceActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProvisioningArtifactsForServiceActionInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.serviceActionId = serviceActionId
    }
}

struct ListProvisioningArtifactsForServiceActionInputBody: Swift.Equatable {
    let serviceActionId: Swift.String?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
    let acceptLanguage: Swift.String?
}

extension ListProvisioningArtifactsForServiceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case serviceActionId = "ServiceActionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension ListProvisioningArtifactsForServiceActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProvisioningArtifactsForServiceActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.provisioningArtifactViews = output.provisioningArtifactViews
        } else {
            self.nextPageToken = nil
            self.provisioningArtifactViews = nil
        }
    }
}

public struct ListProvisioningArtifactsForServiceActionOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// An array of objects with information about product views and provisioning artifacts.
    public var provisioningArtifactViews: [ServiceCatalogClientTypes.ProvisioningArtifactView]?

    public init(
        nextPageToken: Swift.String? = nil,
        provisioningArtifactViews: [ServiceCatalogClientTypes.ProvisioningArtifactView]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisioningArtifactViews = provisioningArtifactViews
    }
}

struct ListProvisioningArtifactsForServiceActionOutputBody: Swift.Equatable {
    let provisioningArtifactViews: [ServiceCatalogClientTypes.ProvisioningArtifactView]?
    let nextPageToken: Swift.String?
}

extension ListProvisioningArtifactsForServiceActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case provisioningArtifactViews = "ProvisioningArtifactViews"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactViewsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifactView?].self, forKey: .provisioningArtifactViews)
        var provisioningArtifactViewsDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifactView]? = nil
        if let provisioningArtifactViewsContainer = provisioningArtifactViewsContainer {
            provisioningArtifactViewsDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifactView]()
            for structure0 in provisioningArtifactViewsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactViewsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactViews = provisioningArtifactViewsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListProvisioningArtifactsForServiceActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProvisioningArtifactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

extension ListProvisioningArtifactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProvisioningArtifactsInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
    }
}

struct ListProvisioningArtifactsInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let productId: Swift.String?
}

extension ListProvisioningArtifactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
    }
}

extension ListProvisioningArtifactsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProvisioningArtifactsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.provisioningArtifactDetails = output.provisioningArtifactDetails
        } else {
            self.nextPageToken = nil
            self.provisioningArtifactDetails = nil
        }
    }
}

public struct ListProvisioningArtifactsOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the provisioning artifacts.
    public var provisioningArtifactDetails: [ServiceCatalogClientTypes.ProvisioningArtifactDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        provisioningArtifactDetails: [ServiceCatalogClientTypes.ProvisioningArtifactDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisioningArtifactDetails = provisioningArtifactDetails
    }
}

struct ListProvisioningArtifactsOutputBody: Swift.Equatable {
    let provisioningArtifactDetails: [ServiceCatalogClientTypes.ProvisioningArtifactDetail]?
    let nextPageToken: Swift.String?
}

extension ListProvisioningArtifactsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case provisioningArtifactDetails = "ProvisioningArtifactDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifactDetail?].self, forKey: .provisioningArtifactDetails)
        var provisioningArtifactDetailsDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifactDetail]? = nil
        if let provisioningArtifactDetailsContainer = provisioningArtifactDetailsContainer {
            provisioningArtifactDetailsDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifactDetail]()
            for structure0 in provisioningArtifactDetailsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactDetailsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactDetails = provisioningArtifactDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListProvisioningArtifactsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecordHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case searchFilter = "SearchFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accessLevelFilter = self.accessLevelFilter {
            try encodeContainer.encode(accessLevelFilter, forKey: .accessLevelFilter)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let searchFilter = self.searchFilter {
            try encodeContainer.encode(searchFilter, forKey: .searchFilter)
        }
    }
}

extension ListRecordHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRecordHistoryInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The access level to use to obtain results. The default is User.
    public var accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The search filter to scope the results.
    public var searchFilter: ServiceCatalogClientTypes.ListRecordHistorySearchFilter?

    public init(
        acceptLanguage: Swift.String? = nil,
        accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        searchFilter: ServiceCatalogClientTypes.ListRecordHistorySearchFilter? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.searchFilter = searchFilter
    }
}

struct ListRecordHistoryInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    let searchFilter: ServiceCatalogClientTypes.ListRecordHistorySearchFilter?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
}

extension ListRecordHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case searchFilter = "SearchFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let accessLevelFilterDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.AccessLevelFilter.self, forKey: .accessLevelFilter)
        accessLevelFilter = accessLevelFilterDecoded
        let searchFilterDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ListRecordHistorySearchFilter.self, forKey: .searchFilter)
        searchFilter = searchFilterDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListRecordHistoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecordHistoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.recordDetails = output.recordDetails
        } else {
            self.nextPageToken = nil
            self.recordDetails = nil
        }
    }
}

public struct ListRecordHistoryOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// The records, in reverse chronological order.
    public var recordDetails: [ServiceCatalogClientTypes.RecordDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        recordDetails: [ServiceCatalogClientTypes.RecordDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.recordDetails = recordDetails
    }
}

struct ListRecordHistoryOutputBody: Swift.Equatable {
    let recordDetails: [ServiceCatalogClientTypes.RecordDetail]?
    let nextPageToken: Swift.String?
}

extension ListRecordHistoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case recordDetails = "RecordDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.RecordDetail?].self, forKey: .recordDetails)
        var recordDetailsDecoded0:[ServiceCatalogClientTypes.RecordDetail]? = nil
        if let recordDetailsContainer = recordDetailsContainer {
            recordDetailsDecoded0 = [ServiceCatalogClientTypes.RecordDetail]()
            for structure0 in recordDetailsContainer {
                if let structure0 = structure0 {
                    recordDetailsDecoded0?.append(structure0)
                }
            }
        }
        recordDetails = recordDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListRecordHistoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes.ListRecordHistorySearchFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// The search filter to use when listing history records.
    public struct ListRecordHistorySearchFilter: Swift.Equatable {
        /// The filter key.
        ///
        /// * product - Filter results based on the specified product identifier.
        ///
        /// * provisionedproduct - Filter results based on the provisioned product identifier.
        public var key: Swift.String?
        /// The filter value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ListResourcesForTagOptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListResourcesForTagOptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourcesForTagOptionInput: Swift.Equatable {
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The resource type.
    ///
    /// * Portfolio
    ///
    /// * Product
    public var resourceType: Swift.String?
    /// The TagOption identifier.
    /// This member is required.
    public var tagOptionId: Swift.String?

    public init(
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        tagOptionId: Swift.String? = nil
    )
    {
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.resourceType = resourceType
        self.tagOptionId = tagOptionId
    }
}

struct ListResourcesForTagOptionInputBody: Swift.Equatable {
}

extension ListResourcesForTagOptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListResourcesForTagOptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourcesForTagOptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.pageToken = output.pageToken
            self.resourceDetails = output.resourceDetails
        } else {
            self.pageToken = nil
            self.resourceDetails = nil
        }
    }
}

public struct ListResourcesForTagOptionOutput: Swift.Equatable {
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// Information about the resources.
    public var resourceDetails: [ServiceCatalogClientTypes.ResourceDetail]?

    public init(
        pageToken: Swift.String? = nil,
        resourceDetails: [ServiceCatalogClientTypes.ResourceDetail]? = nil
    )
    {
        self.pageToken = pageToken
        self.resourceDetails = resourceDetails
    }
}

struct ListResourcesForTagOptionOutputBody: Swift.Equatable {
    let resourceDetails: [ServiceCatalogClientTypes.ResourceDetail]?
    let pageToken: Swift.String?
}

extension ListResourcesForTagOptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageToken = "PageToken"
        case resourceDetails = "ResourceDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ResourceDetail?].self, forKey: .resourceDetails)
        var resourceDetailsDecoded0:[ServiceCatalogClientTypes.ResourceDetail]? = nil
        if let resourceDetailsContainer = resourceDetailsContainer {
            resourceDetailsDecoded0 = [ServiceCatalogClientTypes.ResourceDetail]()
            for structure0 in resourceDetailsContainer {
                if let structure0 = structure0 {
                    resourceDetailsDecoded0?.append(structure0)
                }
            }
        }
        resourceDetails = resourceDetailsDecoded0
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

enum ListResourcesForTagOptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceActionsForProvisioningArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }
}

extension ListServiceActionsForProvisioningArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceActionsForProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The product identifier. For example, prod-abcdzk7xy33qa.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct ListServiceActionsForProvisioningArtifactInputBody: Swift.Equatable {
    let productId: Swift.String?
    let provisioningArtifactId: Swift.String?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
    let acceptLanguage: Swift.String?
}

extension ListServiceActionsForProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension ListServiceActionsForProvisioningArtifactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceActionsForProvisioningArtifactOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.serviceActionSummaries = output.serviceActionSummaries
        } else {
            self.nextPageToken = nil
            self.serviceActionSummaries = nil
        }
    }
}

public struct ListServiceActionsForProvisioningArtifactOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// An object containing information about the self-service actions associated with the provisioning artifact.
    public var serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]?

    public init(
        nextPageToken: Swift.String? = nil,
        serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.serviceActionSummaries = serviceActionSummaries
    }
}

struct ListServiceActionsForProvisioningArtifactOutputBody: Swift.Equatable {
    let serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]?
    let nextPageToken: Swift.String?
}

extension ListServiceActionsForProvisioningArtifactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case serviceActionSummaries = "ServiceActionSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ServiceActionSummary?].self, forKey: .serviceActionSummaries)
        var serviceActionSummariesDecoded0:[ServiceCatalogClientTypes.ServiceActionSummary]? = nil
        if let serviceActionSummariesContainer = serviceActionSummariesContainer {
            serviceActionSummariesDecoded0 = [ServiceCatalogClientTypes.ServiceActionSummary]()
            for structure0 in serviceActionSummariesContainer {
                if let structure0 = structure0 {
                    serviceActionSummariesDecoded0?.append(structure0)
                }
            }
        }
        serviceActionSummaries = serviceActionSummariesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListServiceActionsForProvisioningArtifactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceActionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

extension ListServiceActionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceActionsInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct ListServiceActionsInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
}

extension ListServiceActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListServiceActionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceActionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.serviceActionSummaries = output.serviceActionSummaries
        } else {
            self.nextPageToken = nil
            self.serviceActionSummaries = nil
        }
    }
}

public struct ListServiceActionsOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// An object containing information about the service actions associated with the provisioning artifact.
    public var serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]?

    public init(
        nextPageToken: Swift.String? = nil,
        serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.serviceActionSummaries = serviceActionSummaries
    }
}

struct ListServiceActionsOutputBody: Swift.Equatable {
    let serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]?
    let nextPageToken: Swift.String?
}

extension ListServiceActionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case serviceActionSummaries = "ServiceActionSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ServiceActionSummary?].self, forKey: .serviceActionSummaries)
        var serviceActionSummariesDecoded0:[ServiceCatalogClientTypes.ServiceActionSummary]? = nil
        if let serviceActionSummariesContainer = serviceActionSummariesContainer {
            serviceActionSummariesDecoded0 = [ServiceCatalogClientTypes.ServiceActionSummary]()
            for structure0 in serviceActionSummariesContainer {
                if let structure0 = structure0 {
                    serviceActionSummariesDecoded0?.append(structure0)
                }
            }
        }
        serviceActionSummaries = serviceActionSummariesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListServiceActionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStackInstancesForProvisionedProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionedProductId = "ProvisionedProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let provisionedProductId = self.provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
    }
}

extension ListStackInstancesForProvisionedProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListStackInstancesForProvisionedProductInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The identifier of the provisioned product.
    /// This member is required.
    public var provisionedProductId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.provisionedProductId = provisionedProductId
    }
}

struct ListStackInstancesForProvisionedProductInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let provisionedProductId: Swift.String?
    let pageToken: Swift.String?
    let pageSize: Swift.Int?
}

extension ListStackInstancesForProvisionedProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionedProductId = "ProvisionedProductId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListStackInstancesForProvisionedProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStackInstancesForProvisionedProductOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.stackInstances = output.stackInstances
        } else {
            self.nextPageToken = nil
            self.stackInstances = nil
        }
    }
}

public struct ListStackInstancesForProvisionedProductOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// List of stack instances.
    public var stackInstances: [ServiceCatalogClientTypes.StackInstance]?

    public init(
        nextPageToken: Swift.String? = nil,
        stackInstances: [ServiceCatalogClientTypes.StackInstance]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.stackInstances = stackInstances
    }
}

struct ListStackInstancesForProvisionedProductOutputBody: Swift.Equatable {
    let stackInstances: [ServiceCatalogClientTypes.StackInstance]?
    let nextPageToken: Swift.String?
}

extension ListStackInstancesForProvisionedProductOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case stackInstances = "StackInstances"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackInstancesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.StackInstance?].self, forKey: .stackInstances)
        var stackInstancesDecoded0:[ServiceCatalogClientTypes.StackInstance]? = nil
        if let stackInstancesContainer = stackInstancesContainer {
            stackInstancesDecoded0 = [ServiceCatalogClientTypes.StackInstance]()
            for structure0 in stackInstancesContainer {
                if let structure0 = structure0 {
                    stackInstancesDecoded0?.append(structure0)
                }
            }
        }
        stackInstances = stackInstancesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListStackInstancesForProvisionedProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes.ListTagOptionsFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Filters to use when listing TagOptions.
    public struct ListTagOptionsFilters: Swift.Equatable {
        /// The active state.
        public var active: Swift.Bool?
        /// The TagOption key.
        public var key: Swift.String?
        /// The TagOption value.
        public var value: Swift.String?

        public init(
            active: Swift.Bool? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.active = active
            self.key = key
            self.value = value
        }
    }

}

extension ListTagOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

extension ListTagOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagOptionsInput: Swift.Equatable {
    /// The search filters. If no search filters are specified, the output includes all TagOptions.
    public var filters: ServiceCatalogClientTypes.ListTagOptionsFilters?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init(
        filters: ServiceCatalogClientTypes.ListTagOptionsFilters? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct ListTagOptionsInputBody: Swift.Equatable {
    let filters: ServiceCatalogClientTypes.ListTagOptionsFilters?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
}

extension ListTagOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ListTagOptionsFilters.self, forKey: .filters)
        filters = filtersDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListTagOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagOptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.pageToken = output.pageToken
            self.tagOptionDetails = output.tagOptionDetails
        } else {
            self.pageToken = nil
            self.tagOptionDetails = nil
        }
    }
}

public struct ListTagOptionsOutput: Swift.Equatable {
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// Information about the TagOptions.
    public var tagOptionDetails: [ServiceCatalogClientTypes.TagOptionDetail]?

    public init(
        pageToken: Swift.String? = nil,
        tagOptionDetails: [ServiceCatalogClientTypes.TagOptionDetail]? = nil
    )
    {
        self.pageToken = pageToken
        self.tagOptionDetails = tagOptionDetails
    }
}

struct ListTagOptionsOutputBody: Swift.Equatable {
    let tagOptionDetails: [ServiceCatalogClientTypes.TagOptionDetail]?
    let pageToken: Swift.String?
}

extension ListTagOptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageToken = "PageToken"
        case tagOptionDetails = "TagOptionDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagOptionDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.TagOptionDetail?].self, forKey: .tagOptionDetails)
        var tagOptionDetailsDecoded0:[ServiceCatalogClientTypes.TagOptionDetail]? = nil
        if let tagOptionDetailsContainer = tagOptionDetailsContainer {
            tagOptionDetailsDecoded0 = [ServiceCatalogClientTypes.TagOptionDetail]()
            for structure0 in tagOptionDetailsContainer {
                if let structure0 = structure0 {
                    tagOptionDetailsDecoded0?.append(structure0)
                }
            }
        }
        tagOptionDetails = tagOptionDetailsDecoded0
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

enum ListTagOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotifyProvisionProductEngineWorkflowResultInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case idempotencyToken = "IdempotencyToken"
        case outputs = "Outputs"
        case recordId = "RecordId"
        case resourceIdentifier = "ResourceIdentifier"
        case status = "Status"
        case workflowToken = "WorkflowToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for recordoutput0 in outputs {
                try outputsContainer.encode(recordoutput0)
            }
        }
        if let recordId = self.recordId {
            try encodeContainer.encode(recordId, forKey: .recordId)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workflowToken = self.workflowToken {
            try encodeContainer.encode(workflowToken, forKey: .workflowToken)
        }
    }
}

extension NotifyProvisionProductEngineWorkflowResultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct NotifyProvisionProductEngineWorkflowResultInput: Swift.Equatable {
    /// The reason why the provisioning engine execution failed.
    public var failureReason: Swift.String?
    /// The idempotency token that identifies the provisioning engine execution.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The output of the provisioning engine execution.
    public var outputs: [ServiceCatalogClientTypes.RecordOutput]?
    /// The identifier of the record.
    /// This member is required.
    public var recordId: Swift.String?
    /// The ID for the provisioned product resources that are part of a resource group.
    public var resourceIdentifier: ServiceCatalogClientTypes.EngineWorkflowResourceIdentifier?
    /// The status of the provisioning engine execution.
    /// This member is required.
    public var status: ServiceCatalogClientTypes.EngineWorkflowStatus?
    /// The encrypted contents of the provisioning engine execution payload that Service Catalog sends after the Terraform product provisioning workflow starts.
    /// This member is required.
    public var workflowToken: Swift.String?

    public init(
        failureReason: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        outputs: [ServiceCatalogClientTypes.RecordOutput]? = nil,
        recordId: Swift.String? = nil,
        resourceIdentifier: ServiceCatalogClientTypes.EngineWorkflowResourceIdentifier? = nil,
        status: ServiceCatalogClientTypes.EngineWorkflowStatus? = nil,
        workflowToken: Swift.String? = nil
    )
    {
        self.failureReason = failureReason
        self.idempotencyToken = idempotencyToken
        self.outputs = outputs
        self.recordId = recordId
        self.resourceIdentifier = resourceIdentifier
        self.status = status
        self.workflowToken = workflowToken
    }
}

struct NotifyProvisionProductEngineWorkflowResultInputBody: Swift.Equatable {
    let workflowToken: Swift.String?
    let recordId: Swift.String?
    let status: ServiceCatalogClientTypes.EngineWorkflowStatus?
    let failureReason: Swift.String?
    let resourceIdentifier: ServiceCatalogClientTypes.EngineWorkflowResourceIdentifier?
    let outputs: [ServiceCatalogClientTypes.RecordOutput]?
    let idempotencyToken: Swift.String?
}

extension NotifyProvisionProductEngineWorkflowResultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case idempotencyToken = "IdempotencyToken"
        case outputs = "Outputs"
        case recordId = "RecordId"
        case resourceIdentifier = "ResourceIdentifier"
        case status = "Status"
        case workflowToken = "WorkflowToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowToken)
        workflowToken = workflowTokenDecoded
        let recordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordId)
        recordId = recordIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.EngineWorkflowStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.EngineWorkflowResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.RecordOutput?].self, forKey: .outputs)
        var outputsDecoded0:[ServiceCatalogClientTypes.RecordOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ServiceCatalogClientTypes.RecordOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension NotifyProvisionProductEngineWorkflowResultOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct NotifyProvisionProductEngineWorkflowResultOutput: Swift.Equatable {

    public init() { }
}

enum NotifyProvisionProductEngineWorkflowResultOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotifyTerminateProvisionedProductEngineWorkflowResultInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case idempotencyToken = "IdempotencyToken"
        case recordId = "RecordId"
        case status = "Status"
        case workflowToken = "WorkflowToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let recordId = self.recordId {
            try encodeContainer.encode(recordId, forKey: .recordId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workflowToken = self.workflowToken {
            try encodeContainer.encode(workflowToken, forKey: .workflowToken)
        }
    }
}

extension NotifyTerminateProvisionedProductEngineWorkflowResultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct NotifyTerminateProvisionedProductEngineWorkflowResultInput: Swift.Equatable {
    /// The reason why the terminate engine execution failed.
    public var failureReason: Swift.String?
    /// The idempotency token that identifies the terminate engine execution.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The identifier of the record.
    /// This member is required.
    public var recordId: Swift.String?
    /// The status of the terminate engine execution.
    /// This member is required.
    public var status: ServiceCatalogClientTypes.EngineWorkflowStatus?
    /// The encrypted contents of the terminate engine execution payload that Service Catalog sends after the Terraform product terminate workflow starts.
    /// This member is required.
    public var workflowToken: Swift.String?

    public init(
        failureReason: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        recordId: Swift.String? = nil,
        status: ServiceCatalogClientTypes.EngineWorkflowStatus? = nil,
        workflowToken: Swift.String? = nil
    )
    {
        self.failureReason = failureReason
        self.idempotencyToken = idempotencyToken
        self.recordId = recordId
        self.status = status
        self.workflowToken = workflowToken
    }
}

struct NotifyTerminateProvisionedProductEngineWorkflowResultInputBody: Swift.Equatable {
    let workflowToken: Swift.String?
    let recordId: Swift.String?
    let status: ServiceCatalogClientTypes.EngineWorkflowStatus?
    let failureReason: Swift.String?
    let idempotencyToken: Swift.String?
}

extension NotifyTerminateProvisionedProductEngineWorkflowResultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case idempotencyToken = "IdempotencyToken"
        case recordId = "RecordId"
        case status = "Status"
        case workflowToken = "WorkflowToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowToken)
        workflowToken = workflowTokenDecoded
        let recordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordId)
        recordId = recordIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.EngineWorkflowStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension NotifyTerminateProvisionedProductEngineWorkflowResultOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct NotifyTerminateProvisionedProductEngineWorkflowResultOutput: Swift.Equatable {

    public init() { }
}

enum NotifyTerminateProvisionedProductEngineWorkflowResultOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotifyUpdateProvisionedProductEngineWorkflowResultInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case idempotencyToken = "IdempotencyToken"
        case outputs = "Outputs"
        case recordId = "RecordId"
        case status = "Status"
        case workflowToken = "WorkflowToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for recordoutput0 in outputs {
                try outputsContainer.encode(recordoutput0)
            }
        }
        if let recordId = self.recordId {
            try encodeContainer.encode(recordId, forKey: .recordId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workflowToken = self.workflowToken {
            try encodeContainer.encode(workflowToken, forKey: .workflowToken)
        }
    }
}

extension NotifyUpdateProvisionedProductEngineWorkflowResultInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct NotifyUpdateProvisionedProductEngineWorkflowResultInput: Swift.Equatable {
    /// The reason why the update engine execution failed.
    public var failureReason: Swift.String?
    /// The idempotency token that identifies the update engine execution.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The output of the update engine execution.
    public var outputs: [ServiceCatalogClientTypes.RecordOutput]?
    /// The identifier of the record.
    /// This member is required.
    public var recordId: Swift.String?
    /// The status of the update engine execution.
    /// This member is required.
    public var status: ServiceCatalogClientTypes.EngineWorkflowStatus?
    /// The encrypted contents of the update engine execution payload that Service Catalog sends after the Terraform product update workflow starts.
    /// This member is required.
    public var workflowToken: Swift.String?

    public init(
        failureReason: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        outputs: [ServiceCatalogClientTypes.RecordOutput]? = nil,
        recordId: Swift.String? = nil,
        status: ServiceCatalogClientTypes.EngineWorkflowStatus? = nil,
        workflowToken: Swift.String? = nil
    )
    {
        self.failureReason = failureReason
        self.idempotencyToken = idempotencyToken
        self.outputs = outputs
        self.recordId = recordId
        self.status = status
        self.workflowToken = workflowToken
    }
}

struct NotifyUpdateProvisionedProductEngineWorkflowResultInputBody: Swift.Equatable {
    let workflowToken: Swift.String?
    let recordId: Swift.String?
    let status: ServiceCatalogClientTypes.EngineWorkflowStatus?
    let failureReason: Swift.String?
    let outputs: [ServiceCatalogClientTypes.RecordOutput]?
    let idempotencyToken: Swift.String?
}

extension NotifyUpdateProvisionedProductEngineWorkflowResultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case idempotencyToken = "IdempotencyToken"
        case outputs = "Outputs"
        case recordId = "RecordId"
        case status = "Status"
        case workflowToken = "WorkflowToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowToken)
        workflowToken = workflowTokenDecoded
        let recordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordId)
        recordId = recordIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.EngineWorkflowStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.RecordOutput?].self, forKey: .outputs)
        var outputsDecoded0:[ServiceCatalogClientTypes.RecordOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ServiceCatalogClientTypes.RecordOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension NotifyUpdateProvisionedProductEngineWorkflowResultOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct NotifyUpdateProvisionedProductEngineWorkflowResultOutput: Swift.Equatable {

    public init() { }
}

enum NotifyUpdateProvisionedProductEngineWorkflowResultOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OperationNotSupportedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OperationNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation is not supported.
public struct OperationNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotSupportedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OperationNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceCatalogClientTypes.OrganizationNode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.OrganizationNodeType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about the organization node.
    public struct OrganizationNode: Swift.Equatable {
        /// The organization node type.
        public var type: ServiceCatalogClientTypes.OrganizationNodeType?
        /// The identifier of the organization node.
        public var value: Swift.String?

        public init(
            type: ServiceCatalogClientTypes.OrganizationNodeType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum OrganizationNodeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case organization
        case organizationalUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationNodeType] {
            return [
                .account,
                .organization,
                .organizationalUnit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .organization: return "ORGANIZATION"
            case .organizationalUnit: return "ORGANIZATIONAL_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrganizationNodeType(rawValue: rawValue) ?? OrganizationNodeType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ParameterConstraints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPattern = "AllowedPattern"
        case allowedValues = "AllowedValues"
        case constraintDescription = "ConstraintDescription"
        case maxLength = "MaxLength"
        case maxValue = "MaxValue"
        case minLength = "MinLength"
        case minValue = "MinValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = self.allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for string0 in allowedValues {
                try allowedValuesContainer.encode(string0)
            }
        }
        if let constraintDescription = self.constraintDescription {
            try encodeContainer.encode(constraintDescription, forKey: .constraintDescription)
        }
        if let maxLength = self.maxLength {
            try encodeContainer.encode(maxLength, forKey: .maxLength)
        }
        if let maxValue = self.maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minLength = self.minLength {
            try encodeContainer.encode(minLength, forKey: .minLength)
        }
        if let minValue = self.minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[Swift.String]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [Swift.String]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let allowedPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let constraintDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraintDescription)
        constraintDescription = constraintDescriptionDecoded
        let maxLengthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxLength)
        maxLength = maxLengthDecoded
        let minLengthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minLength)
        minLength = minLengthDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minValue)
        minValue = minValueDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// The constraints that the administrator has put on the parameter.
    public struct ParameterConstraints: Swift.Equatable {
        /// A regular expression that represents the patterns that allow for String types. The pattern must match the entire parameter value provided.
        public var allowedPattern: Swift.String?
        /// The values that the administrator has allowed for the parameter.
        public var allowedValues: [Swift.String]?
        /// A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of [A-Za-z0-9]+ displays the following error message when the user specifies an invalid value: Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+ By adding a constraint description, such as must only contain letters (uppercase and lowercase) and numbers, you can display the following customized error message: Malformed input-Parameter MyParameter must only contain uppercase and lowercase letters and numbers.
        public var constraintDescription: Swift.String?
        /// An integer value that determines the largest number of characters you want to allow for String types.
        public var maxLength: Swift.String?
        /// A numeric value that determines the largest numeric value you want to allow for Number types.
        public var maxValue: Swift.String?
        /// An integer value that determines the smallest number of characters you want to allow for String types.
        public var minLength: Swift.String?
        /// A numeric value that determines the smallest numeric value you want to allow for Number types.
        public var minValue: Swift.String?

        public init(
            allowedPattern: Swift.String? = nil,
            allowedValues: [Swift.String]? = nil,
            constraintDescription: Swift.String? = nil,
            maxLength: Swift.String? = nil,
            maxValue: Swift.String? = nil,
            minLength: Swift.String? = nil,
            minValue: Swift.String? = nil
        )
        {
            self.allowedPattern = allowedPattern
            self.allowedValues = allowedValues
            self.constraintDescription = constraintDescription
            self.maxLength = maxLength
            self.maxValue = maxValue
            self.minLength = minLength
            self.minValue = minValue
        }
    }

}

extension ServiceCatalogClientTypes.PortfolioDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case id = "Id"
        case providerName = "ProviderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a portfolio.
    public struct PortfolioDetail: Swift.Equatable {
        /// The ARN assigned to the portfolio.
        public var arn: Swift.String?
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The description of the portfolio.
        public var description: Swift.String?
        /// The name to use for display purposes.
        public var displayName: Swift.String?
        /// The portfolio identifier.
        public var id: Swift.String?
        /// The name of the portfolio provider.
        public var providerName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            providerName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.id = id
            self.providerName = providerName
        }
    }

}

extension ServiceCatalogClientTypes.PortfolioShareDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accepted = "Accepted"
        case principalId = "PrincipalId"
        case sharePrincipals = "SharePrincipals"
        case shareTagOptions = "ShareTagOptions"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if accepted != false {
            try encodeContainer.encode(accepted, forKey: .accepted)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if sharePrincipals != false {
            try encodeContainer.encode(sharePrincipals, forKey: .sharePrincipals)
        }
        if shareTagOptions != false {
            try encodeContainer.encode(shareTagOptions, forKey: .shareTagOptions)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.DescribePortfolioShareType.self, forKey: .type)
        type = typeDecoded
        let acceptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accepted) ?? false
        accepted = acceptedDecoded
        let shareTagOptionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .shareTagOptions) ?? false
        shareTagOptions = shareTagOptionsDecoded
        let sharePrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharePrincipals) ?? false
        sharePrincipals = sharePrincipalsDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about the portfolio share.
    public struct PortfolioShareDetail: Swift.Equatable {
        /// Indicates whether the shared portfolio is imported by the recipient account. If the recipient is in an organization node, the share is automatically imported, and the field is always set to true.
        public var accepted: Swift.Bool
        /// The identifier of the recipient entity that received the portfolio share. The recipient entity can be one of the following: 1. An external account. 2. An organziation member account. 3. An organzational unit (OU). 4. The organization itself. (This shares with every account in the organization).
        public var principalId: Swift.String?
        /// Indicates if Principal sharing is enabled or disabled for the portfolio share.
        public var sharePrincipals: Swift.Bool
        /// Indicates whether TagOptions sharing is enabled or disabled for the portfolio share.
        public var shareTagOptions: Swift.Bool
        /// The type of the portfolio share.
        public var type: ServiceCatalogClientTypes.DescribePortfolioShareType?

        public init(
            accepted: Swift.Bool = false,
            principalId: Swift.String? = nil,
            sharePrincipals: Swift.Bool = false,
            shareTagOptions: Swift.Bool = false,
            type: ServiceCatalogClientTypes.DescribePortfolioShareType? = nil
        )
        {
            self.accepted = accepted
            self.principalId = principalId
            self.sharePrincipals = sharePrincipals
            self.shareTagOptions = shareTagOptions
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum PortfolioShareType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsOrganizations
        case awsServicecatalog
        case imported
        case sdkUnknown(Swift.String)

        public static var allCases: [PortfolioShareType] {
            return [
                .awsOrganizations,
                .awsServicecatalog,
                .imported,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsOrganizations: return "AWS_ORGANIZATIONS"
            case .awsServicecatalog: return "AWS_SERVICECATALOG"
            case .imported: return "IMPORTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PortfolioShareType(rawValue: rawValue) ?? PortfolioShareType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.Principal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principalARN = "PrincipalARN"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principalARN = self.principalARN {
            try encodeContainer.encode(principalARN, forKey: .principalARN)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalARN)
        principalARN = principalARNDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a principal.
    public struct Principal: Swift.Equatable {
        /// The ARN of the principal (user, role, or group). This field allows for an ARN with no accountID, with or without wildcard characters if the PrincipalType is an IAM_PATTERN. For more information, review [associate-principal-with-portfolio](https://docs.aws.amazon.com/cli/latest/reference/servicecatalog/associate-principal-with-portfolio.html#options) in the Amazon Web Services CLI Command Reference.
        public var principalARN: Swift.String?
        /// The principal type. The supported value is IAM if you use a fully defined ARN, or IAM_PATTERN if you use an ARN with no accountID, with or without wildcard characters.
        public var principalType: ServiceCatalogClientTypes.PrincipalType?

        public init(
            principalARN: Swift.String? = nil,
            principalType: ServiceCatalogClientTypes.PrincipalType? = nil
        )
        {
            self.principalARN = principalARN
            self.principalType = principalType
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum PrincipalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case iamPattern
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .iam,
                .iamPattern,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .iamPattern: return "IAM_PATTERN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ProductSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case sdkUnknown(Swift.String)

        public static var allCases: [ProductSource] {
            return [
                .account,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProductSource(rawValue: rawValue) ?? ProductSource.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ProductType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudFormationTemplate
        case marketplace
        case terraformCloud
        case terraformOpenSource
        case sdkUnknown(Swift.String)

        public static var allCases: [ProductType] {
            return [
                .cloudFormationTemplate,
                .marketplace,
                .terraformCloud,
                .terraformOpenSource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudFormationTemplate: return "CLOUD_FORMATION_TEMPLATE"
            case .marketplace: return "MARKETPLACE"
            case .terraformCloud: return "TERRAFORM_CLOUD"
            case .terraformOpenSource: return "TERRAFORM_OPEN_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProductType(rawValue: rawValue) ?? ProductType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProductViewAggregationValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateCount = "ApproximateCount"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if approximateCount != 0 {
            try encodeContainer.encode(approximateCount, forKey: .approximateCount)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let approximateCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateCount) ?? 0
        approximateCount = approximateCountDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// A single product view aggregation value/count pair, containing metadata about each product to which the calling user has access.
    public struct ProductViewAggregationValue: Swift.Equatable {
        /// An approximate count of the products that match the value.
        public var approximateCount: Swift.Int
        /// The value of the product view aggregation.
        public var value: Swift.String?

        public init(
            approximateCount: Swift.Int = 0,
            value: Swift.String? = nil
        )
        {
            self.approximateCount = approximateCount
            self.value = value
        }
    }

}

extension ServiceCatalogClientTypes.ProductViewDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case productARN = "ProductARN"
        case productViewSummary = "ProductViewSummary"
        case sourceConnection = "SourceConnection"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let productARN = self.productARN {
            try encodeContainer.encode(productARN, forKey: .productARN)
        }
        if let productViewSummary = self.productViewSummary {
            try encodeContainer.encode(productViewSummary, forKey: .productViewSummary)
        }
        if let sourceConnection = self.sourceConnection {
            try encodeContainer.encode(sourceConnection, forKey: .sourceConnection)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummaryDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewSummary.self, forKey: .productViewSummary)
        productViewSummary = productViewSummaryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let productARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productARN)
        productARN = productARNDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let sourceConnectionDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SourceConnectionDetail.self, forKey: .sourceConnection)
        sourceConnection = sourceConnectionDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a product view.
    public struct ProductViewDetail: Swift.Equatable {
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The ARN of the product.
        public var productARN: Swift.String?
        /// Summary information about the product view.
        public var productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
        /// A top level ProductViewDetail response containing details about the products connection. Service Catalog returns this field for the CreateProduct, UpdateProduct, DescribeProductAsAdmin, and SearchProductAsAdmin APIs. This response contains the same fields as the ConnectionParameters request, with the addition of the LastSync response.
        public var sourceConnection: ServiceCatalogClientTypes.SourceConnectionDetail?
        /// The status of the product.
        ///
        /// * AVAILABLE - The product is ready for use.
        ///
        /// * CREATING - Product creation has started; the product is not ready for use.
        ///
        /// * FAILED - An action failed.
        public var status: ServiceCatalogClientTypes.Status?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            productARN: Swift.String? = nil,
            productViewSummary: ServiceCatalogClientTypes.ProductViewSummary? = nil,
            sourceConnection: ServiceCatalogClientTypes.SourceConnectionDetail? = nil,
            status: ServiceCatalogClientTypes.Status? = nil
        )
        {
            self.createdTime = createdTime
            self.productARN = productARN
            self.productViewSummary = productViewSummary
            self.sourceConnection = sourceConnection
            self.status = status
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ProductViewFilterBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fulltextsearch
        case owner
        case producttype
        case sourceproductid
        case sdkUnknown(Swift.String)

        public static var allCases: [ProductViewFilterBy] {
            return [
                .fulltextsearch,
                .owner,
                .producttype,
                .sourceproductid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fulltextsearch: return "FullTextSearch"
            case .owner: return "Owner"
            case .producttype: return "ProductType"
            case .sourceproductid: return "SourceProductId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProductViewFilterBy(rawValue: rawValue) ?? ProductViewFilterBy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ProductViewSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationdate
        case title
        case versioncount
        case sdkUnknown(Swift.String)

        public static var allCases: [ProductViewSortBy] {
            return [
                .creationdate,
                .title,
                .versioncount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationdate: return "CreationDate"
            case .title: return "Title"
            case .versioncount: return "VersionCount"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProductViewSortBy(rawValue: rawValue) ?? ProductViewSortBy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProductViewSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributor = "Distributor"
        case hasDefaultPath = "HasDefaultPath"
        case id = "Id"
        case name = "Name"
        case owner = "Owner"
        case productId = "ProductId"
        case shortDescription = "ShortDescription"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distributor = self.distributor {
            try encodeContainer.encode(distributor, forKey: .distributor)
        }
        if hasDefaultPath != false {
            try encodeContainer.encode(hasDefaultPath, forKey: .hasDefaultPath)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let shortDescription = self.shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
        if let supportDescription = self.supportDescription {
            try encodeContainer.encode(supportDescription, forKey: .supportDescription)
        }
        if let supportEmail = self.supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportUrl = self.supportUrl {
            try encodeContainer.encode(supportUrl, forKey: .supportUrl)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductType.self, forKey: .type)
        type = typeDecoded
        let distributorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributor)
        distributor = distributorDecoded
        let hasDefaultPathDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasDefaultPath) ?? false
        hasDefaultPath = hasDefaultPathDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportDescription)
        supportDescription = supportDescriptionDecoded
        let supportUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportUrl)
        supportUrl = supportUrlDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Summary information about a product view.
    public struct ProductViewSummary: Swift.Equatable {
        /// The distributor of the product. Contact the product administrator for the significance of this value.
        public var distributor: Swift.String?
        /// Indicates whether the product has a default path. If the product does not have a default path, call [ListLaunchPaths] to disambiguate between paths. Otherwise, [ListLaunchPaths] is not required, and the output of [ProductViewSummary] can be used directly with [DescribeProvisioningParameters].
        public var hasDefaultPath: Swift.Bool
        /// The product view identifier.
        public var id: Swift.String?
        /// The name of the product.
        public var name: Swift.String?
        /// The owner of the product. Contact the product administrator for the significance of this value.
        public var owner: Swift.String?
        /// The product identifier.
        public var productId: Swift.String?
        /// Short description of the product.
        public var shortDescription: Swift.String?
        /// The description of the support for this Product.
        public var supportDescription: Swift.String?
        /// The email contact information to obtain support for this Product.
        public var supportEmail: Swift.String?
        /// The URL information to obtain support for this Product.
        public var supportUrl: Swift.String?
        /// The product type. Contact the product administrator for the significance of this value. If this value is MARKETPLACE, the product was created by Amazon Web Services Marketplace.
        public var type: ServiceCatalogClientTypes.ProductType?

        public init(
            distributor: Swift.String? = nil,
            hasDefaultPath: Swift.Bool = false,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            productId: Swift.String? = nil,
            shortDescription: Swift.String? = nil,
            supportDescription: Swift.String? = nil,
            supportEmail: Swift.String? = nil,
            supportUrl: Swift.String? = nil,
            type: ServiceCatalogClientTypes.ProductType? = nil
        )
        {
            self.distributor = distributor
            self.hasDefaultPath = hasDefaultPath
            self.id = id
            self.name = name
            self.owner = owner
            self.productId = productId
            self.shortDescription = shortDescription
            self.supportDescription = supportDescription
            self.supportEmail = supportEmail
            self.supportUrl = supportUrl
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum PropertyKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case launchrole
        case owner
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyKey] {
            return [
                .launchrole,
                .owner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .launchrole: return "LAUNCH_ROLE"
            case .owner: return "OWNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyKey(rawValue: rawValue) ?? PropertyKey.sdkUnknown(rawValue)
        }
    }
}

extension ProvisionProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisionToken = "ProvisionToken"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case provisioningParameters = "ProvisioningParameters"
        case provisioningPreferences = "ProvisioningPreferences"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for notificationarn0 in notificationArns {
                try notificationArnsContainer.encode(notificationarn0)
            }
        }
        if let pathId = self.pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let pathName = self.pathName {
            try encodeContainer.encode(pathName, forKey: .pathName)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisionToken = self.provisionToken {
            try encodeContainer.encode(provisionToken, forKey: .provisionToken)
        }
        if let provisionedProductName = self.provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = self.provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
        if let provisioningParameters = provisioningParameters {
            var provisioningParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .provisioningParameters)
            for provisioningparameter0 in provisioningParameters {
                try provisioningParametersContainer.encode(provisioningparameter0)
            }
        }
        if let provisioningPreferences = self.provisioningPreferences {
            try encodeContainer.encode(provisioningPreferences, forKey: .provisioningPreferences)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension ProvisionProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ProvisionProductInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.
    public var notificationArns: [Swift.String]?
    /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use [ListLaunchPaths]. You must provide the name or ID, but not both.
    public var pathId: Swift.String?
    /// The name of the path. You must provide the name or ID, but not both.
    public var pathName: Swift.String?
    /// The product identifier. You must provide the name or ID, but not both.
    public var productId: Swift.String?
    /// The name of the product. You must provide the name or ID, but not both.
    public var productName: Swift.String?
    /// An idempotency token that uniquely identifies the provisioning request.
    /// This member is required.
    public var provisionToken: Swift.String?
    /// A user-friendly name for the provisioned product. This value must be unique for the Amazon Web Services account and cannot be updated after the product is provisioned.
    /// This member is required.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactId: Swift.String?
    /// The name of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactName: Swift.String?
    /// Parameters specified by the administrator that are required for provisioning the product.
    public var provisioningParameters: [ServiceCatalogClientTypes.ProvisioningParameter]?
    /// An object that contains information about the provisioning preferences for a stack set.
    public var provisioningPreferences: ServiceCatalogClientTypes.ProvisioningPreferences?
    /// One or more tags.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        acceptLanguage: Swift.String? = nil,
        notificationArns: [Swift.String]? = nil,
        pathId: Swift.String? = nil,
        pathName: Swift.String? = nil,
        productId: Swift.String? = nil,
        productName: Swift.String? = nil,
        provisionToken: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningArtifactName: Swift.String? = nil,
        provisioningParameters: [ServiceCatalogClientTypes.ProvisioningParameter]? = nil,
        provisioningPreferences: ServiceCatalogClientTypes.ProvisioningPreferences? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.notificationArns = notificationArns
        self.pathId = pathId
        self.pathName = pathName
        self.productId = productId
        self.productName = productName
        self.provisionToken = provisionToken
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.provisioningParameters = provisioningParameters
        self.provisioningPreferences = provisioningPreferences
        self.tags = tags
    }
}

struct ProvisionProductInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let productId: Swift.String?
    let productName: Swift.String?
    let provisioningArtifactId: Swift.String?
    let provisioningArtifactName: Swift.String?
    let pathId: Swift.String?
    let pathName: Swift.String?
    let provisionedProductName: Swift.String?
    let provisioningParameters: [ServiceCatalogClientTypes.ProvisioningParameter]?
    let provisioningPreferences: ServiceCatalogClientTypes.ProvisioningPreferences?
    let tags: [ServiceCatalogClientTypes.Tag]?
    let notificationArns: [Swift.String]?
    let provisionToken: Swift.String?
}

extension ProvisionProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisionToken = "ProvisionToken"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case provisioningParameters = "ProvisioningParameters"
        case provisioningPreferences = "ProvisioningPreferences"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let pathNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathName)
        pathName = pathNameDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisioningParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningParameter?].self, forKey: .provisioningParameters)
        var provisioningParametersDecoded0:[ServiceCatalogClientTypes.ProvisioningParameter]? = nil
        if let provisioningParametersContainer = provisioningParametersContainer {
            provisioningParametersDecoded0 = [ServiceCatalogClientTypes.ProvisioningParameter]()
            for structure0 in provisioningParametersContainer {
                if let structure0 = structure0 {
                    provisioningParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningParameters = provisioningParametersDecoded0
        let provisioningPreferencesDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningPreferences.self, forKey: .provisioningPreferences)
        provisioningPreferences = provisioningPreferencesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let notificationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[Swift.String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [Swift.String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let provisionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionToken)
        provisionToken = provisionTokenDecoded
    }
}

extension ProvisionProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ProvisionProductOutputBody = try responseDecoder.decode(responseBody: data)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct ProvisionProductOutput: Swift.Equatable {
    /// Information about the result of provisioning the product.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init(
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct ProvisionProductOutputBody: Swift.Equatable {
    let recordDetail: ServiceCatalogClientTypes.RecordDetail?
}

extension ProvisionProductOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

enum ProvisionProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes.ProvisionedProductAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case idempotencyToken = "IdempotencyToken"
        case lastProvisioningRecordId = "LastProvisioningRecordId"
        case lastRecordId = "LastRecordId"
        case lastSuccessfulProvisioningRecordId = "LastSuccessfulProvisioningRecordId"
        case name = "Name"
        case physicalId = "PhysicalId"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case tags = "Tags"
        case type = "Type"
        case userArn = "UserArn"
        case userArnSession = "UserArnSession"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lastProvisioningRecordId = self.lastProvisioningRecordId {
            try encodeContainer.encode(lastProvisioningRecordId, forKey: .lastProvisioningRecordId)
        }
        if let lastRecordId = self.lastRecordId {
            try encodeContainer.encode(lastRecordId, forKey: .lastRecordId)
        }
        if let lastSuccessfulProvisioningRecordId = self.lastSuccessfulProvisioningRecordId {
            try encodeContainer.encode(lastSuccessfulProvisioningRecordId, forKey: .lastSuccessfulProvisioningRecordId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let physicalId = self.physicalId {
            try encodeContainer.encode(physicalId, forKey: .physicalId)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = self.provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
        if let userArnSession = self.userArnSession {
            try encodeContainer.encode(userArnSession, forKey: .userArnSession)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let lastRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastRecordId)
        lastRecordId = lastRecordIdDecoded
        let lastProvisioningRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProvisioningRecordId)
        lastProvisioningRecordId = lastProvisioningRecordIdDecoded
        let lastSuccessfulProvisioningRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSuccessfulProvisioningRecordId)
        lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let physicalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalId)
        physicalId = physicalIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let userArnSessionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArnSession)
        userArnSession = userArnSessionDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a provisioned product.
    public struct ProvisionedProductAttribute: Swift.Equatable {
        /// The ARN of the provisioned product.
        public var arn: Swift.String?
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The identifier of the provisioned product.
        public var id: Swift.String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public var idempotencyToken: Swift.String?
        /// The record identifier of the last request performed on this provisioned product of the following types:
        ///
        /// * ProvisionProduct
        ///
        /// * UpdateProvisionedProduct
        ///
        /// * ExecuteProvisionedProductPlan
        ///
        /// * TerminateProvisionedProduct
        public var lastProvisioningRecordId: Swift.String?
        /// The record identifier of the last request performed on this provisioned product.
        public var lastRecordId: Swift.String?
        /// The record identifier of the last successful request performed on this provisioned product of the following types:
        ///
        /// * ProvisionProduct
        ///
        /// * UpdateProvisionedProduct
        ///
        /// * ExecuteProvisionedProductPlan
        ///
        /// * TerminateProvisionedProduct
        public var lastSuccessfulProvisioningRecordId: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var name: Swift.String?
        /// The assigned identifier for the resource, such as an EC2 instance ID or an S3 bucket name.
        public var physicalId: Swift.String?
        /// The product identifier.
        public var productId: Swift.String?
        /// The name of the product.
        public var productName: Swift.String?
        /// The identifier of the provisioning artifact.
        public var provisioningArtifactId: Swift.String?
        /// The name of the provisioning artifact.
        public var provisioningArtifactName: Swift.String?
        /// The current status of the provisioned product.
        ///
        /// * AVAILABLE - Stable state, ready to perform any operation. The most recent operation succeeded and completed.
        ///
        /// * UNDER_CHANGE - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.
        ///
        /// * TAINTED - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.
        ///
        /// * ERROR - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.
        ///
        /// * PLAN_IN_PROGRESS - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.
        public var status: ServiceCatalogClientTypes.ProvisionedProductStatus?
        /// The current status message of the provisioned product.
        public var statusMessage: Swift.String?
        /// One or more tags.
        public var tags: [ServiceCatalogClientTypes.Tag]?
        /// The type of provisioned product. The supported values are CFN_STACK and CFN_STACKSET.
        public var type: Swift.String?
        /// The Amazon Resource Name (ARN) of the user.
        public var userArn: Swift.String?
        /// The ARN of the user in the session. This ARN might contain a session ID.
        public var userArnSession: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            idempotencyToken: Swift.String? = nil,
            lastProvisioningRecordId: Swift.String? = nil,
            lastRecordId: Swift.String? = nil,
            lastSuccessfulProvisioningRecordId: Swift.String? = nil,
            name: Swift.String? = nil,
            physicalId: Swift.String? = nil,
            productId: Swift.String? = nil,
            productName: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            provisioningArtifactName: Swift.String? = nil,
            status: ServiceCatalogClientTypes.ProvisionedProductStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [ServiceCatalogClientTypes.Tag]? = nil,
            type: Swift.String? = nil,
            userArn: Swift.String? = nil,
            userArnSession: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.idempotencyToken = idempotencyToken
            self.lastProvisioningRecordId = lastProvisioningRecordId
            self.lastRecordId = lastRecordId
            self.lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId
            self.name = name
            self.physicalId = physicalId
            self.productId = productId
            self.productName = productName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningArtifactName = provisioningArtifactName
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
            self.type = type
            self.userArn = userArn
            self.userArnSession = userArnSession
        }
    }

}

extension ServiceCatalogClientTypes.ProvisionedProductDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case idempotencyToken = "IdempotencyToken"
        case lastProvisioningRecordId = "LastProvisioningRecordId"
        case lastRecordId = "LastRecordId"
        case lastSuccessfulProvisioningRecordId = "LastSuccessfulProvisioningRecordId"
        case launchRoleArn = "LaunchRoleArn"
        case name = "Name"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lastProvisioningRecordId = self.lastProvisioningRecordId {
            try encodeContainer.encode(lastProvisioningRecordId, forKey: .lastProvisioningRecordId)
        }
        if let lastRecordId = self.lastRecordId {
            try encodeContainer.encode(lastRecordId, forKey: .lastRecordId)
        }
        if let lastSuccessfulProvisioningRecordId = self.lastSuccessfulProvisioningRecordId {
            try encodeContainer.encode(lastSuccessfulProvisioningRecordId, forKey: .lastSuccessfulProvisioningRecordId)
        }
        if let launchRoleArn = self.launchRoleArn {
            try encodeContainer.encode(launchRoleArn, forKey: .launchRoleArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let lastRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastRecordId)
        lastRecordId = lastRecordIdDecoded
        let lastProvisioningRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProvisioningRecordId)
        lastProvisioningRecordId = lastProvisioningRecordIdDecoded
        let lastSuccessfulProvisioningRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSuccessfulProvisioningRecordId)
        lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let launchRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchRoleArn)
        launchRoleArn = launchRoleArnDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a provisioned product.
    public struct ProvisionedProductDetail: Swift.Equatable {
        /// The ARN of the provisioned product.
        public var arn: Swift.String?
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The identifier of the provisioned product.
        public var id: Swift.String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public var idempotencyToken: Swift.String?
        /// The record identifier of the last request performed on this provisioned product of the following types:
        ///
        /// * ProvisionProduct
        ///
        /// * UpdateProvisionedProduct
        ///
        /// * ExecuteProvisionedProductPlan
        ///
        /// * TerminateProvisionedProduct
        public var lastProvisioningRecordId: Swift.String?
        /// The record identifier of the last request performed on this provisioned product.
        public var lastRecordId: Swift.String?
        /// The record identifier of the last successful request performed on this provisioned product of the following types:
        ///
        /// * ProvisionProduct
        ///
        /// * UpdateProvisionedProduct
        ///
        /// * ExecuteProvisionedProductPlan
        ///
        /// * TerminateProvisionedProduct
        public var lastSuccessfulProvisioningRecordId: Swift.String?
        /// The ARN of the launch role associated with the provisioned product.
        public var launchRoleArn: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var name: Swift.String?
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        public var productId: Swift.String?
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        public var provisioningArtifactId: Swift.String?
        /// The current status of the provisioned product.
        ///
        /// * AVAILABLE - Stable state, ready to perform any operation. The most recent operation succeeded and completed.
        ///
        /// * UNDER_CHANGE - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.
        ///
        /// * TAINTED - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.
        ///
        /// * ERROR - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.
        ///
        /// * PLAN_IN_PROGRESS - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.
        public var status: ServiceCatalogClientTypes.ProvisionedProductStatus?
        /// The current status message of the provisioned product.
        public var statusMessage: Swift.String?
        /// The type of provisioned product. The supported values are CFN_STACK and CFN_STACKSET.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            idempotencyToken: Swift.String? = nil,
            lastProvisioningRecordId: Swift.String? = nil,
            lastRecordId: Swift.String? = nil,
            lastSuccessfulProvisioningRecordId: Swift.String? = nil,
            launchRoleArn: Swift.String? = nil,
            name: Swift.String? = nil,
            productId: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            status: ServiceCatalogClientTypes.ProvisionedProductStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.idempotencyToken = idempotencyToken
            self.lastProvisioningRecordId = lastProvisioningRecordId
            self.lastRecordId = lastRecordId
            self.lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId
            self.launchRoleArn = launchRoleArn
            self.name = name
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes.ProvisionedProductPlanDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case planId = "PlanId"
        case planName = "PlanName"
        case planType = "PlanType"
        case productId = "ProductId"
        case provisionProductId = "ProvisionProductId"
        case provisionProductName = "ProvisionProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningParameters = "ProvisioningParameters"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case tags = "Tags"
        case updatedTime = "UpdatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for notificationarn0 in notificationArns {
                try notificationArnsContainer.encode(notificationarn0)
            }
        }
        if let pathId = self.pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let planId = self.planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
        if let planName = self.planName {
            try encodeContainer.encode(planName, forKey: .planName)
        }
        if let planType = self.planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisionProductId = self.provisionProductId {
            try encodeContainer.encode(provisionProductId, forKey: .provisionProductId)
        }
        if let provisionProductName = self.provisionProductName {
            try encodeContainer.encode(provisionProductName, forKey: .provisionProductName)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningParameters = provisioningParameters {
            var provisioningParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .provisioningParameters)
            for updateprovisioningparameter0 in provisioningParameters {
                try provisioningParametersContainer.encode(updateprovisioningparameter0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let updatedTime = self.updatedTime {
            try encodeContainer.encodeTimestamp(updatedTime, format: .epochSeconds, forKey: .updatedTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let planNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planName)
        planName = planNameDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planId)
        planId = planIdDecoded
        let provisionProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionProductId)
        provisionProductId = provisionProductIdDecoded
        let provisionProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionProductName)
        provisionProductName = provisionProductNameDecoded
        let planTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductPlanStatus.self, forKey: .status)
        status = statusDecoded
        let updatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let notificationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[Swift.String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [Swift.String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let provisioningParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.UpdateProvisioningParameter?].self, forKey: .provisioningParameters)
        var provisioningParametersDecoded0:[ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil
        if let provisioningParametersContainer = provisioningParametersContainer {
            provisioningParametersDecoded0 = [ServiceCatalogClientTypes.UpdateProvisioningParameter]()
            for structure0 in provisioningParametersContainer {
                if let structure0 = structure0 {
                    provisioningParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningParameters = provisioningParametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a plan.
    public struct ProvisionedProductPlanDetails: Swift.Equatable {
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.
        public var notificationArns: [Swift.String]?
        /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use [ListLaunchPaths].
        public var pathId: Swift.String?
        /// The plan identifier.
        public var planId: Swift.String?
        /// The name of the plan.
        public var planName: Swift.String?
        /// The plan type.
        public var planType: ServiceCatalogClientTypes.ProvisionedProductPlanType?
        /// The product identifier.
        public var productId: Swift.String?
        /// The product identifier.
        public var provisionProductId: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var provisionProductName: Swift.String?
        /// The identifier of the provisioning artifact.
        public var provisioningArtifactId: Swift.String?
        /// Parameters specified by the administrator that are required for provisioning the product.
        public var provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
        /// The status.
        public var status: ServiceCatalogClientTypes.ProvisionedProductPlanStatus?
        /// The status message.
        public var statusMessage: Swift.String?
        /// One or more tags.
        public var tags: [ServiceCatalogClientTypes.Tag]?
        /// The UTC time stamp when the plan was last updated.
        public var updatedTime: ClientRuntime.Date?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            notificationArns: [Swift.String]? = nil,
            pathId: Swift.String? = nil,
            planId: Swift.String? = nil,
            planName: Swift.String? = nil,
            planType: ServiceCatalogClientTypes.ProvisionedProductPlanType? = nil,
            productId: Swift.String? = nil,
            provisionProductId: Swift.String? = nil,
            provisionProductName: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil,
            status: ServiceCatalogClientTypes.ProvisionedProductPlanStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [ServiceCatalogClientTypes.Tag]? = nil,
            updatedTime: ClientRuntime.Date? = nil
        )
        {
            self.createdTime = createdTime
            self.notificationArns = notificationArns
            self.pathId = pathId
            self.planId = planId
            self.planName = planName
            self.planType = planType
            self.productId = productId
            self.provisionProductId = provisionProductId
            self.provisionProductName = provisionProductName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningParameters = provisioningParameters
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
            self.updatedTime = updatedTime
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ProvisionedProductPlanStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case createSuccess
        case executeFailed
        case executeInProgress
        case executeSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedProductPlanStatus] {
            return [
                .createFailed,
                .createInProgress,
                .createSuccess,
                .executeFailed,
                .executeInProgress,
                .executeSuccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createSuccess: return "CREATE_SUCCESS"
            case .executeFailed: return "EXECUTE_FAILED"
            case .executeInProgress: return "EXECUTE_IN_PROGRESS"
            case .executeSuccess: return "EXECUTE_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedProductPlanStatus(rawValue: rawValue) ?? ProvisionedProductPlanStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProvisionedProductPlanSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case planId = "PlanId"
        case planName = "PlanName"
        case planType = "PlanType"
        case provisionProductId = "ProvisionProductId"
        case provisionProductName = "ProvisionProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let planId = self.planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
        if let planName = self.planName {
            try encodeContainer.encode(planName, forKey: .planName)
        }
        if let planType = self.planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
        if let provisionProductId = self.provisionProductId {
            try encodeContainer.encode(provisionProductId, forKey: .provisionProductId)
        }
        if let provisionProductName = self.provisionProductName {
            try encodeContainer.encode(provisionProductName, forKey: .provisionProductName)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let planNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planName)
        planName = planNameDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planId)
        planId = planIdDecoded
        let provisionProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionProductId)
        provisionProductId = provisionProductIdDecoded
        let provisionProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionProductName)
        provisionProductName = provisionProductNameDecoded
        let planTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Summary information about a plan.
    public struct ProvisionedProductPlanSummary: Swift.Equatable {
        /// The plan identifier.
        public var planId: Swift.String?
        /// The name of the plan.
        public var planName: Swift.String?
        /// The plan type.
        public var planType: ServiceCatalogClientTypes.ProvisionedProductPlanType?
        /// The product identifier.
        public var provisionProductId: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var provisionProductName: Swift.String?
        /// The identifier of the provisioning artifact.
        public var provisioningArtifactId: Swift.String?

        public init(
            planId: Swift.String? = nil,
            planName: Swift.String? = nil,
            planType: ServiceCatalogClientTypes.ProvisionedProductPlanType? = nil,
            provisionProductId: Swift.String? = nil,
            provisionProductName: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil
        )
        {
            self.planId = planId
            self.planName = planName
            self.planType = planType
            self.provisionProductId = provisionProductId
            self.provisionProductName = provisionProductName
            self.provisioningArtifactId = provisioningArtifactId
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ProvisionedProductPlanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudformation
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedProductPlanType] {
            return [
                .cloudformation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudformation: return "CLOUDFORMATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedProductPlanType(rawValue: rawValue) ?? ProvisionedProductPlanType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ProvisionedProductStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case error
        case planInProgress
        case tainted
        case underChange
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedProductStatus] {
            return [
                .available,
                .error,
                .planInProgress,
                .tainted,
                .underChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .planInProgress: return "PLAN_IN_PROGRESS"
            case .tainted: return "TAINTED"
            case .underChange: return "UNDER_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedProductStatus(rawValue: rawValue) ?? ProvisionedProductStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ProvisionedProductViewFilterBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case searchquery
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedProductViewFilterBy] {
            return [
                .searchquery,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .searchquery: return "SearchQuery"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedProductViewFilterBy(rawValue: rawValue) ?? ProvisionedProductViewFilterBy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case description = "Description"
        case guidance = "Guidance"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let guidance = self.guidance {
            try encodeContainer.encode(guidance.rawValue, forKey: .guidance)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let guidanceDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactGuidance.self, forKey: .guidance)
        guidance = guidanceDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a provisioning artifact. A provisioning artifact is also known as a product version.
    public struct ProvisioningArtifact: Swift.Equatable {
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The description of the provisioning artifact.
        public var description: Swift.String?
        /// Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.
        public var guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance?
        /// The identifier of the provisioning artifact.
        public var id: Swift.String?
        /// The name of the provisioning artifact.
        public var name: Swift.String?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.description = description
            self.guidance = guidance
            self.id = id
            self.name = name
        }
    }

}

extension ServiceCatalogClientTypes.ProvisioningArtifactDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case createdTime = "CreatedTime"
        case description = "Description"
        case guidance = "Guidance"
        case id = "Id"
        case name = "Name"
        case sourceRevision = "SourceRevision"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let guidance = self.guidance {
            try encodeContainer.encode(guidance.rawValue, forKey: .guidance)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceRevision = self.sourceRevision {
            try encodeContainer.encode(sourceRevision, forKey: .sourceRevision)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactType.self, forKey: .type)
        type = typeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let guidanceDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactGuidance.self, forKey: .guidance)
        guidance = guidanceDecoded
        let sourceRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRevision)
        sourceRevision = sourceRevisionDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a provisioning artifact (also known as a version) for a product.
    public struct ProvisioningArtifactDetail: Swift.Equatable {
        /// Indicates whether the product version is active.
        public var active: Swift.Bool?
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The description of the provisioning artifact.
        public var description: Swift.String?
        /// Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.
        public var guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance?
        /// The identifier of the provisioning artifact.
        public var id: Swift.String?
        /// The name of the provisioning artifact.
        public var name: Swift.String?
        /// Specifies the revision of the external artifact that was used to automatically sync the Service Catalog product and create the provisioning artifact. Service Catalog includes this response parameter as a high level field to the existing ProvisioningArtifactDetail type, which is returned as part of the response for CreateProduct, UpdateProduct, DescribeProductAsAdmin, DescribeProvisioningArtifact, ListProvisioningArtifact, and UpdateProvisioningArticat APIs. This field only exists for Repo-Synced products.
        public var sourceRevision: Swift.String?
        /// The type of provisioning artifact. CLOUD_FORMATION_TEMPLATE - CloudFormation template
        public var type: ServiceCatalogClientTypes.ProvisioningArtifactType?

        public init(
            active: Swift.Bool? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            sourceRevision: Swift.String? = nil,
            type: ServiceCatalogClientTypes.ProvisioningArtifactType? = nil
        )
        {
            self.active = active
            self.createdTime = createdTime
            self.description = description
            self.guidance = guidance
            self.id = id
            self.name = name
            self.sourceRevision = sourceRevision
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ProvisioningArtifactGuidance: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case deprecated
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningArtifactGuidance] {
            return [
                .default,
                .deprecated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .deprecated: return "DEPRECATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisioningArtifactGuidance(rawValue: rawValue) ?? ProvisioningArtifactGuidance.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Provisioning artifact output.
    public struct ProvisioningArtifactOutput: Swift.Equatable {
        /// Description of the provisioning artifact output key.
        public var description: Swift.String?
        /// The provisioning artifact output key.
        public var key: Swift.String?

        public init(
            description: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.description = description
            self.key = key
        }
    }

}

extension ServiceCatalogClientTypes.ProvisioningArtifactParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case description = "Description"
        case isNoEcho = "IsNoEcho"
        case parameterConstraints = "ParameterConstraints"
        case parameterKey = "ParameterKey"
        case parameterType = "ParameterType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isNoEcho != false {
            try encodeContainer.encode(isNoEcho, forKey: .isNoEcho)
        }
        if let parameterConstraints = self.parameterConstraints {
            try encodeContainer.encode(parameterConstraints, forKey: .parameterConstraints)
        }
        if let parameterKey = self.parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let parameterType = self.parameterType {
            try encodeContainer.encode(parameterType, forKey: .parameterType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let parameterTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterType)
        parameterType = parameterTypeDecoded
        let isNoEchoDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isNoEcho) ?? false
        isNoEcho = isNoEchoDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parameterConstraintsDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ParameterConstraints.self, forKey: .parameterConstraints)
        parameterConstraints = parameterConstraintsDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a parameter used to provision a product.
    public struct ProvisioningArtifactParameter: Swift.Equatable {
        /// The default value.
        public var defaultValue: Swift.String?
        /// The description of the parameter.
        public var description: Swift.String?
        /// If this value is true, the value for this parameter is obfuscated from view when the parameter is retrieved. This parameter is used to hide sensitive information.
        public var isNoEcho: Swift.Bool
        /// Constraints that the administrator has put on a parameter.
        public var parameterConstraints: ServiceCatalogClientTypes.ParameterConstraints?
        /// The parameter key.
        public var parameterKey: Swift.String?
        /// The parameter type.
        public var parameterType: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            isNoEcho: Swift.Bool = false,
            parameterConstraints: ServiceCatalogClientTypes.ParameterConstraints? = nil,
            parameterKey: Swift.String? = nil,
            parameterType: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.isNoEcho = isNoEcho
            self.parameterConstraints = parameterConstraints
            self.parameterKey = parameterKey
            self.parameterType = parameterType
        }
    }

}

extension ServiceCatalogClientTypes.ProvisioningArtifactPreferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackSetAccounts = "StackSetAccounts"
        case stackSetRegions = "StackSetRegions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackSetAccounts = stackSetAccounts {
            var stackSetAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetAccounts)
            for accountid0 in stackSetAccounts {
                try stackSetAccountsContainer.encode(accountid0)
            }
        }
        if let stackSetRegions = stackSetRegions {
            var stackSetRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetRegions)
            for region0 in stackSetRegions {
                try stackSetRegionsContainer.encode(region0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackSetAccounts)
        var stackSetAccountsDecoded0:[Swift.String]? = nil
        if let stackSetAccountsContainer = stackSetAccountsContainer {
            stackSetAccountsDecoded0 = [Swift.String]()
            for string0 in stackSetAccountsContainer {
                if let string0 = string0 {
                    stackSetAccountsDecoded0?.append(string0)
                }
            }
        }
        stackSetAccounts = stackSetAccountsDecoded0
        let stackSetRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackSetRegions)
        var stackSetRegionsDecoded0:[Swift.String]? = nil
        if let stackSetRegionsContainer = stackSetRegionsContainer {
            stackSetRegionsDecoded0 = [Swift.String]()
            for string0 in stackSetRegionsContainer {
                if let string0 = string0 {
                    stackSetRegionsDecoded0?.append(string0)
                }
            }
        }
        stackSetRegions = stackSetRegionsDecoded0
    }
}

extension ServiceCatalogClientTypes {
    /// The user-defined preferences that will be applied during product provisioning, unless overridden by ProvisioningPreferences or UpdateProvisioningPreferences. For more information on maximum concurrent accounts and failure tolerance, see [Stack set operation options](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-ops-options) in the CloudFormation User Guide.
    public struct ProvisioningArtifactPreferences: Swift.Equatable {
        /// One or more Amazon Web Services accounts where stack instances are deployed from the stack set. These accounts can be scoped in ProvisioningPreferences$StackSetAccounts and UpdateProvisioningPreferences$StackSetAccounts. Applicable only to a CFN_STACKSET provisioned product type.
        public var stackSetAccounts: [Swift.String]?
        /// One or more Amazon Web Services Regions where stack instances are deployed from the stack set. These Regions can be scoped in ProvisioningPreferences$StackSetRegions and UpdateProvisioningPreferences$StackSetRegions. Applicable only to a CFN_STACKSET provisioned product type.
        public var stackSetRegions: [Swift.String]?

        public init(
            stackSetAccounts: [Swift.String]? = nil,
            stackSetRegions: [Swift.String]? = nil
        )
        {
            self.stackSetAccounts = stackSetAccounts
            self.stackSetRegions = stackSetRegions
        }
    }

}

extension ServiceCatalogClientTypes.ProvisioningArtifactProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case disableTemplateValidation = "DisableTemplateValidation"
        case info = "Info"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if disableTemplateValidation != false {
            try encodeContainer.encode(disableTemplateValidation, forKey: .disableTemplateValidation)
        }
        if let info = info {
            var infoContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .info)
            for (dictKey0, provisioningArtifactInfo0) in info {
                try infoContainer.encode(provisioningArtifactInfo0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let infoContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .info)
        var infoDecoded0: [Swift.String:Swift.String]? = nil
        if let infoContainer = infoContainer {
            infoDecoded0 = [Swift.String:Swift.String]()
            for (key0, provisioningartifactinfovalue0) in infoContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    infoDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        info = infoDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactType.self, forKey: .type)
        type = typeDecoded
        let disableTemplateValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableTemplateValidation) ?? false
        disableTemplateValidation = disableTemplateValidationDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a provisioning artifact (also known as a version) for a product.
    public struct ProvisioningArtifactProperties: Swift.Equatable {
        /// The description of the provisioning artifact, including how it differs from the previous provisioning artifact.
        public var description: Swift.String?
        /// If set to true, Service Catalog stops validating the specified provisioning artifact even if it is invalid. Service Catalog does not support template validation for the TERRAFORM_OS product type.
        public var disableTemplateValidation: Swift.Bool
        /// Specify the template source with one of the following options, but not both. Keys accepted: [ LoadTemplateFromURL, ImportFromPhysicalId ] The URL of the CloudFormation template in Amazon S3 or GitHub in JSON format. Specify the URL in JSON format as follows: "LoadTemplateFromURL": "https://s3.amazonaws.com/cf-templates-ozkq9d3hgiq2-us-east-1/..."ImportFromPhysicalId: The physical id of the resource that contains the template. Currently only supports CloudFormation stack arn. Specify the physical id in JSON format as follows: ImportFromPhysicalId: arn:aws:cloudformation:[us-east-1]:[accountId]:stack/[StackName]/[resourceId]
        public var info: [Swift.String:Swift.String]?
        /// The name of the provisioning artifact (for example, v1 v2beta). No spaces are allowed.
        public var name: Swift.String?
        /// The type of provisioning artifact.
        ///
        /// * CLOUD_FORMATION_TEMPLATE - CloudFormation template
        ///
        /// * TERRAFORM_OPEN_SOURCE - Terraform open source configuration file
        public var type: ServiceCatalogClientTypes.ProvisioningArtifactType?

        public init(
            description: Swift.String? = nil,
            disableTemplateValidation: Swift.Bool = false,
            info: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            type: ServiceCatalogClientTypes.ProvisioningArtifactType? = nil
        )
        {
            self.description = description
            self.disableTemplateValidation = disableTemplateValidation
            self.info = info
            self.name = name
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ProvisioningArtifactPropertyName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case id
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningArtifactPropertyName] {
            return [
                .id,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .id: return "Id"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisioningArtifactPropertyName(rawValue: rawValue) ?? ProvisioningArtifactPropertyName.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case provisioningArtifactMetadata = "ProvisioningArtifactMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioningArtifactMetadata = provisioningArtifactMetadata {
            var provisioningArtifactMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .provisioningArtifactMetadata)
            for (dictKey0, provisioningArtifactInfo0) in provisioningArtifactMetadata {
                try provisioningArtifactMetadataContainer.encode(provisioningArtifactInfo0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let provisioningArtifactMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .provisioningArtifactMetadata)
        var provisioningArtifactMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let provisioningArtifactMetadataContainer = provisioningArtifactMetadataContainer {
            provisioningArtifactMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, provisioningartifactinfovalue0) in provisioningArtifactMetadataContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    provisioningArtifactMetadataDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        provisioningArtifactMetadata = provisioningArtifactMetadataDecoded0
    }
}

extension ServiceCatalogClientTypes {
    /// Summary information about a provisioning artifact (also known as a version) for a product.
    public struct ProvisioningArtifactSummary: Swift.Equatable {
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The description of the provisioning artifact.
        public var description: Swift.String?
        /// The identifier of the provisioning artifact.
        public var id: Swift.String?
        /// The name of the provisioning artifact.
        public var name: Swift.String?
        /// The metadata for the provisioning artifact. This is used with Amazon Web Services Marketplace products.
        public var provisioningArtifactMetadata: [Swift.String:Swift.String]?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            provisioningArtifactMetadata: [Swift.String:Swift.String]? = nil
        )
        {
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.name = name
            self.provisioningArtifactMetadata = provisioningArtifactMetadata
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ProvisioningArtifactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudFormationTemplate
        case marketplaceAmi
        case marketplaceCar
        case terraformCloud
        case terraformOpenSource
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningArtifactType] {
            return [
                .cloudFormationTemplate,
                .marketplaceAmi,
                .marketplaceCar,
                .terraformCloud,
                .terraformOpenSource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudFormationTemplate: return "CLOUD_FORMATION_TEMPLATE"
            case .marketplaceAmi: return "MARKETPLACE_AMI"
            case .marketplaceCar: return "MARKETPLACE_CAR"
            case .terraformCloud: return "TERRAFORM_CLOUD"
            case .terraformOpenSource: return "TERRAFORM_OPEN_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisioningArtifactType(rawValue: rawValue) ?? ProvisioningArtifactType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactView: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productViewSummary = "ProductViewSummary"
        case provisioningArtifact = "ProvisioningArtifact"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productViewSummary = self.productViewSummary {
            try encodeContainer.encode(productViewSummary, forKey: .productViewSummary)
        }
        if let provisioningArtifact = self.provisioningArtifact {
            try encodeContainer.encode(provisioningArtifact, forKey: .provisioningArtifact)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummaryDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewSummary.self, forKey: .productViewSummary)
        productViewSummary = productViewSummaryDecoded
        let provisioningArtifactDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifact.self, forKey: .provisioningArtifact)
        provisioningArtifact = provisioningArtifactDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// An object that contains summary information about a product view and a provisioning artifact.
    public struct ProvisioningArtifactView: Swift.Equatable {
        /// Summary information about a product view.
        public var productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
        /// Information about a provisioning artifact. A provisioning artifact is also known as a product version.
        public var provisioningArtifact: ServiceCatalogClientTypes.ProvisioningArtifact?

        public init(
            productViewSummary: ServiceCatalogClientTypes.ProductViewSummary? = nil,
            provisioningArtifact: ServiceCatalogClientTypes.ProvisioningArtifact? = nil
        )
        {
            self.productViewSummary = productViewSummary
            self.provisioningArtifact = provisioningArtifact
        }
    }

}

extension ServiceCatalogClientTypes.ProvisioningParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a parameter used to provision a product.
    public struct ProvisioningParameter: Swift.Equatable {
        /// The parameter key.
        public var key: Swift.String?
        /// The parameter value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ServiceCatalogClientTypes.ProvisioningPreferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackSetAccounts = "StackSetAccounts"
        case stackSetFailureToleranceCount = "StackSetFailureToleranceCount"
        case stackSetFailureTolerancePercentage = "StackSetFailureTolerancePercentage"
        case stackSetMaxConcurrencyCount = "StackSetMaxConcurrencyCount"
        case stackSetMaxConcurrencyPercentage = "StackSetMaxConcurrencyPercentage"
        case stackSetRegions = "StackSetRegions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackSetAccounts = stackSetAccounts {
            var stackSetAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetAccounts)
            for accountid0 in stackSetAccounts {
                try stackSetAccountsContainer.encode(accountid0)
            }
        }
        if let stackSetFailureToleranceCount = self.stackSetFailureToleranceCount {
            try encodeContainer.encode(stackSetFailureToleranceCount, forKey: .stackSetFailureToleranceCount)
        }
        if let stackSetFailureTolerancePercentage = self.stackSetFailureTolerancePercentage {
            try encodeContainer.encode(stackSetFailureTolerancePercentage, forKey: .stackSetFailureTolerancePercentage)
        }
        if let stackSetMaxConcurrencyCount = self.stackSetMaxConcurrencyCount {
            try encodeContainer.encode(stackSetMaxConcurrencyCount, forKey: .stackSetMaxConcurrencyCount)
        }
        if let stackSetMaxConcurrencyPercentage = self.stackSetMaxConcurrencyPercentage {
            try encodeContainer.encode(stackSetMaxConcurrencyPercentage, forKey: .stackSetMaxConcurrencyPercentage)
        }
        if let stackSetRegions = stackSetRegions {
            var stackSetRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetRegions)
            for region0 in stackSetRegions {
                try stackSetRegionsContainer.encode(region0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackSetAccounts)
        var stackSetAccountsDecoded0:[Swift.String]? = nil
        if let stackSetAccountsContainer = stackSetAccountsContainer {
            stackSetAccountsDecoded0 = [Swift.String]()
            for string0 in stackSetAccountsContainer {
                if let string0 = string0 {
                    stackSetAccountsDecoded0?.append(string0)
                }
            }
        }
        stackSetAccounts = stackSetAccountsDecoded0
        let stackSetRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackSetRegions)
        var stackSetRegionsDecoded0:[Swift.String]? = nil
        if let stackSetRegionsContainer = stackSetRegionsContainer {
            stackSetRegionsDecoded0 = [Swift.String]()
            for string0 in stackSetRegionsContainer {
                if let string0 = string0 {
                    stackSetRegionsDecoded0?.append(string0)
                }
            }
        }
        stackSetRegions = stackSetRegionsDecoded0
        let stackSetFailureToleranceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetFailureToleranceCount)
        stackSetFailureToleranceCount = stackSetFailureToleranceCountDecoded
        let stackSetFailureTolerancePercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetFailureTolerancePercentage)
        stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentageDecoded
        let stackSetMaxConcurrencyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetMaxConcurrencyCount)
        stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCountDecoded
        let stackSetMaxConcurrencyPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetMaxConcurrencyPercentage)
        stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentageDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// The user-defined preferences that will be applied when updating a provisioned product. Not all preferences are applicable to all provisioned product type One or more Amazon Web Services accounts that will have access to the provisioned product. Applicable only to a CFN_STACKSET provisioned product type. The Amazon Web Services accounts specified should be within the list of accounts in the STACKSET constraint. To get the list of accounts in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all accounts from the STACKSET constraint.
    public struct ProvisioningPreferences: Swift.Equatable {
        /// One or more Amazon Web Services accounts where the provisioned product will be available. Applicable only to a CFN_STACKSET provisioned product type. The specified accounts should be within the list of accounts from the STACKSET constraint. To get the list of accounts in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all acounts from the STACKSET constraint.
        public var stackSetAccounts: [Swift.String]?
        /// The number of accounts, per Region, for which this operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both. The default value is 0 if no value is specified.
        public var stackSetFailureToleranceCount: Swift.Int?
        /// The percentage of accounts, per Region, for which this stack operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions. When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both.
        public var stackSetFailureTolerancePercentage: Swift.Int?
        /// The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of StackSetFailureToleranceCount. StackSetMaxConcurrentCount is at most one more than the StackSetFailureToleranceCount. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public var stackSetMaxConcurrencyCount: Swift.Int?
        /// The maximum percentage of accounts in which to perform this operation at one time. When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, Service Catalog sets the number as 1 instead. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public var stackSetMaxConcurrencyPercentage: Swift.Int?
        /// One or more Amazon Web Services Regions where the provisioned product will be available. Applicable only to a CFN_STACKSET provisioned product type. The specified Regions should be within the list of Regions from the STACKSET constraint. To get the list of Regions in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all Regions from the STACKSET constraint.
        public var stackSetRegions: [Swift.String]?

        public init(
            stackSetAccounts: [Swift.String]? = nil,
            stackSetFailureToleranceCount: Swift.Int? = nil,
            stackSetFailureTolerancePercentage: Swift.Int? = nil,
            stackSetMaxConcurrencyCount: Swift.Int? = nil,
            stackSetMaxConcurrencyPercentage: Swift.Int? = nil,
            stackSetRegions: [Swift.String]? = nil
        )
        {
            self.stackSetAccounts = stackSetAccounts
            self.stackSetFailureToleranceCount = stackSetFailureToleranceCount
            self.stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage
            self.stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount
            self.stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage
            self.stackSetRegions = stackSetRegions
        }
    }

}

extension ServiceCatalogClientTypes.RecordDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case launchRoleArn = "LaunchRoleArn"
        case pathId = "PathId"
        case productId = "ProductId"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisionedProductType = "ProvisionedProductType"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case recordErrors = "RecordErrors"
        case recordId = "RecordId"
        case recordTags = "RecordTags"
        case recordType = "RecordType"
        case status = "Status"
        case updatedTime = "UpdatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let launchRoleArn = self.launchRoleArn {
            try encodeContainer.encode(launchRoleArn, forKey: .launchRoleArn)
        }
        if let pathId = self.pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisionedProductId = self.provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductName = self.provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisionedProductType = self.provisionedProductType {
            try encodeContainer.encode(provisionedProductType, forKey: .provisionedProductType)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let recordErrors = recordErrors {
            var recordErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordErrors)
            for recorderror0 in recordErrors {
                try recordErrorsContainer.encode(recorderror0)
            }
        }
        if let recordId = self.recordId {
            try encodeContainer.encode(recordId, forKey: .recordId)
        }
        if let recordTags = recordTags {
            var recordTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordTags)
            for recordtag0 in recordTags {
                try recordTagsContainer.encode(recordtag0)
            }
        }
        if let recordType = self.recordType {
            try encodeContainer.encode(recordType, forKey: .recordType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTime = self.updatedTime {
            try encodeContainer.encodeTimestamp(updatedTime, format: .epochSeconds, forKey: .updatedTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordId)
        recordId = recordIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let provisionedProductTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductType)
        provisionedProductType = provisionedProductTypeDecoded
        let recordTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordType)
        recordType = recordTypeDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let recordErrorsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.RecordError?].self, forKey: .recordErrors)
        var recordErrorsDecoded0:[ServiceCatalogClientTypes.RecordError]? = nil
        if let recordErrorsContainer = recordErrorsContainer {
            recordErrorsDecoded0 = [ServiceCatalogClientTypes.RecordError]()
            for structure0 in recordErrorsContainer {
                if let structure0 = structure0 {
                    recordErrorsDecoded0?.append(structure0)
                }
            }
        }
        recordErrors = recordErrorsDecoded0
        let recordTagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.RecordTag?].self, forKey: .recordTags)
        var recordTagsDecoded0:[ServiceCatalogClientTypes.RecordTag]? = nil
        if let recordTagsContainer = recordTagsContainer {
            recordTagsDecoded0 = [ServiceCatalogClientTypes.RecordTag]()
            for structure0 in recordTagsContainer {
                if let structure0 = structure0 {
                    recordTagsDecoded0?.append(structure0)
                }
            }
        }
        recordTags = recordTagsDecoded0
        let launchRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchRoleArn)
        launchRoleArn = launchRoleArnDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a request operation.
    public struct RecordDetail: Swift.Equatable {
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The ARN of the launch role associated with the provisioned product.
        public var launchRoleArn: Swift.String?
        /// The path identifier.
        public var pathId: Swift.String?
        /// The product identifier.
        public var productId: Swift.String?
        /// The identifier of the provisioned product.
        public var provisionedProductId: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var provisionedProductName: Swift.String?
        /// The type of provisioned product. The supported values are CFN_STACK, CFN_STACKSET, TERRAFORM_OPEN_SOURCE, and TERRAFORM_CLOUD.
        public var provisionedProductType: Swift.String?
        /// The identifier of the provisioning artifact.
        public var provisioningArtifactId: Swift.String?
        /// The errors that occurred.
        public var recordErrors: [ServiceCatalogClientTypes.RecordError]?
        /// The identifier of the record.
        public var recordId: Swift.String?
        /// One or more tags.
        public var recordTags: [ServiceCatalogClientTypes.RecordTag]?
        /// The record type.
        ///
        /// * PROVISION_PRODUCT
        ///
        /// * UPDATE_PROVISIONED_PRODUCT
        ///
        /// * TERMINATE_PROVISIONED_PRODUCT
        public var recordType: Swift.String?
        /// The status of the provisioned product.
        ///
        /// * CREATED - The request was created but the operation has not started.
        ///
        /// * IN_PROGRESS - The requested operation is in progress.
        ///
        /// * IN_PROGRESS_IN_ERROR - The provisioned product is under change but the requested operation failed and some remediation is occurring. For example, a rollback.
        ///
        /// * SUCCEEDED - The requested operation has successfully completed.
        ///
        /// * FAILED - The requested operation has unsuccessfully completed. Investigate using the error messages returned.
        public var status: ServiceCatalogClientTypes.RecordStatus?
        /// The time when the record was last updated.
        public var updatedTime: ClientRuntime.Date?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            launchRoleArn: Swift.String? = nil,
            pathId: Swift.String? = nil,
            productId: Swift.String? = nil,
            provisionedProductId: Swift.String? = nil,
            provisionedProductName: Swift.String? = nil,
            provisionedProductType: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            recordErrors: [ServiceCatalogClientTypes.RecordError]? = nil,
            recordId: Swift.String? = nil,
            recordTags: [ServiceCatalogClientTypes.RecordTag]? = nil,
            recordType: Swift.String? = nil,
            status: ServiceCatalogClientTypes.RecordStatus? = nil,
            updatedTime: ClientRuntime.Date? = nil
        )
        {
            self.createdTime = createdTime
            self.launchRoleArn = launchRoleArn
            self.pathId = pathId
            self.productId = productId
            self.provisionedProductId = provisionedProductId
            self.provisionedProductName = provisionedProductName
            self.provisionedProductType = provisionedProductType
            self.provisioningArtifactId = provisioningArtifactId
            self.recordErrors = recordErrors
            self.recordId = recordId
            self.recordTags = recordTags
            self.recordType = recordType
            self.status = status
            self.updatedTime = updatedTime
        }
    }

}

extension ServiceCatalogClientTypes.RecordError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// The error code and description resulting from an operation.
    public struct RecordError: Swift.Equatable {
        /// The numeric value of the error.
        public var code: Swift.String?
        /// The description of the error.
        public var description: Swift.String?

        public init(
            code: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.code = code
            self.description = description
        }
    }

}

extension ServiceCatalogClientTypes.RecordOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case outputKey = "OutputKey"
        case outputValue = "OutputValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let outputKey = self.outputKey {
            try encodeContainer.encode(outputKey, forKey: .outputKey)
        }
        if let outputValue = self.outputValue {
            try encodeContainer.encode(outputValue, forKey: .outputValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputKey)
        outputKey = outputKeyDecoded
        let outputValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputValue)
        outputValue = outputValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// The output for the product created as the result of a request. For example, the output for a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.
    public struct RecordOutput: Swift.Equatable {
        /// The description of the output.
        public var description: Swift.String?
        /// The output key.
        public var outputKey: Swift.String?
        /// The output value.
        public var outputValue: Swift.String?

        public init(
            description: Swift.String? = nil,
            outputKey: Swift.String? = nil,
            outputValue: Swift.String? = nil
        )
        {
            self.description = description
            self.outputKey = outputKey
            self.outputValue = outputValue
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum RecordStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case failed
        case inProgress
        case inProgressInError
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordStatus] {
            return [
                .created,
                .failed,
                .inProgress,
                .inProgressInError,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .inProgressInError: return "IN_PROGRESS_IN_ERROR"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordStatus(rawValue: rawValue) ?? RecordStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.RecordTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a tag, which is a key-value pair.
    public struct RecordTag: Swift.Equatable {
        /// The key for this tag.
        public var key: Swift.String?
        /// The value for this tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension RejectPortfolioShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case portfolioShareType = "PortfolioShareType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let portfolioShareType = self.portfolioShareType {
            try encodeContainer.encode(portfolioShareType.rawValue, forKey: .portfolioShareType)
        }
    }
}

extension RejectPortfolioShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RejectPortfolioShareInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The type of shared portfolios to reject. The default is to reject imported portfolios.
    ///
    /// * AWS_ORGANIZATIONS - Reject portfolios shared by the management account of your organization.
    ///
    /// * IMPORTED - Reject imported portfolios.
    ///
    /// * AWS_SERVICECATALOG - Not supported. (Throws ResourceNotFoundException.)
    ///
    ///
    /// For example, aws servicecatalog reject-portfolio-share --portfolio-id "port-2qwzkwxt3y5fk" --portfolio-share-type AWS_ORGANIZATIONS
    public var portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?

    public init(
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.portfolioShareType = portfolioShareType
    }
}

struct RejectPortfolioShareInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?
}

extension RejectPortfolioShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case portfolioShareType = "PortfolioShareType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let portfolioShareTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PortfolioShareType.self, forKey: .portfolioShareType)
        portfolioShareType = portfolioShareTypeDecoded
    }
}

extension RejectPortfolioShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RejectPortfolioShareOutput: Swift.Equatable {

    public init() { }
}

enum RejectPortfolioShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum Replacement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conditional
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [Replacement] {
            return [
                .conditional,
                .false,
                .true,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conditional: return "CONDITIONAL"
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Replacement(rawValue: rawValue) ?? Replacement.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum RequiresRecreation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case always
        case conditionally
        case never
        case sdkUnknown(Swift.String)

        public static var allCases: [RequiresRecreation] {
            return [
                .always,
                .conditionally,
                .never,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .always: return "ALWAYS"
            case .conditionally: return "CONDITIONALLY"
            case .never: return "NEVER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequiresRecreation(rawValue: rawValue) ?? RequiresRecreation.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ResourceAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationpolicy
        case deletionpolicy
        case metadata
        case properties
        case tags
        case updatepolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceAttribute] {
            return [
                .creationpolicy,
                .deletionpolicy,
                .metadata,
                .properties,
                .tags,
                .updatepolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationpolicy: return "CREATIONPOLICY"
            case .deletionpolicy: return "DELETIONPOLICY"
            case .metadata: return "METADATA"
            case .properties: return "PROPERTIES"
            case .tags: return "TAGS"
            case .updatepolicy: return "UPDATEPOLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceAttribute(rawValue: rawValue) ?? ResourceAttribute.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ResourceChange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case details = "Details"
        case logicalResourceId = "LogicalResourceId"
        case physicalResourceId = "PhysicalResourceId"
        case replacement = "Replacement"
        case resourceType = "ResourceType"
        case scope = "Scope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let details = details {
            var detailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .details)
            for resourcechangedetail0 in details {
                try detailsContainer.encode(resourcechangedetail0)
            }
        }
        if let logicalResourceId = self.logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = self.physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let replacement = self.replacement {
            try encodeContainer.encode(replacement.rawValue, forKey: .replacement)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let scope = scope {
            var scopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scope)
            for resourceattribute0 in scope {
                try scopeContainer.encode(resourceattribute0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ChangeAction.self, forKey: .action)
        action = actionDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let replacementDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Replacement.self, forKey: .replacement)
        replacement = replacementDecoded
        let scopeContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ResourceAttribute?].self, forKey: .scope)
        var scopeDecoded0:[ServiceCatalogClientTypes.ResourceAttribute]? = nil
        if let scopeContainer = scopeContainer {
            scopeDecoded0 = [ServiceCatalogClientTypes.ResourceAttribute]()
            for enum0 in scopeContainer {
                if let enum0 = enum0 {
                    scopeDecoded0?.append(enum0)
                }
            }
        }
        scope = scopeDecoded0
        let detailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ResourceChangeDetail?].self, forKey: .details)
        var detailsDecoded0:[ServiceCatalogClientTypes.ResourceChangeDetail]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [ServiceCatalogClientTypes.ResourceChangeDetail]()
            for structure0 in detailsContainer {
                if let structure0 = structure0 {
                    detailsDecoded0?.append(structure0)
                }
            }
        }
        details = detailsDecoded0
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a resource change that will occur when a plan is executed.
    public struct ResourceChange: Swift.Equatable {
        /// The change action.
        public var action: ServiceCatalogClientTypes.ChangeAction?
        /// Information about the resource changes.
        public var details: [ServiceCatalogClientTypes.ResourceChangeDetail]?
        /// The ID of the resource, as defined in the CloudFormation template.
        public var logicalResourceId: Swift.String?
        /// The ID of the resource, if it was already created.
        public var physicalResourceId: Swift.String?
        /// If the change type is Modify, indicates whether the existing resource is deleted and replaced with a new one.
        public var replacement: ServiceCatalogClientTypes.Replacement?
        /// The type of resource.
        public var resourceType: Swift.String?
        /// The change scope.
        public var scope: [ServiceCatalogClientTypes.ResourceAttribute]?

        public init(
            action: ServiceCatalogClientTypes.ChangeAction? = nil,
            details: [ServiceCatalogClientTypes.ResourceChangeDetail]? = nil,
            logicalResourceId: Swift.String? = nil,
            physicalResourceId: Swift.String? = nil,
            replacement: ServiceCatalogClientTypes.Replacement? = nil,
            resourceType: Swift.String? = nil,
            scope: [ServiceCatalogClientTypes.ResourceAttribute]? = nil
        )
        {
            self.action = action
            self.details = details
            self.logicalResourceId = logicalResourceId
            self.physicalResourceId = physicalResourceId
            self.replacement = replacement
            self.resourceType = resourceType
            self.scope = scope
        }
    }

}

extension ServiceCatalogClientTypes.ResourceChangeDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case causingEntity = "CausingEntity"
        case evaluation = "Evaluation"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let causingEntity = self.causingEntity {
            try encodeContainer.encode(causingEntity, forKey: .causingEntity)
        }
        if let evaluation = self.evaluation {
            try encodeContainer.encode(evaluation.rawValue, forKey: .evaluation)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ResourceTargetDefinition.self, forKey: .target)
        target = targetDecoded
        let evaluationDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.EvaluationType.self, forKey: .evaluation)
        evaluation = evaluationDecoded
        let causingEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .causingEntity)
        causingEntity = causingEntityDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a change to a resource attribute.
    public struct ResourceChangeDetail: Swift.Equatable {
        /// The ID of the entity that caused the change.
        public var causingEntity: Swift.String?
        /// For static evaluations, the value of the resource attribute will change and the new value is known. For dynamic evaluations, the value might change, and any new value will be determined when the plan is updated.
        public var evaluation: ServiceCatalogClientTypes.EvaluationType?
        /// Information about the resource attribute to be modified.
        public var target: ServiceCatalogClientTypes.ResourceTargetDefinition?

        public init(
            causingEntity: Swift.String? = nil,
            evaluation: ServiceCatalogClientTypes.EvaluationType? = nil,
            target: ServiceCatalogClientTypes.ResourceTargetDefinition? = nil
        )
        {
            self.causingEntity = causingEntity
            self.evaluation = evaluation
            self.target = target
        }
    }

}

extension ServiceCatalogClientTypes.ResourceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case createdTime = "CreatedTime"
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a resource.
    public struct ResourceDetail: Swift.Equatable {
        /// The ARN of the resource.
        public var arn: Swift.String?
        /// The creation time of the resource.
        public var createdTime: ClientRuntime.Date?
        /// The description of the resource.
        public var description: Swift.String?
        /// The identifier of the resource.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.name = name
        }
    }

}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource that is currently in use. Ensure that the resource is not in use and retry the operation.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceCatalogClientTypes.ResourceTargetDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute = "Attribute"
        case name = "Name"
        case requiresRecreation = "RequiresRecreation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiresRecreation = self.requiresRecreation {
            try encodeContainer.encode(requiresRecreation.rawValue, forKey: .requiresRecreation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ResourceAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requiresRecreationDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RequiresRecreation.self, forKey: .requiresRecreation)
        requiresRecreation = requiresRecreationDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a change to a resource attribute.
    public struct ResourceTargetDefinition: Swift.Equatable {
        /// The attribute to be changed.
        public var attribute: ServiceCatalogClientTypes.ResourceAttribute?
        /// If the attribute is Properties, the value is the name of the property. Otherwise, the value is null.
        public var name: Swift.String?
        /// If the attribute is Properties, indicates whether a change to this property causes the resource to be re-created.
        public var requiresRecreation: ServiceCatalogClientTypes.RequiresRecreation?

        public init(
            attribute: ServiceCatalogClientTypes.ResourceAttribute? = nil,
            name: Swift.String? = nil,
            requiresRecreation: ServiceCatalogClientTypes.RequiresRecreation? = nil
        )
        {
            self.attribute = attribute
            self.name = name
            self.requiresRecreation = requiresRecreation
        }
    }

}

extension ScanProvisionedProductsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accessLevelFilter = self.accessLevelFilter {
            try encodeContainer.encode(accessLevelFilter, forKey: .accessLevelFilter)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

extension ScanProvisionedProductsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ScanProvisionedProductsInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The access level to use to obtain results. The default is User.
    public var accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct ScanProvisionedProductsInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
}

extension ScanProvisionedProductsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let accessLevelFilterDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.AccessLevelFilter.self, forKey: .accessLevelFilter)
        accessLevelFilter = accessLevelFilterDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ScanProvisionedProductsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ScanProvisionedProductsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.provisionedProducts = output.provisionedProducts
        } else {
            self.nextPageToken = nil
            self.provisionedProducts = nil
        }
    }
}

public struct ScanProvisionedProductsOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the provisioned products.
    public var provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProducts = provisionedProducts
    }
}

struct ScanProvisionedProductsOutputBody: Swift.Equatable {
    let provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductDetail]?
    let nextPageToken: Swift.String?
}

extension ScanProvisionedProductsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case provisionedProducts = "ProvisionedProducts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisionedProductDetail?].self, forKey: .provisionedProducts)
        var provisionedProductsDecoded0:[ServiceCatalogClientTypes.ProvisionedProductDetail]? = nil
        if let provisionedProductsContainer = provisionedProductsContainer {
            provisionedProductsDecoded0 = [ServiceCatalogClientTypes.ProvisionedProductDetail]()
            for structure0 in provisionedProductsContainer {
                if let structure0 = structure0 {
                    provisionedProductsDecoded0?.append(structure0)
                }
            }
        }
        provisionedProducts = provisionedProductsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ScanProvisionedProductsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchProductsAsAdminInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case productSource = "ProductSource"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, productViewFilters0) in filters {
                var productViewFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for productviewfiltervalue1 in productViewFilters0 {
                    try productViewFilters0Container.encode(productviewfiltervalue1)
                }
            }
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productSource = self.productSource {
            try encodeContainer.encode(productSource.rawValue, forKey: .productSource)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension SearchProductsAsAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchProductsAsAdminInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The search filters. If no search filters are specified, the output includes all products to which the administrator has access.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier.
    public var portfolioId: Swift.String?
    /// Access level of the source of the product.
    public var productSource: ServiceCatalogClientTypes.ProductSource?
    /// The sort field. If no value is specified, the results are not sorted.
    public var sortBy: ServiceCatalogClientTypes.ProductViewSortBy?
    /// The sort order. If no value is specified, the results are not sorted.
    public var sortOrder: ServiceCatalogClientTypes.SortOrder?

    public init(
        acceptLanguage: Swift.String? = nil,
        filters: [Swift.String:[Swift.String]]? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productSource: ServiceCatalogClientTypes.ProductSource? = nil,
        sortBy: ServiceCatalogClientTypes.ProductViewSortBy? = nil,
        sortOrder: ServiceCatalogClientTypes.SortOrder? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
        self.productSource = productSource
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct SearchProductsAsAdminInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let filters: [Swift.String:[Swift.String]]?
    let sortBy: ServiceCatalogClientTypes.ProductViewSortBy?
    let sortOrder: ServiceCatalogClientTypes.SortOrder?
    let pageToken: Swift.String?
    let pageSize: Swift.Int?
    let productSource: ServiceCatalogClientTypes.ProductSource?
}

extension SearchProductsAsAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case productSource = "ProductSource"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, productviewfiltervalues0) in filtersContainer {
                var productviewfiltervalues0Decoded0: [Swift.String]? = nil
                if let productviewfiltervalues0 = productviewfiltervalues0 {
                    productviewfiltervalues0Decoded0 = [Swift.String]()
                    for string1 in productviewfiltervalues0 {
                        if let string1 = string1 {
                            productviewfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = productviewfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let productSourceDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductSource.self, forKey: .productSource)
        productSource = productSourceDecoded
    }
}

extension SearchProductsAsAdminOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchProductsAsAdminOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.productViewDetails = output.productViewDetails
        } else {
            self.nextPageToken = nil
            self.productViewDetails = nil
        }
    }
}

public struct SearchProductsAsAdminOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the product views.
    public var productViewDetails: [ServiceCatalogClientTypes.ProductViewDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        productViewDetails: [ServiceCatalogClientTypes.ProductViewDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.productViewDetails = productViewDetails
    }
}

struct SearchProductsAsAdminOutputBody: Swift.Equatable {
    let productViewDetails: [ServiceCatalogClientTypes.ProductViewDetail]?
    let nextPageToken: Swift.String?
}

extension SearchProductsAsAdminOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case productViewDetails = "ProductViewDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProductViewDetail?].self, forKey: .productViewDetails)
        var productViewDetailsDecoded0:[ServiceCatalogClientTypes.ProductViewDetail]? = nil
        if let productViewDetailsContainer = productViewDetailsContainer {
            productViewDetailsDecoded0 = [ServiceCatalogClientTypes.ProductViewDetail]()
            for structure0 in productViewDetailsContainer {
                if let structure0 = structure0 {
                    productViewDetailsDecoded0?.append(structure0)
                }
            }
        }
        productViewDetails = productViewDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum SearchProductsAsAdminOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchProductsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, productViewFilters0) in filters {
                var productViewFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for productviewfiltervalue1 in productViewFilters0 {
                    try productViewFilters0Container.encode(productviewfiltervalue1)
                }
            }
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension SearchProductsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchProductsInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The search filters. If no search filters are specified, the output includes all products to which the caller has access.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The sort field. If no value is specified, the results are not sorted.
    public var sortBy: ServiceCatalogClientTypes.ProductViewSortBy?
    /// The sort order. If no value is specified, the results are not sorted.
    public var sortOrder: ServiceCatalogClientTypes.SortOrder?

    public init(
        acceptLanguage: Swift.String? = nil,
        filters: [Swift.String:[Swift.String]]? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        sortBy: ServiceCatalogClientTypes.ProductViewSortBy? = nil,
        sortOrder: ServiceCatalogClientTypes.SortOrder? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct SearchProductsInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let filters: [Swift.String:[Swift.String]]?
    let pageSize: Swift.Int?
    let sortBy: ServiceCatalogClientTypes.ProductViewSortBy?
    let sortOrder: ServiceCatalogClientTypes.SortOrder?
    let pageToken: Swift.String?
}

extension SearchProductsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, productviewfiltervalues0) in filtersContainer {
                var productviewfiltervalues0Decoded0: [Swift.String]? = nil
                if let productviewfiltervalues0 = productviewfiltervalues0 {
                    productviewfiltervalues0Decoded0 = [Swift.String]()
                    for string1 in productviewfiltervalues0 {
                        if let string1 = string1 {
                            productviewfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = productviewfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension SearchProductsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchProductsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.productViewAggregations = output.productViewAggregations
            self.productViewSummaries = output.productViewSummaries
        } else {
            self.nextPageToken = nil
            self.productViewAggregations = nil
            self.productViewSummaries = nil
        }
    }
}

public struct SearchProductsOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// The product view aggregations.
    public var productViewAggregations: [Swift.String:[ServiceCatalogClientTypes.ProductViewAggregationValue]]?
    /// Information about the product views.
    public var productViewSummaries: [ServiceCatalogClientTypes.ProductViewSummary]?

    public init(
        nextPageToken: Swift.String? = nil,
        productViewAggregations: [Swift.String:[ServiceCatalogClientTypes.ProductViewAggregationValue]]? = nil,
        productViewSummaries: [ServiceCatalogClientTypes.ProductViewSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.productViewAggregations = productViewAggregations
        self.productViewSummaries = productViewSummaries
    }
}

struct SearchProductsOutputBody: Swift.Equatable {
    let productViewSummaries: [ServiceCatalogClientTypes.ProductViewSummary]?
    let productViewAggregations: [Swift.String:[ServiceCatalogClientTypes.ProductViewAggregationValue]]?
    let nextPageToken: Swift.String?
}

extension SearchProductsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case productViewAggregations = "ProductViewAggregations"
        case productViewSummaries = "ProductViewSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProductViewSummary?].self, forKey: .productViewSummaries)
        var productViewSummariesDecoded0:[ServiceCatalogClientTypes.ProductViewSummary]? = nil
        if let productViewSummariesContainer = productViewSummariesContainer {
            productViewSummariesDecoded0 = [ServiceCatalogClientTypes.ProductViewSummary]()
            for structure0 in productViewSummariesContainer {
                if let structure0 = structure0 {
                    productViewSummariesDecoded0?.append(structure0)
                }
            }
        }
        productViewSummaries = productViewSummariesDecoded0
        let productViewAggregationsContainer = try containerValues.decodeIfPresent([Swift.String: [ServiceCatalogClientTypes.ProductViewAggregationValue?]?].self, forKey: .productViewAggregations)
        var productViewAggregationsDecoded0: [Swift.String:[ServiceCatalogClientTypes.ProductViewAggregationValue]]? = nil
        if let productViewAggregationsContainer = productViewAggregationsContainer {
            productViewAggregationsDecoded0 = [Swift.String:[ServiceCatalogClientTypes.ProductViewAggregationValue]]()
            for (key0, productviewaggregationvalues0) in productViewAggregationsContainer {
                var productviewaggregationvalues0Decoded0: [ServiceCatalogClientTypes.ProductViewAggregationValue]? = nil
                if let productviewaggregationvalues0 = productviewaggregationvalues0 {
                    productviewaggregationvalues0Decoded0 = [ServiceCatalogClientTypes.ProductViewAggregationValue]()
                    for structure1 in productviewaggregationvalues0 {
                        if let structure1 = structure1 {
                            productviewaggregationvalues0Decoded0?.append(structure1)
                        }
                    }
                }
                productViewAggregationsDecoded0?[key0] = productviewaggregationvalues0Decoded0
            }
        }
        productViewAggregations = productViewAggregationsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum SearchProductsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchProvisionedProductsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accessLevelFilter = self.accessLevelFilter {
            try encodeContainer.encode(accessLevelFilter, forKey: .accessLevelFilter)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, provisionedProductFilters0) in filters {
                var provisionedProductFilters0Container = filtersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for provisionedproductviewfiltervalue1 in provisionedProductFilters0 {
                    try provisionedProductFilters0Container.encode(provisionedproductviewfiltervalue1)
                }
            }
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = self.pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension SearchProvisionedProductsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchProvisionedProductsInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The access level to use to obtain results. The default is User.
    public var accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    /// The search filters. When the key is SearchQuery, the searchable fields are arn, createdTime, id, lastRecordId, idempotencyToken, name, physicalId, productId, provisioningArtifactId, type, status, tags, userArn, userArnSession, lastProvisioningRecordId, lastSuccessfulProvisioningRecordId, productName, and provisioningArtifactName. Example: "SearchQuery":["status:AVAILABLE"]
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The sort field. If no value is specified, the results are not sorted. The valid values are arn, id, name, and lastRecordId.
    public var sortBy: Swift.String?
    /// The sort order. If no value is specified, the results are not sorted.
    public var sortOrder: ServiceCatalogClientTypes.SortOrder?

    public init(
        acceptLanguage: Swift.String? = nil,
        accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter? = nil,
        filters: [Swift.String:[Swift.String]]? = nil,
        pageSize: Swift.Int? = nil,
        pageToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: ServiceCatalogClientTypes.SortOrder? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct SearchProvisionedProductsInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    let filters: [Swift.String:[Swift.String]]?
    let sortBy: Swift.String?
    let sortOrder: ServiceCatalogClientTypes.SortOrder?
    let pageSize: Swift.Int?
    let pageToken: Swift.String?
}

extension SearchProvisionedProductsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let accessLevelFilterDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.AccessLevelFilter.self, forKey: .accessLevelFilter)
        accessLevelFilter = accessLevelFilterDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, provisionedproductviewfiltervalues0) in filtersContainer {
                var provisionedproductviewfiltervalues0Decoded0: [Swift.String]? = nil
                if let provisionedproductviewfiltervalues0 = provisionedproductviewfiltervalues0 {
                    provisionedproductviewfiltervalues0Decoded0 = [Swift.String]()
                    for string1 in provisionedproductviewfiltervalues0 {
                        if let string1 = string1 {
                            provisionedproductviewfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = provisionedproductviewfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension SearchProvisionedProductsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchProvisionedProductsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.provisionedProducts = output.provisionedProducts
            self.totalResultsCount = output.totalResultsCount
        } else {
            self.nextPageToken = nil
            self.provisionedProducts = nil
            self.totalResultsCount = 0
        }
    }
}

public struct SearchProvisionedProductsOutput: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the provisioned products.
    public var provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductAttribute]?
    /// The number of provisioned products found.
    public var totalResultsCount: Swift.Int

    public init(
        nextPageToken: Swift.String? = nil,
        provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductAttribute]? = nil,
        totalResultsCount: Swift.Int = 0
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProducts = provisionedProducts
        self.totalResultsCount = totalResultsCount
    }
}

struct SearchProvisionedProductsOutputBody: Swift.Equatable {
    let provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductAttribute]?
    let totalResultsCount: Swift.Int
    let nextPageToken: Swift.String?
}

extension SearchProvisionedProductsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case provisionedProducts = "ProvisionedProducts"
        case totalResultsCount = "TotalResultsCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisionedProductAttribute?].self, forKey: .provisionedProducts)
        var provisionedProductsDecoded0:[ServiceCatalogClientTypes.ProvisionedProductAttribute]? = nil
        if let provisionedProductsContainer = provisionedProductsContainer {
            provisionedProductsDecoded0 = [ServiceCatalogClientTypes.ProvisionedProductAttribute]()
            for structure0 in provisionedProductsContainer {
                if let structure0 = structure0 {
                    provisionedProductsDecoded0?.append(structure0)
                }
            }
        }
        provisionedProducts = provisionedProductsDecoded0
        let totalResultsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResultsCount) ?? 0
        totalResultsCount = totalResultsCountDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum SearchProvisionedProductsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes.ServiceActionAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let serviceActionId = self.serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// A self-service action association consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.
    public struct ServiceActionAssociation: Swift.Equatable {
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        /// This member is required.
        public var productId: Swift.String?
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        /// This member is required.
        public var provisioningArtifactId: Swift.String?
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        /// This member is required.
        public var serviceActionId: Swift.String?

        public init(
            productId: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            serviceActionId: Swift.String? = nil
        )
        {
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.serviceActionId = serviceActionId
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ServiceActionAssociationErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case duplicateresourceexception
        case internalfailure
        case invalidparameterexception
        case limitexceededexception
        case resourcenotfoundexception
        case throttlingexception
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceActionAssociationErrorCode] {
            return [
                .duplicateresourceexception,
                .internalfailure,
                .invalidparameterexception,
                .limitexceededexception,
                .resourcenotfoundexception,
                .throttlingexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .duplicateresourceexception: return "DUPLICATE_RESOURCE"
            case .internalfailure: return "INTERNAL_FAILURE"
            case .invalidparameterexception: return "INVALID_PARAMETER"
            case .limitexceededexception: return "LIMIT_EXCEEDED"
            case .resourcenotfoundexception: return "RESOURCE_NOT_FOUND"
            case .throttlingexception: return "THROTTLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceActionAssociationErrorCode(rawValue: rawValue) ?? ServiceActionAssociationErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ServiceActionDefinitionKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assumerole
        case name
        case parameters
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceActionDefinitionKey] {
            return [
                .assumerole,
                .name,
                .parameters,
                .version,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assumerole: return "AssumeRole"
            case .name: return "Name"
            case .parameters: return "Parameters"
            case .version: return "Version"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceActionDefinitionKey(rawValue: rawValue) ?? ServiceActionDefinitionKey.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ServiceActionDefinitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssmautomation
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceActionDefinitionType] {
            return [
                .ssmautomation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssmautomation: return "SSM_AUTOMATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceActionDefinitionType(rawValue: rawValue) ?? ServiceActionDefinitionType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ServiceActionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case serviceActionSummary = "ServiceActionSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .definition)
            for (dictKey0, serviceActionDefinitionMap0) in definition {
                try definitionContainer.encode(serviceActionDefinitionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let serviceActionSummary = self.serviceActionSummary {
            try encodeContainer.encode(serviceActionSummary, forKey: .serviceActionSummary)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionSummaryDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionSummary.self, forKey: .serviceActionSummary)
        serviceActionSummary = serviceActionSummaryDecoded
        let definitionContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .definition)
        var definitionDecoded0: [Swift.String:Swift.String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [Swift.String:Swift.String]()
            for (key0, serviceactiondefinitionvalue0) in definitionContainer {
                if let serviceactiondefinitionvalue0 = serviceactiondefinitionvalue0 {
                    definitionDecoded0?[key0] = serviceactiondefinitionvalue0
                }
            }
        }
        definition = definitionDecoded0
    }
}

extension ServiceCatalogClientTypes {
    /// An object containing detailed information about the self-service action.
    public struct ServiceActionDetail: Swift.Equatable {
        /// A map that defines the self-service action.
        public var definition: [Swift.String:Swift.String]?
        /// Summary information about the self-service action.
        public var serviceActionSummary: ServiceCatalogClientTypes.ServiceActionSummary?

        public init(
            definition: [Swift.String:Swift.String]? = nil,
            serviceActionSummary: ServiceCatalogClientTypes.ServiceActionSummary? = nil
        )
        {
            self.definition = definition
            self.serviceActionSummary = serviceActionSummary
        }
    }

}

extension ServiceCatalogClientTypes.ServiceActionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitionType = "DefinitionType"
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definitionType = self.definitionType {
            try encodeContainer.encode(definitionType.rawValue, forKey: .definitionType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let definitionTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionDefinitionType.self, forKey: .definitionType)
        definitionType = definitionTypeDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Detailed information about the self-service action.
    public struct ServiceActionSummary: Swift.Equatable {
        /// The self-service action definition type. For example, SSM_AUTOMATION.
        public var definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType?
        /// The self-service action description.
        public var description: Swift.String?
        /// The self-service action identifier.
        public var id: Swift.String?
        /// The self-service action name.
        public var name: Swift.String?

        public init(
            definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.definitionType = definitionType
            self.description = description
            self.id = id
            self.name = name
        }
    }

}

extension ServiceCatalogClientTypes.ShareDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareErrors = "ShareErrors"
        case successfulShares = "SuccessfulShares"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareErrors = shareErrors {
            var shareErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shareErrors)
            for shareerror0 in shareErrors {
                try shareErrorsContainer.encode(shareerror0)
            }
        }
        if let successfulShares = successfulShares {
            var successfulSharesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .successfulShares)
            for accountid0 in successfulShares {
                try successfulSharesContainer.encode(accountid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulSharesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .successfulShares)
        var successfulSharesDecoded0:[Swift.String]? = nil
        if let successfulSharesContainer = successfulSharesContainer {
            successfulSharesDecoded0 = [Swift.String]()
            for string0 in successfulSharesContainer {
                if let string0 = string0 {
                    successfulSharesDecoded0?.append(string0)
                }
            }
        }
        successfulShares = successfulSharesDecoded0
        let shareErrorsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ShareError?].self, forKey: .shareErrors)
        var shareErrorsDecoded0:[ServiceCatalogClientTypes.ShareError]? = nil
        if let shareErrorsContainer = shareErrorsContainer {
            shareErrorsDecoded0 = [ServiceCatalogClientTypes.ShareError]()
            for structure0 in shareErrorsContainer {
                if let structure0 = structure0 {
                    shareErrorsDecoded0?.append(structure0)
                }
            }
        }
        shareErrors = shareErrorsDecoded0
    }
}

extension ServiceCatalogClientTypes {
    /// Information about the portfolio share operation.
    public struct ShareDetails: Swift.Equatable {
        /// List of errors.
        public var shareErrors: [ServiceCatalogClientTypes.ShareError]?
        /// List of accounts for whom the operation succeeded.
        public var successfulShares: [Swift.String]?

        public init(
            shareErrors: [ServiceCatalogClientTypes.ShareError]? = nil,
            successfulShares: [Swift.String]? = nil
        )
        {
            self.shareErrors = shareErrors
            self.successfulShares = successfulShares
        }
    }

}

extension ServiceCatalogClientTypes.ShareError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "Accounts"
        case error = "Error"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for accountid0 in accounts {
                try accountsContainer.encode(accountid0)
            }
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accounts)
        var accountsDecoded0:[Swift.String]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Swift.String]()
            for string0 in accountsContainer {
                if let string0 = string0 {
                    accountsDecoded0?.append(string0)
                }
            }
        }
        accounts = accountsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Errors that occurred during the portfolio share operation.
    public struct ShareError: Swift.Equatable {
        /// List of accounts impacted by the error.
        public var accounts: [Swift.String]?
        /// Error type that happened when processing the operation.
        public var error: Swift.String?
        /// Information about the error.
        public var message: Swift.String?

        public init(
            accounts: [Swift.String]? = nil,
            error: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.accounts = accounts
            self.error = error
            self.message = message
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithErrors
        case error
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .completed,
                .completedWithErrors,
                .error,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.SourceConnection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionParameters = "ConnectionParameters"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionParameters = self.connectionParameters {
            try encodeContainer.encode(connectionParameters, forKey: .connectionParameters)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SourceType.self, forKey: .type)
        type = typeDecoded
        let connectionParametersDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SourceConnectionParameters.self, forKey: .connectionParameters)
        connectionParameters = connectionParametersDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// A top level ProductViewDetail response containing details about the products connection. Service Catalog returns this field for the CreateProduct, UpdateProduct, DescribeProductAsAdmin, and SearchProductAsAdmin APIs. This response contains the same fields as the ConnectionParameters request, with the addition of the LastSync response.
    public struct SourceConnection: Swift.Equatable {
        /// The connection details based on the connection Type.
        /// This member is required.
        public var connectionParameters: ServiceCatalogClientTypes.SourceConnectionParameters?
        /// The only supported SourceConnection type is Codestar.
        public var type: ServiceCatalogClientTypes.SourceType?

        public init(
            connectionParameters: ServiceCatalogClientTypes.SourceConnectionParameters? = nil,
            type: ServiceCatalogClientTypes.SourceType? = nil
        )
        {
            self.connectionParameters = connectionParameters
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes.SourceConnectionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionParameters = "ConnectionParameters"
        case lastSync = "LastSync"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionParameters = self.connectionParameters {
            try encodeContainer.encode(connectionParameters, forKey: .connectionParameters)
        }
        if let lastSync = self.lastSync {
            try encodeContainer.encode(lastSync, forKey: .lastSync)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SourceType.self, forKey: .type)
        type = typeDecoded
        let connectionParametersDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SourceConnectionParameters.self, forKey: .connectionParameters)
        connectionParameters = connectionParametersDecoded
        let lastSyncDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.LastSync.self, forKey: .lastSync)
        lastSync = lastSyncDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Provides details about the configured SourceConnection.
    public struct SourceConnectionDetail: Swift.Equatable {
        /// The connection details based on the connection Type.
        public var connectionParameters: ServiceCatalogClientTypes.SourceConnectionParameters?
        /// Provides details about the product's connection sync and contains the following sub-fields.
        ///
        /// * LastSyncTime
        ///
        /// * LastSyncStatus
        ///
        /// * LastSyncStatusMessage
        ///
        /// * LastSuccessfulSyncTime
        ///
        /// * LastSuccessfulSyncProvisioningArtifactID
        public var lastSync: ServiceCatalogClientTypes.LastSync?
        /// The only supported SourceConnection type is Codestar.
        public var type: ServiceCatalogClientTypes.SourceType?

        public init(
            connectionParameters: ServiceCatalogClientTypes.SourceConnectionParameters? = nil,
            lastSync: ServiceCatalogClientTypes.LastSync? = nil,
            type: ServiceCatalogClientTypes.SourceType? = nil
        )
        {
            self.connectionParameters = connectionParameters
            self.lastSync = lastSync
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes.SourceConnectionParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeStar = "CodeStar"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeStar = self.codeStar {
            try encodeContainer.encode(codeStar, forKey: .codeStar)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeStarDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.CodeStarParameters.self, forKey: .codeStar)
        codeStar = codeStarDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Provides connection details.
    public struct SourceConnectionParameters: Swift.Equatable {
        /// Provides ConnectionType details.
        public var codeStar: ServiceCatalogClientTypes.CodeStarParameters?

        public init(
            codeStar: ServiceCatalogClientTypes.CodeStarParameters? = nil
        )
        {
            self.codeStar = codeStar
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case codestar
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .codestar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .codestar: return "CODESTAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.StackInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case region = "Region"
        case stackInstanceStatus = "StackInstanceStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = self.account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stackInstanceStatus = self.stackInstanceStatus {
            try encodeContainer.encode(stackInstanceStatus.rawValue, forKey: .stackInstanceStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let stackInstanceStatusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.StackInstanceStatus.self, forKey: .stackInstanceStatus)
        stackInstanceStatus = stackInstanceStatusDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// An CloudFormation stack, in a specific account and Region, that's part of a stack set operation. A stack instance is a reference to an attempted or actual stack in a given account within a given Region. A stack instance can exist without a stackfor example, if the stack couldn't be created for some reason. A stack instance is associated with only one stack set. Each stack instance contains the ID of its associated stack set, as well as the ID of the actual stack and the stack status.
    public struct StackInstance: Swift.Equatable {
        /// The name of the Amazon Web Services account that the stack instance is associated with.
        public var account: Swift.String?
        /// The name of the Amazon Web Services Region that the stack instance is associated with.
        public var region: Swift.String?
        /// The status of the stack instance, in terms of its synchronization with its associated stack set.
        ///
        /// * INOPERABLE: A DeleteStackInstances operation has failed and left the stack in an unstable state. Stacks in this state are excluded from further UpdateStackSet operations. You might need to perform a DeleteStackInstances operation, with RetainStacks set to true, to delete the stack instance, and then delete the stack manually.
        ///
        /// * OUTDATED: The stack isn't currently up to date with the stack set because either the associated stack failed during a CreateStackSet or UpdateStackSet operation, or the stack was part of a CreateStackSet or UpdateStackSet operation that failed or was stopped before the stack was created or updated.
        ///
        /// * CURRENT: The stack is currently up to date with the stack set.
        public var stackInstanceStatus: ServiceCatalogClientTypes.StackInstanceStatus?

        public init(
            account: Swift.String? = nil,
            region: Swift.String? = nil,
            stackInstanceStatus: ServiceCatalogClientTypes.StackInstanceStatus? = nil
        )
        {
            self.account = account
            self.region = region
            self.stackInstanceStatus = stackInstanceStatus
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum StackInstanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case current
        case inoperable
        case outdated
        case sdkUnknown(Swift.String)

        public static var allCases: [StackInstanceStatus] {
            return [
                .current,
                .inoperable,
                .outdated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .current: return "CURRENT"
            case .inoperable: return "INOPERABLE"
            case .outdated: return "OUTDATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StackInstanceStatus(rawValue: rawValue) ?? StackInstanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum StackSetOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [StackSetOperationType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StackSetOperationType(rawValue: rawValue) ?? StackSetOperationType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .available,
                .creating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a tag. A tag is a key-value pair. Tags are propagated to the resources created when provisioning a product.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The value for this key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ServiceCatalogClientTypes.TagOptionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case id = "Id"
        case key = "Key"
        case owner = "Owner"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Information about a TagOption.
    public struct TagOptionDetail: Swift.Equatable {
        /// The TagOption active state.
        public var active: Swift.Bool?
        /// The TagOption identifier.
        public var id: Swift.String?
        /// The TagOption key.
        public var key: Swift.String?
        /// The Amazon Web Services account Id of the owner account that created the TagOption.
        public var owner: Swift.String?
        /// The TagOption value.
        public var value: Swift.String?

        public init(
            active: Swift.Bool? = nil,
            id: Swift.String? = nil,
            key: Swift.String? = nil,
            owner: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.active = active
            self.id = id
            self.key = key
            self.owner = owner
            self.value = value
        }
    }

}

extension TagOptionNotMigratedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagOptionNotMigratedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An operation requiring TagOptions failed because the TagOptions migration process has not been performed for this account. Use the Amazon Web Services Management Console to perform the migration process before retrying the operation.
public struct TagOptionNotMigratedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagOptionNotMigratedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagOptionNotMigratedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagOptionNotMigratedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceCatalogClientTypes.TagOptionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for tagoptionvalue0 in values {
                try valuesContainer.encode(tagoptionvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ServiceCatalogClientTypes {
    /// Summary information about a TagOption.
    public struct TagOptionSummary: Swift.Equatable {
        /// The TagOption key.
        public var key: Swift.String?
        /// The TagOption value.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension TerminateProvisionedProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case ignoreErrors = "IgnoreErrors"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case retainPhysicalResources = "RetainPhysicalResources"
        case terminateToken = "TerminateToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let ignoreErrors = self.ignoreErrors {
            try encodeContainer.encode(ignoreErrors, forKey: .ignoreErrors)
        }
        if let provisionedProductId = self.provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductName = self.provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let retainPhysicalResources = self.retainPhysicalResources {
            try encodeContainer.encode(retainPhysicalResources, forKey: .retainPhysicalResources)
        }
        if let terminateToken = self.terminateToken {
            try encodeContainer.encode(terminateToken, forKey: .terminateToken)
        }
    }
}

extension TerminateProvisionedProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TerminateProvisionedProductInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// If set to true, Service Catalog stops managing the specified provisioned product even if it cannot delete the underlying resources.
    public var ignoreErrors: Swift.Bool?
    /// The identifier of the provisioned product. You cannot specify both ProvisionedProductName and ProvisionedProductId.
    public var provisionedProductId: Swift.String?
    /// The name of the provisioned product. You cannot specify both ProvisionedProductName and ProvisionedProductId.
    public var provisionedProductName: Swift.String?
    /// When this boolean parameter is set to true, the TerminateProvisionedProduct API deletes the Service Catalog provisioned product. However, it does not remove the CloudFormation stack, stack set, or the underlying resources of the deleted provisioned product. The default value is false.
    public var retainPhysicalResources: Swift.Bool?
    /// An idempotency token that uniquely identifies the termination request. This token is only valid during the termination process. After the provisioned product is terminated, subsequent requests to terminate the same provisioned product always return ResourceNotFound.
    /// This member is required.
    public var terminateToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        ignoreErrors: Swift.Bool? = nil,
        provisionedProductId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        retainPhysicalResources: Swift.Bool? = nil,
        terminateToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.ignoreErrors = ignoreErrors
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
        self.retainPhysicalResources = retainPhysicalResources
        self.terminateToken = terminateToken
    }
}

struct TerminateProvisionedProductInputBody: Swift.Equatable {
    let provisionedProductName: Swift.String?
    let provisionedProductId: Swift.String?
    let terminateToken: Swift.String?
    let ignoreErrors: Swift.Bool?
    let acceptLanguage: Swift.String?
    let retainPhysicalResources: Swift.Bool?
}

extension TerminateProvisionedProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case ignoreErrors = "IgnoreErrors"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case retainPhysicalResources = "RetainPhysicalResources"
        case terminateToken = "TerminateToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let terminateTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .terminateToken)
        terminateToken = terminateTokenDecoded
        let ignoreErrorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignoreErrors)
        ignoreErrors = ignoreErrorsDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let retainPhysicalResourcesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retainPhysicalResources)
        retainPhysicalResources = retainPhysicalResourcesDecoded
    }
}

extension TerminateProvisionedProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TerminateProvisionedProductOutputBody = try responseDecoder.decode(responseBody: data)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct TerminateProvisionedProductOutput: Swift.Equatable {
    /// Information about the result of this request.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init(
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct TerminateProvisionedProductOutputBody: Swift.Equatable {
    let recordDetail: ServiceCatalogClientTypes.RecordDetail?
}

extension TerminateProvisionedProductOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

enum TerminateProvisionedProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes.UniqueTagResourceIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// The unique key-value pair for a tag that identifies provisioned product resources.
    public struct UniqueTagResourceIdentifier: Swift.Equatable {
        /// A unique key that's attached to a resource.
        public var key: Swift.String?
        /// A unique value that's attached to a resource.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension UpdateConstraintInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case id = "Id"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
    }
}

extension UpdateConstraintInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateConstraintInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The updated description of the constraint.
    public var description: Swift.String?
    /// The identifier of the constraint.
    /// This member is required.
    public var id: Swift.String?
    /// The constraint parameters, in JSON format. The syntax depends on the constraint type as follows: LAUNCH You are required to specify either the RoleArn or the LocalRoleName but can't use both. Specify the RoleArn property as follows: {"RoleArn" : "arn:aws:iam::123456789012:role/LaunchRole"} Specify the LocalRoleName property as follows: {"LocalRoleName": "SCBasicLaunchRole"} If you specify the LocalRoleName property, when an account uses the launch constraint, the IAM role with that name in the account will be used. This allows launch-role constraints to be account-agnostic so the administrator can create fewer resources per shared account. The given role name must exist in the account used to create the launch constraint and the account of the user who launches a product with this launch constraint. You cannot have both a LAUNCH and a STACKSET constraint. You also cannot have more than one LAUNCH constraint on a product and portfolio. NOTIFICATION Specify the NotificationArns property as follows: {"NotificationArns" : ["arn:aws:sns:us-east-1:123456789012:Topic"]} RESOURCE_UPDATE Specify the TagUpdatesOnProvisionedProduct property as follows: {"Version":"2.0","Properties":{"TagUpdateOnProvisionedProduct":"String"}} The TagUpdatesOnProvisionedProduct property accepts a string value of ALLOWED or NOT_ALLOWED. STACKSET Specify the Parameters property as follows: {"Version": "String", "Properties": {"AccountList": [ "String" ], "RegionList": [ "String" ], "AdminRole": "String", "ExecutionRole": "String"}} You cannot have both a LAUNCH and a STACKSET constraint. You also cannot have more than one STACKSET constraint on a product and portfolio. Products with a STACKSET constraint will launch an CloudFormation stack set. TEMPLATE Specify the Rules property. For more information, see [Template Constraint Rules](http://docs.aws.amazon.com/servicecatalog/latest/adminguide/reference-template_constraint_rules.html).
    public var parameters: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        parameters: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.id = id
        self.parameters = parameters
    }
}

struct UpdateConstraintInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
    let description: Swift.String?
    let parameters: Swift.String?
}

extension UpdateConstraintInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case id = "Id"
        case parameters = "Parameters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension UpdateConstraintOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConstraintOutputBody = try responseDecoder.decode(responseBody: data)
            self.constraintDetail = output.constraintDetail
            self.constraintParameters = output.constraintParameters
            self.status = output.status
        } else {
            self.constraintDetail = nil
            self.constraintParameters = nil
            self.status = nil
        }
    }
}

public struct UpdateConstraintOutput: Swift.Equatable {
    /// Information about the constraint.
    public var constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    /// The constraint parameters.
    public var constraintParameters: Swift.String?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init(
        constraintDetail: ServiceCatalogClientTypes.ConstraintDetail? = nil,
        constraintParameters: Swift.String? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.constraintDetail = constraintDetail
        self.constraintParameters = constraintParameters
        self.status = status
    }
}

struct UpdateConstraintOutputBody: Swift.Equatable {
    let constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    let constraintParameters: Swift.String?
    let status: ServiceCatalogClientTypes.Status?
}

extension UpdateConstraintOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintDetail = "ConstraintDetail"
        case constraintParameters = "ConstraintParameters"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ConstraintDetail.self, forKey: .constraintDetail)
        constraintDetail = constraintDetailDecoded
        let constraintParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraintParameters)
        constraintParameters = constraintParametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdateConstraintOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePortfolioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case addTags = "AddTags"
        case description = "Description"
        case displayName = "DisplayName"
        case id = "Id"
        case providerName = "ProviderName"
        case removeTags = "RemoveTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let addTags = addTags {
            var addTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addTags)
            for tag0 in addTags {
                try addTagsContainer.encode(tag0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let removeTags = removeTags {
            var removeTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeTags)
            for tagkey0 in removeTags {
                try removeTagsContainer.encode(tagkey0)
            }
        }
    }
}

extension UpdatePortfolioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The tags to add.
    public var addTags: [ServiceCatalogClientTypes.Tag]?
    /// The updated description of the portfolio.
    public var description: Swift.String?
    /// The name to use for display purposes.
    public var displayName: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The updated name of the portfolio provider.
    public var providerName: Swift.String?
    /// The tags to remove.
    public var removeTags: [Swift.String]?

    public init(
        acceptLanguage: Swift.String? = nil,
        addTags: [ServiceCatalogClientTypes.Tag]? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        id: Swift.String? = nil,
        providerName: Swift.String? = nil,
        removeTags: [Swift.String]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.addTags = addTags
        self.description = description
        self.displayName = displayName
        self.id = id
        self.providerName = providerName
        self.removeTags = removeTags
    }
}

struct UpdatePortfolioInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let providerName: Swift.String?
    let addTags: [ServiceCatalogClientTypes.Tag]?
    let removeTags: [Swift.String]?
}

extension UpdatePortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case addTags = "AddTags"
        case description = "Description"
        case displayName = "DisplayName"
        case id = "Id"
        case providerName = "ProviderName"
        case removeTags = "RemoveTags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let addTagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .addTags)
        var addTagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let addTagsContainer = addTagsContainer {
            addTagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in addTagsContainer {
                if let structure0 = structure0 {
                    addTagsDecoded0?.append(structure0)
                }
            }
        }
        addTags = addTagsDecoded0
        let removeTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeTags)
        var removeTagsDecoded0:[Swift.String]? = nil
        if let removeTagsContainer = removeTagsContainer {
            removeTagsDecoded0 = [Swift.String]()
            for string0 in removeTagsContainer {
                if let string0 = string0 {
                    removeTagsDecoded0?.append(string0)
                }
            }
        }
        removeTags = removeTagsDecoded0
    }
}

extension UpdatePortfolioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePortfolioOutputBody = try responseDecoder.decode(responseBody: data)
            self.portfolioDetail = output.portfolioDetail
            self.tags = output.tags
        } else {
            self.portfolioDetail = nil
            self.tags = nil
        }
    }
}

public struct UpdatePortfolioOutput: Swift.Equatable {
    /// Information about the portfolio.
    public var portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    /// Information about the tags associated with the portfolio.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.portfolioDetail = portfolioDetail
        self.tags = tags
    }
}

struct UpdatePortfolioOutputBody: Swift.Equatable {
    let portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    let tags: [ServiceCatalogClientTypes.Tag]?
}

extension UpdatePortfolioOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioDetail = "PortfolioDetail"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PortfolioDetail.self, forKey: .portfolioDetail)
        portfolioDetail = portfolioDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdatePortfolioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePortfolioShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
        case sharePrincipals = "SharePrincipals"
        case shareTagOptions = "ShareTagOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let organizationNode = self.organizationNode {
            try encodeContainer.encode(organizationNode, forKey: .organizationNode)
        }
        if let portfolioId = self.portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let sharePrincipals = self.sharePrincipals {
            try encodeContainer.encode(sharePrincipals, forKey: .sharePrincipals)
        }
        if let shareTagOptions = self.shareTagOptions {
            try encodeContainer.encode(shareTagOptions, forKey: .shareTagOptions)
        }
    }
}

extension UpdatePortfolioShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePortfolioShareInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The Amazon Web Services account Id of the recipient account. This field is required when updating an external account to account type share.
    public var accountId: Swift.String?
    /// Information about the organization node.
    public var organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    /// The unique identifier of the portfolio for which the share will be updated.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// A flag to enables or disables Principals sharing in the portfolio. If this field is not provided, the current state of the Principals sharing on the portfolio share will not be modified.
    public var sharePrincipals: Swift.Bool?
    /// Enables or disables TagOptions sharing for the portfolio share. If this field is not provided, the current state of TagOptions sharing on the portfolio share will not be modified.
    public var shareTagOptions: Swift.Bool?

    public init(
        acceptLanguage: Swift.String? = nil,
        accountId: Swift.String? = nil,
        organizationNode: ServiceCatalogClientTypes.OrganizationNode? = nil,
        portfolioId: Swift.String? = nil,
        sharePrincipals: Swift.Bool? = nil,
        shareTagOptions: Swift.Bool? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accountId = accountId
        self.organizationNode = organizationNode
        self.portfolioId = portfolioId
        self.sharePrincipals = sharePrincipals
        self.shareTagOptions = shareTagOptions
    }
}

struct UpdatePortfolioShareInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let portfolioId: Swift.String?
    let accountId: Swift.String?
    let organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    let shareTagOptions: Swift.Bool?
    let sharePrincipals: Swift.Bool?
}

extension UpdatePortfolioShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
        case sharePrincipals = "SharePrincipals"
        case shareTagOptions = "ShareTagOptions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationNodeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.OrganizationNode.self, forKey: .organizationNode)
        organizationNode = organizationNodeDecoded
        let shareTagOptionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .shareTagOptions)
        shareTagOptions = shareTagOptionsDecoded
        let sharePrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharePrincipals)
        sharePrincipals = sharePrincipalsDecoded
    }
}

extension UpdatePortfolioShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePortfolioShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.portfolioShareToken = output.portfolioShareToken
            self.status = output.status
        } else {
            self.portfolioShareToken = nil
            self.status = nil
        }
    }
}

public struct UpdatePortfolioShareOutput: Swift.Equatable {
    /// The token that tracks the status of the UpdatePortfolioShare operation for external account to account or organizational type sharing.
    public var portfolioShareToken: Swift.String?
    /// The status of UpdatePortfolioShare operation. You can also obtain the operation status using DescribePortfolioShareStatus API.
    public var status: ServiceCatalogClientTypes.ShareStatus?

    public init(
        portfolioShareToken: Swift.String? = nil,
        status: ServiceCatalogClientTypes.ShareStatus? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
        self.status = status
    }
}

struct UpdatePortfolioShareOutputBody: Swift.Equatable {
    let portfolioShareToken: Swift.String?
    let status: ServiceCatalogClientTypes.ShareStatus?
}

extension UpdatePortfolioShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdatePortfolioShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case addTags = "AddTags"
        case description = "Description"
        case distributor = "Distributor"
        case id = "Id"
        case name = "Name"
        case owner = "Owner"
        case removeTags = "RemoveTags"
        case sourceConnection = "SourceConnection"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let addTags = addTags {
            var addTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addTags)
            for tag0 in addTags {
                try addTagsContainer.encode(tag0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributor = self.distributor {
            try encodeContainer.encode(distributor, forKey: .distributor)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let removeTags = removeTags {
            var removeTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeTags)
            for tagkey0 in removeTags {
                try removeTagsContainer.encode(tagkey0)
            }
        }
        if let sourceConnection = self.sourceConnection {
            try encodeContainer.encode(sourceConnection, forKey: .sourceConnection)
        }
        if let supportDescription = self.supportDescription {
            try encodeContainer.encode(supportDescription, forKey: .supportDescription)
        }
        if let supportEmail = self.supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportUrl = self.supportUrl {
            try encodeContainer.encode(supportUrl, forKey: .supportUrl)
        }
    }
}

extension UpdateProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProductInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The tags to add to the product.
    public var addTags: [ServiceCatalogClientTypes.Tag]?
    /// The updated description of the product.
    public var description: Swift.String?
    /// The updated distributor of the product.
    public var distributor: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The updated product name.
    public var name: Swift.String?
    /// The updated owner of the product.
    public var owner: Swift.String?
    /// The tags to remove from the product.
    public var removeTags: [Swift.String]?
    /// Specifies connection details for the updated product and syncs the product to the connection source artifact. This automatically manages the product's artifacts based on changes to the source. The SourceConnection parameter consists of the following sub-fields.
    ///
    /// * Type
    ///
    /// * ConnectionParamters
    public var sourceConnection: ServiceCatalogClientTypes.SourceConnection?
    /// The updated support description for the product.
    public var supportDescription: Swift.String?
    /// The updated support email for the product.
    public var supportEmail: Swift.String?
    /// The updated support URL for the product.
    public var supportUrl: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        addTags: [ServiceCatalogClientTypes.Tag]? = nil,
        description: Swift.String? = nil,
        distributor: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        removeTags: [Swift.String]? = nil,
        sourceConnection: ServiceCatalogClientTypes.SourceConnection? = nil,
        supportDescription: Swift.String? = nil,
        supportEmail: Swift.String? = nil,
        supportUrl: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.addTags = addTags
        self.description = description
        self.distributor = distributor
        self.id = id
        self.name = name
        self.owner = owner
        self.removeTags = removeTags
        self.sourceConnection = sourceConnection
        self.supportDescription = supportDescription
        self.supportEmail = supportEmail
        self.supportUrl = supportUrl
    }
}

struct UpdateProductInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let owner: Swift.String?
    let description: Swift.String?
    let distributor: Swift.String?
    let supportDescription: Swift.String?
    let supportEmail: Swift.String?
    let supportUrl: Swift.String?
    let addTags: [ServiceCatalogClientTypes.Tag]?
    let removeTags: [Swift.String]?
    let sourceConnection: ServiceCatalogClientTypes.SourceConnection?
}

extension UpdateProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case addTags = "AddTags"
        case description = "Description"
        case distributor = "Distributor"
        case id = "Id"
        case name = "Name"
        case owner = "Owner"
        case removeTags = "RemoveTags"
        case sourceConnection = "SourceConnection"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributor)
        distributor = distributorDecoded
        let supportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportDescription)
        supportDescription = supportDescriptionDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportUrl)
        supportUrl = supportUrlDecoded
        let addTagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .addTags)
        var addTagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let addTagsContainer = addTagsContainer {
            addTagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in addTagsContainer {
                if let structure0 = structure0 {
                    addTagsDecoded0?.append(structure0)
                }
            }
        }
        addTags = addTagsDecoded0
        let removeTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeTags)
        var removeTagsDecoded0:[Swift.String]? = nil
        if let removeTagsContainer = removeTagsContainer {
            removeTagsDecoded0 = [Swift.String]()
            for string0 in removeTagsContainer {
                if let string0 = string0 {
                    removeTagsDecoded0?.append(string0)
                }
            }
        }
        removeTags = removeTagsDecoded0
        let sourceConnectionDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SourceConnection.self, forKey: .sourceConnection)
        sourceConnection = sourceConnectionDecoded
    }
}

extension UpdateProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProductOutputBody = try responseDecoder.decode(responseBody: data)
            self.productViewDetail = output.productViewDetail
            self.tags = output.tags
        } else {
            self.productViewDetail = nil
            self.tags = nil
        }
    }
}

public struct UpdateProductOutput: Swift.Equatable {
    /// Information about the product view.
    public var productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    /// Information about the tags associated with the product.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        productViewDetail: ServiceCatalogClientTypes.ProductViewDetail? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.productViewDetail = productViewDetail
        self.tags = tags
    }
}

struct UpdateProductOutputBody: Swift.Equatable {
    let productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    let tags: [ServiceCatalogClientTypes.Tag]?
}

extension UpdateProductOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productViewDetail = "ProductViewDetail"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewDetail.self, forKey: .productViewDetail)
        productViewDetail = productViewDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProvisionedProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case provisioningParameters = "ProvisioningParameters"
        case provisioningPreferences = "ProvisioningPreferences"
        case tags = "Tags"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pathId = self.pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let pathName = self.pathName {
            try encodeContainer.encode(pathName, forKey: .pathName)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisionedProductId = self.provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductName = self.provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = self.provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
        if let provisioningParameters = provisioningParameters {
            var provisioningParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .provisioningParameters)
            for updateprovisioningparameter0 in provisioningParameters {
                try provisioningParametersContainer.encode(updateprovisioningparameter0)
            }
        }
        if let provisioningPreferences = self.provisioningPreferences {
            try encodeContainer.encode(provisioningPreferences, forKey: .provisioningPreferences)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let updateToken = self.updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }
}

extension UpdateProvisionedProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProvisionedProductInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The path identifier. This value is optional if the product has a default path, and required if the product has more than one path. You must provide the name or ID, but not both.
    public var pathId: Swift.String?
    /// The name of the path. You must provide the name or ID, but not both.
    public var pathName: Swift.String?
    /// The identifier of the product. You must provide the name or ID, but not both.
    public var productId: Swift.String?
    /// The name of the product. You must provide the name or ID, but not both.
    public var productName: Swift.String?
    /// The identifier of the provisioned product. You must provide the name or ID, but not both.
    public var provisionedProductId: Swift.String?
    /// The name of the provisioned product. You cannot specify both ProvisionedProductName and ProvisionedProductId.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact.
    public var provisioningArtifactId: Swift.String?
    /// The name of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactName: Swift.String?
    /// The new parameters.
    public var provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
    /// An object that contains information about the provisioning preferences for a stack set.
    public var provisioningPreferences: ServiceCatalogClientTypes.UpdateProvisioningPreferences?
    /// One or more tags. Requires the product to have RESOURCE_UPDATE constraint with TagUpdatesOnProvisionedProduct set to ALLOWED to allow tag updates.
    public var tags: [ServiceCatalogClientTypes.Tag]?
    /// The idempotency token that uniquely identifies the provisioning update request.
    /// This member is required.
    public var updateToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pathId: Swift.String? = nil,
        pathName: Swift.String? = nil,
        productId: Swift.String? = nil,
        productName: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningArtifactName: Swift.String? = nil,
        provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil,
        provisioningPreferences: ServiceCatalogClientTypes.UpdateProvisioningPreferences? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil,
        updateToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pathId = pathId
        self.pathName = pathName
        self.productId = productId
        self.productName = productName
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.provisioningParameters = provisioningParameters
        self.provisioningPreferences = provisioningPreferences
        self.tags = tags
        self.updateToken = updateToken
    }
}

struct UpdateProvisionedProductInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let provisionedProductName: Swift.String?
    let provisionedProductId: Swift.String?
    let productId: Swift.String?
    let productName: Swift.String?
    let provisioningArtifactId: Swift.String?
    let provisioningArtifactName: Swift.String?
    let pathId: Swift.String?
    let pathName: Swift.String?
    let provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
    let provisioningPreferences: ServiceCatalogClientTypes.UpdateProvisioningPreferences?
    let tags: [ServiceCatalogClientTypes.Tag]?
    let updateToken: Swift.String?
}

extension UpdateProvisionedProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case provisioningParameters = "ProvisioningParameters"
        case provisioningPreferences = "ProvisioningPreferences"
        case tags = "Tags"
        case updateToken = "UpdateToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let pathNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathName)
        pathName = pathNameDecoded
        let provisioningParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.UpdateProvisioningParameter?].self, forKey: .provisioningParameters)
        var provisioningParametersDecoded0:[ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil
        if let provisioningParametersContainer = provisioningParametersContainer {
            provisioningParametersDecoded0 = [ServiceCatalogClientTypes.UpdateProvisioningParameter]()
            for structure0 in provisioningParametersContainer {
                if let structure0 = structure0 {
                    provisioningParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningParameters = provisioningParametersDecoded0
        let provisioningPreferencesDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.UpdateProvisioningPreferences.self, forKey: .provisioningPreferences)
        provisioningPreferences = provisioningPreferencesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let updateTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
    }
}

extension UpdateProvisionedProductOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProvisionedProductOutputBody = try responseDecoder.decode(responseBody: data)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct UpdateProvisionedProductOutput: Swift.Equatable {
    /// Information about the result of the request.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init(
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct UpdateProvisionedProductOutputBody: Swift.Equatable {
    let recordDetail: ServiceCatalogClientTypes.RecordDetail?
}

extension UpdateProvisionedProductOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

enum UpdateProvisionedProductOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProvisionedProductPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductProperties = "ProvisionedProductProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let provisionedProductId = self.provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductProperties = provisionedProductProperties {
            var provisionedProductPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .provisionedProductProperties)
            for (dictKey0, provisionedProductProperties0) in provisionedProductProperties {
                try provisionedProductPropertiesContainer.encode(provisionedProductProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateProvisionedProductPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProvisionedProductPropertiesInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The idempotency token that uniquely identifies the provisioning product update request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The identifier of the provisioned product.
    /// This member is required.
    public var provisionedProductId: Swift.String?
    /// A map that contains the provisioned product properties to be updated. The LAUNCH_ROLE key accepts role ARNs. This key allows an administrator to call UpdateProvisionedProductProperties to update the launch role that is associated with a provisioned product. This role is used when an end user calls a provisioning operation such as UpdateProvisionedProduct, TerminateProvisionedProduct, or ExecuteProvisionedProductServiceAction. Only a role ARN is valid. A user ARN is invalid. The OWNER key accepts user ARNs, IAM role ARNs, and STS assumed-role ARNs. The owner is the user that has permission to see, update, terminate, and execute service actions in the provisioned product. The administrator can change the owner of a provisioned product to another IAM or STS entity within the same account. Both end user owners and administrators can see ownership history of the provisioned product using the ListRecordHistory API. The new owner can describe all past records for the provisioned product using the DescribeRecord API. The previous owner can no longer use DescribeRecord, but can still see the product's history from when he was an owner using ListRecordHistory. If a provisioned product ownership is assigned to an end user, they can see and perform any action through the API or Service Catalog console such as update, terminate, and execute service actions. If an end user provisions a product and the owner is updated to someone else, they will no longer be able to see or perform any actions through API or the Service Catalog console on that provisioned product.
    /// This member is required.
    public var provisionedProductProperties: [Swift.String:Swift.String]?

    public init(
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil,
        provisionedProductProperties: [Swift.String:Swift.String]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.provisionedProductId = provisionedProductId
        self.provisionedProductProperties = provisionedProductProperties
    }
}

struct UpdateProvisionedProductPropertiesInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let provisionedProductId: Swift.String?
    let provisionedProductProperties: [Swift.String:Swift.String]?
    let idempotencyToken: Swift.String?
}

extension UpdateProvisionedProductPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductProperties = "ProvisionedProductProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let provisionedProductPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .provisionedProductProperties)
        var provisionedProductPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let provisionedProductPropertiesContainer = provisionedProductPropertiesContainer {
            provisionedProductPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, propertyvalue0) in provisionedProductPropertiesContainer {
                if let propertyvalue0 = propertyvalue0 {
                    provisionedProductPropertiesDecoded0?[key0] = propertyvalue0
                }
            }
        }
        provisionedProductProperties = provisionedProductPropertiesDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension UpdateProvisionedProductPropertiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProvisionedProductPropertiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.provisionedProductId = output.provisionedProductId
            self.provisionedProductProperties = output.provisionedProductProperties
            self.recordId = output.recordId
            self.status = output.status
        } else {
            self.provisionedProductId = nil
            self.provisionedProductProperties = nil
            self.recordId = nil
            self.status = nil
        }
    }
}

public struct UpdateProvisionedProductPropertiesOutput: Swift.Equatable {
    /// The provisioned product identifier.
    public var provisionedProductId: Swift.String?
    /// A map that contains the properties updated.
    public var provisionedProductProperties: [Swift.String:Swift.String]?
    /// The identifier of the record.
    public var recordId: Swift.String?
    /// The status of the request.
    public var status: ServiceCatalogClientTypes.RecordStatus?

    public init(
        provisionedProductId: Swift.String? = nil,
        provisionedProductProperties: [Swift.String:Swift.String]? = nil,
        recordId: Swift.String? = nil,
        status: ServiceCatalogClientTypes.RecordStatus? = nil
    )
    {
        self.provisionedProductId = provisionedProductId
        self.provisionedProductProperties = provisionedProductProperties
        self.recordId = recordId
        self.status = status
    }
}

struct UpdateProvisionedProductPropertiesOutputBody: Swift.Equatable {
    let provisionedProductId: Swift.String?
    let provisionedProductProperties: [Swift.String:Swift.String]?
    let recordId: Swift.String?
    let status: ServiceCatalogClientTypes.RecordStatus?
}

extension UpdateProvisionedProductPropertiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductProperties = "ProvisionedProductProperties"
        case recordId = "RecordId"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let provisionedProductPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .provisionedProductProperties)
        var provisionedProductPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let provisionedProductPropertiesContainer = provisionedProductPropertiesContainer {
            provisionedProductPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, propertyvalue0) in provisionedProductPropertiesContainer {
                if let propertyvalue0 = propertyvalue0 {
                    provisionedProductPropertiesDecoded0?[key0] = propertyvalue0
                }
            }
        }
        provisionedProductProperties = provisionedProductPropertiesDecoded0
        let recordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordId)
        recordId = recordIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdateProvisionedProductPropertiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProvisioningArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case active = "Active"
        case description = "Description"
        case guidance = "Guidance"
        case name = "Name"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let guidance = self.guidance {
            try encodeContainer.encode(guidance.rawValue, forKey: .guidance)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = self.provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }
}

extension UpdateProvisioningArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// Indicates whether the product version is active. Inactive provisioning artifacts are invisible to end users. End users cannot launch or update a provisioned product from an inactive provisioning artifact.
    public var active: Swift.Bool?
    /// The updated description of the provisioning artifact.
    public var description: Swift.String?
    /// Information set by the administrator to provide guidance to end users about which provisioning artifacts to use. The DEFAULT value indicates that the product version is active. The administrator can set the guidance to DEPRECATED to inform users that the product version is deprecated. Users are able to make updates to a provisioned product of a deprecated version but cannot launch new provisioned products using a deprecated version.
    public var guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance?
    /// The updated name of the provisioning artifact.
    public var name: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        active: Swift.Bool? = nil,
        description: Swift.String? = nil,
        guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance? = nil,
        name: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.active = active
        self.description = description
        self.guidance = guidance
        self.name = name
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct UpdateProvisioningArtifactInputBody: Swift.Equatable {
    let acceptLanguage: Swift.String?
    let productId: Swift.String?
    let provisioningArtifactId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let active: Swift.Bool?
    let guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance?
}

extension UpdateProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case active = "Active"
        case description = "Description"
        case guidance = "Guidance"
        case name = "Name"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let guidanceDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactGuidance.self, forKey: .guidance)
        guidance = guidanceDecoded
    }
}

extension UpdateProvisioningArtifactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProvisioningArtifactOutputBody = try responseDecoder.decode(responseBody: data)
            self.info = output.info
            self.provisioningArtifactDetail = output.provisioningArtifactDetail
            self.status = output.status
        } else {
            self.info = nil
            self.provisioningArtifactDetail = nil
            self.status = nil
        }
    }
}

public struct UpdateProvisioningArtifactOutput: Swift.Equatable {
    /// The URL of the CloudFormation template in Amazon S3 or GitHub in JSON format.
    public var info: [Swift.String:Swift.String]?
    /// Information about the provisioning artifact.
    public var provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init(
        info: [Swift.String:Swift.String]? = nil,
        provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.info = info
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.status = status
    }
}

struct UpdateProvisioningArtifactOutputBody: Swift.Equatable {
    let provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    let info: [Swift.String:Swift.String]?
    let status: ServiceCatalogClientTypes.Status?
}

extension UpdateProvisioningArtifactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case info = "Info"
        case provisioningArtifactDetail = "ProvisioningArtifactDetail"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactDetail.self, forKey: .provisioningArtifactDetail)
        provisioningArtifactDetail = provisioningArtifactDetailDecoded
        let infoContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .info)
        var infoDecoded0: [Swift.String:Swift.String]? = nil
        if let infoContainer = infoContainer {
            infoDecoded0 = [Swift.String:Swift.String]()
            for (key0, provisioningartifactinfovalue0) in infoContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    infoDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        info = infoDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdateProvisioningArtifactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes.UpdateProvisioningParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case usePreviousValue = "UsePreviousValue"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if usePreviousValue != false {
            try encodeContainer.encode(usePreviousValue, forKey: .usePreviousValue)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let usePreviousValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .usePreviousValue) ?? false
        usePreviousValue = usePreviousValueDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// The parameter key-value pair used to update a provisioned product.
    public struct UpdateProvisioningParameter: Swift.Equatable {
        /// The parameter key.
        public var key: Swift.String?
        /// If set to true, Value is ignored and the previous parameter value is kept.
        public var usePreviousValue: Swift.Bool
        /// The parameter value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            usePreviousValue: Swift.Bool = false,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.usePreviousValue = usePreviousValue
            self.value = value
        }
    }

}

extension ServiceCatalogClientTypes.UpdateProvisioningPreferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackSetAccounts = "StackSetAccounts"
        case stackSetFailureToleranceCount = "StackSetFailureToleranceCount"
        case stackSetFailureTolerancePercentage = "StackSetFailureTolerancePercentage"
        case stackSetMaxConcurrencyCount = "StackSetMaxConcurrencyCount"
        case stackSetMaxConcurrencyPercentage = "StackSetMaxConcurrencyPercentage"
        case stackSetOperationType = "StackSetOperationType"
        case stackSetRegions = "StackSetRegions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackSetAccounts = stackSetAccounts {
            var stackSetAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetAccounts)
            for accountid0 in stackSetAccounts {
                try stackSetAccountsContainer.encode(accountid0)
            }
        }
        if let stackSetFailureToleranceCount = self.stackSetFailureToleranceCount {
            try encodeContainer.encode(stackSetFailureToleranceCount, forKey: .stackSetFailureToleranceCount)
        }
        if let stackSetFailureTolerancePercentage = self.stackSetFailureTolerancePercentage {
            try encodeContainer.encode(stackSetFailureTolerancePercentage, forKey: .stackSetFailureTolerancePercentage)
        }
        if let stackSetMaxConcurrencyCount = self.stackSetMaxConcurrencyCount {
            try encodeContainer.encode(stackSetMaxConcurrencyCount, forKey: .stackSetMaxConcurrencyCount)
        }
        if let stackSetMaxConcurrencyPercentage = self.stackSetMaxConcurrencyPercentage {
            try encodeContainer.encode(stackSetMaxConcurrencyPercentage, forKey: .stackSetMaxConcurrencyPercentage)
        }
        if let stackSetOperationType = self.stackSetOperationType {
            try encodeContainer.encode(stackSetOperationType.rawValue, forKey: .stackSetOperationType)
        }
        if let stackSetRegions = stackSetRegions {
            var stackSetRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetRegions)
            for region0 in stackSetRegions {
                try stackSetRegionsContainer.encode(region0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackSetAccounts)
        var stackSetAccountsDecoded0:[Swift.String]? = nil
        if let stackSetAccountsContainer = stackSetAccountsContainer {
            stackSetAccountsDecoded0 = [Swift.String]()
            for string0 in stackSetAccountsContainer {
                if let string0 = string0 {
                    stackSetAccountsDecoded0?.append(string0)
                }
            }
        }
        stackSetAccounts = stackSetAccountsDecoded0
        let stackSetRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackSetRegions)
        var stackSetRegionsDecoded0:[Swift.String]? = nil
        if let stackSetRegionsContainer = stackSetRegionsContainer {
            stackSetRegionsDecoded0 = [Swift.String]()
            for string0 in stackSetRegionsContainer {
                if let string0 = string0 {
                    stackSetRegionsDecoded0?.append(string0)
                }
            }
        }
        stackSetRegions = stackSetRegionsDecoded0
        let stackSetFailureToleranceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetFailureToleranceCount)
        stackSetFailureToleranceCount = stackSetFailureToleranceCountDecoded
        let stackSetFailureTolerancePercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetFailureTolerancePercentage)
        stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentageDecoded
        let stackSetMaxConcurrencyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetMaxConcurrencyCount)
        stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCountDecoded
        let stackSetMaxConcurrencyPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetMaxConcurrencyPercentage)
        stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentageDecoded
        let stackSetOperationTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.StackSetOperationType.self, forKey: .stackSetOperationType)
        stackSetOperationType = stackSetOperationTypeDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// The user-defined preferences that will be applied when updating a provisioned product. Not all preferences are applicable to all provisioned product types.
    public struct UpdateProvisioningPreferences: Swift.Equatable {
        /// One or more Amazon Web Services accounts that will have access to the provisioned product. Applicable only to a CFN_STACKSET provisioned product type. The Amazon Web Services accounts specified should be within the list of accounts in the STACKSET constraint. To get the list of accounts in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all accounts from the STACKSET constraint.
        public var stackSetAccounts: [Swift.String]?
        /// The number of accounts, per Region, for which this operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both. The default value is 0 if no value is specified.
        public var stackSetFailureToleranceCount: Swift.Int?
        /// The percentage of accounts, per Region, for which this stack operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions. When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both.
        public var stackSetFailureTolerancePercentage: Swift.Int?
        /// The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of StackSetFailureToleranceCount. StackSetMaxConcurrentCount is at most one more than the StackSetFailureToleranceCount. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public var stackSetMaxConcurrencyCount: Swift.Int?
        /// The maximum percentage of accounts in which to perform this operation at one time. When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, Service Catalog sets the number as 1 instead. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public var stackSetMaxConcurrencyPercentage: Swift.Int?
        /// Determines what action Service Catalog performs to a stack set or a stack instance represented by the provisioned product. The default value is UPDATE if nothing is specified. Applicable only to a CFN_STACKSET provisioned product type. CREATE Creates a new stack instance in the stack set represented by the provisioned product. In this case, only new stack instances are created based on accounts and Regions; if new ProductId or ProvisioningArtifactID are passed, they will be ignored. UPDATE Updates the stack set represented by the provisioned product and also its stack instances. DELETE Deletes a stack instance in the stack set represented by the provisioned product.
        public var stackSetOperationType: ServiceCatalogClientTypes.StackSetOperationType?
        /// One or more Amazon Web Services Regions where the provisioned product will be available. Applicable only to a CFN_STACKSET provisioned product type. The specified Regions should be within the list of Regions from the STACKSET constraint. To get the list of Regions in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all Regions from the STACKSET constraint.
        public var stackSetRegions: [Swift.String]?

        public init(
            stackSetAccounts: [Swift.String]? = nil,
            stackSetFailureToleranceCount: Swift.Int? = nil,
            stackSetFailureTolerancePercentage: Swift.Int? = nil,
            stackSetMaxConcurrencyCount: Swift.Int? = nil,
            stackSetMaxConcurrencyPercentage: Swift.Int? = nil,
            stackSetOperationType: ServiceCatalogClientTypes.StackSetOperationType? = nil,
            stackSetRegions: [Swift.String]? = nil
        )
        {
            self.stackSetAccounts = stackSetAccounts
            self.stackSetFailureToleranceCount = stackSetFailureToleranceCount
            self.stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage
            self.stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount
            self.stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage
            self.stackSetOperationType = stackSetOperationType
            self.stackSetRegions = stackSetRegions
        }
    }

}

extension UpdateServiceActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case definition = "Definition"
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = self.acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .definition)
            for (dictKey0, serviceActionDefinitionMap0) in definition {
                try definitionContainer.encode(serviceActionDefinitionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateServiceActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServiceActionInput: Swift.Equatable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// A map that defines the self-service action.
    public var definition: [Swift.String:Swift.String]?
    /// The self-service action description.
    public var description: Swift.String?
    /// The self-service action identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The self-service action name.
    public var name: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        definition: [Swift.String:Swift.String]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.definition = definition
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateServiceActionInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let definition: [Swift.String:Swift.String]?
    let description: Swift.String?
    let acceptLanguage: Swift.String?
}

extension UpdateServiceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case definition = "Definition"
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let definitionContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .definition)
        var definitionDecoded0: [Swift.String:Swift.String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [Swift.String:Swift.String]()
            for (key0, serviceactiondefinitionvalue0) in definitionContainer {
                if let serviceactiondefinitionvalue0 = serviceactiondefinitionvalue0 {
                    definitionDecoded0?[key0] = serviceactiondefinitionvalue0
                }
            }
        }
        definition = definitionDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension UpdateServiceActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServiceActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceActionDetail = output.serviceActionDetail
        } else {
            self.serviceActionDetail = nil
        }
    }
}

public struct UpdateServiceActionOutput: Swift.Equatable {
    /// Detailed information about the self-service action.
    public var serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?

    public init(
        serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail? = nil
    )
    {
        self.serviceActionDetail = serviceActionDetail
    }
}

struct UpdateServiceActionOutputBody: Swift.Equatable {
    let serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?
}

extension UpdateServiceActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceActionDetail = "ServiceActionDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionDetail.self, forKey: .serviceActionDetail)
        serviceActionDetail = serviceActionDetailDecoded
    }
}

enum UpdateServiceActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTagOptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case id = "Id"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

extension UpdateTagOptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateTagOptionInput: Swift.Equatable {
    /// The updated active state.
    public var active: Swift.Bool?
    /// The TagOption identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The updated value.
    public var value: Swift.String?

    public init(
        active: Swift.Bool? = nil,
        id: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.active = active
        self.id = id
        self.value = value
    }
}

struct UpdateTagOptionInputBody: Swift.Equatable {
    let id: Swift.String?
    let value: Swift.String?
    let active: Swift.Bool?
}

extension UpdateTagOptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case id = "Id"
        case value = "Value"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
    }
}

extension UpdateTagOptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTagOptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.tagOptionDetail = output.tagOptionDetail
        } else {
            self.tagOptionDetail = nil
        }
    }
}

public struct UpdateTagOptionOutput: Swift.Equatable {
    /// Information about the TagOption.
    public var tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?

    public init(
        tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail? = nil
    )
    {
        self.tagOptionDetail = tagOptionDetail
    }
}

struct UpdateTagOptionOutputBody: Swift.Equatable {
    let tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?
}

extension UpdateTagOptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagOptionDetail = "TagOptionDetail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagOptionDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.TagOptionDetail.self, forKey: .tagOptionDetail)
        tagOptionDetail = tagOptionDetailDecoded
    }
}

enum UpdateTagOptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateResourceException": return try await DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParametersException": return try await InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagOptionNotMigratedException": return try await TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceCatalogClientTypes.UsageInstruction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes {
    /// Additional information provided by the administrator.
    public struct UsageInstruction: Swift.Equatable {
        /// The usage instruction type for the value.
        public var type: Swift.String?
        /// The usage instruction value for this type.
        public var value: Swift.String?

        public init(
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}
