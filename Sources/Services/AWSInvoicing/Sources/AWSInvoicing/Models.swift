//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// You don't have sufficient access to perform this action.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingAccessDenied" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

extension InvoicingClientTypes {

    /// The discounted amount.
    public struct DiscountsBreakdownAmount: Swift.Sendable {
        /// The discounted amount.
        public var amount: Swift.String?
        /// The list of discounts information.
        public var description: Swift.String?
        /// The details for the discount rate..
        public var rate: Swift.String?

        public init(
            amount: Swift.String? = nil,
            description: Swift.String? = nil,
            rate: Swift.String? = nil
        ) {
            self.amount = amount
            self.description = description
            self.rate = rate
        }
    }
}

extension InvoicingClientTypes {

    /// The discounts details.
    public struct DiscountsBreakdown: Swift.Sendable {
        /// The list of discounts information.
        public var breakdown: [InvoicingClientTypes.DiscountsBreakdownAmount]?
        /// The discount's total amount.
        public var totalAmount: Swift.String?

        public init(
            breakdown: [InvoicingClientTypes.DiscountsBreakdownAmount]? = nil,
            totalAmount: Swift.String? = nil
        ) {
            self.breakdown = breakdown
            self.totalAmount = totalAmount
        }
    }
}

extension InvoicingClientTypes {

    /// The fee amount.
    public struct FeesBreakdownAmount: Swift.Sendable {
        /// The fee amount.
        public var amount: Swift.String?
        /// The list of fees information.
        public var description: Swift.String?
        /// Details about the rate amount.
        public var rate: Swift.String?

        public init(
            amount: Swift.String? = nil,
            description: Swift.String? = nil,
            rate: Swift.String? = nil
        ) {
            self.amount = amount
            self.description = description
            self.rate = rate
        }
    }
}

extension InvoicingClientTypes {

    /// The details of fees.
    public struct FeesBreakdown: Swift.Sendable {
        /// The list of fees information.
        public var breakdown: [InvoicingClientTypes.FeesBreakdownAmount]?
        /// The total amount of fees.
        public var totalAmount: Swift.String?

        public init(
            breakdown: [InvoicingClientTypes.FeesBreakdownAmount]? = nil,
            totalAmount: Swift.String? = nil
        ) {
            self.breakdown = breakdown
            self.totalAmount = totalAmount
        }
    }
}

extension InvoicingClientTypes {

    /// The tax amount.
    public struct TaxesBreakdownAmount: Swift.Sendable {
        /// The tax amount.
        public var amount: Swift.String?
        /// The details of the taxes.
        public var description: Swift.String?
        /// The details of the tax rate.
        public var rate: Swift.String?

        public init(
            amount: Swift.String? = nil,
            description: Swift.String? = nil,
            rate: Swift.String? = nil
        ) {
            self.amount = amount
            self.description = description
            self.rate = rate
        }
    }
}

extension InvoicingClientTypes {

    /// The details of the taxes.
    public struct TaxesBreakdown: Swift.Sendable {
        /// A list of tax information.
        public var breakdown: [InvoicingClientTypes.TaxesBreakdownAmount]?
        /// The total amount for your taxes.
        public var totalAmount: Swift.String?

        public init(
            breakdown: [InvoicingClientTypes.TaxesBreakdownAmount]? = nil,
            totalAmount: Swift.String? = nil
        ) {
            self.breakdown = breakdown
            self.totalAmount = totalAmount
        }
    }
}

extension InvoicingClientTypes {

    /// Details about how the total amount was calculated and categorized.
    public struct AmountBreakdown: Swift.Sendable {
        /// The discounted amount.
        public var discounts: InvoicingClientTypes.DiscountsBreakdown?
        /// The fee amount.
        public var fees: InvoicingClientTypes.FeesBreakdown?
        /// The total of a set of the breakdown.
        public var subTotalAmount: Swift.String?
        /// The tax amount.
        public var taxes: InvoicingClientTypes.TaxesBreakdown?

        public init(
            discounts: InvoicingClientTypes.DiscountsBreakdown? = nil,
            fees: InvoicingClientTypes.FeesBreakdown? = nil,
            subTotalAmount: Swift.String? = nil,
            taxes: InvoicingClientTypes.TaxesBreakdown? = nil
        ) {
            self.discounts = discounts
            self.fees = fees
            self.subTotalAmount = subTotalAmount
            self.taxes = taxes
        }
    }
}

/// The processing request failed because of an unknown error, exception, or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The processing request failed because of an unknown error, exception, or failure.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingInternalServer" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The resource could not be found.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingResourceNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingThrottling" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension InvoicingClientTypes {

    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        /// This member is required.
        public var message: Swift.String?
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension InvoicingClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountMembershipError
        case cannotParse
        case duplicateInvoiceUnit
        case expiredNextToken
        case fieldValidationFailed
        case invalidInput
        case invalidNextToken
        case maxAccountsExceeded
        case maxInvoiceUnitsExceeded
        case mutualExclusionError
        case nonMembersPresent
        case other
        case taxSettingsError
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .accountMembershipError,
                .cannotParse,
                .duplicateInvoiceUnit,
                .expiredNextToken,
                .fieldValidationFailed,
                .invalidInput,
                .invalidNextToken,
                .maxAccountsExceeded,
                .maxInvoiceUnitsExceeded,
                .mutualExclusionError,
                .nonMembersPresent,
                .other,
                .taxSettingsError,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountMembershipError: return "accountMembershipError"
            case .cannotParse: return "cannotParse"
            case .duplicateInvoiceUnit: return "duplicateInvoiceUnit"
            case .expiredNextToken: return "expiredNextToken"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .invalidInput: return "invalidInput"
            case .invalidNextToken: return "invalidNextToken"
            case .maxAccountsExceeded: return "maxAccountsExceeded"
            case .maxInvoiceUnitsExceeded: return "maxInvoiceUnitsExceeded"
            case .mutualExclusionError: return "mutualExclusionError"
            case .nonMembersPresent: return "nonMemberPresent"
            case .other: return "other"
            case .taxSettingsError: return "taxSettingsError"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var fieldList: [InvoicingClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// You don't have sufficient access to perform this action.
        public internal(set) var reason: InvoicingClientTypes.ValidationExceptionReason? = nil
        /// You don't have sufficient access to perform this action.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingValidation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [InvoicingClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: InvoicingClientTypes.ValidationExceptionReason? = nil,
        resourceName: Swift.String? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
        self.properties.resourceName = resourceName
    }
}

public struct BatchGetInvoiceProfileInput: Swift.Sendable {
    /// Retrieves the corresponding invoice profile data for these account IDs.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    ) {
        self.accountIds = accountIds
    }
}

extension InvoicingClientTypes {

    /// The details of the address associated with the receiver.
    public struct ReceiverAddress: Swift.Sendable {
        /// The first line of the address.
        public var addressLine1: Swift.String?
        /// The second line of the address, if applicable.
        public var addressLine2: Swift.String?
        /// The third line of the address, if applicable.
        public var addressLine3: Swift.String?
        /// The city that the address is in.
        public var city: Swift.String?
        /// A unique company name.
        public var companyName: Swift.String?
        /// The country code for the country the address is in.
        public var countryCode: Swift.String?
        /// The district or country the address is located in.
        public var districtOrCounty: Swift.String?
        /// The postal code associated with the address.
        public var postalCode: Swift.String?
        /// The state, region, or province the address is located.
        public var stateOrRegion: Swift.String?

        public init(
            addressLine1: Swift.String? = nil,
            addressLine2: Swift.String? = nil,
            addressLine3: Swift.String? = nil,
            city: Swift.String? = nil,
            companyName: Swift.String? = nil,
            countryCode: Swift.String? = nil,
            districtOrCounty: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            stateOrRegion: Swift.String? = nil
        ) {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.addressLine3 = addressLine3
            self.city = city
            self.companyName = companyName
            self.countryCode = countryCode
            self.districtOrCounty = districtOrCounty
            self.postalCode = postalCode
            self.stateOrRegion = stateOrRegion
        }
    }
}

extension InvoicingClientTypes.ReceiverAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension InvoicingClientTypes {

    /// Contains high-level information about the invoice receiver.
    public struct InvoiceProfile: Swift.Sendable {
        /// The account ID the invoice profile is generated for.
        public var accountId: Swift.String?
        /// This specifies the issuing entity of the invoice.
        public var issuer: Swift.String?
        /// The address of the receiver that will be printed on the invoice.
        public var receiverAddress: InvoicingClientTypes.ReceiverAddress?
        /// The email address for the invoice profile receiver.
        public var receiverEmail: Swift.String?
        /// The name of the person receiving the invoice profile.
        public var receiverName: Swift.String?
        /// Your Tax Registration Number (TRN) information.
        public var taxRegistrationNumber: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            issuer: Swift.String? = nil,
            receiverAddress: InvoicingClientTypes.ReceiverAddress? = nil,
            receiverEmail: Swift.String? = nil,
            receiverName: Swift.String? = nil,
            taxRegistrationNumber: Swift.String? = nil
        ) {
            self.accountId = accountId
            self.issuer = issuer
            self.receiverAddress = receiverAddress
            self.receiverEmail = receiverEmail
            self.receiverName = receiverName
            self.taxRegistrationNumber = taxRegistrationNumber
        }
    }
}

extension InvoicingClientTypes.InvoiceProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvoiceProfile(accountId: \(Swift.String(describing: accountId)), issuer: \(Swift.String(describing: issuer)), receiverName: \(Swift.String(describing: receiverName)), receiverAddress: \"CONTENT_REDACTED\", receiverEmail: \"CONTENT_REDACTED\", taxRegistrationNumber: \"CONTENT_REDACTED\")"}
}

public struct BatchGetInvoiceProfileOutput: Swift.Sendable {
    /// A list of invoice profiles corresponding to the requested accounts.
    public var profiles: [InvoicingClientTypes.InvoiceProfile]?

    public init(
        profiles: [InvoicingClientTypes.InvoiceProfile]? = nil
    ) {
        self.profiles = profiles
    }
}

extension InvoicingClientTypes {

    /// The billing period for which you want to retrieve invoice-related documents.
    public struct BillingPeriod: Swift.Sendable {
        /// The billing period month.
        /// This member is required.
        public var month: Swift.Int?
        /// The billing period year.
        /// This member is required.
        public var year: Swift.Int?

        public init(
            month: Swift.Int? = nil,
            year: Swift.Int? = nil
        ) {
            self.month = month
            self.year = year
        }
    }
}

extension InvoicingClientTypes {

    public enum BuyerDomain: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case networkid
        case sdkUnknown(Swift.String)

        public static var allCases: [BuyerDomain] {
            return [
                .networkid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .networkid: return "NetworkID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request could not be completed due to a conflict with the current state of the resource. This exception occurs when a concurrent modification is detected during an update operation, or when attempting to create a resource that already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that caused the conflict.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that caused the conflict.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingConflict" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension InvoicingClientTypes {

    public enum ConnectionTestingMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case prodEnvDollarTest
        case testEnvReplayTest
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionTestingMethod] {
            return [
                .prodEnvDollarTest,
                .testEnvReplayTest
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .prodEnvDollarTest: return "PROD_ENV_DOLLAR_TEST"
            case .testEnvReplayTest: return "TEST_ENV_REPLAY_TEST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvoicingClientTypes {

    /// Represents contact information for a person or role associated with the procurement portal preference.
    public struct Contact: Swift.Sendable {
        /// The email address of the contact person or role.
        public var email: Swift.String?
        /// The name of the contact person or role.
        public var name: Swift.String?

        public init(
            email: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.email = email
            self.name = name
        }
    }
}

extension InvoicingClientTypes.Contact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension InvoicingClientTypes {

    /// The tag structure that contains a tag key and value.
    public struct ResourceTag: Swift.Sendable {
        /// The object key of your of your resource tag.
        /// This member is required.
        public var key: Swift.String?
        /// The specific value of the resource tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

extension InvoicingClientTypes {

    /// This is used to categorize the invoice unit. Values are Amazon Web Services account IDs. Currently, the only supported rule is LINKED_ACCOUNT.
    public struct InvoiceUnitRule: Swift.Sendable {
        /// A list of Amazon Web Services account account IDs that have delegated their billing responsibility to the receiver account through transfer billing. Unlike linked accounts, these bill source accounts can be payer accounts from other organizations that have authorized billing transfer to this account.
        public var billSourceAccounts: [Swift.String]?
        /// The list of LINKED_ACCOUNT IDs where charges are included within the invoice unit.
        public var linkedAccounts: [Swift.String]?

        public init(
            billSourceAccounts: [Swift.String]? = nil,
            linkedAccounts: [Swift.String]? = nil
        ) {
            self.billSourceAccounts = billSourceAccounts
            self.linkedAccounts = linkedAccounts
        }
    }
}

public struct CreateInvoiceUnitInput: Swift.Sendable {
    /// The invoice unit's description. This can be changed at a later time.
    public var description: Swift.String?
    /// The Amazon Web Services account ID chosen to be the receiver of an invoice unit. All invoices generated for that invoice unit will be sent to this account ID.
    /// This member is required.
    public var invoiceReceiver: Swift.String?
    /// The unique name of the invoice unit that is shown on the generated invoice. This can't be changed once it is set. To change this name, you must delete the invoice unit recreate.
    /// This member is required.
    public var name: Swift.String?
    /// The tag structure that contains a tag key and value.
    public var resourceTags: [InvoicingClientTypes.ResourceTag]?
    /// The InvoiceUnitRule object used to create invoice units.
    /// This member is required.
    public var rule: InvoicingClientTypes.InvoiceUnitRule?
    /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
    public var taxInheritanceDisabled: Swift.Bool?

    public init(
        description: Swift.String? = nil,
        invoiceReceiver: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceTags: [InvoicingClientTypes.ResourceTag]? = nil,
        rule: InvoicingClientTypes.InvoiceUnitRule? = nil,
        taxInheritanceDisabled: Swift.Bool? = false
    ) {
        self.description = description
        self.invoiceReceiver = invoiceReceiver
        self.name = name
        self.resourceTags = resourceTags
        self.rule = rule
        self.taxInheritanceDisabled = taxInheritanceDisabled
    }
}

public struct CreateInvoiceUnitOutput: Swift.Sendable {
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    public var invoiceUnitArn: Swift.String?

    public init(
        invoiceUnitArn: Swift.String? = nil
    ) {
        self.invoiceUnitArn = invoiceUnitArn
    }
}

/// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account limits. The error message describes the limit exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingServiceQuotaExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension InvoicingClientTypes {

    public enum EinvoiceDeliveryAttachmentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invoicePdf
        case rfpPdf
        case sdkUnknown(Swift.String)

        public static var allCases: [EinvoiceDeliveryAttachmentType] {
            return [
                .invoicePdf,
                .rfpPdf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invoicePdf: return "INVOICE_PDF"
            case .rfpPdf: return "RFP_PDF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvoicingClientTypes {

    public enum EinvoiceDeliveryDocumentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsCloudCreditMemo
        case awsCloudInvoice
        case awsMarketplaceCreditMemo
        case awsMarketplaceInvoice
        case awsRequestForPayment
        case sdkUnknown(Swift.String)

        public static var allCases: [EinvoiceDeliveryDocumentType] {
            return [
                .awsCloudCreditMemo,
                .awsCloudInvoice,
                .awsMarketplaceCreditMemo,
                .awsMarketplaceInvoice,
                .awsRequestForPayment
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsCloudCreditMemo: return "AWS_CLOUD_CREDIT_MEMO"
            case .awsCloudInvoice: return "AWS_CLOUD_INVOICE"
            case .awsMarketplaceCreditMemo: return "AWS_MARKETPLACE_CREDIT_MEMO"
            case .awsMarketplaceInvoice: return "AWS_MARKETPLACE_INVOICE"
            case .awsRequestForPayment: return "AWS_REQUEST_FOR_PAYMENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvoicingClientTypes {

    public enum ModelProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cxml
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .cxml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cxml: return "CXML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvoicingClientTypes {

    public enum PurchaseOrderDataSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associatedPurchaseOrderRequired
        case purchaseOrderNotRequired
        case sdkUnknown(Swift.String)

        public static var allCases: [PurchaseOrderDataSourceType] {
            return [
                .associatedPurchaseOrderRequired,
                .purchaseOrderNotRequired
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associatedPurchaseOrderRequired: return "ASSOCIATED_PURCHASE_ORDER_REQUIRED"
            case .purchaseOrderNotRequired: return "PURCHASE_ORDER_NOT_REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvoicingClientTypes {

    /// Specifies the source configuration for retrieving purchase order data.
    public struct PurchaseOrderDataSource: Swift.Sendable {
        /// The type of e-invoice document that requires purchase order data.
        public var einvoiceDeliveryDocumentType: InvoicingClientTypes.EinvoiceDeliveryDocumentType?
        /// The type of source for purchase order data.
        public var purchaseOrderDataSourceType: InvoicingClientTypes.PurchaseOrderDataSourceType?

        public init(
            einvoiceDeliveryDocumentType: InvoicingClientTypes.EinvoiceDeliveryDocumentType? = nil,
            purchaseOrderDataSourceType: InvoicingClientTypes.PurchaseOrderDataSourceType? = nil
        ) {
            self.einvoiceDeliveryDocumentType = einvoiceDeliveryDocumentType
            self.purchaseOrderDataSourceType = purchaseOrderDataSourceType
        }
    }
}

extension InvoicingClientTypes {

    /// Specifies the preferences for e-invoice delivery, including document types, attachment types, and customization settings.
    public struct EinvoiceDeliveryPreference: Swift.Sendable {
        /// The method to use for testing the connection to the procurement portal.
        /// This member is required.
        public var connectionTestingMethod: InvoicingClientTypes.ConnectionTestingMethod?
        /// The date when e-invoice delivery should be activated for this preference.
        /// This member is required.
        public var einvoiceDeliveryActivationDate: Foundation.Date?
        /// The types of attachments to include with the e-invoice delivery.
        public var einvoiceDeliveryAttachmentTypes: [InvoicingClientTypes.EinvoiceDeliveryAttachmentType]?
        /// The types of e-invoice documents to be delivered.
        /// This member is required.
        public var einvoiceDeliveryDocumentTypes: [InvoicingClientTypes.EinvoiceDeliveryDocumentType]?
        /// The communication protocol to use for e-invoice delivery.
        /// This member is required.
        public var `protocol`: InvoicingClientTypes.ModelProtocol?
        /// The sources of purchase order data to use for e-invoice generation and delivery.
        /// This member is required.
        public var purchaseOrderDataSources: [InvoicingClientTypes.PurchaseOrderDataSource]?

        public init(
            connectionTestingMethod: InvoicingClientTypes.ConnectionTestingMethod? = nil,
            einvoiceDeliveryActivationDate: Foundation.Date? = nil,
            einvoiceDeliveryAttachmentTypes: [InvoicingClientTypes.EinvoiceDeliveryAttachmentType]? = nil,
            einvoiceDeliveryDocumentTypes: [InvoicingClientTypes.EinvoiceDeliveryDocumentType]? = nil,
            `protocol`: InvoicingClientTypes.ModelProtocol? = nil,
            purchaseOrderDataSources: [InvoicingClientTypes.PurchaseOrderDataSource]? = nil
        ) {
            self.connectionTestingMethod = connectionTestingMethod
            self.einvoiceDeliveryActivationDate = einvoiceDeliveryActivationDate
            self.einvoiceDeliveryAttachmentTypes = einvoiceDeliveryAttachmentTypes
            self.einvoiceDeliveryDocumentTypes = einvoiceDeliveryDocumentTypes
            self.`protocol` = `protocol`
            self.purchaseOrderDataSources = purchaseOrderDataSources
        }
    }
}

extension InvoicingClientTypes {

    public enum ProcurementPortalName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case coupa
        case sapBusinessNetwork
        case sdkUnknown(Swift.String)

        public static var allCases: [ProcurementPortalName] {
            return [
                .coupa,
                .sapBusinessNetwork
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .coupa: return "COUPA"
            case .sapBusinessNetwork: return "SAP_BUSINESS_NETWORK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvoicingClientTypes {

    /// Specifies criteria for selecting which invoices should be processed using a particular procurement portal preference.
    public struct ProcurementPortalPreferenceSelector: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of invoice unit identifiers to which this preference applies.
        public var invoiceUnitArns: [Swift.String]?
        /// The list of seller of record IDs to which this preference applies.
        public var sellerOfRecords: [Swift.String]?

        public init(
            invoiceUnitArns: [Swift.String]? = nil,
            sellerOfRecords: [Swift.String]? = nil
        ) {
            self.invoiceUnitArns = invoiceUnitArns
            self.sellerOfRecords = sellerOfRecords
        }
    }
}

extension InvoicingClientTypes {

    public enum SupplierDomain: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case networkid
        case sdkUnknown(Swift.String)

        public static var allCases: [SupplierDomain] {
            return [
                .networkid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .networkid: return "NetworkID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvoicingClientTypes {

    /// Input parameters for configuring test environment preferences for a procurement portal.
    public struct TestEnvPreferenceInput: Swift.Sendable {
        /// The domain identifier to use for the buyer in the test environment.
        /// This member is required.
        public var buyerDomain: InvoicingClientTypes.BuyerDomain?
        /// The unique identifier to use for the buyer in the test environment.
        /// This member is required.
        public var buyerIdentifier: Swift.String?
        /// The endpoint URL where e-invoices will be delivered in the test environment.
        public var procurementPortalInstanceEndpoint: Swift.String?
        /// The shared secret or authentication credential to use for secure communication in the test environment.
        public var procurementPortalSharedSecret: Swift.String?
        /// The domain identifier to use for the supplier in the test environment.
        /// This member is required.
        public var supplierDomain: InvoicingClientTypes.SupplierDomain?
        /// The unique identifier to use for the supplier in the test environment.
        /// This member is required.
        public var supplierIdentifier: Swift.String?

        public init(
            buyerDomain: InvoicingClientTypes.BuyerDomain? = nil,
            buyerIdentifier: Swift.String? = nil,
            procurementPortalInstanceEndpoint: Swift.String? = nil,
            procurementPortalSharedSecret: Swift.String? = nil,
            supplierDomain: InvoicingClientTypes.SupplierDomain? = nil,
            supplierIdentifier: Swift.String? = nil
        ) {
            self.buyerDomain = buyerDomain
            self.buyerIdentifier = buyerIdentifier
            self.procurementPortalInstanceEndpoint = procurementPortalInstanceEndpoint
            self.procurementPortalSharedSecret = procurementPortalSharedSecret
            self.supplierDomain = supplierDomain
            self.supplierIdentifier = supplierIdentifier
        }
    }
}

public struct CreateProcurementPortalPreferenceInput: Swift.Sendable {
    /// The domain identifier for the buyer in the procurement portal.
    /// This member is required.
    public var buyerDomain: InvoicingClientTypes.BuyerDomain?
    /// The unique identifier for the buyer in the procurement portal.
    /// This member is required.
    public var buyerIdentifier: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// List of contact information for portal administrators and technical contacts responsible for the e-invoice integration.
    /// This member is required.
    public var contacts: [InvoicingClientTypes.Contact]?
    /// Indicates whether e-invoice delivery is enabled for this procurement portal preference. Set to true to enable e-invoice delivery, false to disable.
    /// This member is required.
    public var einvoiceDeliveryEnabled: Swift.Bool?
    /// Specifies the e-invoice delivery configuration including document types, attachment types, and customization settings for the portal.
    public var einvoiceDeliveryPreference: InvoicingClientTypes.EinvoiceDeliveryPreference?
    /// The endpoint URL where e-invoices will be delivered to the procurement portal. Must be a valid HTTPS URL.
    public var procurementPortalInstanceEndpoint: Swift.String?
    /// The name of the procurement portal.
    /// This member is required.
    public var procurementPortalName: InvoicingClientTypes.ProcurementPortalName?
    /// The shared secret or authentication credential used to establish secure communication with the procurement portal. This value must be encrypted at rest.
    public var procurementPortalSharedSecret: Swift.String?
    /// Indicates whether purchase order retrieval is enabled for this procurement portal preference. Set to true to enable PO retrieval, false to disable.
    /// This member is required.
    public var purchaseOrderRetrievalEnabled: Swift.Bool?
    /// The tags to apply to this procurement portal preference resource. Each tag consists of a key and an optional value.
    public var resourceTags: [InvoicingClientTypes.ResourceTag]?
    /// Specifies criteria for selecting which invoices should be processed using a particular procurement portal preference.
    public var selector: InvoicingClientTypes.ProcurementPortalPreferenceSelector?
    /// The domain identifier for the supplier in the procurement portal.
    /// This member is required.
    public var supplierDomain: InvoicingClientTypes.SupplierDomain?
    /// The unique identifier for the supplier in the procurement portal.
    /// This member is required.
    public var supplierIdentifier: Swift.String?
    /// Configuration settings for the test environment of the procurement portal. Includes test credentials and endpoints that are used for validation before production deployment.
    public var testEnvPreference: InvoicingClientTypes.TestEnvPreferenceInput?

    public init(
        buyerDomain: InvoicingClientTypes.BuyerDomain? = nil,
        buyerIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        contacts: [InvoicingClientTypes.Contact]? = nil,
        einvoiceDeliveryEnabled: Swift.Bool? = nil,
        einvoiceDeliveryPreference: InvoicingClientTypes.EinvoiceDeliveryPreference? = nil,
        procurementPortalInstanceEndpoint: Swift.String? = nil,
        procurementPortalName: InvoicingClientTypes.ProcurementPortalName? = nil,
        procurementPortalSharedSecret: Swift.String? = nil,
        purchaseOrderRetrievalEnabled: Swift.Bool? = nil,
        resourceTags: [InvoicingClientTypes.ResourceTag]? = nil,
        selector: InvoicingClientTypes.ProcurementPortalPreferenceSelector? = nil,
        supplierDomain: InvoicingClientTypes.SupplierDomain? = nil,
        supplierIdentifier: Swift.String? = nil,
        testEnvPreference: InvoicingClientTypes.TestEnvPreferenceInput? = nil
    ) {
        self.buyerDomain = buyerDomain
        self.buyerIdentifier = buyerIdentifier
        self.clientToken = clientToken
        self.contacts = contacts
        self.einvoiceDeliveryEnabled = einvoiceDeliveryEnabled
        self.einvoiceDeliveryPreference = einvoiceDeliveryPreference
        self.procurementPortalInstanceEndpoint = procurementPortalInstanceEndpoint
        self.procurementPortalName = procurementPortalName
        self.procurementPortalSharedSecret = procurementPortalSharedSecret
        self.purchaseOrderRetrievalEnabled = purchaseOrderRetrievalEnabled
        self.resourceTags = resourceTags
        self.selector = selector
        self.supplierDomain = supplierDomain
        self.supplierIdentifier = supplierIdentifier
        self.testEnvPreference = testEnvPreference
    }
}

extension CreateProcurementPortalPreferenceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProcurementPortalPreferenceInput(buyerDomain: \(Swift.String(describing: buyerDomain)), buyerIdentifier: \(Swift.String(describing: buyerIdentifier)), clientToken: \(Swift.String(describing: clientToken)), einvoiceDeliveryEnabled: \(Swift.String(describing: einvoiceDeliveryEnabled)), einvoiceDeliveryPreference: \(Swift.String(describing: einvoiceDeliveryPreference)), procurementPortalInstanceEndpoint: \(Swift.String(describing: procurementPortalInstanceEndpoint)), procurementPortalName: \(Swift.String(describing: procurementPortalName)), purchaseOrderRetrievalEnabled: \(Swift.String(describing: purchaseOrderRetrievalEnabled)), resourceTags: \(Swift.String(describing: resourceTags)), selector: \(Swift.String(describing: selector)), supplierDomain: \(Swift.String(describing: supplierDomain)), supplierIdentifier: \(Swift.String(describing: supplierIdentifier)), testEnvPreference: \(Swift.String(describing: testEnvPreference)), contacts: \"CONTENT_REDACTED\", procurementPortalSharedSecret: \"CONTENT_REDACTED\")"}
}

public struct CreateProcurementPortalPreferenceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the created procurement portal preference.
    /// This member is required.
    public var procurementPortalPreferenceArn: Swift.String?

    public init(
        procurementPortalPreferenceArn: Swift.String? = nil
    ) {
        self.procurementPortalPreferenceArn = procurementPortalPreferenceArn
    }
}

extension InvoicingClientTypes {

    /// The details of currency exchange.
    public struct CurrencyExchangeDetails: Swift.Sendable {
        /// The currency exchange rate.
        public var rate: Swift.String?
        /// The exchange source currency.
        public var sourceCurrencyCode: Swift.String?
        /// The exchange target currency.
        public var targetCurrencyCode: Swift.String?

        public init(
            rate: Swift.String? = nil,
            sourceCurrencyCode: Swift.String? = nil,
            targetCurrencyCode: Swift.String? = nil
        ) {
            self.rate = rate
            self.sourceCurrencyCode = sourceCurrencyCode
            self.targetCurrencyCode = targetCurrencyCode
        }
    }
}

extension InvoicingClientTypes {

    /// The time period that you want invoice-related documents for.
    public struct DateInterval: Swift.Sendable {
        /// The end of the time period that you want invoice-related documents for. The end date is exclusive. For example, if end is 2019-01-10, Amazon Web Services retrieves invoice-related documents from the start date up to, but not including, 2018-01-10.
        /// This member is required.
        public var endDate: Foundation.Date?
        /// The beginning of the time period that you want invoice-related documents for. The start date is inclusive. For example, if start is 2019-01-01, AWS retrieves invoices starting at 2019-01-01 up to the end date.
        /// This member is required.
        public var startDate: Foundation.Date?

        public init(
            endDate: Foundation.Date? = nil,
            startDate: Foundation.Date? = nil
        ) {
            self.endDate = endDate
            self.startDate = startDate
        }
    }
}

public struct DeleteInvoiceUnitInput: Swift.Sendable {
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    /// This member is required.
    public var invoiceUnitArn: Swift.String?

    public init(
        invoiceUnitArn: Swift.String? = nil
    ) {
        self.invoiceUnitArn = invoiceUnitArn
    }
}

public struct DeleteInvoiceUnitOutput: Swift.Sendable {
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    public var invoiceUnitArn: Swift.String?

    public init(
        invoiceUnitArn: Swift.String? = nil
    ) {
        self.invoiceUnitArn = invoiceUnitArn
    }
}

public struct DeleteProcurementPortalPreferenceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the procurement portal preference to delete.
    /// This member is required.
    public var procurementPortalPreferenceArn: Swift.String?

    public init(
        procurementPortalPreferenceArn: Swift.String? = nil
    ) {
        self.procurementPortalPreferenceArn = procurementPortalPreferenceArn
    }
}

public struct DeleteProcurementPortalPreferenceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted procurement portal preference.
    /// This member is required.
    public var procurementPortalPreferenceArn: Swift.String?

    public init(
        procurementPortalPreferenceArn: Swift.String? = nil
    ) {
        self.procurementPortalPreferenceArn = procurementPortalPreferenceArn
    }
}

extension InvoicingClientTypes {

    /// The organization name providing Amazon Web Services services.
    public struct Entity: Swift.Sendable {
        /// The name of the entity that issues the Amazon Web Services invoice.
        public var invoicingEntity: Swift.String?

        public init(
            invoicingEntity: Swift.String? = nil
        ) {
            self.invoicingEntity = invoicingEntity
        }
    }
}

extension InvoicingClientTypes {

    /// An optional input to the list API. If multiple filters are specified, the returned list will be a configuration that match all of the provided filters. Supported filter types are InvoiceReceivers, Names, and Accounts.
    public struct Filters: Swift.Sendable {
        /// You can specify a list of Amazon Web Services account IDs inside filters to return invoice units that match only the specified accounts. If multiple accounts are provided, the result is an OR condition (match any) of the specified accounts. The specified account IDs are matched with either the receiver or the linked accounts in the rules.
        public var accounts: [Swift.String]?
        /// A list of Amazon Web Services account account IDs used to filter invoice units. These are payer accounts from other Organizations that have delegated their billing responsibility to the receiver account through the billing transfer feature.
        public var billSourceAccounts: [Swift.String]?
        /// You can specify a list of Amazon Web Services account IDs inside filters to return invoice units that match only the specified accounts. If multiple accounts are provided, the result is an OR condition (match any) of the specified accounts. This filter only matches the specified accounts on the invoice receivers of the invoice units.
        public var invoiceReceivers: [Swift.String]?
        /// An optional input to the list API. You can specify a list of invoice unit names inside filters to return invoice units that match only the specified invoice unit names. If multiple names are provided, the result is an OR condition (match any) of the specified invoice unit names.
        public var names: [Swift.String]?

        public init(
            accounts: [Swift.String]? = nil,
            billSourceAccounts: [Swift.String]? = nil,
            invoiceReceivers: [Swift.String]? = nil,
            names: [Swift.String]? = nil
        ) {
            self.accounts = accounts
            self.billSourceAccounts = billSourceAccounts
            self.invoiceReceivers = invoiceReceivers
            self.names = names
        }
    }
}

public struct GetInvoicePDFInput: Swift.Sendable {
    /// Your unique invoice ID.
    /// This member is required.
    public var invoiceId: Swift.String?

    public init(
        invoiceId: Swift.String? = nil
    ) {
        self.invoiceId = invoiceId
    }
}

extension InvoicingClientTypes {

    /// Supplemental document associated with the invoice.
    public struct SupplementalDocument: Swift.Sendable {
        /// The pre-signed URL to download invoice supplemental document.
        public var documentUrl: Swift.String?
        /// The pre-signed URL expiration date of invoice supplemental document.
        public var documentUrlExpirationDate: Foundation.Date?

        public init(
            documentUrl: Swift.String? = nil,
            documentUrlExpirationDate: Foundation.Date? = nil
        ) {
            self.documentUrl = documentUrl
            self.documentUrlExpirationDate = documentUrlExpirationDate
        }
    }
}

extension InvoicingClientTypes {

    /// Invoice document data.
    public struct InvoicePDF: Swift.Sendable {
        /// The pre-signed URL to download the invoice document.
        public var documentUrl: Swift.String?
        /// The pre-signed URL expiration date of the invoice document.
        public var documentUrlExpirationDate: Foundation.Date?
        /// Your unique invoice ID.
        public var invoiceId: Swift.String?
        /// List of supplemental documents associated with the invoice.
        public var supplementalDocuments: [InvoicingClientTypes.SupplementalDocument]?

        public init(
            documentUrl: Swift.String? = nil,
            documentUrlExpirationDate: Foundation.Date? = nil,
            invoiceId: Swift.String? = nil,
            supplementalDocuments: [InvoicingClientTypes.SupplementalDocument]? = nil
        ) {
            self.documentUrl = documentUrl
            self.documentUrlExpirationDate = documentUrlExpirationDate
            self.invoiceId = invoiceId
            self.supplementalDocuments = supplementalDocuments
        }
    }
}

public struct GetInvoicePDFOutput: Swift.Sendable {
    /// The invoice document and supplemental documents associated with the invoice.
    public var invoicePDF: InvoicingClientTypes.InvoicePDF?

    public init(
        invoicePDF: InvoicingClientTypes.InvoicePDF? = nil
    ) {
        self.invoicePDF = invoicePDF
    }
}

public struct GetInvoiceUnitInput: Swift.Sendable {
    /// The state of an invoice unit at a specified time. You can see legacy invoice units that are currently deleted if the AsOf time is set to before it was deleted. If an AsOf is not provided, the default value is the current time.
    public var asOf: Foundation.Date?
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    /// This member is required.
    public var invoiceUnitArn: Swift.String?

    public init(
        asOf: Foundation.Date? = nil,
        invoiceUnitArn: Swift.String? = nil
    ) {
        self.asOf = asOf
        self.invoiceUnitArn = invoiceUnitArn
    }
}

public struct GetInvoiceUnitOutput: Swift.Sendable {
    /// The assigned description for an invoice unit.
    public var description: Swift.String?
    /// The Amazon Web Services account ID chosen to be the receiver of an invoice unit. All invoices generated for that invoice unit will be sent to this account ID.
    public var invoiceReceiver: Swift.String?
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    public var invoiceUnitArn: Swift.String?
    /// The most recent date the invoice unit response was updated.
    public var lastModified: Foundation.Date?
    /// The unique name of the invoice unit that is shown on the generated invoice.
    public var name: Swift.String?
    /// This is used to categorize the invoice unit. Values are Amazon Web Services account IDs. Currently, the only supported rule is LINKED_ACCOUNT.
    public var rule: InvoicingClientTypes.InvoiceUnitRule?
    /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
    public var taxInheritanceDisabled: Swift.Bool?

    public init(
        description: Swift.String? = nil,
        invoiceReceiver: Swift.String? = nil,
        invoiceUnitArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        name: Swift.String? = nil,
        rule: InvoicingClientTypes.InvoiceUnitRule? = nil,
        taxInheritanceDisabled: Swift.Bool? = false
    ) {
        self.description = description
        self.invoiceReceiver = invoiceReceiver
        self.invoiceUnitArn = invoiceUnitArn
        self.lastModified = lastModified
        self.name = name
        self.rule = rule
        self.taxInheritanceDisabled = taxInheritanceDisabled
    }
}

public struct GetProcurementPortalPreferenceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the procurement portal preference to retrieve.
    /// This member is required.
    public var procurementPortalPreferenceArn: Swift.String?

    public init(
        procurementPortalPreferenceArn: Swift.String? = nil
    ) {
        self.procurementPortalPreferenceArn = procurementPortalPreferenceArn
    }
}

extension InvoicingClientTypes {

    public enum ProcurementPortalPreferenceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case pendingVerification
        case suspended
        case testFailed
        case testInitializationFailed
        case testInitialized
        case sdkUnknown(Swift.String)

        public static var allCases: [ProcurementPortalPreferenceStatus] {
            return [
                .active,
                .pendingVerification,
                .suspended,
                .testFailed,
                .testInitializationFailed,
                .testInitialized
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .pendingVerification: return "PENDING_VERIFICATION"
            case .suspended: return "SUSPENDED"
            case .testFailed: return "TEST_FAILED"
            case .testInitializationFailed: return "TEST_INITIALIZATION_FAILED"
            case .testInitialized: return "TEST_INITIALIZED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvoicingClientTypes {

    /// Contains configuration settings for testing the procurement portal integration in a non-production environment.
    public struct TestEnvPreference: Swift.Sendable {
        /// The domain identifier for the buyer in the test environment of the procurement portal.
        /// This member is required.
        public var buyerDomain: InvoicingClientTypes.BuyerDomain?
        /// The unique identifier for the buyer in the test environment of the procurement portal.
        /// This member is required.
        public var buyerIdentifier: Swift.String?
        /// The endpoint URL where e-invoices are delivered in the test environment.
        public var procurementPortalInstanceEndpoint: Swift.String?
        /// The shared secret or authentication credential used for secure communication with the test environment.
        public var procurementPortalSharedSecret: Swift.String?
        /// The endpoint URL used for retrieving purchase orders in the test environment.
        public var purchaseOrderRetrievalEndpoint: Swift.String?
        /// The domain identifier for the supplier in the test environment of the procurement portal.
        /// This member is required.
        public var supplierDomain: InvoicingClientTypes.SupplierDomain?
        /// The unique identifier for the supplier in the test environment of the procurement portal.
        /// This member is required.
        public var supplierIdentifier: Swift.String?

        public init(
            buyerDomain: InvoicingClientTypes.BuyerDomain? = nil,
            buyerIdentifier: Swift.String? = nil,
            procurementPortalInstanceEndpoint: Swift.String? = nil,
            procurementPortalSharedSecret: Swift.String? = nil,
            purchaseOrderRetrievalEndpoint: Swift.String? = nil,
            supplierDomain: InvoicingClientTypes.SupplierDomain? = nil,
            supplierIdentifier: Swift.String? = nil
        ) {
            self.buyerDomain = buyerDomain
            self.buyerIdentifier = buyerIdentifier
            self.procurementPortalInstanceEndpoint = procurementPortalInstanceEndpoint
            self.procurementPortalSharedSecret = procurementPortalSharedSecret
            self.purchaseOrderRetrievalEndpoint = purchaseOrderRetrievalEndpoint
            self.supplierDomain = supplierDomain
            self.supplierIdentifier = supplierIdentifier
        }
    }
}

extension InvoicingClientTypes {

    /// Represents the full configuration of a procurement portal preference, including settings for e-invoice delivery and purchase order retrieval.
    public struct ProcurementPortalPreference: Swift.Sendable {
        /// The Amazon Web Services account ID associated with this procurement portal preference.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// The domain identifier for the buyer in the procurement portal.
        /// This member is required.
        public var buyerDomain: InvoicingClientTypes.BuyerDomain?
        /// The unique identifier for the buyer in the procurement portal.
        /// This member is required.
        public var buyerIdentifier: Swift.String?
        /// List of contact information for portal administrators and technical contacts.
        public var contacts: [InvoicingClientTypes.Contact]?
        /// The date and time when the procurement portal preference was created.
        /// This member is required.
        public var createDate: Foundation.Date?
        /// Indicates whether e-invoice delivery is enabled for this procurement portal preference.
        /// This member is required.
        public var einvoiceDeliveryEnabled: Swift.Bool?
        /// The configuration settings that specify how e-invoices are delivered to the procurement portal.
        public var einvoiceDeliveryPreference: InvoicingClientTypes.EinvoiceDeliveryPreference?
        /// The current status of the e-invoice delivery preference.
        public var einvoiceDeliveryPreferenceStatus: InvoicingClientTypes.ProcurementPortalPreferenceStatus?
        /// The reason for the current e-invoice delivery preference status.
        public var einvoiceDeliveryPreferenceStatusReason: Swift.String?
        /// The date and time when the procurement portal preference was last updated.
        /// This member is required.
        public var lastUpdateDate: Foundation.Date?
        /// The endpoint URL where e-invoices are delivered to the procurement portal.
        public var procurementPortalInstanceEndpoint: Swift.String?
        /// The name of the procurement portal.
        /// This member is required.
        public var procurementPortalName: InvoicingClientTypes.ProcurementPortalName?
        /// The Amazon Resource Name (ARN) of the procurement portal preference.
        /// This member is required.
        public var procurementPortalPreferenceArn: Swift.String?
        /// The shared secret or authentication credential used for secure communication with the procurement portal.
        public var procurementPortalSharedSecret: Swift.String?
        /// Indicates whether purchase order retrieval is enabled for this procurement portal preference.
        /// This member is required.
        public var purchaseOrderRetrievalEnabled: Swift.Bool?
        /// The endpoint URL used for retrieving purchase orders from the procurement portal.
        public var purchaseOrderRetrievalEndpoint: Swift.String?
        /// The current status of the purchase order retrieval preference.
        public var purchaseOrderRetrievalPreferenceStatus: InvoicingClientTypes.ProcurementPortalPreferenceStatus?
        /// The reason for the current purchase order retrieval preference status.
        public var purchaseOrderRetrievalPreferenceStatusReason: Swift.String?
        /// Specifies criteria for selecting which invoices should be processed using a particular procurement portal preference.
        public var selector: InvoicingClientTypes.ProcurementPortalPreferenceSelector?
        /// The domain identifier for the supplier in the procurement portal.
        /// This member is required.
        public var supplierDomain: InvoicingClientTypes.SupplierDomain?
        /// The unique identifier for the supplier in the procurement portal.
        /// This member is required.
        public var supplierIdentifier: Swift.String?
        /// Configuration on settings for the test environment of the procurement portal.
        public var testEnvPreference: InvoicingClientTypes.TestEnvPreference?
        /// The version number of the procurement portal preference configuration.
        /// This member is required.
        public var version: Swift.Int?

        public init(
            awsAccountId: Swift.String? = nil,
            buyerDomain: InvoicingClientTypes.BuyerDomain? = nil,
            buyerIdentifier: Swift.String? = nil,
            contacts: [InvoicingClientTypes.Contact]? = nil,
            createDate: Foundation.Date? = nil,
            einvoiceDeliveryEnabled: Swift.Bool? = nil,
            einvoiceDeliveryPreference: InvoicingClientTypes.EinvoiceDeliveryPreference? = nil,
            einvoiceDeliveryPreferenceStatus: InvoicingClientTypes.ProcurementPortalPreferenceStatus? = nil,
            einvoiceDeliveryPreferenceStatusReason: Swift.String? = nil,
            lastUpdateDate: Foundation.Date? = nil,
            procurementPortalInstanceEndpoint: Swift.String? = nil,
            procurementPortalName: InvoicingClientTypes.ProcurementPortalName? = nil,
            procurementPortalPreferenceArn: Swift.String? = nil,
            procurementPortalSharedSecret: Swift.String? = nil,
            purchaseOrderRetrievalEnabled: Swift.Bool? = nil,
            purchaseOrderRetrievalEndpoint: Swift.String? = nil,
            purchaseOrderRetrievalPreferenceStatus: InvoicingClientTypes.ProcurementPortalPreferenceStatus? = nil,
            purchaseOrderRetrievalPreferenceStatusReason: Swift.String? = nil,
            selector: InvoicingClientTypes.ProcurementPortalPreferenceSelector? = nil,
            supplierDomain: InvoicingClientTypes.SupplierDomain? = nil,
            supplierIdentifier: Swift.String? = nil,
            testEnvPreference: InvoicingClientTypes.TestEnvPreference? = nil,
            version: Swift.Int? = nil
        ) {
            self.awsAccountId = awsAccountId
            self.buyerDomain = buyerDomain
            self.buyerIdentifier = buyerIdentifier
            self.contacts = contacts
            self.createDate = createDate
            self.einvoiceDeliveryEnabled = einvoiceDeliveryEnabled
            self.einvoiceDeliveryPreference = einvoiceDeliveryPreference
            self.einvoiceDeliveryPreferenceStatus = einvoiceDeliveryPreferenceStatus
            self.einvoiceDeliveryPreferenceStatusReason = einvoiceDeliveryPreferenceStatusReason
            self.lastUpdateDate = lastUpdateDate
            self.procurementPortalInstanceEndpoint = procurementPortalInstanceEndpoint
            self.procurementPortalName = procurementPortalName
            self.procurementPortalPreferenceArn = procurementPortalPreferenceArn
            self.procurementPortalSharedSecret = procurementPortalSharedSecret
            self.purchaseOrderRetrievalEnabled = purchaseOrderRetrievalEnabled
            self.purchaseOrderRetrievalEndpoint = purchaseOrderRetrievalEndpoint
            self.purchaseOrderRetrievalPreferenceStatus = purchaseOrderRetrievalPreferenceStatus
            self.purchaseOrderRetrievalPreferenceStatusReason = purchaseOrderRetrievalPreferenceStatusReason
            self.selector = selector
            self.supplierDomain = supplierDomain
            self.supplierIdentifier = supplierIdentifier
            self.testEnvPreference = testEnvPreference
            self.version = version
        }
    }
}

extension InvoicingClientTypes.ProcurementPortalPreference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProcurementPortalPreference(awsAccountId: \(Swift.String(describing: awsAccountId)), buyerDomain: \(Swift.String(describing: buyerDomain)), buyerIdentifier: \(Swift.String(describing: buyerIdentifier)), createDate: \(Swift.String(describing: createDate)), einvoiceDeliveryEnabled: \(Swift.String(describing: einvoiceDeliveryEnabled)), einvoiceDeliveryPreference: \(Swift.String(describing: einvoiceDeliveryPreference)), einvoiceDeliveryPreferenceStatus: \(Swift.String(describing: einvoiceDeliveryPreferenceStatus)), einvoiceDeliveryPreferenceStatusReason: \(Swift.String(describing: einvoiceDeliveryPreferenceStatusReason)), lastUpdateDate: \(Swift.String(describing: lastUpdateDate)), procurementPortalInstanceEndpoint: \(Swift.String(describing: procurementPortalInstanceEndpoint)), procurementPortalName: \(Swift.String(describing: procurementPortalName)), procurementPortalPreferenceArn: \(Swift.String(describing: procurementPortalPreferenceArn)), procurementPortalSharedSecret: \(Swift.String(describing: procurementPortalSharedSecret)), purchaseOrderRetrievalEnabled: \(Swift.String(describing: purchaseOrderRetrievalEnabled)), purchaseOrderRetrievalEndpoint: \(Swift.String(describing: purchaseOrderRetrievalEndpoint)), purchaseOrderRetrievalPreferenceStatus: \(Swift.String(describing: purchaseOrderRetrievalPreferenceStatus)), purchaseOrderRetrievalPreferenceStatusReason: \(Swift.String(describing: purchaseOrderRetrievalPreferenceStatusReason)), selector: \(Swift.String(describing: selector)), supplierDomain: \(Swift.String(describing: supplierDomain)), supplierIdentifier: \(Swift.String(describing: supplierIdentifier)), testEnvPreference: \(Swift.String(describing: testEnvPreference)), version: \(Swift.String(describing: version)), contacts: \"CONTENT_REDACTED\")"}
}

public struct GetProcurementPortalPreferenceOutput: Swift.Sendable {
    /// The detailed configuration of the requested procurement portal preference.
    /// This member is required.
    public var procurementPortalPreference: InvoicingClientTypes.ProcurementPortalPreference?

    public init(
        procurementPortalPreference: InvoicingClientTypes.ProcurementPortalPreference? = nil
    ) {
        self.procurementPortalPreference = procurementPortalPreference
    }
}

extension InvoicingClientTypes {

    /// The amount charged after taxes, in the preferred currency.
    public struct InvoiceCurrencyAmount: Swift.Sendable {
        /// Details about the invoice currency amount.
        public var amountBreakdown: InvoicingClientTypes.AmountBreakdown?
        /// The currency dominion of the invoice document.
        public var currencyCode: Swift.String?
        /// The details of currency exchange.
        public var currencyExchangeDetails: InvoicingClientTypes.CurrencyExchangeDetails?
        /// The invoice currency amount.
        public var totalAmount: Swift.String?
        /// Details about the invoice total amount before tax.
        public var totalAmountBeforeTax: Swift.String?

        public init(
            amountBreakdown: InvoicingClientTypes.AmountBreakdown? = nil,
            currencyCode: Swift.String? = nil,
            currencyExchangeDetails: InvoicingClientTypes.CurrencyExchangeDetails? = nil,
            totalAmount: Swift.String? = nil,
            totalAmountBeforeTax: Swift.String? = nil
        ) {
            self.amountBreakdown = amountBreakdown
            self.currencyCode = currencyCode
            self.currencyExchangeDetails = currencyExchangeDetails
            self.totalAmount = totalAmount
            self.totalAmountBeforeTax = totalAmountBeforeTax
        }
    }
}

extension InvoicingClientTypes {

    public enum InvoiceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creditMemo
        case invoice
        case sdkUnknown(Swift.String)

        public static var allCases: [InvoiceType] {
            return [
                .creditMemo,
                .invoice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creditMemo: return "CREDIT_MEMO"
            case .invoice: return "INVOICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvoicingClientTypes {

    /// The invoice that the API retrieved.
    public struct InvoiceSummary: Swift.Sendable {
        /// The Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The summary with the product and service currency.
        public var baseCurrencyAmount: InvoicingClientTypes.InvoiceCurrencyAmount?
        /// The billing period of the invoice-related document.
        public var billingPeriod: InvoicingClientTypes.BillingPeriod?
        /// The invoice due date.
        public var dueDate: Foundation.Date?
        /// The organization name providing Amazon Web Services services.
        public var entity: InvoicingClientTypes.Entity?
        /// The invoice ID.
        public var invoiceId: Swift.String?
        /// The type of invoice.
        public var invoiceType: InvoicingClientTypes.InvoiceType?
        /// The issued date of the invoice.
        public var issuedDate: Foundation.Date?
        /// The initial or original invoice ID.
        public var originalInvoiceId: Swift.String?
        /// The summary with the customer configured currency.
        public var paymentCurrencyAmount: InvoicingClientTypes.InvoiceCurrencyAmount?
        /// The purchase order number associated to the invoice.
        public var purchaseOrderNumber: Swift.String?
        /// The summary with the tax currency.
        public var taxCurrencyAmount: InvoicingClientTypes.InvoiceCurrencyAmount?

        public init(
            accountId: Swift.String? = nil,
            baseCurrencyAmount: InvoicingClientTypes.InvoiceCurrencyAmount? = nil,
            billingPeriod: InvoicingClientTypes.BillingPeriod? = nil,
            dueDate: Foundation.Date? = nil,
            entity: InvoicingClientTypes.Entity? = nil,
            invoiceId: Swift.String? = nil,
            invoiceType: InvoicingClientTypes.InvoiceType? = nil,
            issuedDate: Foundation.Date? = nil,
            originalInvoiceId: Swift.String? = nil,
            paymentCurrencyAmount: InvoicingClientTypes.InvoiceCurrencyAmount? = nil,
            purchaseOrderNumber: Swift.String? = nil,
            taxCurrencyAmount: InvoicingClientTypes.InvoiceCurrencyAmount? = nil
        ) {
            self.accountId = accountId
            self.baseCurrencyAmount = baseCurrencyAmount
            self.billingPeriod = billingPeriod
            self.dueDate = dueDate
            self.entity = entity
            self.invoiceId = invoiceId
            self.invoiceType = invoiceType
            self.issuedDate = issuedDate
            self.originalInvoiceId = originalInvoiceId
            self.paymentCurrencyAmount = paymentCurrencyAmount
            self.purchaseOrderNumber = purchaseOrderNumber
            self.taxCurrencyAmount = taxCurrencyAmount
        }
    }
}

extension InvoicingClientTypes {

    /// Filters for your invoice summaries.
    public struct InvoiceSummariesFilter: Swift.Sendable {
        /// The billing period associated with the invoice documents.
        public var billingPeriod: InvoicingClientTypes.BillingPeriod?
        /// The name of the entity that issues the Amazon Web Services invoice.
        public var invoicingEntity: Swift.String?
        /// The date range for invoice summary retrieval.
        public var timeInterval: InvoicingClientTypes.DateInterval?

        public init(
            billingPeriod: InvoicingClientTypes.BillingPeriod? = nil,
            invoicingEntity: Swift.String? = nil,
            timeInterval: InvoicingClientTypes.DateInterval? = nil
        ) {
            self.billingPeriod = billingPeriod
            self.invoicingEntity = invoicingEntity
            self.timeInterval = timeInterval
        }
    }
}

extension InvoicingClientTypes {

    public enum ListInvoiceSummariesResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountId
        case invoiceId
        case sdkUnknown(Swift.String)

        public static var allCases: [ListInvoiceSummariesResourceType] {
            return [
                .accountId,
                .invoiceId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .invoiceId: return "INVOICE_ID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvoicingClientTypes {

    /// Specifies the invoice summary.
    public struct InvoiceSummariesSelector: Swift.Sendable {
        /// The query identifier type (INVOICE_ID or ACCOUNT_ID).
        /// This member is required.
        public var resourceType: InvoicingClientTypes.ListInvoiceSummariesResourceType?
        /// The value of the query identifier.
        /// This member is required.
        public var value: Swift.String?

        public init(
            resourceType: InvoicingClientTypes.ListInvoiceSummariesResourceType? = nil,
            value: Swift.String? = nil
        ) {
            self.resourceType = resourceType
            self.value = value
        }
    }
}

extension InvoicingClientTypes {

    /// An invoice unit is a set of mutually exclusive accounts that correspond to your business entity. Invoice units allow you separate Amazon Web Services account costs and configures your invoice for each business entity going forward.
    public struct InvoiceUnit: Swift.Sendable {
        /// The assigned description for an invoice unit. This information can't be modified or deleted.
        public var description: Swift.String?
        /// The account that receives invoices related to the invoice unit.
        public var invoiceReceiver: Swift.String?
        /// ARN to identify an invoice unit. This information can't be modified or deleted.
        public var invoiceUnitArn: Swift.String?
        /// The last time the invoice unit was updated. This is important to determine the version of invoice unit configuration used to create the invoices. Any invoice created after this modified time will use this invoice unit configuration.
        public var lastModified: Foundation.Date?
        /// A unique name that is distinctive within your Amazon Web Services.
        public var name: Swift.String?
        /// An InvoiceUnitRule object used the categorize invoice units.
        public var rule: InvoicingClientTypes.InvoiceUnitRule?
        /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
        public var taxInheritanceDisabled: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            invoiceReceiver: Swift.String? = nil,
            invoiceUnitArn: Swift.String? = nil,
            lastModified: Foundation.Date? = nil,
            name: Swift.String? = nil,
            rule: InvoicingClientTypes.InvoiceUnitRule? = nil,
            taxInheritanceDisabled: Swift.Bool? = false
        ) {
            self.description = description
            self.invoiceReceiver = invoiceReceiver
            self.invoiceUnitArn = invoiceUnitArn
            self.lastModified = lastModified
            self.name = name
            self.rule = rule
            self.taxInheritanceDisabled = taxInheritanceDisabled
        }
    }
}

public struct ListInvoiceSummariesInput: Swift.Sendable {
    /// Filters you can use to customize your invoice summary.
    public var filter: InvoicingClientTypes.InvoiceSummariesFilter?
    /// The maximum number of invoice summaries a paginated response can contain.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The option to retrieve details for a specific invoice by providing its unique ID. Alternatively, access information for all invoices linked to the account by providing an account ID.
    /// This member is required.
    public var selector: InvoicingClientTypes.InvoiceSummariesSelector?

    public init(
        filter: InvoicingClientTypes.InvoiceSummariesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        selector: InvoicingClientTypes.InvoiceSummariesSelector? = nil
    ) {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.selector = selector
    }
}

public struct ListInvoiceSummariesOutput: Swift.Sendable {
    /// List of key (summary level) invoice details without line item details.
    /// This member is required.
    public var invoiceSummaries: [InvoicingClientTypes.InvoiceSummary]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?

    public init(
        invoiceSummaries: [InvoicingClientTypes.InvoiceSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.invoiceSummaries = invoiceSummaries
        self.nextToken = nextToken
    }
}

public struct ListInvoiceUnitsInput: Swift.Sendable {
    /// The state of an invoice unit at a specified time. You can see legacy invoice units that are currently deleted if the AsOf time is set to before it was deleted. If an AsOf is not provided, the default value is the current time.
    public var asOf: Foundation.Date?
    /// An optional input to the list API. If multiple filters are specified, the returned list will be a configuration that match all of the provided filters. Supported filter types are InvoiceReceivers, Names, and Accounts.
    public var filters: InvoicingClientTypes.Filters?
    /// The maximum number of invoice units that can be returned.
    public var maxResults: Swift.Int?
    /// The next token used to indicate where the returned list should start from.
    public var nextToken: Swift.String?

    public init(
        asOf: Foundation.Date? = nil,
        filters: InvoicingClientTypes.Filters? = nil,
        maxResults: Swift.Int? = 500,
        nextToken: Swift.String? = nil
    ) {
        self.asOf = asOf
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListInvoiceUnitsOutput: Swift.Sendable {
    /// An invoice unit is a set of mutually exclusive accounts that correspond to your business entity.
    public var invoiceUnits: [InvoicingClientTypes.InvoiceUnit]?
    /// The next token used to indicate where the returned list should start from.
    public var nextToken: Swift.String?

    public init(
        invoiceUnits: [InvoicingClientTypes.InvoiceUnit]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.invoiceUnits = invoiceUnits
        self.nextToken = nextToken
    }
}

public struct ListProcurementPortalPreferencesInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension InvoicingClientTypes {

    /// Provides a summary of a procurement portal preference, including key identifiers and status information.
    public struct ProcurementPortalPreferenceSummary: Swift.Sendable {
        /// The Amazon Web Services account ID associated with this procurement portal preference summary.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// The domain identifier for the buyer in the procurement portal.
        /// This member is required.
        public var buyerDomain: InvoicingClientTypes.BuyerDomain?
        /// The unique identifier for the buyer in the procurement portal.
        /// This member is required.
        public var buyerIdentifier: Swift.String?
        /// The date and time when the procurement portal preference was created.
        /// This member is required.
        public var createDate: Foundation.Date?
        /// Indicates whether e-invoice delivery is enabled for this procurement portal preference.
        /// This member is required.
        public var einvoiceDeliveryEnabled: Swift.Bool?
        /// The current status of the e-invoice delivery preference in this summary.
        public var einvoiceDeliveryPreferenceStatus: InvoicingClientTypes.ProcurementPortalPreferenceStatus?
        /// The reason for the current e-invoice delivery preference status in this summary.
        public var einvoiceDeliveryPreferenceStatusReason: Swift.String?
        /// The date and time when the procurement portal preference was last updated.
        /// This member is required.
        public var lastUpdateDate: Foundation.Date?
        /// The name of the procurement portal.
        /// This member is required.
        public var procurementPortalName: InvoicingClientTypes.ProcurementPortalName?
        /// The Amazon Resource Name (ARN) of the procurement portal preference.
        /// This member is required.
        public var procurementPortalPreferenceArn: Swift.String?
        /// Indicates whether purchase order retrieval is enabled for this procurement portal preference.
        /// This member is required.
        public var purchaseOrderRetrievalEnabled: Swift.Bool?
        /// The current status of the purchase order retrieval preference in this summary.
        public var purchaseOrderRetrievalPreferenceStatus: InvoicingClientTypes.ProcurementPortalPreferenceStatus?
        /// The reason for the current purchase order retrieval preference status in this summary.
        public var purchaseOrderRetrievalPreferenceStatusReason: Swift.String?
        /// Specifies criteria for selecting which invoices should be processed using a particular procurement portal preference.
        public var selector: InvoicingClientTypes.ProcurementPortalPreferenceSelector?
        /// The domain identifier for the supplier in the procurement portal.
        /// This member is required.
        public var supplierDomain: InvoicingClientTypes.SupplierDomain?
        /// The unique identifier for the supplier in the procurement portal.
        /// This member is required.
        public var supplierIdentifier: Swift.String?
        /// The version number of the procurement portal preference configuration in this summary.
        /// This member is required.
        public var version: Swift.Int?

        public init(
            awsAccountId: Swift.String? = nil,
            buyerDomain: InvoicingClientTypes.BuyerDomain? = nil,
            buyerIdentifier: Swift.String? = nil,
            createDate: Foundation.Date? = nil,
            einvoiceDeliveryEnabled: Swift.Bool? = nil,
            einvoiceDeliveryPreferenceStatus: InvoicingClientTypes.ProcurementPortalPreferenceStatus? = nil,
            einvoiceDeliveryPreferenceStatusReason: Swift.String? = nil,
            lastUpdateDate: Foundation.Date? = nil,
            procurementPortalName: InvoicingClientTypes.ProcurementPortalName? = nil,
            procurementPortalPreferenceArn: Swift.String? = nil,
            purchaseOrderRetrievalEnabled: Swift.Bool? = nil,
            purchaseOrderRetrievalPreferenceStatus: InvoicingClientTypes.ProcurementPortalPreferenceStatus? = nil,
            purchaseOrderRetrievalPreferenceStatusReason: Swift.String? = nil,
            selector: InvoicingClientTypes.ProcurementPortalPreferenceSelector? = nil,
            supplierDomain: InvoicingClientTypes.SupplierDomain? = nil,
            supplierIdentifier: Swift.String? = nil,
            version: Swift.Int? = nil
        ) {
            self.awsAccountId = awsAccountId
            self.buyerDomain = buyerDomain
            self.buyerIdentifier = buyerIdentifier
            self.createDate = createDate
            self.einvoiceDeliveryEnabled = einvoiceDeliveryEnabled
            self.einvoiceDeliveryPreferenceStatus = einvoiceDeliveryPreferenceStatus
            self.einvoiceDeliveryPreferenceStatusReason = einvoiceDeliveryPreferenceStatusReason
            self.lastUpdateDate = lastUpdateDate
            self.procurementPortalName = procurementPortalName
            self.procurementPortalPreferenceArn = procurementPortalPreferenceArn
            self.purchaseOrderRetrievalEnabled = purchaseOrderRetrievalEnabled
            self.purchaseOrderRetrievalPreferenceStatus = purchaseOrderRetrievalPreferenceStatus
            self.purchaseOrderRetrievalPreferenceStatusReason = purchaseOrderRetrievalPreferenceStatusReason
            self.selector = selector
            self.supplierDomain = supplierDomain
            self.supplierIdentifier = supplierIdentifier
            self.version = version
        }
    }
}

public struct ListProcurementPortalPreferencesOutput: Swift.Sendable {
    /// The token to use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The list of procurement portal preferences associated with the Amazon Web Services account.
    public var procurementPortalPreferences: [InvoicingClientTypes.ProcurementPortalPreferenceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        procurementPortalPreferences: [InvoicingClientTypes.ProcurementPortalPreferenceSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.procurementPortalPreferences = procurementPortalPreferences
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of tags to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Adds a tag to a resource.
    public var resourceTags: [InvoicingClientTypes.ResourceTag]?

    public init(
        resourceTags: [InvoicingClientTypes.ResourceTag]? = nil
    ) {
        self.resourceTags = resourceTags
    }
}

public struct PutProcurementPortalPreferenceInput: Swift.Sendable {
    /// Updated list of contact information for portal administrators and technical contacts.
    /// This member is required.
    public var contacts: [InvoicingClientTypes.Contact]?
    /// Updated flag indicating whether e-invoice delivery is enabled for this procurement portal preference.
    /// This member is required.
    public var einvoiceDeliveryEnabled: Swift.Bool?
    /// Updated e-invoice delivery configuration including document types, attachment types, and customization settings for the portal.
    public var einvoiceDeliveryPreference: InvoicingClientTypes.EinvoiceDeliveryPreference?
    /// The updated endpoint URL where e-invoices will be delivered to the procurement portal. Must be a valid HTTPS URL.
    public var procurementPortalInstanceEndpoint: Swift.String?
    /// The Amazon Resource Name (ARN) of the procurement portal preference to update.
    /// This member is required.
    public var procurementPortalPreferenceArn: Swift.String?
    /// The updated shared secret or authentication credential for the procurement portal. This value must be encrypted at rest.
    public var procurementPortalSharedSecret: Swift.String?
    /// Updated flag indicating whether purchase order retrieval is enabled for this procurement portal preference.
    /// This member is required.
    public var purchaseOrderRetrievalEnabled: Swift.Bool?
    /// Specifies criteria for selecting which invoices should be processed using a particular procurement portal preference.
    public var selector: InvoicingClientTypes.ProcurementPortalPreferenceSelector?
    /// Updated configuration settings for the test environment of the procurement portal.
    public var testEnvPreference: InvoicingClientTypes.TestEnvPreferenceInput?

    public init(
        contacts: [InvoicingClientTypes.Contact]? = nil,
        einvoiceDeliveryEnabled: Swift.Bool? = nil,
        einvoiceDeliveryPreference: InvoicingClientTypes.EinvoiceDeliveryPreference? = nil,
        procurementPortalInstanceEndpoint: Swift.String? = nil,
        procurementPortalPreferenceArn: Swift.String? = nil,
        procurementPortalSharedSecret: Swift.String? = nil,
        purchaseOrderRetrievalEnabled: Swift.Bool? = nil,
        selector: InvoicingClientTypes.ProcurementPortalPreferenceSelector? = nil,
        testEnvPreference: InvoicingClientTypes.TestEnvPreferenceInput? = nil
    ) {
        self.contacts = contacts
        self.einvoiceDeliveryEnabled = einvoiceDeliveryEnabled
        self.einvoiceDeliveryPreference = einvoiceDeliveryPreference
        self.procurementPortalInstanceEndpoint = procurementPortalInstanceEndpoint
        self.procurementPortalPreferenceArn = procurementPortalPreferenceArn
        self.procurementPortalSharedSecret = procurementPortalSharedSecret
        self.purchaseOrderRetrievalEnabled = purchaseOrderRetrievalEnabled
        self.selector = selector
        self.testEnvPreference = testEnvPreference
    }
}

extension PutProcurementPortalPreferenceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutProcurementPortalPreferenceInput(einvoiceDeliveryEnabled: \(Swift.String(describing: einvoiceDeliveryEnabled)), einvoiceDeliveryPreference: \(Swift.String(describing: einvoiceDeliveryPreference)), procurementPortalInstanceEndpoint: \(Swift.String(describing: procurementPortalInstanceEndpoint)), procurementPortalPreferenceArn: \(Swift.String(describing: procurementPortalPreferenceArn)), purchaseOrderRetrievalEnabled: \(Swift.String(describing: purchaseOrderRetrievalEnabled)), selector: \(Swift.String(describing: selector)), testEnvPreference: \(Swift.String(describing: testEnvPreference)), contacts: \"CONTENT_REDACTED\", procurementPortalSharedSecret: \"CONTENT_REDACTED\")"}
}

public struct PutProcurementPortalPreferenceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated procurement portal preference.
    /// This member is required.
    public var procurementPortalPreferenceArn: Swift.String?

    public init(
        procurementPortalPreferenceArn: Swift.String? = nil
    ) {
        self.procurementPortalPreferenceArn = procurementPortalPreferenceArn
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds a tag to a resource.
    /// This member is required.
    public var resourceTags: [InvoicingClientTypes.ResourceTag]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTags: [InvoicingClientTypes.ResourceTag]? = nil
    ) {
        self.resourceArn = resourceArn
        self.resourceTags = resourceTags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys for the tags to be removed.
    /// This member is required.
    public var resourceTagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.resourceTagKeys = resourceTagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateInvoiceUnitInput: Swift.Sendable {
    /// The assigned description for an invoice unit. This information can't be modified or deleted.
    public var description: Swift.String?
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    /// This member is required.
    public var invoiceUnitArn: Swift.String?
    /// The InvoiceUnitRule object used to update invoice units.
    public var rule: InvoicingClientTypes.InvoiceUnitRule?
    /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
    public var taxInheritanceDisabled: Swift.Bool?

    public init(
        description: Swift.String? = nil,
        invoiceUnitArn: Swift.String? = nil,
        rule: InvoicingClientTypes.InvoiceUnitRule? = nil,
        taxInheritanceDisabled: Swift.Bool? = false
    ) {
        self.description = description
        self.invoiceUnitArn = invoiceUnitArn
        self.rule = rule
        self.taxInheritanceDisabled = taxInheritanceDisabled
    }
}

public struct UpdateInvoiceUnitOutput: Swift.Sendable {
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    public var invoiceUnitArn: Swift.String?

    public init(
        invoiceUnitArn: Swift.String? = nil
    ) {
        self.invoiceUnitArn = invoiceUnitArn
    }
}

public struct UpdateProcurementPortalPreferenceStatusInput: Swift.Sendable {
    /// The updated status of the e-invoice delivery preference.
    public var einvoiceDeliveryPreferenceStatus: InvoicingClientTypes.ProcurementPortalPreferenceStatus?
    /// The reason for the e-invoice delivery preference status update, providing context for the change.
    public var einvoiceDeliveryPreferenceStatusReason: Swift.String?
    /// The Amazon Resource Name (ARN) of the procurement portal preference to update.
    /// This member is required.
    public var procurementPortalPreferenceArn: Swift.String?
    /// The updated status of the purchase order retrieval preference.
    public var purchaseOrderRetrievalPreferenceStatus: InvoicingClientTypes.ProcurementPortalPreferenceStatus?
    /// The reason for the purchase order retrieval preference status update, providing context for the change.
    public var purchaseOrderRetrievalPreferenceStatusReason: Swift.String?

    public init(
        einvoiceDeliveryPreferenceStatus: InvoicingClientTypes.ProcurementPortalPreferenceStatus? = nil,
        einvoiceDeliveryPreferenceStatusReason: Swift.String? = nil,
        procurementPortalPreferenceArn: Swift.String? = nil,
        purchaseOrderRetrievalPreferenceStatus: InvoicingClientTypes.ProcurementPortalPreferenceStatus? = nil,
        purchaseOrderRetrievalPreferenceStatusReason: Swift.String? = nil
    ) {
        self.einvoiceDeliveryPreferenceStatus = einvoiceDeliveryPreferenceStatus
        self.einvoiceDeliveryPreferenceStatusReason = einvoiceDeliveryPreferenceStatusReason
        self.procurementPortalPreferenceArn = procurementPortalPreferenceArn
        self.purchaseOrderRetrievalPreferenceStatus = purchaseOrderRetrievalPreferenceStatus
        self.purchaseOrderRetrievalPreferenceStatusReason = purchaseOrderRetrievalPreferenceStatusReason
    }
}

public struct UpdateProcurementPortalPreferenceStatusOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the procurement portal preference with updated status.
    /// This member is required.
    public var procurementPortalPreferenceArn: Swift.String?

    public init(
        procurementPortalPreferenceArn: Swift.String? = nil
    ) {
        self.procurementPortalPreferenceArn = procurementPortalPreferenceArn
    }
}

extension BatchGetInvoiceProfileInput {

    static func urlPathProvider(_ value: BatchGetInvoiceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateInvoiceUnitInput {

    static func urlPathProvider(_ value: CreateInvoiceUnitInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProcurementPortalPreferenceInput {

    static func urlPathProvider(_ value: CreateProcurementPortalPreferenceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteInvoiceUnitInput {

    static func urlPathProvider(_ value: DeleteInvoiceUnitInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProcurementPortalPreferenceInput {

    static func urlPathProvider(_ value: DeleteProcurementPortalPreferenceInput) -> Swift.String? {
        return "/"
    }
}

extension GetInvoicePDFInput {

    static func urlPathProvider(_ value: GetInvoicePDFInput) -> Swift.String? {
        return "/"
    }
}

extension GetInvoiceUnitInput {

    static func urlPathProvider(_ value: GetInvoiceUnitInput) -> Swift.String? {
        return "/"
    }
}

extension GetProcurementPortalPreferenceInput {

    static func urlPathProvider(_ value: GetProcurementPortalPreferenceInput) -> Swift.String? {
        return "/"
    }
}

extension ListInvoiceSummariesInput {

    static func urlPathProvider(_ value: ListInvoiceSummariesInput) -> Swift.String? {
        return "/"
    }
}

extension ListInvoiceUnitsInput {

    static func urlPathProvider(_ value: ListInvoiceUnitsInput) -> Swift.String? {
        return "/"
    }
}

extension ListProcurementPortalPreferencesInput {

    static func urlPathProvider(_ value: ListProcurementPortalPreferencesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PutProcurementPortalPreferenceInput {

    static func urlPathProvider(_ value: PutProcurementPortalPreferenceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateInvoiceUnitInput {

    static func urlPathProvider(_ value: UpdateInvoiceUnitInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProcurementPortalPreferenceStatusInput {

    static func urlPathProvider(_ value: UpdateProcurementPortalPreferenceStatusInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetInvoiceProfileInput {

    static func write(value: BatchGetInvoiceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateInvoiceUnitInput {

    static func write(value: CreateInvoiceUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["InvoiceReceiver"].write(value.invoiceReceiver)
        try writer["Name"].write(value.name)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: InvoicingClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Rule"].write(value.rule, with: InvoicingClientTypes.InvoiceUnitRule.write(value:to:))
        try writer["TaxInheritanceDisabled"].write(value.taxInheritanceDisabled)
    }
}

extension CreateProcurementPortalPreferenceInput {

    static func write(value: CreateProcurementPortalPreferenceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BuyerDomain"].write(value.buyerDomain)
        try writer["BuyerIdentifier"].write(value.buyerIdentifier)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Contacts"].writeList(value.contacts, memberWritingClosure: InvoicingClientTypes.Contact.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EinvoiceDeliveryEnabled"].write(value.einvoiceDeliveryEnabled)
        try writer["EinvoiceDeliveryPreference"].write(value.einvoiceDeliveryPreference, with: InvoicingClientTypes.EinvoiceDeliveryPreference.write(value:to:))
        try writer["ProcurementPortalInstanceEndpoint"].write(value.procurementPortalInstanceEndpoint)
        try writer["ProcurementPortalName"].write(value.procurementPortalName)
        try writer["ProcurementPortalSharedSecret"].write(value.procurementPortalSharedSecret)
        try writer["PurchaseOrderRetrievalEnabled"].write(value.purchaseOrderRetrievalEnabled)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: InvoicingClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Selector"].write(value.selector, with: InvoicingClientTypes.ProcurementPortalPreferenceSelector.write(value:to:))
        try writer["SupplierDomain"].write(value.supplierDomain)
        try writer["SupplierIdentifier"].write(value.supplierIdentifier)
        try writer["TestEnvPreference"].write(value.testEnvPreference, with: InvoicingClientTypes.TestEnvPreferenceInput.write(value:to:))
    }
}

extension DeleteInvoiceUnitInput {

    static func write(value: DeleteInvoiceUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InvoiceUnitArn"].write(value.invoiceUnitArn)
    }
}

extension DeleteProcurementPortalPreferenceInput {

    static func write(value: DeleteProcurementPortalPreferenceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProcurementPortalPreferenceArn"].write(value.procurementPortalPreferenceArn)
    }
}

extension GetInvoicePDFInput {

    static func write(value: GetInvoicePDFInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InvoiceId"].write(value.invoiceId)
    }
}

extension GetInvoiceUnitInput {

    static func write(value: GetInvoiceUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AsOf"].writeTimestamp(value.asOf, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["InvoiceUnitArn"].write(value.invoiceUnitArn)
    }
}

extension GetProcurementPortalPreferenceInput {

    static func write(value: GetProcurementPortalPreferenceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProcurementPortalPreferenceArn"].write(value.procurementPortalPreferenceArn)
    }
}

extension ListInvoiceSummariesInput {

    static func write(value: ListInvoiceSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: InvoicingClientTypes.InvoiceSummariesFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Selector"].write(value.selector, with: InvoicingClientTypes.InvoiceSummariesSelector.write(value:to:))
    }
}

extension ListInvoiceUnitsInput {

    static func write(value: ListInvoiceUnitsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AsOf"].writeTimestamp(value.asOf, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Filters"].write(value.filters, with: InvoicingClientTypes.Filters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListProcurementPortalPreferencesInput {

    static func write(value: ListProcurementPortalPreferencesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension PutProcurementPortalPreferenceInput {

    static func write(value: PutProcurementPortalPreferenceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Contacts"].writeList(value.contacts, memberWritingClosure: InvoicingClientTypes.Contact.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EinvoiceDeliveryEnabled"].write(value.einvoiceDeliveryEnabled)
        try writer["EinvoiceDeliveryPreference"].write(value.einvoiceDeliveryPreference, with: InvoicingClientTypes.EinvoiceDeliveryPreference.write(value:to:))
        try writer["ProcurementPortalInstanceEndpoint"].write(value.procurementPortalInstanceEndpoint)
        try writer["ProcurementPortalPreferenceArn"].write(value.procurementPortalPreferenceArn)
        try writer["ProcurementPortalSharedSecret"].write(value.procurementPortalSharedSecret)
        try writer["PurchaseOrderRetrievalEnabled"].write(value.purchaseOrderRetrievalEnabled)
        try writer["Selector"].write(value.selector, with: InvoicingClientTypes.ProcurementPortalPreferenceSelector.write(value:to:))
        try writer["TestEnvPreference"].write(value.testEnvPreference, with: InvoicingClientTypes.TestEnvPreferenceInput.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: InvoicingClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceTagKeys"].writeList(value.resourceTagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateInvoiceUnitInput {

    static func write(value: UpdateInvoiceUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["InvoiceUnitArn"].write(value.invoiceUnitArn)
        try writer["Rule"].write(value.rule, with: InvoicingClientTypes.InvoiceUnitRule.write(value:to:))
        try writer["TaxInheritanceDisabled"].write(value.taxInheritanceDisabled)
    }
}

extension UpdateProcurementPortalPreferenceStatusInput {

    static func write(value: UpdateProcurementPortalPreferenceStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EinvoiceDeliveryPreferenceStatus"].write(value.einvoiceDeliveryPreferenceStatus)
        try writer["EinvoiceDeliveryPreferenceStatusReason"].write(value.einvoiceDeliveryPreferenceStatusReason)
        try writer["ProcurementPortalPreferenceArn"].write(value.procurementPortalPreferenceArn)
        try writer["PurchaseOrderRetrievalPreferenceStatus"].write(value.purchaseOrderRetrievalPreferenceStatus)
        try writer["PurchaseOrderRetrievalPreferenceStatusReason"].write(value.purchaseOrderRetrievalPreferenceStatusReason)
    }
}

extension BatchGetInvoiceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetInvoiceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetInvoiceProfileOutput()
        value.profiles = try reader["Profiles"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.InvoiceProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateInvoiceUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInvoiceUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInvoiceUnitOutput()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        return value
    }
}

extension CreateProcurementPortalPreferenceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProcurementPortalPreferenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProcurementPortalPreferenceOutput()
        value.procurementPortalPreferenceArn = try reader["ProcurementPortalPreferenceArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteInvoiceUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInvoiceUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInvoiceUnitOutput()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        return value
    }
}

extension DeleteProcurementPortalPreferenceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProcurementPortalPreferenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProcurementPortalPreferenceOutput()
        value.procurementPortalPreferenceArn = try reader["ProcurementPortalPreferenceArn"].readIfPresent() ?? ""
        return value
    }
}

extension GetInvoicePDFOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInvoicePDFOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInvoicePDFOutput()
        value.invoicePDF = try reader["InvoicePDF"].readIfPresent(with: InvoicingClientTypes.InvoicePDF.read(from:))
        return value
    }
}

extension GetInvoiceUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInvoiceUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInvoiceUnitOutput()
        value.description = try reader["Description"].readIfPresent()
        value.invoiceReceiver = try reader["InvoiceReceiver"].readIfPresent()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.rule = try reader["Rule"].readIfPresent(with: InvoicingClientTypes.InvoiceUnitRule.read(from:))
        value.taxInheritanceDisabled = try reader["TaxInheritanceDisabled"].readIfPresent()
        return value
    }
}

extension GetProcurementPortalPreferenceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProcurementPortalPreferenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProcurementPortalPreferenceOutput()
        value.procurementPortalPreference = try reader["ProcurementPortalPreference"].readIfPresent(with: InvoicingClientTypes.ProcurementPortalPreference.read(from:))
        return value
    }
}

extension ListInvoiceSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInvoiceSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInvoiceSummariesOutput()
        value.invoiceSummaries = try reader["InvoiceSummaries"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.InvoiceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInvoiceUnitsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInvoiceUnitsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInvoiceUnitsOutput()
        value.invoiceUnits = try reader["InvoiceUnits"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.InvoiceUnit.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListProcurementPortalPreferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProcurementPortalPreferencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProcurementPortalPreferencesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.procurementPortalPreferences = try reader["ProcurementPortalPreferences"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.ProcurementPortalPreferenceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutProcurementPortalPreferenceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutProcurementPortalPreferenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutProcurementPortalPreferenceOutput()
        value.procurementPortalPreferenceArn = try reader["ProcurementPortalPreferenceArn"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateInvoiceUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInvoiceUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateInvoiceUnitOutput()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        return value
    }
}

extension UpdateProcurementPortalPreferenceStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProcurementPortalPreferenceStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProcurementPortalPreferenceStatusOutput()
        value.procurementPortalPreferenceArn = try reader["ProcurementPortalPreferenceArn"].readIfPresent() ?? ""
        return value
    }
}

enum BatchGetInvoiceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInvoiceUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProcurementPortalPreferenceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingConflict": return try ConflictException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInvoiceUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProcurementPortalPreferenceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInvoicePDFOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInvoiceUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProcurementPortalPreferenceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingConflict": return try ConflictException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInvoiceSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInvoiceUnitsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProcurementPortalPreferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingConflict": return try ConflictException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutProcurementPortalPreferenceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingConflict": return try ConflictException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInvoiceUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProcurementPortalPreferenceStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingConflict": return try ConflictException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvoicingClientTypes.AmountBreakdown {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.AmountBreakdown {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.AmountBreakdown()
        value.subTotalAmount = try reader["SubTotalAmount"].readIfPresent()
        value.discounts = try reader["Discounts"].readIfPresent(with: InvoicingClientTypes.DiscountsBreakdown.read(from:))
        value.taxes = try reader["Taxes"].readIfPresent(with: InvoicingClientTypes.TaxesBreakdown.read(from:))
        value.fees = try reader["Fees"].readIfPresent(with: InvoicingClientTypes.FeesBreakdown.read(from:))
        return value
    }
}

extension InvoicingClientTypes.BillingPeriod {

    static func write(value: InvoicingClientTypes.BillingPeriod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Month"].write(value.month)
        try writer["Year"].write(value.year)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.BillingPeriod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.BillingPeriod()
        value.month = try reader["Month"].readIfPresent() ?? 0
        value.year = try reader["Year"].readIfPresent() ?? 0
        return value
    }
}

extension InvoicingClientTypes.Contact {

    static func write(value: InvoicingClientTypes.Contact?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Email"].write(value.email)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.Contact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.Contact()
        value.name = try reader["Name"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.CurrencyExchangeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.CurrencyExchangeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.CurrencyExchangeDetails()
        value.sourceCurrencyCode = try reader["SourceCurrencyCode"].readIfPresent()
        value.targetCurrencyCode = try reader["TargetCurrencyCode"].readIfPresent()
        value.rate = try reader["Rate"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.DateInterval {

    static func write(value: InvoicingClientTypes.DateInterval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndDate"].writeTimestamp(value.endDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartDate"].writeTimestamp(value.startDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension InvoicingClientTypes.DiscountsBreakdown {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.DiscountsBreakdown {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.DiscountsBreakdown()
        value.breakdown = try reader["Breakdown"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.DiscountsBreakdownAmount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalAmount = try reader["TotalAmount"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.DiscountsBreakdownAmount {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.DiscountsBreakdownAmount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.DiscountsBreakdownAmount()
        value.description = try reader["Description"].readIfPresent()
        value.amount = try reader["Amount"].readIfPresent()
        value.rate = try reader["Rate"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.EinvoiceDeliveryPreference {

    static func write(value: InvoicingClientTypes.EinvoiceDeliveryPreference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionTestingMethod"].write(value.connectionTestingMethod)
        try writer["EinvoiceDeliveryActivationDate"].writeTimestamp(value.einvoiceDeliveryActivationDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["EinvoiceDeliveryAttachmentTypes"].writeList(value.einvoiceDeliveryAttachmentTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<InvoicingClientTypes.EinvoiceDeliveryAttachmentType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EinvoiceDeliveryDocumentTypes"].writeList(value.einvoiceDeliveryDocumentTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<InvoicingClientTypes.EinvoiceDeliveryDocumentType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Protocol"].write(value.`protocol`)
        try writer["PurchaseOrderDataSources"].writeList(value.purchaseOrderDataSources, memberWritingClosure: InvoicingClientTypes.PurchaseOrderDataSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.EinvoiceDeliveryPreference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.EinvoiceDeliveryPreference()
        value.einvoiceDeliveryDocumentTypes = try reader["EinvoiceDeliveryDocumentTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<InvoicingClientTypes.EinvoiceDeliveryDocumentType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.einvoiceDeliveryAttachmentTypes = try reader["EinvoiceDeliveryAttachmentTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<InvoicingClientTypes.EinvoiceDeliveryAttachmentType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.`protocol` = try reader["Protocol"].readIfPresent() ?? .sdkUnknown("")
        value.purchaseOrderDataSources = try reader["PurchaseOrderDataSources"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.PurchaseOrderDataSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.connectionTestingMethod = try reader["ConnectionTestingMethod"].readIfPresent() ?? .sdkUnknown("")
        value.einvoiceDeliveryActivationDate = try reader["EinvoiceDeliveryActivationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension InvoicingClientTypes.Entity {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.Entity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.Entity()
        value.invoicingEntity = try reader["InvoicingEntity"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.FeesBreakdown {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.FeesBreakdown {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.FeesBreakdown()
        value.breakdown = try reader["Breakdown"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.FeesBreakdownAmount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalAmount = try reader["TotalAmount"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.FeesBreakdownAmount {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.FeesBreakdownAmount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.FeesBreakdownAmount()
        value.description = try reader["Description"].readIfPresent()
        value.amount = try reader["Amount"].readIfPresent()
        value.rate = try reader["Rate"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.Filters {

    static func write(value: InvoicingClientTypes.Filters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Accounts"].writeList(value.accounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BillSourceAccounts"].writeList(value.billSourceAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InvoiceReceivers"].writeList(value.invoiceReceivers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension InvoicingClientTypes.InvoiceCurrencyAmount {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceCurrencyAmount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceCurrencyAmount()
        value.totalAmount = try reader["TotalAmount"].readIfPresent()
        value.totalAmountBeforeTax = try reader["TotalAmountBeforeTax"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        value.amountBreakdown = try reader["AmountBreakdown"].readIfPresent(with: InvoicingClientTypes.AmountBreakdown.read(from:))
        value.currencyExchangeDetails = try reader["CurrencyExchangeDetails"].readIfPresent(with: InvoicingClientTypes.CurrencyExchangeDetails.read(from:))
        return value
    }
}

extension InvoicingClientTypes.InvoicePDF {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoicePDF {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoicePDF()
        value.invoiceId = try reader["InvoiceId"].readIfPresent()
        value.documentUrl = try reader["DocumentUrl"].readIfPresent()
        value.documentUrlExpirationDate = try reader["DocumentUrlExpirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.supplementalDocuments = try reader["SupplementalDocuments"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.SupplementalDocument.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension InvoicingClientTypes.InvoiceProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceProfile()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.receiverName = try reader["ReceiverName"].readIfPresent()
        value.receiverAddress = try reader["ReceiverAddress"].readIfPresent(with: InvoicingClientTypes.ReceiverAddress.read(from:))
        value.receiverEmail = try reader["ReceiverEmail"].readIfPresent()
        value.issuer = try reader["Issuer"].readIfPresent()
        value.taxRegistrationNumber = try reader["TaxRegistrationNumber"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.InvoiceSummariesFilter {

    static func write(value: InvoicingClientTypes.InvoiceSummariesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriod"].write(value.billingPeriod, with: InvoicingClientTypes.BillingPeriod.write(value:to:))
        try writer["InvoicingEntity"].write(value.invoicingEntity)
        try writer["TimeInterval"].write(value.timeInterval, with: InvoicingClientTypes.DateInterval.write(value:to:))
    }
}

extension InvoicingClientTypes.InvoiceSummariesSelector {

    static func write(value: InvoicingClientTypes.InvoiceSummariesSelector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceType"].write(value.resourceType)
        try writer["Value"].write(value.value)
    }
}

extension InvoicingClientTypes.InvoiceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceSummary()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.invoiceId = try reader["InvoiceId"].readIfPresent()
        value.issuedDate = try reader["IssuedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dueDate = try reader["DueDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.entity = try reader["Entity"].readIfPresent(with: InvoicingClientTypes.Entity.read(from:))
        value.billingPeriod = try reader["BillingPeriod"].readIfPresent(with: InvoicingClientTypes.BillingPeriod.read(from:))
        value.invoiceType = try reader["InvoiceType"].readIfPresent()
        value.originalInvoiceId = try reader["OriginalInvoiceId"].readIfPresent()
        value.purchaseOrderNumber = try reader["PurchaseOrderNumber"].readIfPresent()
        value.baseCurrencyAmount = try reader["BaseCurrencyAmount"].readIfPresent(with: InvoicingClientTypes.InvoiceCurrencyAmount.read(from:))
        value.taxCurrencyAmount = try reader["TaxCurrencyAmount"].readIfPresent(with: InvoicingClientTypes.InvoiceCurrencyAmount.read(from:))
        value.paymentCurrencyAmount = try reader["PaymentCurrencyAmount"].readIfPresent(with: InvoicingClientTypes.InvoiceCurrencyAmount.read(from:))
        return value
    }
}

extension InvoicingClientTypes.InvoiceUnit {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceUnit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceUnit()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        value.invoiceReceiver = try reader["InvoiceReceiver"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.taxInheritanceDisabled = try reader["TaxInheritanceDisabled"].readIfPresent()
        value.rule = try reader["Rule"].readIfPresent(with: InvoicingClientTypes.InvoiceUnitRule.read(from:))
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension InvoicingClientTypes.InvoiceUnitRule {

    static func write(value: InvoicingClientTypes.InvoiceUnitRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillSourceAccounts"].writeList(value.billSourceAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LinkedAccounts"].writeList(value.linkedAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceUnitRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceUnitRule()
        value.linkedAccounts = try reader["LinkedAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.billSourceAccounts = try reader["BillSourceAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension InvoicingClientTypes.ProcurementPortalPreference {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.ProcurementPortalPreference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.ProcurementPortalPreference()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent() ?? ""
        value.procurementPortalPreferenceArn = try reader["ProcurementPortalPreferenceArn"].readIfPresent() ?? ""
        value.procurementPortalName = try reader["ProcurementPortalName"].readIfPresent() ?? .sdkUnknown("")
        value.buyerDomain = try reader["BuyerDomain"].readIfPresent() ?? .sdkUnknown("")
        value.buyerIdentifier = try reader["BuyerIdentifier"].readIfPresent() ?? ""
        value.supplierDomain = try reader["SupplierDomain"].readIfPresent() ?? .sdkUnknown("")
        value.supplierIdentifier = try reader["SupplierIdentifier"].readIfPresent() ?? ""
        value.selector = try reader["Selector"].readIfPresent(with: InvoicingClientTypes.ProcurementPortalPreferenceSelector.read(from:))
        value.procurementPortalSharedSecret = try reader["ProcurementPortalSharedSecret"].readIfPresent()
        value.procurementPortalInstanceEndpoint = try reader["ProcurementPortalInstanceEndpoint"].readIfPresent()
        value.purchaseOrderRetrievalEndpoint = try reader["PurchaseOrderRetrievalEndpoint"].readIfPresent()
        value.testEnvPreference = try reader["TestEnvPreference"].readIfPresent(with: InvoicingClientTypes.TestEnvPreference.read(from:))
        value.einvoiceDeliveryEnabled = try reader["EinvoiceDeliveryEnabled"].readIfPresent() ?? false
        value.einvoiceDeliveryPreference = try reader["EinvoiceDeliveryPreference"].readIfPresent(with: InvoicingClientTypes.EinvoiceDeliveryPreference.read(from:))
        value.purchaseOrderRetrievalEnabled = try reader["PurchaseOrderRetrievalEnabled"].readIfPresent() ?? false
        value.contacts = try reader["Contacts"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.Contact.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.einvoiceDeliveryPreferenceStatus = try reader["EinvoiceDeliveryPreferenceStatus"].readIfPresent()
        value.einvoiceDeliveryPreferenceStatusReason = try reader["EinvoiceDeliveryPreferenceStatusReason"].readIfPresent()
        value.purchaseOrderRetrievalPreferenceStatus = try reader["PurchaseOrderRetrievalPreferenceStatus"].readIfPresent()
        value.purchaseOrderRetrievalPreferenceStatusReason = try reader["PurchaseOrderRetrievalPreferenceStatusReason"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateDate = try reader["LastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension InvoicingClientTypes.ProcurementPortalPreferenceSelector {

    static func write(value: InvoicingClientTypes.ProcurementPortalPreferenceSelector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InvoiceUnitArns"].writeList(value.invoiceUnitArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SellerOfRecords"].writeList(value.sellerOfRecords, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.ProcurementPortalPreferenceSelector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.ProcurementPortalPreferenceSelector()
        value.invoiceUnitArns = try reader["InvoiceUnitArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sellerOfRecords = try reader["SellerOfRecords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension InvoicingClientTypes.ProcurementPortalPreferenceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.ProcurementPortalPreferenceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.ProcurementPortalPreferenceSummary()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent() ?? ""
        value.procurementPortalPreferenceArn = try reader["ProcurementPortalPreferenceArn"].readIfPresent() ?? ""
        value.procurementPortalName = try reader["ProcurementPortalName"].readIfPresent() ?? .sdkUnknown("")
        value.buyerDomain = try reader["BuyerDomain"].readIfPresent() ?? .sdkUnknown("")
        value.buyerIdentifier = try reader["BuyerIdentifier"].readIfPresent() ?? ""
        value.supplierDomain = try reader["SupplierDomain"].readIfPresent() ?? .sdkUnknown("")
        value.supplierIdentifier = try reader["SupplierIdentifier"].readIfPresent() ?? ""
        value.selector = try reader["Selector"].readIfPresent(with: InvoicingClientTypes.ProcurementPortalPreferenceSelector.read(from:))
        value.einvoiceDeliveryEnabled = try reader["EinvoiceDeliveryEnabled"].readIfPresent() ?? false
        value.purchaseOrderRetrievalEnabled = try reader["PurchaseOrderRetrievalEnabled"].readIfPresent() ?? false
        value.einvoiceDeliveryPreferenceStatus = try reader["EinvoiceDeliveryPreferenceStatus"].readIfPresent()
        value.einvoiceDeliveryPreferenceStatusReason = try reader["EinvoiceDeliveryPreferenceStatusReason"].readIfPresent()
        value.purchaseOrderRetrievalPreferenceStatus = try reader["PurchaseOrderRetrievalPreferenceStatus"].readIfPresent()
        value.purchaseOrderRetrievalPreferenceStatusReason = try reader["PurchaseOrderRetrievalPreferenceStatusReason"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateDate = try reader["LastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension InvoicingClientTypes.PurchaseOrderDataSource {

    static func write(value: InvoicingClientTypes.PurchaseOrderDataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EinvoiceDeliveryDocumentType"].write(value.einvoiceDeliveryDocumentType)
        try writer["PurchaseOrderDataSourceType"].write(value.purchaseOrderDataSourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.PurchaseOrderDataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.PurchaseOrderDataSource()
        value.einvoiceDeliveryDocumentType = try reader["EinvoiceDeliveryDocumentType"].readIfPresent()
        value.purchaseOrderDataSourceType = try reader["PurchaseOrderDataSourceType"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.ReceiverAddress {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.ReceiverAddress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.ReceiverAddress()
        value.addressLine1 = try reader["AddressLine1"].readIfPresent()
        value.addressLine2 = try reader["AddressLine2"].readIfPresent()
        value.addressLine3 = try reader["AddressLine3"].readIfPresent()
        value.districtOrCounty = try reader["DistrictOrCounty"].readIfPresent()
        value.city = try reader["City"].readIfPresent()
        value.stateOrRegion = try reader["StateOrRegion"].readIfPresent()
        value.countryCode = try reader["CountryCode"].readIfPresent()
        value.companyName = try reader["CompanyName"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.ResourceTag {

    static func write(value: InvoicingClientTypes.ResourceTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.ResourceTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.ResourceTag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension InvoicingClientTypes.SupplementalDocument {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.SupplementalDocument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.SupplementalDocument()
        value.documentUrl = try reader["DocumentUrl"].readIfPresent()
        value.documentUrlExpirationDate = try reader["DocumentUrlExpirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension InvoicingClientTypes.TaxesBreakdown {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.TaxesBreakdown {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.TaxesBreakdown()
        value.breakdown = try reader["Breakdown"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.TaxesBreakdownAmount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalAmount = try reader["TotalAmount"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.TaxesBreakdownAmount {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.TaxesBreakdownAmount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.TaxesBreakdownAmount()
        value.description = try reader["Description"].readIfPresent()
        value.amount = try reader["Amount"].readIfPresent()
        value.rate = try reader["Rate"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.TestEnvPreference {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.TestEnvPreference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.TestEnvPreference()
        value.buyerDomain = try reader["BuyerDomain"].readIfPresent() ?? .sdkUnknown("")
        value.buyerIdentifier = try reader["BuyerIdentifier"].readIfPresent() ?? ""
        value.supplierDomain = try reader["SupplierDomain"].readIfPresent() ?? .sdkUnknown("")
        value.supplierIdentifier = try reader["SupplierIdentifier"].readIfPresent() ?? ""
        value.procurementPortalSharedSecret = try reader["ProcurementPortalSharedSecret"].readIfPresent()
        value.procurementPortalInstanceEndpoint = try reader["ProcurementPortalInstanceEndpoint"].readIfPresent()
        value.purchaseOrderRetrievalEndpoint = try reader["PurchaseOrderRetrievalEndpoint"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.TestEnvPreferenceInput {

    static func write(value: InvoicingClientTypes.TestEnvPreferenceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BuyerDomain"].write(value.buyerDomain)
        try writer["BuyerIdentifier"].write(value.buyerIdentifier)
        try writer["ProcurementPortalInstanceEndpoint"].write(value.procurementPortalInstanceEndpoint)
        try writer["ProcurementPortalSharedSecret"].write(value.procurementPortalSharedSecret)
        try writer["SupplierDomain"].write(value.supplierDomain)
        try writer["SupplierIdentifier"].write(value.supplierIdentifier)
    }
}

extension InvoicingClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

public enum InvoicingClientTypes {}
