//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// You don't have sufficient access to perform this action.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingAccessDenied" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

extension InvoicingClientTypes {

    /// The discounted amount.
    public struct DiscountsBreakdownAmount: Swift.Sendable {
        /// The discounted amount.
        public var amount: Swift.String?
        /// The list of discounts information.
        public var description: Swift.String?
        /// The details for the discount rate..
        public var rate: Swift.String?

        public init(
            amount: Swift.String? = nil,
            description: Swift.String? = nil,
            rate: Swift.String? = nil
        ) {
            self.amount = amount
            self.description = description
            self.rate = rate
        }
    }
}

extension InvoicingClientTypes {

    /// The discounts details.
    public struct DiscountsBreakdown: Swift.Sendable {
        /// The list of discounts information.
        public var breakdown: [InvoicingClientTypes.DiscountsBreakdownAmount]?
        /// The discount's total amount.
        public var totalAmount: Swift.String?

        public init(
            breakdown: [InvoicingClientTypes.DiscountsBreakdownAmount]? = nil,
            totalAmount: Swift.String? = nil
        ) {
            self.breakdown = breakdown
            self.totalAmount = totalAmount
        }
    }
}

extension InvoicingClientTypes {

    /// The fee amount.
    public struct FeesBreakdownAmount: Swift.Sendable {
        /// The fee amount.
        public var amount: Swift.String?
        /// The list of fees information.
        public var description: Swift.String?
        /// Details about the rate amount.
        public var rate: Swift.String?

        public init(
            amount: Swift.String? = nil,
            description: Swift.String? = nil,
            rate: Swift.String? = nil
        ) {
            self.amount = amount
            self.description = description
            self.rate = rate
        }
    }
}

extension InvoicingClientTypes {

    /// The details of fees.
    public struct FeesBreakdown: Swift.Sendable {
        /// The list of fees information.
        public var breakdown: [InvoicingClientTypes.FeesBreakdownAmount]?
        /// The total amount of fees.
        public var totalAmount: Swift.String?

        public init(
            breakdown: [InvoicingClientTypes.FeesBreakdownAmount]? = nil,
            totalAmount: Swift.String? = nil
        ) {
            self.breakdown = breakdown
            self.totalAmount = totalAmount
        }
    }
}

extension InvoicingClientTypes {

    /// The tax amount.
    public struct TaxesBreakdownAmount: Swift.Sendable {
        /// The tax amount.
        public var amount: Swift.String?
        /// The details of the taxes.
        public var description: Swift.String?
        /// The details of the tax rate.
        public var rate: Swift.String?

        public init(
            amount: Swift.String? = nil,
            description: Swift.String? = nil,
            rate: Swift.String? = nil
        ) {
            self.amount = amount
            self.description = description
            self.rate = rate
        }
    }
}

extension InvoicingClientTypes {

    /// The details of the taxes.
    public struct TaxesBreakdown: Swift.Sendable {
        /// A list of tax information.
        public var breakdown: [InvoicingClientTypes.TaxesBreakdownAmount]?
        /// The total amount for your taxes.
        public var totalAmount: Swift.String?

        public init(
            breakdown: [InvoicingClientTypes.TaxesBreakdownAmount]? = nil,
            totalAmount: Swift.String? = nil
        ) {
            self.breakdown = breakdown
            self.totalAmount = totalAmount
        }
    }
}

extension InvoicingClientTypes {

    /// Details about how the total amount was calculated and categorized.
    public struct AmountBreakdown: Swift.Sendable {
        /// The discounted amount.
        public var discounts: InvoicingClientTypes.DiscountsBreakdown?
        /// The fee amount.
        public var fees: InvoicingClientTypes.FeesBreakdown?
        /// The total of a set of the breakdown.
        public var subTotalAmount: Swift.String?
        /// The tax amount.
        public var taxes: InvoicingClientTypes.TaxesBreakdown?

        public init(
            discounts: InvoicingClientTypes.DiscountsBreakdown? = nil,
            fees: InvoicingClientTypes.FeesBreakdown? = nil,
            subTotalAmount: Swift.String? = nil,
            taxes: InvoicingClientTypes.TaxesBreakdown? = nil
        ) {
            self.discounts = discounts
            self.fees = fees
            self.subTotalAmount = subTotalAmount
            self.taxes = taxes
        }
    }
}

/// The processing request failed because of an unknown error, exception, or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The processing request failed because of an unknown error, exception, or failure.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingInternalServer" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The resource could not be found.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingResourceNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingThrottling" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension InvoicingClientTypes {

    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        /// This member is required.
        public var message: Swift.String?
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension InvoicingClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountMembershipError
        case cannotParse
        case duplicateInvoiceUnit
        case expiredNextToken
        case fieldValidationFailed
        case invalidInput
        case invalidNextToken
        case maxAccountsExceeded
        case maxInvoiceUnitsExceeded
        case mutualExclusionError
        case nonMembersPresent
        case other
        case taxSettingsError
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .accountMembershipError,
                .cannotParse,
                .duplicateInvoiceUnit,
                .expiredNextToken,
                .fieldValidationFailed,
                .invalidInput,
                .invalidNextToken,
                .maxAccountsExceeded,
                .maxInvoiceUnitsExceeded,
                .mutualExclusionError,
                .nonMembersPresent,
                .other,
                .taxSettingsError,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountMembershipError: return "accountMembershipError"
            case .cannotParse: return "cannotParse"
            case .duplicateInvoiceUnit: return "duplicateInvoiceUnit"
            case .expiredNextToken: return "expiredNextToken"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .invalidInput: return "invalidInput"
            case .invalidNextToken: return "invalidNextToken"
            case .maxAccountsExceeded: return "maxAccountsExceeded"
            case .maxInvoiceUnitsExceeded: return "maxInvoiceUnitsExceeded"
            case .mutualExclusionError: return "mutualExclusionError"
            case .nonMembersPresent: return "nonMemberPresent"
            case .other: return "other"
            case .taxSettingsError: return "taxSettingsError"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var fieldList: [InvoicingClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// You don't have sufficient access to perform this action.
        public internal(set) var reason: InvoicingClientTypes.ValidationExceptionReason? = nil
        /// You don't have sufficient access to perform this action.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingValidation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [InvoicingClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: InvoicingClientTypes.ValidationExceptionReason? = nil,
        resourceName: Swift.String? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
        self.properties.resourceName = resourceName
    }
}

public struct BatchGetInvoiceProfileInput: Swift.Sendable {
    /// Retrieves the corresponding invoice profile data for these account IDs.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    ) {
        self.accountIds = accountIds
    }
}

extension InvoicingClientTypes {

    /// The details of the address associated with the receiver.
    public struct ReceiverAddress: Swift.Sendable {
        /// The first line of the address.
        public var addressLine1: Swift.String?
        /// The second line of the address, if applicable.
        public var addressLine2: Swift.String?
        /// The third line of the address, if applicable.
        public var addressLine3: Swift.String?
        /// The city that the address is in.
        public var city: Swift.String?
        /// A unique company name.
        public var companyName: Swift.String?
        /// The country code for the country the address is in.
        public var countryCode: Swift.String?
        /// The district or country the address is located in.
        public var districtOrCounty: Swift.String?
        /// The postal code associated with the address.
        public var postalCode: Swift.String?
        /// The state, region, or province the address is located.
        public var stateOrRegion: Swift.String?

        public init(
            addressLine1: Swift.String? = nil,
            addressLine2: Swift.String? = nil,
            addressLine3: Swift.String? = nil,
            city: Swift.String? = nil,
            companyName: Swift.String? = nil,
            countryCode: Swift.String? = nil,
            districtOrCounty: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            stateOrRegion: Swift.String? = nil
        ) {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.addressLine3 = addressLine3
            self.city = city
            self.companyName = companyName
            self.countryCode = countryCode
            self.districtOrCounty = districtOrCounty
            self.postalCode = postalCode
            self.stateOrRegion = stateOrRegion
        }
    }
}

extension InvoicingClientTypes.ReceiverAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension InvoicingClientTypes {

    /// Contains high-level information about the invoice receiver.
    public struct InvoiceProfile: Swift.Sendable {
        /// The account ID the invoice profile is generated for.
        public var accountId: Swift.String?
        /// This specifies the issuing entity of the invoice.
        public var issuer: Swift.String?
        /// The address of the receiver that will be printed on the invoice.
        public var receiverAddress: InvoicingClientTypes.ReceiverAddress?
        /// The email address for the invoice profile receiver.
        public var receiverEmail: Swift.String?
        /// The name of the person receiving the invoice profile.
        public var receiverName: Swift.String?
        /// Your Tax Registration Number (TRN) information.
        public var taxRegistrationNumber: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            issuer: Swift.String? = nil,
            receiverAddress: InvoicingClientTypes.ReceiverAddress? = nil,
            receiverEmail: Swift.String? = nil,
            receiverName: Swift.String? = nil,
            taxRegistrationNumber: Swift.String? = nil
        ) {
            self.accountId = accountId
            self.issuer = issuer
            self.receiverAddress = receiverAddress
            self.receiverEmail = receiverEmail
            self.receiverName = receiverName
            self.taxRegistrationNumber = taxRegistrationNumber
        }
    }
}

extension InvoicingClientTypes.InvoiceProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvoiceProfile(accountId: \(Swift.String(describing: accountId)), issuer: \(Swift.String(describing: issuer)), receiverName: \(Swift.String(describing: receiverName)), receiverAddress: \"CONTENT_REDACTED\", receiverEmail: \"CONTENT_REDACTED\", taxRegistrationNumber: \"CONTENT_REDACTED\")"}
}

public struct BatchGetInvoiceProfileOutput: Swift.Sendable {
    /// A list of invoice profiles corresponding to the requested accounts.
    public var profiles: [InvoicingClientTypes.InvoiceProfile]?

    public init(
        profiles: [InvoicingClientTypes.InvoiceProfile]? = nil
    ) {
        self.profiles = profiles
    }
}

extension InvoicingClientTypes {

    /// The billing period for which you want to retrieve invoice-related documents.
    public struct BillingPeriod: Swift.Sendable {
        /// The billing period month.
        /// This member is required.
        public var month: Swift.Int?
        /// The billing period year.
        /// This member is required.
        public var year: Swift.Int?

        public init(
            month: Swift.Int? = nil,
            year: Swift.Int? = nil
        ) {
            self.month = month
            self.year = year
        }
    }
}

extension InvoicingClientTypes {

    /// The tag structure that contains a tag key and value.
    public struct ResourceTag: Swift.Sendable {
        /// The object key of your of your resource tag.
        /// This member is required.
        public var key: Swift.String?
        /// The specific value of the resource tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

extension InvoicingClientTypes {

    /// This is used to categorize the invoice unit. Values are Amazon Web Services account IDs. Currently, the only supported rule is LINKED_ACCOUNT.
    public struct InvoiceUnitRule: Swift.Sendable {
        /// The list of LINKED_ACCOUNT IDs where charges are included within the invoice unit.
        public var linkedAccounts: [Swift.String]?

        public init(
            linkedAccounts: [Swift.String]? = nil
        ) {
            self.linkedAccounts = linkedAccounts
        }
    }
}

public struct CreateInvoiceUnitInput: Swift.Sendable {
    /// The invoice unit's description. This can be changed at a later time.
    public var description: Swift.String?
    /// The Amazon Web Services account ID chosen to be the receiver of an invoice unit. All invoices generated for that invoice unit will be sent to this account ID.
    /// This member is required.
    public var invoiceReceiver: Swift.String?
    /// The unique name of the invoice unit that is shown on the generated invoice. This can't be changed once it is set. To change this name, you must delete the invoice unit recreate.
    /// This member is required.
    public var name: Swift.String?
    /// The tag structure that contains a tag key and value.
    public var resourceTags: [InvoicingClientTypes.ResourceTag]?
    /// The InvoiceUnitRule object used to create invoice units.
    /// This member is required.
    public var rule: InvoicingClientTypes.InvoiceUnitRule?
    /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
    public var taxInheritanceDisabled: Swift.Bool?

    public init(
        description: Swift.String? = nil,
        invoiceReceiver: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceTags: [InvoicingClientTypes.ResourceTag]? = nil,
        rule: InvoicingClientTypes.InvoiceUnitRule? = nil,
        taxInheritanceDisabled: Swift.Bool? = false
    ) {
        self.description = description
        self.invoiceReceiver = invoiceReceiver
        self.name = name
        self.resourceTags = resourceTags
        self.rule = rule
        self.taxInheritanceDisabled = taxInheritanceDisabled
    }
}

public struct CreateInvoiceUnitOutput: Swift.Sendable {
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    public var invoiceUnitArn: Swift.String?

    public init(
        invoiceUnitArn: Swift.String? = nil
    ) {
        self.invoiceUnitArn = invoiceUnitArn
    }
}

extension InvoicingClientTypes {

    /// The details of currency exchange.
    public struct CurrencyExchangeDetails: Swift.Sendable {
        /// The currency exchange rate.
        public var rate: Swift.String?
        /// The exchange source currency.
        public var sourceCurrencyCode: Swift.String?
        /// The exchange target currency.
        public var targetCurrencyCode: Swift.String?

        public init(
            rate: Swift.String? = nil,
            sourceCurrencyCode: Swift.String? = nil,
            targetCurrencyCode: Swift.String? = nil
        ) {
            self.rate = rate
            self.sourceCurrencyCode = sourceCurrencyCode
            self.targetCurrencyCode = targetCurrencyCode
        }
    }
}

extension InvoicingClientTypes {

    /// The time period that you want invoice-related documents for.
    public struct DateInterval: Swift.Sendable {
        /// The end of the time period that you want invoice-related documents for. The end date is exclusive. For example, if end is 2019-01-10, Amazon Web Services retrieves invoice-related documents from the start date up to, but not including, 2018-01-10.
        /// This member is required.
        public var endDate: Foundation.Date?
        /// The beginning of the time period that you want invoice-related documents for. The start date is inclusive. For example, if start is 2019-01-01, AWS retrieves invoices starting at 2019-01-01 up to the end date.
        /// This member is required.
        public var startDate: Foundation.Date?

        public init(
            endDate: Foundation.Date? = nil,
            startDate: Foundation.Date? = nil
        ) {
            self.endDate = endDate
            self.startDate = startDate
        }
    }
}

public struct DeleteInvoiceUnitInput: Swift.Sendable {
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    /// This member is required.
    public var invoiceUnitArn: Swift.String?

    public init(
        invoiceUnitArn: Swift.String? = nil
    ) {
        self.invoiceUnitArn = invoiceUnitArn
    }
}

public struct DeleteInvoiceUnitOutput: Swift.Sendable {
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    public var invoiceUnitArn: Swift.String?

    public init(
        invoiceUnitArn: Swift.String? = nil
    ) {
        self.invoiceUnitArn = invoiceUnitArn
    }
}

extension InvoicingClientTypes {

    /// The organization name providing Amazon Web Services services.
    public struct Entity: Swift.Sendable {
        /// The name of the entity that issues the Amazon Web Services invoice.
        public var invoicingEntity: Swift.String?

        public init(
            invoicingEntity: Swift.String? = nil
        ) {
            self.invoicingEntity = invoicingEntity
        }
    }
}

extension InvoicingClientTypes {

    /// An optional input to the list API. If multiple filters are specified, the returned list will be a configuration that match all of the provided filters. Supported filter types are InvoiceReceivers, Names, and Accounts.
    public struct Filters: Swift.Sendable {
        /// You can specify a list of Amazon Web Services account IDs inside filters to return invoice units that match only the specified accounts. If multiple accounts are provided, the result is an OR condition (match any) of the specified accounts. The specified account IDs are matched with either the receiver or the linked accounts in the rules.
        public var accounts: [Swift.String]?
        /// You can specify a list of Amazon Web Services account IDs inside filters to return invoice units that match only the specified accounts. If multiple accounts are provided, the result is an OR condition (match any) of the specified accounts. This filter only matches the specified accounts on the invoice receivers of the invoice units.
        public var invoiceReceivers: [Swift.String]?
        /// An optional input to the list API. You can specify a list of invoice unit names inside filters to return invoice units that match only the specified invoice unit names. If multiple names are provided, the result is an OR condition (match any) of the specified invoice unit names.
        public var names: [Swift.String]?

        public init(
            accounts: [Swift.String]? = nil,
            invoiceReceivers: [Swift.String]? = nil,
            names: [Swift.String]? = nil
        ) {
            self.accounts = accounts
            self.invoiceReceivers = invoiceReceivers
            self.names = names
        }
    }
}

public struct GetInvoiceUnitInput: Swift.Sendable {
    /// The state of an invoice unit at a specified time. You can see legacy invoice units that are currently deleted if the AsOf time is set to before it was deleted. If an AsOf is not provided, the default value is the current time.
    public var asOf: Foundation.Date?
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    /// This member is required.
    public var invoiceUnitArn: Swift.String?

    public init(
        asOf: Foundation.Date? = nil,
        invoiceUnitArn: Swift.String? = nil
    ) {
        self.asOf = asOf
        self.invoiceUnitArn = invoiceUnitArn
    }
}

public struct GetInvoiceUnitOutput: Swift.Sendable {
    /// The assigned description for an invoice unit.
    public var description: Swift.String?
    /// The Amazon Web Services account ID chosen to be the receiver of an invoice unit. All invoices generated for that invoice unit will be sent to this account ID.
    public var invoiceReceiver: Swift.String?
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    public var invoiceUnitArn: Swift.String?
    /// The most recent date the invoice unit response was updated.
    public var lastModified: Foundation.Date?
    /// The unique name of the invoice unit that is shown on the generated invoice.
    public var name: Swift.String?
    /// This is used to categorize the invoice unit. Values are Amazon Web Services account IDs. Currently, the only supported rule is LINKED_ACCOUNT.
    public var rule: InvoicingClientTypes.InvoiceUnitRule?
    /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
    public var taxInheritanceDisabled: Swift.Bool?

    public init(
        description: Swift.String? = nil,
        invoiceReceiver: Swift.String? = nil,
        invoiceUnitArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        name: Swift.String? = nil,
        rule: InvoicingClientTypes.InvoiceUnitRule? = nil,
        taxInheritanceDisabled: Swift.Bool? = false
    ) {
        self.description = description
        self.invoiceReceiver = invoiceReceiver
        self.invoiceUnitArn = invoiceUnitArn
        self.lastModified = lastModified
        self.name = name
        self.rule = rule
        self.taxInheritanceDisabled = taxInheritanceDisabled
    }
}

extension InvoicingClientTypes {

    /// The amount charged after taxes, in the preferred currency.
    public struct InvoiceCurrencyAmount: Swift.Sendable {
        /// Details about the invoice currency amount.
        public var amountBreakdown: InvoicingClientTypes.AmountBreakdown?
        /// The currency dominion of the invoice document.
        public var currencyCode: Swift.String?
        /// The details of currency exchange.
        public var currencyExchangeDetails: InvoicingClientTypes.CurrencyExchangeDetails?
        /// The invoice currency amount.
        public var totalAmount: Swift.String?
        /// Details about the invoice total amount before tax.
        public var totalAmountBeforeTax: Swift.String?

        public init(
            amountBreakdown: InvoicingClientTypes.AmountBreakdown? = nil,
            currencyCode: Swift.String? = nil,
            currencyExchangeDetails: InvoicingClientTypes.CurrencyExchangeDetails? = nil,
            totalAmount: Swift.String? = nil,
            totalAmountBeforeTax: Swift.String? = nil
        ) {
            self.amountBreakdown = amountBreakdown
            self.currencyCode = currencyCode
            self.currencyExchangeDetails = currencyExchangeDetails
            self.totalAmount = totalAmount
            self.totalAmountBeforeTax = totalAmountBeforeTax
        }
    }
}

extension InvoicingClientTypes {

    public enum InvoiceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creditMemo
        case invoice
        case sdkUnknown(Swift.String)

        public static var allCases: [InvoiceType] {
            return [
                .creditMemo,
                .invoice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creditMemo: return "CREDIT_MEMO"
            case .invoice: return "INVOICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvoicingClientTypes {

    /// The invoice that the API retrieved.
    public struct InvoiceSummary: Swift.Sendable {
        /// The Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The summary with the product and service currency.
        public var baseCurrencyAmount: InvoicingClientTypes.InvoiceCurrencyAmount?
        /// The billing period of the invoice-related document.
        public var billingPeriod: InvoicingClientTypes.BillingPeriod?
        /// The invoice due date.
        public var dueDate: Foundation.Date?
        /// The organization name providing Amazon Web Services services.
        public var entity: InvoicingClientTypes.Entity?
        /// The invoice ID.
        public var invoiceId: Swift.String?
        /// The type of invoice.
        public var invoiceType: InvoicingClientTypes.InvoiceType?
        /// The issued date of the invoice.
        public var issuedDate: Foundation.Date?
        /// The initial or original invoice ID.
        public var originalInvoiceId: Swift.String?
        /// The summary with the customer configured currency.
        public var paymentCurrencyAmount: InvoicingClientTypes.InvoiceCurrencyAmount?
        /// The purchase order number associated to the invoice.
        public var purchaseOrderNumber: Swift.String?
        /// The summary with the tax currency.
        public var taxCurrencyAmount: InvoicingClientTypes.InvoiceCurrencyAmount?

        public init(
            accountId: Swift.String? = nil,
            baseCurrencyAmount: InvoicingClientTypes.InvoiceCurrencyAmount? = nil,
            billingPeriod: InvoicingClientTypes.BillingPeriod? = nil,
            dueDate: Foundation.Date? = nil,
            entity: InvoicingClientTypes.Entity? = nil,
            invoiceId: Swift.String? = nil,
            invoiceType: InvoicingClientTypes.InvoiceType? = nil,
            issuedDate: Foundation.Date? = nil,
            originalInvoiceId: Swift.String? = nil,
            paymentCurrencyAmount: InvoicingClientTypes.InvoiceCurrencyAmount? = nil,
            purchaseOrderNumber: Swift.String? = nil,
            taxCurrencyAmount: InvoicingClientTypes.InvoiceCurrencyAmount? = nil
        ) {
            self.accountId = accountId
            self.baseCurrencyAmount = baseCurrencyAmount
            self.billingPeriod = billingPeriod
            self.dueDate = dueDate
            self.entity = entity
            self.invoiceId = invoiceId
            self.invoiceType = invoiceType
            self.issuedDate = issuedDate
            self.originalInvoiceId = originalInvoiceId
            self.paymentCurrencyAmount = paymentCurrencyAmount
            self.purchaseOrderNumber = purchaseOrderNumber
            self.taxCurrencyAmount = taxCurrencyAmount
        }
    }
}

extension InvoicingClientTypes {

    /// Filters for your invoice summaries.
    public struct InvoiceSummariesFilter: Swift.Sendable {
        /// The billing period associated with the invoice documents.
        public var billingPeriod: InvoicingClientTypes.BillingPeriod?
        /// The name of the entity that issues the Amazon Web Services invoice.
        public var invoicingEntity: Swift.String?
        /// The date range for invoice summary retrieval.
        public var timeInterval: InvoicingClientTypes.DateInterval?

        public init(
            billingPeriod: InvoicingClientTypes.BillingPeriod? = nil,
            invoicingEntity: Swift.String? = nil,
            timeInterval: InvoicingClientTypes.DateInterval? = nil
        ) {
            self.billingPeriod = billingPeriod
            self.invoicingEntity = invoicingEntity
            self.timeInterval = timeInterval
        }
    }
}

extension InvoicingClientTypes {

    public enum ListInvoiceSummariesResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountId
        case invoiceId
        case sdkUnknown(Swift.String)

        public static var allCases: [ListInvoiceSummariesResourceType] {
            return [
                .accountId,
                .invoiceId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .invoiceId: return "INVOICE_ID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvoicingClientTypes {

    /// Specifies the invoice summary.
    public struct InvoiceSummariesSelector: Swift.Sendable {
        /// The query identifier type (INVOICE_ID or ACCOUNT_ID).
        /// This member is required.
        public var resourceType: InvoicingClientTypes.ListInvoiceSummariesResourceType?
        /// The value of the query identifier.
        /// This member is required.
        public var value: Swift.String?

        public init(
            resourceType: InvoicingClientTypes.ListInvoiceSummariesResourceType? = nil,
            value: Swift.String? = nil
        ) {
            self.resourceType = resourceType
            self.value = value
        }
    }
}

extension InvoicingClientTypes {

    /// An invoice unit is a set of mutually exclusive accounts that correspond to your business entity. Invoice units allow you separate Amazon Web Services account costs and configures your invoice for each business entity going forward.
    public struct InvoiceUnit: Swift.Sendable {
        /// The assigned description for an invoice unit. This information can't be modified or deleted.
        public var description: Swift.String?
        /// The account that receives invoices related to the invoice unit.
        public var invoiceReceiver: Swift.String?
        /// ARN to identify an invoice unit. This information can't be modified or deleted.
        public var invoiceUnitArn: Swift.String?
        /// The last time the invoice unit was updated. This is important to determine the version of invoice unit configuration used to create the invoices. Any invoice created after this modified time will use this invoice unit configuration.
        public var lastModified: Foundation.Date?
        /// A unique name that is distinctive within your Amazon Web Services.
        public var name: Swift.String?
        /// An InvoiceUnitRule object used the categorize invoice units.
        public var rule: InvoicingClientTypes.InvoiceUnitRule?
        /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
        public var taxInheritanceDisabled: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            invoiceReceiver: Swift.String? = nil,
            invoiceUnitArn: Swift.String? = nil,
            lastModified: Foundation.Date? = nil,
            name: Swift.String? = nil,
            rule: InvoicingClientTypes.InvoiceUnitRule? = nil,
            taxInheritanceDisabled: Swift.Bool? = false
        ) {
            self.description = description
            self.invoiceReceiver = invoiceReceiver
            self.invoiceUnitArn = invoiceUnitArn
            self.lastModified = lastModified
            self.name = name
            self.rule = rule
            self.taxInheritanceDisabled = taxInheritanceDisabled
        }
    }
}

public struct ListInvoiceSummariesInput: Swift.Sendable {
    /// Filters you can use to customize your invoice summary.
    public var filter: InvoicingClientTypes.InvoiceSummariesFilter?
    /// The maximum number of invoice summaries a paginated response can contain.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The option to retrieve details for a specific invoice by providing its unique ID. Alternatively, access information for all invoices linked to the account by providing an account ID.
    /// This member is required.
    public var selector: InvoicingClientTypes.InvoiceSummariesSelector?

    public init(
        filter: InvoicingClientTypes.InvoiceSummariesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        selector: InvoicingClientTypes.InvoiceSummariesSelector? = nil
    ) {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.selector = selector
    }
}

public struct ListInvoiceSummariesOutput: Swift.Sendable {
    /// List of key (summary level) invoice details without line item details.
    /// This member is required.
    public var invoiceSummaries: [InvoicingClientTypes.InvoiceSummary]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?

    public init(
        invoiceSummaries: [InvoicingClientTypes.InvoiceSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.invoiceSummaries = invoiceSummaries
        self.nextToken = nextToken
    }
}

public struct ListInvoiceUnitsInput: Swift.Sendable {
    /// The state of an invoice unit at a specified time. You can see legacy invoice units that are currently deleted if the AsOf time is set to before it was deleted. If an AsOf is not provided, the default value is the current time.
    public var asOf: Foundation.Date?
    /// An optional input to the list API. If multiple filters are specified, the returned list will be a configuration that match all of the provided filters. Supported filter types are InvoiceReceivers, Names, and Accounts.
    public var filters: InvoicingClientTypes.Filters?
    /// The maximum number of invoice units that can be returned.
    public var maxResults: Swift.Int?
    /// The next token used to indicate where the returned list should start from.
    public var nextToken: Swift.String?

    public init(
        asOf: Foundation.Date? = nil,
        filters: InvoicingClientTypes.Filters? = nil,
        maxResults: Swift.Int? = 500,
        nextToken: Swift.String? = nil
    ) {
        self.asOf = asOf
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListInvoiceUnitsOutput: Swift.Sendable {
    /// An invoice unit is a set of mutually exclusive accounts that correspond to your business entity.
    public var invoiceUnits: [InvoicingClientTypes.InvoiceUnit]?
    /// The next token used to indicate where the returned list should start from.
    public var nextToken: Swift.String?

    public init(
        invoiceUnits: [InvoicingClientTypes.InvoiceUnit]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.invoiceUnits = invoiceUnits
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of tags to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Adds a tag to a resource.
    public var resourceTags: [InvoicingClientTypes.ResourceTag]?

    public init(
        resourceTags: [InvoicingClientTypes.ResourceTag]? = nil
    ) {
        self.resourceTags = resourceTags
    }
}

/// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account limits. The error message describes the limit exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingServiceQuotaExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds a tag to a resource.
    /// This member is required.
    public var resourceTags: [InvoicingClientTypes.ResourceTag]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTags: [InvoicingClientTypes.ResourceTag]? = nil
    ) {
        self.resourceArn = resourceArn
        self.resourceTags = resourceTags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys for the tags to be removed.
    /// This member is required.
    public var resourceTagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.resourceTagKeys = resourceTagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateInvoiceUnitInput: Swift.Sendable {
    /// The assigned description for an invoice unit. This information can't be modified or deleted.
    public var description: Swift.String?
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    /// This member is required.
    public var invoiceUnitArn: Swift.String?
    /// The InvoiceUnitRule object used to update invoice units.
    public var rule: InvoicingClientTypes.InvoiceUnitRule?
    /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
    public var taxInheritanceDisabled: Swift.Bool?

    public init(
        description: Swift.String? = nil,
        invoiceUnitArn: Swift.String? = nil,
        rule: InvoicingClientTypes.InvoiceUnitRule? = nil,
        taxInheritanceDisabled: Swift.Bool? = false
    ) {
        self.description = description
        self.invoiceUnitArn = invoiceUnitArn
        self.rule = rule
        self.taxInheritanceDisabled = taxInheritanceDisabled
    }
}

public struct UpdateInvoiceUnitOutput: Swift.Sendable {
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    public var invoiceUnitArn: Swift.String?

    public init(
        invoiceUnitArn: Swift.String? = nil
    ) {
        self.invoiceUnitArn = invoiceUnitArn
    }
}

extension BatchGetInvoiceProfileInput {

    static func urlPathProvider(_ value: BatchGetInvoiceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateInvoiceUnitInput {

    static func urlPathProvider(_ value: CreateInvoiceUnitInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteInvoiceUnitInput {

    static func urlPathProvider(_ value: DeleteInvoiceUnitInput) -> Swift.String? {
        return "/"
    }
}

extension GetInvoiceUnitInput {

    static func urlPathProvider(_ value: GetInvoiceUnitInput) -> Swift.String? {
        return "/"
    }
}

extension ListInvoiceSummariesInput {

    static func urlPathProvider(_ value: ListInvoiceSummariesInput) -> Swift.String? {
        return "/"
    }
}

extension ListInvoiceUnitsInput {

    static func urlPathProvider(_ value: ListInvoiceUnitsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateInvoiceUnitInput {

    static func urlPathProvider(_ value: UpdateInvoiceUnitInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetInvoiceProfileInput {

    static func write(value: BatchGetInvoiceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateInvoiceUnitInput {

    static func write(value: CreateInvoiceUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["InvoiceReceiver"].write(value.invoiceReceiver)
        try writer["Name"].write(value.name)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: InvoicingClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Rule"].write(value.rule, with: InvoicingClientTypes.InvoiceUnitRule.write(value:to:))
        try writer["TaxInheritanceDisabled"].write(value.taxInheritanceDisabled)
    }
}

extension DeleteInvoiceUnitInput {

    static func write(value: DeleteInvoiceUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InvoiceUnitArn"].write(value.invoiceUnitArn)
    }
}

extension GetInvoiceUnitInput {

    static func write(value: GetInvoiceUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AsOf"].writeTimestamp(value.asOf, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["InvoiceUnitArn"].write(value.invoiceUnitArn)
    }
}

extension ListInvoiceSummariesInput {

    static func write(value: ListInvoiceSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: InvoicingClientTypes.InvoiceSummariesFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Selector"].write(value.selector, with: InvoicingClientTypes.InvoiceSummariesSelector.write(value:to:))
    }
}

extension ListInvoiceUnitsInput {

    static func write(value: ListInvoiceUnitsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AsOf"].writeTimestamp(value.asOf, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Filters"].write(value.filters, with: InvoicingClientTypes.Filters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: InvoicingClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceTagKeys"].writeList(value.resourceTagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateInvoiceUnitInput {

    static func write(value: UpdateInvoiceUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["InvoiceUnitArn"].write(value.invoiceUnitArn)
        try writer["Rule"].write(value.rule, with: InvoicingClientTypes.InvoiceUnitRule.write(value:to:))
        try writer["TaxInheritanceDisabled"].write(value.taxInheritanceDisabled)
    }
}

extension BatchGetInvoiceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetInvoiceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetInvoiceProfileOutput()
        value.profiles = try reader["Profiles"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.InvoiceProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateInvoiceUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInvoiceUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInvoiceUnitOutput()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        return value
    }
}

extension DeleteInvoiceUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInvoiceUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInvoiceUnitOutput()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        return value
    }
}

extension GetInvoiceUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInvoiceUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInvoiceUnitOutput()
        value.description = try reader["Description"].readIfPresent()
        value.invoiceReceiver = try reader["InvoiceReceiver"].readIfPresent()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.rule = try reader["Rule"].readIfPresent(with: InvoicingClientTypes.InvoiceUnitRule.read(from:))
        value.taxInheritanceDisabled = try reader["TaxInheritanceDisabled"].readIfPresent()
        return value
    }
}

extension ListInvoiceSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInvoiceSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInvoiceSummariesOutput()
        value.invoiceSummaries = try reader["InvoiceSummaries"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.InvoiceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInvoiceUnitsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInvoiceUnitsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInvoiceUnitsOutput()
        value.invoiceUnits = try reader["InvoiceUnits"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.InvoiceUnit.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateInvoiceUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInvoiceUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateInvoiceUnitOutput()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        return value
    }
}

enum BatchGetInvoiceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInvoiceUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInvoiceUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInvoiceUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInvoiceSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInvoiceUnitsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInvoiceUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvoicingClientTypes.InvoiceProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceProfile()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.receiverName = try reader["ReceiverName"].readIfPresent()
        value.receiverAddress = try reader["ReceiverAddress"].readIfPresent(with: InvoicingClientTypes.ReceiverAddress.read(from:))
        value.receiverEmail = try reader["ReceiverEmail"].readIfPresent()
        value.issuer = try reader["Issuer"].readIfPresent()
        value.taxRegistrationNumber = try reader["TaxRegistrationNumber"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.ReceiverAddress {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.ReceiverAddress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.ReceiverAddress()
        value.addressLine1 = try reader["AddressLine1"].readIfPresent()
        value.addressLine2 = try reader["AddressLine2"].readIfPresent()
        value.addressLine3 = try reader["AddressLine3"].readIfPresent()
        value.districtOrCounty = try reader["DistrictOrCounty"].readIfPresent()
        value.city = try reader["City"].readIfPresent()
        value.stateOrRegion = try reader["StateOrRegion"].readIfPresent()
        value.countryCode = try reader["CountryCode"].readIfPresent()
        value.companyName = try reader["CompanyName"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.InvoiceUnitRule {

    static func write(value: InvoicingClientTypes.InvoiceUnitRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LinkedAccounts"].writeList(value.linkedAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceUnitRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceUnitRule()
        value.linkedAccounts = try reader["LinkedAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension InvoicingClientTypes.InvoiceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceSummary()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.invoiceId = try reader["InvoiceId"].readIfPresent()
        value.issuedDate = try reader["IssuedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dueDate = try reader["DueDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.entity = try reader["Entity"].readIfPresent(with: InvoicingClientTypes.Entity.read(from:))
        value.billingPeriod = try reader["BillingPeriod"].readIfPresent(with: InvoicingClientTypes.BillingPeriod.read(from:))
        value.invoiceType = try reader["InvoiceType"].readIfPresent()
        value.originalInvoiceId = try reader["OriginalInvoiceId"].readIfPresent()
        value.purchaseOrderNumber = try reader["PurchaseOrderNumber"].readIfPresent()
        value.baseCurrencyAmount = try reader["BaseCurrencyAmount"].readIfPresent(with: InvoicingClientTypes.InvoiceCurrencyAmount.read(from:))
        value.taxCurrencyAmount = try reader["TaxCurrencyAmount"].readIfPresent(with: InvoicingClientTypes.InvoiceCurrencyAmount.read(from:))
        value.paymentCurrencyAmount = try reader["PaymentCurrencyAmount"].readIfPresent(with: InvoicingClientTypes.InvoiceCurrencyAmount.read(from:))
        return value
    }
}

extension InvoicingClientTypes.InvoiceCurrencyAmount {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceCurrencyAmount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceCurrencyAmount()
        value.totalAmount = try reader["TotalAmount"].readIfPresent()
        value.totalAmountBeforeTax = try reader["TotalAmountBeforeTax"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        value.amountBreakdown = try reader["AmountBreakdown"].readIfPresent(with: InvoicingClientTypes.AmountBreakdown.read(from:))
        value.currencyExchangeDetails = try reader["CurrencyExchangeDetails"].readIfPresent(with: InvoicingClientTypes.CurrencyExchangeDetails.read(from:))
        return value
    }
}

extension InvoicingClientTypes.CurrencyExchangeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.CurrencyExchangeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.CurrencyExchangeDetails()
        value.sourceCurrencyCode = try reader["SourceCurrencyCode"].readIfPresent()
        value.targetCurrencyCode = try reader["TargetCurrencyCode"].readIfPresent()
        value.rate = try reader["Rate"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.AmountBreakdown {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.AmountBreakdown {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.AmountBreakdown()
        value.subTotalAmount = try reader["SubTotalAmount"].readIfPresent()
        value.discounts = try reader["Discounts"].readIfPresent(with: InvoicingClientTypes.DiscountsBreakdown.read(from:))
        value.taxes = try reader["Taxes"].readIfPresent(with: InvoicingClientTypes.TaxesBreakdown.read(from:))
        value.fees = try reader["Fees"].readIfPresent(with: InvoicingClientTypes.FeesBreakdown.read(from:))
        return value
    }
}

extension InvoicingClientTypes.FeesBreakdown {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.FeesBreakdown {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.FeesBreakdown()
        value.breakdown = try reader["Breakdown"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.FeesBreakdownAmount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalAmount = try reader["TotalAmount"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.FeesBreakdownAmount {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.FeesBreakdownAmount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.FeesBreakdownAmount()
        value.description = try reader["Description"].readIfPresent()
        value.amount = try reader["Amount"].readIfPresent()
        value.rate = try reader["Rate"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.TaxesBreakdown {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.TaxesBreakdown {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.TaxesBreakdown()
        value.breakdown = try reader["Breakdown"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.TaxesBreakdownAmount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalAmount = try reader["TotalAmount"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.TaxesBreakdownAmount {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.TaxesBreakdownAmount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.TaxesBreakdownAmount()
        value.description = try reader["Description"].readIfPresent()
        value.amount = try reader["Amount"].readIfPresent()
        value.rate = try reader["Rate"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.DiscountsBreakdown {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.DiscountsBreakdown {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.DiscountsBreakdown()
        value.breakdown = try reader["Breakdown"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.DiscountsBreakdownAmount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalAmount = try reader["TotalAmount"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.DiscountsBreakdownAmount {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.DiscountsBreakdownAmount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.DiscountsBreakdownAmount()
        value.description = try reader["Description"].readIfPresent()
        value.amount = try reader["Amount"].readIfPresent()
        value.rate = try reader["Rate"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.BillingPeriod {

    static func write(value: InvoicingClientTypes.BillingPeriod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Month"].write(value.month)
        try writer["Year"].write(value.year)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.BillingPeriod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.BillingPeriod()
        value.month = try reader["Month"].readIfPresent() ?? 0
        value.year = try reader["Year"].readIfPresent() ?? 0
        return value
    }
}

extension InvoicingClientTypes.Entity {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.Entity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.Entity()
        value.invoicingEntity = try reader["InvoicingEntity"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.InvoiceUnit {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceUnit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceUnit()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        value.invoiceReceiver = try reader["InvoiceReceiver"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.taxInheritanceDisabled = try reader["TaxInheritanceDisabled"].readIfPresent()
        value.rule = try reader["Rule"].readIfPresent(with: InvoicingClientTypes.InvoiceUnitRule.read(from:))
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension InvoicingClientTypes.ResourceTag {

    static func write(value: InvoicingClientTypes.ResourceTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.ResourceTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.ResourceTag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension InvoicingClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension InvoicingClientTypes.InvoiceSummariesSelector {

    static func write(value: InvoicingClientTypes.InvoiceSummariesSelector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceType"].write(value.resourceType)
        try writer["Value"].write(value.value)
    }
}

extension InvoicingClientTypes.InvoiceSummariesFilter {

    static func write(value: InvoicingClientTypes.InvoiceSummariesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriod"].write(value.billingPeriod, with: InvoicingClientTypes.BillingPeriod.write(value:to:))
        try writer["InvoicingEntity"].write(value.invoicingEntity)
        try writer["TimeInterval"].write(value.timeInterval, with: InvoicingClientTypes.DateInterval.write(value:to:))
    }
}

extension InvoicingClientTypes.DateInterval {

    static func write(value: InvoicingClientTypes.DateInterval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndDate"].writeTimestamp(value.endDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartDate"].writeTimestamp(value.startDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension InvoicingClientTypes.Filters {

    static func write(value: InvoicingClientTypes.Filters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Accounts"].writeList(value.accounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InvoiceReceivers"].writeList(value.invoiceReceivers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum InvoicingClientTypes {}
