//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// You don't have sufficient access to perform this action.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingAccessDenied" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

/// The processing request failed because of an unknown error, exception, or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The processing request failed because of an unknown error, exception, or failure.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingInternalServer" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The resource could not be found.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingResourceNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingThrottling" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvoicingClientTypes {

    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        /// This member is required.
        public var message: Swift.String?
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension InvoicingClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountMembershipError
        case cannotParse
        case duplicateInvoiceUnit
        case expiredNextToken
        case fieldValidationFailed
        case invalidInput
        case invalidNextToken
        case maxAccountsExceeded
        case maxInvoiceUnitsExceeded
        case mutualExclusionError
        case nonMembersPresent
        case other
        case taxSettingsError
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .accountMembershipError,
                .cannotParse,
                .duplicateInvoiceUnit,
                .expiredNextToken,
                .fieldValidationFailed,
                .invalidInput,
                .invalidNextToken,
                .maxAccountsExceeded,
                .maxInvoiceUnitsExceeded,
                .mutualExclusionError,
                .nonMembersPresent,
                .other,
                .taxSettingsError,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountMembershipError: return "accountMembershipError"
            case .cannotParse: return "cannotParse"
            case .duplicateInvoiceUnit: return "duplicateInvoiceUnit"
            case .expiredNextToken: return "expiredNextToken"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .invalidInput: return "invalidInput"
            case .invalidNextToken: return "invalidNextToken"
            case .maxAccountsExceeded: return "maxAccountsExceeded"
            case .maxInvoiceUnitsExceeded: return "maxInvoiceUnitsExceeded"
            case .mutualExclusionError: return "mutualExclusionError"
            case .nonMembersPresent: return "nonMemberPresent"
            case .other: return "other"
            case .taxSettingsError: return "taxSettingsError"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var fieldList: [InvoicingClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// You don't have sufficient access to perform this action.
        public internal(set) var reason: InvoicingClientTypes.ValidationExceptionReason? = nil
        /// You don't have sufficient access to perform this action.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingValidation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [InvoicingClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: InvoicingClientTypes.ValidationExceptionReason? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
        self.properties.resourceName = resourceName
    }
}

public struct BatchGetInvoiceProfileInput: Swift.Sendable {
    /// Retrieves the corresponding invoice profile data for these account IDs.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

extension InvoicingClientTypes {

    /// The details of the address associated with the receiver.
    public struct ReceiverAddress: Swift.Sendable {
        /// The first line of the address.
        public var addressLine1: Swift.String?
        /// The second line of the address, if applicable.
        public var addressLine2: Swift.String?
        /// The third line of the address, if applicable.
        public var addressLine3: Swift.String?
        /// The city that the address is in.
        public var city: Swift.String?
        /// A unique company name.
        public var companyName: Swift.String?
        /// The country code for the country the address is in.
        public var countryCode: Swift.String?
        /// The district or country the address is located in.
        public var districtOrCounty: Swift.String?
        /// The postal code associated with the address.
        public var postalCode: Swift.String?
        /// The state, region, or province the address is located.
        public var stateOrRegion: Swift.String?

        public init(
            addressLine1: Swift.String? = nil,
            addressLine2: Swift.String? = nil,
            addressLine3: Swift.String? = nil,
            city: Swift.String? = nil,
            companyName: Swift.String? = nil,
            countryCode: Swift.String? = nil,
            districtOrCounty: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            stateOrRegion: Swift.String? = nil
        )
        {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.addressLine3 = addressLine3
            self.city = city
            self.companyName = companyName
            self.countryCode = countryCode
            self.districtOrCounty = districtOrCounty
            self.postalCode = postalCode
            self.stateOrRegion = stateOrRegion
        }
    }
}

extension InvoicingClientTypes.ReceiverAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension InvoicingClientTypes {

    /// Contains high-level information about the invoice receiver.
    public struct InvoiceProfile: Swift.Sendable {
        /// The account ID the invoice profile is generated for.
        public var accountId: Swift.String?
        /// This specifies the issuing entity of the invoice.
        public var issuer: Swift.String?
        /// The address of the receiver that will be printed on the invoice.
        public var receiverAddress: InvoicingClientTypes.ReceiverAddress?
        /// The email address for the invoice profile receiver.
        public var receiverEmail: Swift.String?
        /// The name of the person receiving the invoice profile.
        public var receiverName: Swift.String?
        /// Your Tax Registration Number (TRN) information.
        public var taxRegistrationNumber: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            issuer: Swift.String? = nil,
            receiverAddress: InvoicingClientTypes.ReceiverAddress? = nil,
            receiverEmail: Swift.String? = nil,
            receiverName: Swift.String? = nil,
            taxRegistrationNumber: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.issuer = issuer
            self.receiverAddress = receiverAddress
            self.receiverEmail = receiverEmail
            self.receiverName = receiverName
            self.taxRegistrationNumber = taxRegistrationNumber
        }
    }
}

extension InvoicingClientTypes.InvoiceProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvoiceProfile(accountId: \(Swift.String(describing: accountId)), issuer: \(Swift.String(describing: issuer)), receiverName: \(Swift.String(describing: receiverName)), receiverAddress: \"CONTENT_REDACTED\", receiverEmail: \"CONTENT_REDACTED\", taxRegistrationNumber: \"CONTENT_REDACTED\")"}
}

public struct BatchGetInvoiceProfileOutput: Swift.Sendable {
    /// A list of invoice profiles corresponding to the requested accounts.
    public var profiles: [InvoicingClientTypes.InvoiceProfile]?

    public init(
        profiles: [InvoicingClientTypes.InvoiceProfile]? = nil
    )
    {
        self.profiles = profiles
    }
}

extension InvoicingClientTypes {

    /// The tag structure that contains a tag key and value.
    public struct ResourceTag: Swift.Sendable {
        /// The object key of your of your resource tag.
        /// This member is required.
        public var key: Swift.String?
        /// The specific value of the resource tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension InvoicingClientTypes {

    /// This is used to categorize the invoice unit. Values are Amazon Web Services account IDs. Currently, the only supported rule is LINKED_ACCOUNT.
    public struct InvoiceUnitRule: Swift.Sendable {
        /// The list of LINKED_ACCOUNT IDs where charges are included within the invoice unit.
        public var linkedAccounts: [Swift.String]?

        public init(
            linkedAccounts: [Swift.String]? = nil
        )
        {
            self.linkedAccounts = linkedAccounts
        }
    }
}

public struct CreateInvoiceUnitInput: Swift.Sendable {
    /// The invoice unit's description. This can be changed at a later time.
    public var description: Swift.String?
    /// The Amazon Web Services account ID chosen to be the receiver of an invoice unit. All invoices generated for that invoice unit will be sent to this account ID.
    /// This member is required.
    public var invoiceReceiver: Swift.String?
    /// The unique name of the invoice unit that is shown on the generated invoice. This can't be changed once it is set. To change this name, you must delete the invoice unit recreate.
    /// This member is required.
    public var name: Swift.String?
    /// The tag structure that contains a tag key and value.
    public var resourceTags: [InvoicingClientTypes.ResourceTag]?
    /// The InvoiceUnitRule object used to create invoice units.
    /// This member is required.
    public var rule: InvoicingClientTypes.InvoiceUnitRule?
    /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
    public var taxInheritanceDisabled: Swift.Bool?

    public init(
        description: Swift.String? = nil,
        invoiceReceiver: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceTags: [InvoicingClientTypes.ResourceTag]? = nil,
        rule: InvoicingClientTypes.InvoiceUnitRule? = nil,
        taxInheritanceDisabled: Swift.Bool? = false
    )
    {
        self.description = description
        self.invoiceReceiver = invoiceReceiver
        self.name = name
        self.resourceTags = resourceTags
        self.rule = rule
        self.taxInheritanceDisabled = taxInheritanceDisabled
    }
}

public struct CreateInvoiceUnitOutput: Swift.Sendable {
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    public var invoiceUnitArn: Swift.String?

    public init(
        invoiceUnitArn: Swift.String? = nil
    )
    {
        self.invoiceUnitArn = invoiceUnitArn
    }
}

public struct DeleteInvoiceUnitInput: Swift.Sendable {
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    /// This member is required.
    public var invoiceUnitArn: Swift.String?

    public init(
        invoiceUnitArn: Swift.String? = nil
    )
    {
        self.invoiceUnitArn = invoiceUnitArn
    }
}

public struct DeleteInvoiceUnitOutput: Swift.Sendable {
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    public var invoiceUnitArn: Swift.String?

    public init(
        invoiceUnitArn: Swift.String? = nil
    )
    {
        self.invoiceUnitArn = invoiceUnitArn
    }
}

extension InvoicingClientTypes {

    /// An optional input to the list API. If multiple filters are specified, the returned list will be a configuration that match all of the provided filters. Supported filter types are InvoiceReceivers, Names, and Accounts.
    public struct Filters: Swift.Sendable {
        /// You can specify a list of Amazon Web Services account IDs inside filters to return invoice units that match only the specified accounts. If multiple accounts are provided, the result is an OR condition (match any) of the specified accounts. The specified account IDs are matched with either the receiver or the linked accounts in the rules.
        public var accounts: [Swift.String]?
        /// You can specify a list of Amazon Web Services account IDs inside filters to return invoice units that match only the specified accounts. If multiple accounts are provided, the result is an OR condition (match any) of the specified accounts. This filter only matches the specified accounts on the invoice receivers of the invoice units.
        public var invoiceReceivers: [Swift.String]?
        /// An optional input to the list API. You can specify a list of invoice unit names inside filters to return invoice units that match only the specified invoice unit names. If multiple names are provided, the result is an OR condition (match any) of the specified invoice unit names.
        public var names: [Swift.String]?

        public init(
            accounts: [Swift.String]? = nil,
            invoiceReceivers: [Swift.String]? = nil,
            names: [Swift.String]? = nil
        )
        {
            self.accounts = accounts
            self.invoiceReceivers = invoiceReceivers
            self.names = names
        }
    }
}

public struct GetInvoiceUnitInput: Swift.Sendable {
    /// The state of an invoice unit at a specified time. You can see legacy invoice units that are currently deleted if the AsOf time is set to before it was deleted. If an AsOf is not provided, the default value is the current time.
    public var asOf: Foundation.Date?
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    /// This member is required.
    public var invoiceUnitArn: Swift.String?

    public init(
        asOf: Foundation.Date? = nil,
        invoiceUnitArn: Swift.String? = nil
    )
    {
        self.asOf = asOf
        self.invoiceUnitArn = invoiceUnitArn
    }
}

public struct GetInvoiceUnitOutput: Swift.Sendable {
    /// The assigned description for an invoice unit.
    public var description: Swift.String?
    /// The Amazon Web Services account ID chosen to be the receiver of an invoice unit. All invoices generated for that invoice unit will be sent to this account ID.
    public var invoiceReceiver: Swift.String?
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    public var invoiceUnitArn: Swift.String?
    /// The most recent date the invoice unit response was updated.
    public var lastModified: Foundation.Date?
    /// The unique name of the invoice unit that is shown on the generated invoice.
    public var name: Swift.String?
    /// This is used to categorize the invoice unit. Values are Amazon Web Services account IDs. Currently, the only supported rule is LINKED_ACCOUNT.
    public var rule: InvoicingClientTypes.InvoiceUnitRule?
    /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
    public var taxInheritanceDisabled: Swift.Bool?

    public init(
        description: Swift.String? = nil,
        invoiceReceiver: Swift.String? = nil,
        invoiceUnitArn: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        name: Swift.String? = nil,
        rule: InvoicingClientTypes.InvoiceUnitRule? = nil,
        taxInheritanceDisabled: Swift.Bool? = false
    )
    {
        self.description = description
        self.invoiceReceiver = invoiceReceiver
        self.invoiceUnitArn = invoiceUnitArn
        self.lastModified = lastModified
        self.name = name
        self.rule = rule
        self.taxInheritanceDisabled = taxInheritanceDisabled
    }
}

extension InvoicingClientTypes {

    /// An invoice unit is a set of mutually exclusive accounts that correspond to your business entity. Invoice units allow you separate Amazon Web Services account costs and configures your invoice for each business entity going forward.
    public struct InvoiceUnit: Swift.Sendable {
        /// The assigned description for an invoice unit. This information can't be modified or deleted.
        public var description: Swift.String?
        /// The account that receives invoices related to the invoice unit.
        public var invoiceReceiver: Swift.String?
        /// ARN to identify an invoice unit. This information can't be modified or deleted.
        public var invoiceUnitArn: Swift.String?
        /// The last time the invoice unit was updated. This is important to determine the version of invoice unit configuration used to create the invoices. Any invoice created after this modified time will use this invoice unit configuration.
        public var lastModified: Foundation.Date?
        /// A unique name that is distinctive within your Amazon Web Services.
        public var name: Swift.String?
        /// An InvoiceUnitRule object used the categorize invoice units.
        public var rule: InvoicingClientTypes.InvoiceUnitRule?
        /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
        public var taxInheritanceDisabled: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            invoiceReceiver: Swift.String? = nil,
            invoiceUnitArn: Swift.String? = nil,
            lastModified: Foundation.Date? = nil,
            name: Swift.String? = nil,
            rule: InvoicingClientTypes.InvoiceUnitRule? = nil,
            taxInheritanceDisabled: Swift.Bool? = false
        )
        {
            self.description = description
            self.invoiceReceiver = invoiceReceiver
            self.invoiceUnitArn = invoiceUnitArn
            self.lastModified = lastModified
            self.name = name
            self.rule = rule
            self.taxInheritanceDisabled = taxInheritanceDisabled
        }
    }
}

public struct ListInvoiceUnitsInput: Swift.Sendable {
    /// The state of an invoice unit at a specified time. You can see legacy invoice units that are currently deleted if the AsOf time is set to before it was deleted. If an AsOf is not provided, the default value is the current time.
    public var asOf: Foundation.Date?
    /// An optional input to the list API. If multiple filters are specified, the returned list will be a configuration that match all of the provided filters. Supported filter types are InvoiceReceivers, Names, and Accounts.
    public var filters: InvoicingClientTypes.Filters?
    /// The maximum number of invoice units that can be returned.
    public var maxResults: Swift.Int?
    /// The next token used to indicate where the returned list should start from.
    public var nextToken: Swift.String?

    public init(
        asOf: Foundation.Date? = nil,
        filters: InvoicingClientTypes.Filters? = nil,
        maxResults: Swift.Int? = 500,
        nextToken: Swift.String? = nil
    )
    {
        self.asOf = asOf
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListInvoiceUnitsOutput: Swift.Sendable {
    /// An invoice unit is a set of mutually exclusive accounts that correspond to your business entity.
    public var invoiceUnits: [InvoicingClientTypes.InvoiceUnit]?
    /// The next token used to indicate where the returned list should start from.
    public var nextToken: Swift.String?

    public init(
        invoiceUnits: [InvoicingClientTypes.InvoiceUnit]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.invoiceUnits = invoiceUnits
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of tags to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Adds a tag to a resource.
    public var resourceTags: [InvoicingClientTypes.ResourceTag]?

    public init(
        resourceTags: [InvoicingClientTypes.ResourceTag]? = nil
    )
    {
        self.resourceTags = resourceTags
    }
}

/// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account limits. The error message describes the limit exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvoicingServiceQuotaExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Adds a tag to a resource.
    /// This member is required.
    public var resourceTags: [InvoicingClientTypes.ResourceTag]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTags: [InvoicingClientTypes.ResourceTag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceTags = resourceTags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys for the tags to be removed.
    /// This member is required.
    public var resourceTagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceTagKeys = resourceTagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateInvoiceUnitInput: Swift.Sendable {
    /// The assigned description for an invoice unit. This information can't be modified or deleted.
    public var description: Swift.String?
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    /// This member is required.
    public var invoiceUnitArn: Swift.String?
    /// The InvoiceUnitRule object used to update invoice units.
    public var rule: InvoicingClientTypes.InvoiceUnitRule?
    /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
    public var taxInheritanceDisabled: Swift.Bool?

    public init(
        description: Swift.String? = nil,
        invoiceUnitArn: Swift.String? = nil,
        rule: InvoicingClientTypes.InvoiceUnitRule? = nil,
        taxInheritanceDisabled: Swift.Bool? = false
    )
    {
        self.description = description
        self.invoiceUnitArn = invoiceUnitArn
        self.rule = rule
        self.taxInheritanceDisabled = taxInheritanceDisabled
    }
}

public struct UpdateInvoiceUnitOutput: Swift.Sendable {
    /// The ARN to identify an invoice unit. This information can't be modified or deleted.
    public var invoiceUnitArn: Swift.String?

    public init(
        invoiceUnitArn: Swift.String? = nil
    )
    {
        self.invoiceUnitArn = invoiceUnitArn
    }
}

extension BatchGetInvoiceProfileInput {

    static func urlPathProvider(_ value: BatchGetInvoiceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateInvoiceUnitInput {

    static func urlPathProvider(_ value: CreateInvoiceUnitInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteInvoiceUnitInput {

    static func urlPathProvider(_ value: DeleteInvoiceUnitInput) -> Swift.String? {
        return "/"
    }
}

extension GetInvoiceUnitInput {

    static func urlPathProvider(_ value: GetInvoiceUnitInput) -> Swift.String? {
        return "/"
    }
}

extension ListInvoiceUnitsInput {

    static func urlPathProvider(_ value: ListInvoiceUnitsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateInvoiceUnitInput {

    static func urlPathProvider(_ value: UpdateInvoiceUnitInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetInvoiceProfileInput {

    static func write(value: BatchGetInvoiceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateInvoiceUnitInput {

    static func write(value: CreateInvoiceUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["InvoiceReceiver"].write(value.invoiceReceiver)
        try writer["Name"].write(value.name)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: InvoicingClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Rule"].write(value.rule, with: InvoicingClientTypes.InvoiceUnitRule.write(value:to:))
        try writer["TaxInheritanceDisabled"].write(value.taxInheritanceDisabled)
    }
}

extension DeleteInvoiceUnitInput {

    static func write(value: DeleteInvoiceUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InvoiceUnitArn"].write(value.invoiceUnitArn)
    }
}

extension GetInvoiceUnitInput {

    static func write(value: GetInvoiceUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AsOf"].writeTimestamp(value.asOf, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["InvoiceUnitArn"].write(value.invoiceUnitArn)
    }
}

extension ListInvoiceUnitsInput {

    static func write(value: ListInvoiceUnitsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AsOf"].writeTimestamp(value.asOf, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Filters"].write(value.filters, with: InvoicingClientTypes.Filters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: InvoicingClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceTagKeys"].writeList(value.resourceTagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateInvoiceUnitInput {

    static func write(value: UpdateInvoiceUnitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["InvoiceUnitArn"].write(value.invoiceUnitArn)
        try writer["Rule"].write(value.rule, with: InvoicingClientTypes.InvoiceUnitRule.write(value:to:))
        try writer["TaxInheritanceDisabled"].write(value.taxInheritanceDisabled)
    }
}

extension BatchGetInvoiceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetInvoiceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetInvoiceProfileOutput()
        value.profiles = try reader["Profiles"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.InvoiceProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateInvoiceUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInvoiceUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInvoiceUnitOutput()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        return value
    }
}

extension DeleteInvoiceUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInvoiceUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInvoiceUnitOutput()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        return value
    }
}

extension GetInvoiceUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInvoiceUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInvoiceUnitOutput()
        value.description = try reader["Description"].readIfPresent()
        value.invoiceReceiver = try reader["InvoiceReceiver"].readIfPresent()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.rule = try reader["Rule"].readIfPresent(with: InvoicingClientTypes.InvoiceUnitRule.read(from:))
        value.taxInheritanceDisabled = try reader["TaxInheritanceDisabled"].readIfPresent()
        return value
    }
}

extension ListInvoiceUnitsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInvoiceUnitsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInvoiceUnitsOutput()
        value.invoiceUnits = try reader["InvoiceUnits"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.InvoiceUnit.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateInvoiceUnitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInvoiceUnitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateInvoiceUnitOutput()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        return value
    }
}

enum BatchGetInvoiceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInvoiceUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInvoiceUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInvoiceUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInvoiceUnitsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInvoiceUnitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvoicingAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvoicingInternalServer": return try InternalServerException.makeError(baseError: baseError)
            case "InvoicingResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "InvoicingThrottling": return try ThrottlingException.makeError(baseError: baseError)
            case "InvoicingValidation": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: InvoicingClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvoicingClientTypes.InvoiceProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceProfile()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.receiverName = try reader["ReceiverName"].readIfPresent()
        value.receiverAddress = try reader["ReceiverAddress"].readIfPresent(with: InvoicingClientTypes.ReceiverAddress.read(from:))
        value.receiverEmail = try reader["ReceiverEmail"].readIfPresent()
        value.issuer = try reader["Issuer"].readIfPresent()
        value.taxRegistrationNumber = try reader["TaxRegistrationNumber"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.ReceiverAddress {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.ReceiverAddress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.ReceiverAddress()
        value.addressLine1 = try reader["AddressLine1"].readIfPresent()
        value.addressLine2 = try reader["AddressLine2"].readIfPresent()
        value.addressLine3 = try reader["AddressLine3"].readIfPresent()
        value.districtOrCounty = try reader["DistrictOrCounty"].readIfPresent()
        value.city = try reader["City"].readIfPresent()
        value.stateOrRegion = try reader["StateOrRegion"].readIfPresent()
        value.countryCode = try reader["CountryCode"].readIfPresent()
        value.companyName = try reader["CompanyName"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        return value
    }
}

extension InvoicingClientTypes.InvoiceUnitRule {

    static func write(value: InvoicingClientTypes.InvoiceUnitRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LinkedAccounts"].writeList(value.linkedAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceUnitRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceUnitRule()
        value.linkedAccounts = try reader["LinkedAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension InvoicingClientTypes.InvoiceUnit {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.InvoiceUnit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.InvoiceUnit()
        value.invoiceUnitArn = try reader["InvoiceUnitArn"].readIfPresent()
        value.invoiceReceiver = try reader["InvoiceReceiver"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.taxInheritanceDisabled = try reader["TaxInheritanceDisabled"].readIfPresent()
        value.rule = try reader["Rule"].readIfPresent(with: InvoicingClientTypes.InvoiceUnitRule.read(from:))
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension InvoicingClientTypes.ResourceTag {

    static func write(value: InvoicingClientTypes.ResourceTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.ResourceTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.ResourceTag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension InvoicingClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> InvoicingClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InvoicingClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension InvoicingClientTypes.Filters {

    static func write(value: InvoicingClientTypes.Filters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Accounts"].writeList(value.accounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InvoiceReceivers"].writeList(value.invoiceReceivers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum InvoicingClientTypes {}
