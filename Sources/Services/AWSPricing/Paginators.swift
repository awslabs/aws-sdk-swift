// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension PricingClient {
    /// Paginate over `[DescribeServicesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeServicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeServicesOutputResponse`
    public func describeServicesPaginated(input: DescribeServicesInput) -> ClientRuntime.PaginatorSequence<DescribeServicesInput, DescribeServicesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeServicesInput, DescribeServicesOutputResponse>(input: input, inputKey: \DescribeServicesInput.nextToken, outputKey: \DescribeServicesOutputResponse.nextToken, paginationFunction: self.describeServices(input:))
    }
}

extension DescribeServicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeServicesInput {
        return DescribeServicesInput(
            formatVersion: self.formatVersion,
            maxResults: self.maxResults,
            nextToken: token,
            serviceCode: self.serviceCode
        )}
}

extension PaginatorSequence where Input == DescribeServicesInput, Output == DescribeServicesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeServicesPaginated`
    /// to access the nested member `[PricingClientTypes.Service]`
    /// - Returns: `[PricingClientTypes.Service]`
    public func services() async throws -> [PricingClientTypes.Service] {
        return try await self.asyncCompactMap { item in item.services }
    }
}
extension PricingClient {
    /// Paginate over `[GetAttributeValuesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetAttributeValuesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetAttributeValuesOutputResponse`
    public func getAttributeValuesPaginated(input: GetAttributeValuesInput) -> ClientRuntime.PaginatorSequence<GetAttributeValuesInput, GetAttributeValuesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetAttributeValuesInput, GetAttributeValuesOutputResponse>(input: input, inputKey: \GetAttributeValuesInput.nextToken, outputKey: \GetAttributeValuesOutputResponse.nextToken, paginationFunction: self.getAttributeValues(input:))
    }
}

extension GetAttributeValuesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetAttributeValuesInput {
        return GetAttributeValuesInput(
            attributeName: self.attributeName,
            maxResults: self.maxResults,
            nextToken: token,
            serviceCode: self.serviceCode
        )}
}

extension PaginatorSequence where Input == GetAttributeValuesInput, Output == GetAttributeValuesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `getAttributeValuesPaginated`
    /// to access the nested member `[PricingClientTypes.AttributeValue]`
    /// - Returns: `[PricingClientTypes.AttributeValue]`
    public func attributeValues() async throws -> [PricingClientTypes.AttributeValue] {
        return try await self.asyncCompactMap { item in item.attributeValues }
    }
}
extension PricingClient {
    /// Paginate over `[GetProductsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetProductsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetProductsOutputResponse`
    public func getProductsPaginated(input: GetProductsInput) -> ClientRuntime.PaginatorSequence<GetProductsInput, GetProductsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetProductsInput, GetProductsOutputResponse>(input: input, inputKey: \GetProductsInput.nextToken, outputKey: \GetProductsOutputResponse.nextToken, paginationFunction: self.getProducts(input:))
    }
}

extension GetProductsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetProductsInput {
        return GetProductsInput(
            filters: self.filters,
            formatVersion: self.formatVersion,
            maxResults: self.maxResults,
            nextToken: token,
            serviceCode: self.serviceCode
        )}
}

extension PaginatorSequence where Input == GetProductsInput, Output == GetProductsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `getProductsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func priceList() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.priceList }
    }
}
extension PricingClient {
    /// Paginate over `[ListPriceListsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPriceListsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPriceListsOutputResponse`
    public func listPriceListsPaginated(input: ListPriceListsInput) -> ClientRuntime.PaginatorSequence<ListPriceListsInput, ListPriceListsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPriceListsInput, ListPriceListsOutputResponse>(input: input, inputKey: \ListPriceListsInput.nextToken, outputKey: \ListPriceListsOutputResponse.nextToken, paginationFunction: self.listPriceLists(input:))
    }
}

extension ListPriceListsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPriceListsInput {
        return ListPriceListsInput(
            currencyCode: self.currencyCode,
            effectiveDate: self.effectiveDate,
            maxResults: self.maxResults,
            nextToken: token,
            regionCode: self.regionCode,
            serviceCode: self.serviceCode
        )}
}

extension PaginatorSequence where Input == ListPriceListsInput, Output == ListPriceListsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listPriceListsPaginated`
    /// to access the nested member `[PricingClientTypes.PriceList]`
    /// - Returns: `[PricingClientTypes.PriceList]`
    public func priceLists() async throws -> [PricingClientTypes.PriceList] {
        return try await self.asyncCompactMap { item in item.priceLists }
    }
}
