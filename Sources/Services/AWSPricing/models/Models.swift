// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// General authentication failure. The request wasn't signed correctly.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PricingClientTypes.AttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PricingClientTypes {
    /// The values of a given attribute, such as Throughput Optimized HDD or Provisioned IOPS for the Amazon EC2volumeType attribute.
    public struct AttributeValue: Swift.Equatable {
        /// The specific value of an attributeName.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension DescribeServicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formatVersion = "FormatVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formatVersion = self.formatVersion {
            try encodeContainer.encode(formatVersion, forKey: .formatVersion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension DescribeServicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeServicesInput: Swift.Equatable {
    /// The format version that you want the response to be in. Valid values are: aws_v1
    public var formatVersion: Swift.String?
    /// The maximum number of results that you want returned in the response.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The code for the service whose information you want to retrieve, such as AmazonEC2. You can use the ServiceCode to filter the results in a GetProducts call. To retrieve a list of all services, leave this blank.
    public var serviceCode: Swift.String?

    public init(
        formatVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.formatVersion = formatVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct DescribeServicesInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let formatVersion: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formatVersion = "FormatVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let formatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeServicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeServicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.formatVersion = output.formatVersion
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.formatVersion = nil
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct DescribeServicesOutput: Swift.Equatable {
    /// The format version of the response. For example, aws_v1.
    public var formatVersion: Swift.String?
    /// The pagination token for the next set of retrievable results.
    public var nextToken: Swift.String?
    /// The service metadata for the service or services in the response.
    public var services: [PricingClientTypes.Service]?

    public init(
        formatVersion: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        services: [PricingClientTypes.Service]? = nil
    )
    {
        self.formatVersion = formatVersion
        self.nextToken = nextToken
        self.services = services
    }
}

struct DescribeServicesOutputBody: Swift.Equatable {
    let services: [PricingClientTypes.Service]?
    let formatVersion: Swift.String?
    let nextToken: Swift.String?
}

extension DescribeServicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formatVersion = "FormatVersion"
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([PricingClientTypes.Service?].self, forKey: .services)
        var servicesDecoded0:[PricingClientTypes.Service]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [PricingClientTypes.Service]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let formatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeServicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ExpiredNextTokenException": return try await ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExpiredNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExpiredNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pagination token expired. Try again without a pagination token.
public struct ExpiredNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ExpiredNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExpiredNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PricingClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field = "Field"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(PricingClientTypes.FilterType.self, forKey: .type)
        type = typeDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PricingClientTypes {
    /// The constraints that you want all returned products to match.
    public struct Filter: Swift.Equatable {
        /// The product metadata field that you want to filter on. You can filter by just the service code to see all products for a specific service, filter by just the attribute name to see a specific attribute for multiple services, or use both a service code and an attribute name to retrieve only products that match both fields. Valid values include: ServiceCode, and all attribute names For example, you can filter by the AmazonEC2 service code and the volumeType attribute name to get the prices for only Amazon EC2 volumes.
        /// This member is required.
        public var field: Swift.String?
        /// The type of filter that you want to use. Valid values are: TERM_MATCH. TERM_MATCH returns only products that match both the given filter field and the given value.
        /// This member is required.
        public var type: PricingClientTypes.FilterType?
        /// The service code or attribute value that you want to filter by. If you're filtering by service code this is the actual service code, such as AmazonEC2. If you're filtering by attribute name, this is the attribute value that you want the returned products to match, such as a Provisioned IOPS volume.
        /// This member is required.
        public var value: Swift.String?

        public init(
            field: Swift.String? = nil,
            type: PricingClientTypes.FilterType? = nil,
            value: Swift.String? = nil
        )
        {
            self.field = field
            self.type = type
            self.value = value
        }
    }

}

extension PricingClientTypes {
    public enum FilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case termMatch
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterType] {
            return [
                .termMatch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .termMatch: return "TERM_MATCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterType(rawValue: rawValue) ?? FilterType.sdkUnknown(rawValue)
        }
    }
}

extension GetAttributeValuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension GetAttributeValuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAttributeValuesInput: Swift.Equatable {
    /// The name of the attribute that you want to retrieve the values for, such as volumeType.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The maximum number of results to return in response.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The service code for the service whose attributes you want to retrieve. For example, if you want the retrieve an EC2 attribute, use AmazonEC2.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        attributeName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct GetAttributeValuesInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let attributeName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetAttributeValuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetAttributeValuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAttributeValuesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributeValues = output.attributeValues
            self.nextToken = output.nextToken
        } else {
            self.attributeValues = nil
            self.nextToken = nil
        }
    }
}

public struct GetAttributeValuesOutput: Swift.Equatable {
    /// The list of values for an attribute. For example, Throughput Optimized HDD and Provisioned IOPS are two available values for the AmazonEC2volumeType.
    public var attributeValues: [PricingClientTypes.AttributeValue]?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        attributeValues: [PricingClientTypes.AttributeValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributeValues = attributeValues
        self.nextToken = nextToken
    }
}

struct GetAttributeValuesOutputBody: Swift.Equatable {
    let attributeValues: [PricingClientTypes.AttributeValue]?
    let nextToken: Swift.String?
}

extension GetAttributeValuesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeValues = "AttributeValues"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeValuesContainer = try containerValues.decodeIfPresent([PricingClientTypes.AttributeValue?].self, forKey: .attributeValues)
        var attributeValuesDecoded0:[PricingClientTypes.AttributeValue]? = nil
        if let attributeValuesContainer = attributeValuesContainer {
            attributeValuesDecoded0 = [PricingClientTypes.AttributeValue]()
            for structure0 in attributeValuesContainer {
                if let structure0 = structure0 {
                    attributeValuesDecoded0?.append(structure0)
                }
            }
        }
        attributeValues = attributeValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetAttributeValuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ExpiredNextTokenException": return try await ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPriceListFileUrlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormat = "FileFormat"
        case priceListArn = "PriceListArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormat = self.fileFormat {
            try encodeContainer.encode(fileFormat, forKey: .fileFormat)
        }
        if let priceListArn = self.priceListArn {
            try encodeContainer.encode(priceListArn, forKey: .priceListArn)
        }
    }
}

extension GetPriceListFileUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPriceListFileUrlInput: Swift.Equatable {
    /// The format that you want to retrieve your Price List files in. The FileFormat can be obtained from the [ListPriceLists](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_ListPriceLists.html) response.
    /// This member is required.
    public var fileFormat: Swift.String?
    /// The unique identifier that maps to where your Price List files are located. PriceListArn can be obtained from the [ListPriceLists](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_ListPriceLists.html) response.
    /// This member is required.
    public var priceListArn: Swift.String?

    public init(
        fileFormat: Swift.String? = nil,
        priceListArn: Swift.String? = nil
    )
    {
        self.fileFormat = fileFormat
        self.priceListArn = priceListArn
    }
}

struct GetPriceListFileUrlInputBody: Swift.Equatable {
    let priceListArn: Swift.String?
    let fileFormat: Swift.String?
}

extension GetPriceListFileUrlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormat = "FileFormat"
        case priceListArn = "PriceListArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priceListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .priceListArn)
        priceListArn = priceListArnDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
    }
}

extension GetPriceListFileUrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPriceListFileUrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.url = output.url
        } else {
            self.url = nil
        }
    }
}

public struct GetPriceListFileUrlOutput: Swift.Equatable {
    /// The URL to download your Price List file from.
    public var url: Swift.String?

    public init(
        url: Swift.String? = nil
    )
    {
        self.url = url
    }
}

struct GetPriceListFileUrlOutputBody: Swift.Equatable {
    let url: Swift.String?
}

extension GetPriceListFileUrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case url = "Url"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

enum GetPriceListFileUrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProductsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case formatVersion = "FormatVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let formatVersion = self.formatVersion {
            try encodeContainer.encode(formatVersion, forKey: .formatVersion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension GetProductsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetProductsInput: Swift.Equatable {
    /// The list of filters that limit the returned products. only products that match all filters are returned.
    public var filters: [PricingClientTypes.Filter]?
    /// The format version that you want the response to be in. Valid values are: aws_v1
    public var formatVersion: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The code for the service whose products you want to retrieve.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        filters: [PricingClientTypes.Filter]? = nil,
        formatVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.filters = filters
        self.formatVersion = formatVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

struct GetProductsInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let filters: [PricingClientTypes.Filter]?
    let formatVersion: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetProductsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case formatVersion = "FormatVersion"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([PricingClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[PricingClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PricingClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let formatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetProductsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProductsOutputBody = try responseDecoder.decode(responseBody: data)
            self.formatVersion = output.formatVersion
            self.nextToken = output.nextToken
            self.priceList = output.priceList
        } else {
            self.formatVersion = nil
            self.nextToken = nil
            self.priceList = nil
        }
    }
}

public struct GetProductsOutput: Swift.Equatable {
    /// The format version of the response. For example, aws_v1.
    public var formatVersion: Swift.String?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The list of products that match your filters. The list contains both the product metadata and the price information.
    public var priceList: [Swift.String]?

    public init(
        formatVersion: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        priceList: [Swift.String]? = nil
    )
    {
        self.formatVersion = formatVersion
        self.nextToken = nextToken
        self.priceList = priceList
    }
}

struct GetProductsOutputBody: Swift.Equatable {
    let formatVersion: Swift.String?
    let priceList: [Swift.String]?
    let nextToken: Swift.String?
}

extension GetProductsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formatVersion = "FormatVersion"
        case nextToken = "NextToken"
        case priceList = "PriceList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formatVersion)
        formatVersion = formatVersionDecoded
        let priceListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .priceList)
        var priceListDecoded0:[Swift.String]? = nil
        if let priceListContainer = priceListContainer {
            priceListDecoded0 = [Swift.String]()
            for string0 in priceListContainer {
                if let string0 = string0 {
                    priceListDecoded0?.append(string0)
                }
            }
        }
        priceList = priceListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetProductsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ExpiredNextTokenException": return try await ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error on the server occurred during the processing of your request. Try again later.
public struct InternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pagination token is invalid. Try again without a pagination token.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more parameters had an invalid value.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListPriceListsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case effectiveDate = "EffectiveDate"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case regionCode = "RegionCode"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let effectiveDate = self.effectiveDate {
            try encodeContainer.encodeTimestamp(effectiveDate, format: .epochSeconds, forKey: .effectiveDate)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let regionCode = self.regionCode {
            try encodeContainer.encode(regionCode, forKey: .regionCode)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }
}

extension ListPriceListsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPriceListsInput: Swift.Equatable {
    /// The three alphabetical character ISO-4217 currency code that the Price List files are denominated in.
    /// This member is required.
    public var currencyCode: Swift.String?
    /// The date that the Price List file prices are effective from.
    /// This member is required.
    public var effectiveDate: ClientRuntime.Date?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// This is used to filter the Price List by Amazon Web Services Region. For example, to get the price list only for the US East (N. Virginia) Region, use us-east-1. If nothing is specified, you retrieve price lists for all applicable Regions. The available RegionCode list can be retrieved from [GetAttributeValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_GetAttributeValues.html) API.
    public var regionCode: Swift.String?
    /// The service code or the Savings Plan service code for the attributes that you want to retrieve. For example, to get the list of applicable Amazon EC2 price lists, use AmazonEC2. For a full list of service codes containing On-Demand and Reserved Instance (RI) pricing, use the [DescribeServices](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_DescribeServices.html#awscostmanagement-pricing_DescribeServices-request-FormatVersion) API. To retrieve the Compute Savings Plan price lists, use ComputeSavingsPlans. To retrieve Machine Learning Savings Plans price lists, use MachineLearningSavingsPlans.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        currencyCode: Swift.String? = nil,
        effectiveDate: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        regionCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.currencyCode = currencyCode
        self.effectiveDate = effectiveDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.regionCode = regionCode
        self.serviceCode = serviceCode
    }
}

struct ListPriceListsInputBody: Swift.Equatable {
    let serviceCode: Swift.String?
    let effectiveDate: ClientRuntime.Date?
    let regionCode: Swift.String?
    let currencyCode: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPriceListsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case effectiveDate = "EffectiveDate"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case regionCode = "RegionCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let effectiveDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .effectiveDate)
        effectiveDate = effectiveDateDecoded
        let regionCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionCode)
        regionCode = regionCodeDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPriceListsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPriceListsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.priceLists = output.priceLists
        } else {
            self.nextToken = nil
            self.priceLists = nil
        }
    }
}

public struct ListPriceListsOutput: Swift.Equatable {
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The type of price list references that match your request.
    public var priceLists: [PricingClientTypes.PriceList]?

    public init(
        nextToken: Swift.String? = nil,
        priceLists: [PricingClientTypes.PriceList]? = nil
    )
    {
        self.nextToken = nextToken
        self.priceLists = priceLists
    }
}

struct ListPriceListsOutputBody: Swift.Equatable {
    let priceLists: [PricingClientTypes.PriceList]?
    let nextToken: Swift.String?
}

extension ListPriceListsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case priceLists = "PriceLists"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priceListsContainer = try containerValues.decodeIfPresent([PricingClientTypes.PriceList?].self, forKey: .priceLists)
        var priceListsDecoded0:[PricingClientTypes.PriceList]? = nil
        if let priceListsContainer = priceListsContainer {
            priceListsDecoded0 = [PricingClientTypes.PriceList]()
            for structure0 in priceListsContainer {
                if let structure0 = structure0 {
                    priceListsDecoded0?.append(structure0)
                }
            }
        }
        priceLists = priceListsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPriceListsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredNextTokenException": return try await ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource can't be found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PricingClientTypes.PriceList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case fileFormats = "FileFormats"
        case priceListArn = "PriceListArn"
        case regionCode = "RegionCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let fileFormats = fileFormats {
            var fileFormatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileFormats)
            for fileformat0 in fileFormats {
                try fileFormatsContainer.encode(fileformat0)
            }
        }
        if let priceListArn = self.priceListArn {
            try encodeContainer.encode(priceListArn, forKey: .priceListArn)
        }
        if let regionCode = self.regionCode {
            try encodeContainer.encode(regionCode, forKey: .regionCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priceListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .priceListArn)
        priceListArn = priceListArnDecoded
        let regionCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionCode)
        regionCode = regionCodeDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let fileFormatsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fileFormats)
        var fileFormatsDecoded0:[Swift.String]? = nil
        if let fileFormatsContainer = fileFormatsContainer {
            fileFormatsDecoded0 = [Swift.String]()
            for string0 in fileFormatsContainer {
                if let string0 = string0 {
                    fileFormatsDecoded0?.append(string0)
                }
            }
        }
        fileFormats = fileFormatsDecoded0
    }
}

extension PricingClientTypes {
    /// This feature is in preview release and is subject to change. Your use of Amazon Web Services Price List API is subject to the Beta Service Participation terms of the [Amazon Web Services Service Terms](https://aws.amazon.com/service-terms/) (Section 1.10). This is the type of price list references that match your request.
    public struct PriceList: Swift.Equatable {
        /// The three alphabetical character ISO-4217 currency code the Price List files are denominated in.
        public var currencyCode: Swift.String?
        /// The format you want to retrieve your Price List files. The FileFormat can be obtained from the [ListPriceList](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_ListPriceLists.html) response.
        public var fileFormats: [Swift.String]?
        /// The unique identifier that maps to where your Price List files are located. PriceListArn can be obtained from the [ListPriceList](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_ListPriceLists.html) response.
        public var priceListArn: Swift.String?
        /// This is used to filter the Price List by Amazon Web Services Region. For example, to get the price list only for the US East (N. Virginia) Region, use us-east-1. If nothing is specified, you retrieve price lists for all applicable Regions. The available RegionCode list can be retrieved from [GetAttributeValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_GetAttributeValues.html) API.
        public var regionCode: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            fileFormats: [Swift.String]? = nil,
            priceListArn: Swift.String? = nil,
            regionCode: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.fileFormats = fileFormats
            self.priceListArn = priceListArn
            self.regionCode = regionCode
        }
    }

}

extension PricingClientTypes.Service: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case serviceCode = "ServiceCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for string0 in attributeNames {
                try attributeNamesContainer.encode(string0)
            }
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[Swift.String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [Swift.String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension PricingClientTypes {
    /// The metadata for a service, such as the service code and available attribute names.
    public struct Service: Swift.Equatable {
        /// The attributes that are available for this service.
        public var attributeNames: [Swift.String]?
        /// The code for the Amazon Web Services service.
        /// This member is required.
        public var serviceCode: Swift.String?

        public init(
            attributeNames: [Swift.String]? = nil,
            serviceCode: Swift.String? = nil
        )
        {
            self.attributeNames = attributeNames
            self.serviceCode = serviceCode
        }
    }

}
