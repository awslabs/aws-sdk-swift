//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// General authentication failure. The request wasn't signed correctly.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PricingClientTypes {

    /// The values of a given attribute, such as Throughput Optimized HDD or Provisioned IOPS for the Amazon EC2volumeType attribute.
    public struct AttributeValue: Swift.Sendable {
        /// The specific value of an attributeName.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }
}

/// The pagination token expired. Try again without a pagination token.
public struct ExpiredNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An error on the server occurred during the processing of your request. Try again later.
public struct InternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The pagination token is invalid. Try again without a pagination token.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more parameters had an invalid value.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested resource can't be found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You've made too many requests exceeding service quotas.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeServicesInput: Swift.Sendable {
    /// The format version that you want the response to be in. Valid values are: aws_v1
    public var formatVersion: Swift.String?
    /// The maximum number of results that you want returned in the response.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The code for the service whose information you want to retrieve, such as AmazonEC2. You can use the ServiceCode to filter the results in a GetProducts call. To retrieve a list of all services, leave this blank.
    public var serviceCode: Swift.String?

    public init(
        formatVersion: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.formatVersion = formatVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

extension PricingClientTypes {

    /// The metadata for a service, such as the service code and available attribute names.
    public struct Service: Swift.Sendable {
        /// The attributes that are available for this service.
        public var attributeNames: [Swift.String]?
        /// The code for the Amazon Web Services service.
        /// This member is required.
        public var serviceCode: Swift.String?

        public init(
            attributeNames: [Swift.String]? = nil,
            serviceCode: Swift.String? = nil
        )
        {
            self.attributeNames = attributeNames
            self.serviceCode = serviceCode
        }
    }
}

public struct DescribeServicesOutput: Swift.Sendable {
    /// The format version of the response. For example, aws_v1.
    public var formatVersion: Swift.String?
    /// The pagination token for the next set of retrievable results.
    public var nextToken: Swift.String?
    /// The service metadata for the service or services in the response.
    public var services: [PricingClientTypes.Service]?

    public init(
        formatVersion: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        services: [PricingClientTypes.Service]? = nil
    )
    {
        self.formatVersion = formatVersion
        self.nextToken = nextToken
        self.services = services
    }
}

public struct GetAttributeValuesInput: Swift.Sendable {
    /// The name of the attribute that you want to retrieve the values for, such as volumeType.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The maximum number of results to return in response.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The service code for the service whose attributes you want to retrieve. For example, if you want the retrieve an EC2 attribute, use AmazonEC2.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        attributeName: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

public struct GetAttributeValuesOutput: Swift.Sendable {
    /// The list of values for an attribute. For example, Throughput Optimized HDD and Provisioned IOPS are two available values for the AmazonEC2volumeType.
    public var attributeValues: [PricingClientTypes.AttributeValue]?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        attributeValues: [PricingClientTypes.AttributeValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributeValues = attributeValues
        self.nextToken = nextToken
    }
}

/// The requested resource can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetPriceListFileUrlInput: Swift.Sendable {
    /// The format that you want to retrieve your Price List files in. The FileFormat can be obtained from the [ListPriceLists](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_ListPriceLists.html) response.
    /// This member is required.
    public var fileFormat: Swift.String?
    /// The unique identifier that maps to where your Price List files are located. PriceListArn can be obtained from the [ListPriceLists](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_ListPriceLists.html) response.
    /// This member is required.
    public var priceListArn: Swift.String?

    public init(
        fileFormat: Swift.String? = nil,
        priceListArn: Swift.String? = nil
    )
    {
        self.fileFormat = fileFormat
        self.priceListArn = priceListArn
    }
}

public struct GetPriceListFileUrlOutput: Swift.Sendable {
    /// The URL to download your Price List file from.
    public var url: Swift.String?

    public init(
        url: Swift.String? = nil
    )
    {
        self.url = url
    }
}

extension PricingClientTypes {

    public enum FilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case termMatch
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterType] {
            return [
                .termMatch
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .termMatch: return "TERM_MATCH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PricingClientTypes {

    /// The constraints that you want all returned products to match.
    public struct Filter: Swift.Sendable {
        /// The product metadata field that you want to filter on. You can filter by just the service code to see all products for a specific service, filter by just the attribute name to see a specific attribute for multiple services, or use both a service code and an attribute name to retrieve only products that match both fields. Valid values include: ServiceCode, and all attribute names For example, you can filter by the AmazonEC2 service code and the volumeType attribute name to get the prices for only Amazon EC2 volumes.
        /// This member is required.
        public var field: Swift.String?
        /// The type of filter that you want to use. Valid values are: TERM_MATCH. TERM_MATCH returns only products that match both the given filter field and the given value.
        /// This member is required.
        public var type: PricingClientTypes.FilterType?
        /// The service code or attribute value that you want to filter by. If you're filtering by service code this is the actual service code, such as AmazonEC2. If you're filtering by attribute name, this is the attribute value that you want the returned products to match, such as a Provisioned IOPS volume.
        /// This member is required.
        public var value: Swift.String?

        public init(
            field: Swift.String? = nil,
            type: PricingClientTypes.FilterType? = nil,
            value: Swift.String? = nil
        )
        {
            self.field = field
            self.type = type
            self.value = value
        }
    }
}

public struct GetProductsInput: Swift.Sendable {
    /// The list of filters that limit the returned products. only products that match all filters are returned.
    public var filters: [PricingClientTypes.Filter]?
    /// The format version that you want the response to be in. Valid values are: aws_v1
    public var formatVersion: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The code for the service whose products you want to retrieve.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        filters: [PricingClientTypes.Filter]? = nil,
        formatVersion: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.filters = filters
        self.formatVersion = formatVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceCode = serviceCode
    }
}

public struct GetProductsOutput: Swift.Sendable {
    /// The format version of the response. For example, aws_v1.
    public var formatVersion: Swift.String?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The list of products that match your filters. The list contains both the product metadata and the price information.
    public var priceList: [Swift.String]?

    public init(
        formatVersion: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        priceList: [Swift.String]? = nil
    )
    {
        self.formatVersion = formatVersion
        self.nextToken = nextToken
        self.priceList = priceList
    }
}

public struct ListPriceListsInput: Swift.Sendable {
    /// The three alphabetical character ISO-4217 currency code that the Price List files are denominated in.
    /// This member is required.
    public var currencyCode: Swift.String?
    /// The date that the Price List file prices are effective from.
    /// This member is required.
    public var effectiveDate: Foundation.Date?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// This is used to filter the Price List by Amazon Web Services Region. For example, to get the price list only for the US East (N. Virginia) Region, use us-east-1. If nothing is specified, you retrieve price lists for all applicable Regions. The available RegionCode list can be retrieved from [GetAttributeValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_GetAttributeValues.html) API.
    public var regionCode: Swift.String?
    /// The service code or the Savings Plan service code for the attributes that you want to retrieve. For example, to get the list of applicable Amazon EC2 price lists, use AmazonEC2. For a full list of service codes containing On-Demand and Reserved Instance (RI) pricing, use the [DescribeServices](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_DescribeServices.html#awscostmanagement-pricing_DescribeServices-request-FormatVersion) API. To retrieve the Reserved Instance and Compute Savings Plan price lists, use ComputeSavingsPlans. To retrieve Machine Learning Savings Plans price lists, use MachineLearningSavingsPlans.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init(
        currencyCode: Swift.String? = nil,
        effectiveDate: Foundation.Date? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        regionCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.currencyCode = currencyCode
        self.effectiveDate = effectiveDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.regionCode = regionCode
        self.serviceCode = serviceCode
    }
}

extension PricingClientTypes {

    /// This feature is in preview release and is subject to change. Your use of Amazon Web Services Price List API is subject to the Beta Service Participation terms of the [Amazon Web Services Service Terms](https://aws.amazon.com/service-terms/) (Section 1.10). This is the type of price list references that match your request.
    public struct PriceList: Swift.Sendable {
        /// The three alphabetical character ISO-4217 currency code the Price List files are denominated in.
        public var currencyCode: Swift.String?
        /// The format you want to retrieve your Price List files. The FileFormat can be obtained from the [ListPriceList](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_ListPriceLists.html) response.
        public var fileFormats: [Swift.String]?
        /// The unique identifier that maps to where your Price List files are located. PriceListArn can be obtained from the [ListPriceList](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_ListPriceLists.html) response.
        public var priceListArn: Swift.String?
        /// This is used to filter the Price List by Amazon Web Services Region. For example, to get the price list only for the US East (N. Virginia) Region, use us-east-1. If nothing is specified, you retrieve price lists for all applicable Regions. The available RegionCode list can be retrieved from [GetAttributeValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_pricing_GetAttributeValues.html) API.
        public var regionCode: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            fileFormats: [Swift.String]? = nil,
            priceListArn: Swift.String? = nil,
            regionCode: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.fileFormats = fileFormats
            self.priceListArn = priceListArn
            self.regionCode = regionCode
        }
    }
}

public struct ListPriceListsOutput: Swift.Sendable {
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The type of price list references that match your request.
    public var priceLists: [PricingClientTypes.PriceList]?

    public init(
        nextToken: Swift.String? = nil,
        priceLists: [PricingClientTypes.PriceList]? = nil
    )
    {
        self.nextToken = nextToken
        self.priceLists = priceLists
    }
}

extension DescribeServicesInput {

    static func urlPathProvider(_ value: DescribeServicesInput) -> Swift.String? {
        return "/"
    }
}

extension GetAttributeValuesInput {

    static func urlPathProvider(_ value: GetAttributeValuesInput) -> Swift.String? {
        return "/"
    }
}

extension GetPriceListFileUrlInput {

    static func urlPathProvider(_ value: GetPriceListFileUrlInput) -> Swift.String? {
        return "/"
    }
}

extension GetProductsInput {

    static func urlPathProvider(_ value: GetProductsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPriceListsInput {

    static func urlPathProvider(_ value: ListPriceListsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeServicesInput {

    static func write(value: DescribeServicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FormatVersion"].write(value.formatVersion)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension GetAttributeValuesInput {

    static func write(value: GetAttributeValuesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension GetPriceListFileUrlInput {

    static func write(value: GetPriceListFileUrlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileFormat"].write(value.fileFormat)
        try writer["PriceListArn"].write(value.priceListArn)
    }
}

extension GetProductsInput {

    static func write(value: GetProductsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PricingClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FormatVersion"].write(value.formatVersion)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension ListPriceListsInput {

    static func write(value: ListPriceListsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CurrencyCode"].write(value.currencyCode)
        try writer["EffectiveDate"].writeTimestamp(value.effectiveDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RegionCode"].write(value.regionCode)
        try writer["ServiceCode"].write(value.serviceCode)
    }
}

extension DescribeServicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeServicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeServicesOutput()
        value.formatVersion = try reader["FormatVersion"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.services = try reader["Services"].readListIfPresent(memberReadingClosure: PricingClientTypes.Service.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAttributeValuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAttributeValuesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAttributeValuesOutput()
        value.attributeValues = try reader["AttributeValues"].readListIfPresent(memberReadingClosure: PricingClientTypes.AttributeValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetPriceListFileUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPriceListFileUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPriceListFileUrlOutput()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension GetProductsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProductsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProductsOutput()
        value.formatVersion = try reader["FormatVersion"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.priceList = try reader["PriceList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPriceListsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPriceListsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPriceListsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.priceLists = try reader["PriceLists"].readListIfPresent(memberReadingClosure: PricingClientTypes.PriceList.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

enum DescribeServicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ExpiredNextTokenException": return try ExpiredNextTokenException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAttributeValuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ExpiredNextTokenException": return try ExpiredNextTokenException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPriceListFileUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProductsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ExpiredNextTokenException": return try ExpiredNextTokenException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPriceListsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ExpiredNextTokenException": return try ExpiredNextTokenException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalErrorException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExpiredNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ExpiredNextTokenException {
        let reader = baseError.errorBodyReader
        var value = ExpiredNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PricingClientTypes.Service {

    static func read(from reader: SmithyJSON.Reader) throws -> PricingClientTypes.Service {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PricingClientTypes.Service()
        value.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.attributeNames = try reader["AttributeNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PricingClientTypes.AttributeValue {

    static func read(from reader: SmithyJSON.Reader) throws -> PricingClientTypes.AttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PricingClientTypes.AttributeValue()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension PricingClientTypes.PriceList {

    static func read(from reader: SmithyJSON.Reader) throws -> PricingClientTypes.PriceList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PricingClientTypes.PriceList()
        value.priceListArn = try reader["PriceListArn"].readIfPresent()
        value.regionCode = try reader["RegionCode"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        value.fileFormats = try reader["FileFormats"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PricingClientTypes.Filter {

    static func write(value: PricingClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Field"].write(value.field)
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }
}

public enum PricingClientTypes {}
