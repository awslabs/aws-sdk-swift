// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AlreadyStreamedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AlreadyStreamedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception thrown when a bulk publish operation is requested less than 24 hours after a previous bulk publish operation completed successfully.
public struct AlreadyStreamedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message associated with the AlreadyStreamedException exception.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AlreadyStreamed" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AlreadyStreamedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AlreadyStreamedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BulkPublishInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/bulkpublish"
    }
}

/// The input for the BulkPublish operation.
public struct BulkPublishInput: Swift.Equatable {
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct BulkPublishInputBody: Swift.Equatable {
}

extension BulkPublishInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension BulkPublishOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BulkPublishOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolId = output.identityPoolId
        } else {
            self.identityPoolId = nil
        }
    }
}

/// The output for the BulkPublish operation.
public struct BulkPublishOutput: Swift.Equatable {
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    public var identityPoolId: Swift.String?

    public init(
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct BulkPublishOutputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
}

extension BulkPublishOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

enum BulkPublishOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AlreadyStreamed": return try await AlreadyStreamedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateRequest": return try await DuplicateRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CognitoSyncClientTypes {
    public enum BulkPublishStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [BulkPublishStatus] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BulkPublishStatus(rawValue: rawValue) ?? BulkPublishStatus.sdkUnknown(rawValue)
        }
    }
}

extension CognitoSyncClientTypes.CognitoStreams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
        case streamName = "StreamName"
        case streamingStatus = "StreamingStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let streamingStatus = self.streamingStatus {
            try encodeContainer.encode(streamingStatus.rawValue, forKey: .streamingStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let streamingStatusDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.StreamingStatus.self, forKey: .streamingStatus)
        streamingStatus = streamingStatusDecoded
    }
}

extension CognitoSyncClientTypes {
    /// Configuration options for configure Cognito streams.
    public struct CognitoStreams: Swift.Equatable {
        /// The ARN of the role Amazon Cognito can assume in order to publish to the stream. This role must grant access to Amazon Cognito (cognito-sync) to invoke PutRecord on your Cognito stream.
        public var roleArn: Swift.String?
        /// The name of the Cognito stream to receive updates. This stream must be in the developers account and in the same region as the identity pool.
        public var streamName: Swift.String?
        /// Status of the Cognito streams. Valid values are: ENABLED - Streaming of updates to identity pool is enabled. DISABLED - Streaming of updates to identity pool is disabled. Bulk publish will also fail if StreamingStatus is DISABLED.
        public var streamingStatus: CognitoSyncClientTypes.StreamingStatus?

        public init(
            roleArn: Swift.String? = nil,
            streamName: Swift.String? = nil,
            streamingStatus: CognitoSyncClientTypes.StreamingStatus? = nil
        )
        {
            self.roleArn = roleArn
            self.streamName = streamName
            self.streamingStatus = streamingStatus
        }
    }

}

extension ConcurrentModificationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown if there are parallel requests to modify a resource.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message returned by a ConcurrentModicationException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModification" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CognitoSyncClientTypes.Dataset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case dataStorage = "DataStorage"
        case datasetName = "DatasetName"
        case identityId = "IdentityId"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case numRecords = "NumRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let dataStorage = self.dataStorage {
            try encodeContainer.encode(dataStorage, forKey: .dataStorage)
        }
        if let datasetName = self.datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let identityId = self.identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let numRecords = self.numRecords {
            try encodeContainer.encode(numRecords, forKey: .numRecords)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let dataStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataStorage)
        dataStorage = dataStorageDecoded
        let numRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numRecords)
        numRecords = numRecordsDecoded
    }
}

extension CognitoSyncClientTypes {
    /// A collection of data for an identity pool. An identity pool can have multiple datasets. A dataset is per identity and can be general or associated with a particular entity in an application (like a saved game). Datasets are automatically created if they don't exist. Data is synced by dataset, and a dataset can hold up to 1MB of key-value pairs.
    public struct Dataset: Swift.Equatable {
        /// Date on which the dataset was created.
        public var creationDate: ClientRuntime.Date?
        /// Total size in bytes of the records in this dataset.
        public var dataStorage: Swift.Int?
        /// A string of up to 128 characters. Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.' (dot).
        public var datasetName: Swift.String?
        /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
        public var identityId: Swift.String?
        /// The device that made the last change to this dataset.
        public var lastModifiedBy: Swift.String?
        /// Date when the dataset was last modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// Number of records in this dataset.
        public var numRecords: Swift.Int?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            dataStorage: Swift.Int? = nil,
            datasetName: Swift.String? = nil,
            identityId: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            numRecords: Swift.Int? = nil
        )
        {
            self.creationDate = creationDate
            self.dataStorage = dataStorage
            self.datasetName = datasetName
            self.identityId = identityId
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.numRecords = numRecords
        }
    }

}

extension DeleteDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        guard let identityId = identityId else {
            return nil
        }
        guard let datasetName = datasetName else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets/\(datasetName.urlPercentEncoding())"
    }
}

/// A request to delete the specific dataset.
public struct DeleteDatasetInput: Swift.Equatable {
    /// A string of up to 128 characters. Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.' (dot).
    /// This member is required.
    public var datasetName: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        datasetName: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
}

extension DeleteDatasetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataset = output.dataset
        } else {
            self.dataset = nil
        }
    }
}

/// Response to a successful DeleteDataset request.
public struct DeleteDatasetOutput: Swift.Equatable {
    /// A collection of data for an identity pool. An identity pool can have multiple datasets. A dataset is per identity and can be general or associated with a particular entity in an application (like a saved game). Datasets are automatically created if they don't exist. Data is synced by dataset, and a dataset can hold up to 1MB of key-value pairs.
    public var dataset: CognitoSyncClientTypes.Dataset?

    public init(
        dataset: CognitoSyncClientTypes.Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

struct DeleteDatasetOutputBody: Swift.Equatable {
    let dataset: CognitoSyncClientTypes.Dataset?
}

extension DeleteDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataset = "Dataset"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.Dataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

enum DeleteDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflict": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        guard let identityId = identityId else {
            return nil
        }
        guard let datasetName = datasetName else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets/\(datasetName.urlPercentEncoding())"
    }
}

/// A request for meta data about a dataset (creation date, number of records, size) by owner and dataset name.
public struct DescribeDatasetInput: Swift.Equatable {
    /// A string of up to 128 characters. Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.' (dot).
    /// This member is required.
    public var datasetName: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        datasetName: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
}

extension DescribeDatasetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataset = output.dataset
        } else {
            self.dataset = nil
        }
    }
}

/// Response to a successful DescribeDataset request.
public struct DescribeDatasetOutput: Swift.Equatable {
    /// Meta data for a collection of data for an identity. An identity can have multiple datasets. A dataset can be general or associated with a particular entity in an application (like a saved game). Datasets are automatically created if they don't exist. Data is synced by dataset, and a dataset can hold up to 1MB of key-value pairs.
    public var dataset: CognitoSyncClientTypes.Dataset?

    public init(
        dataset: CognitoSyncClientTypes.Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

struct DescribeDatasetOutputBody: Swift.Equatable {
    let dataset: CognitoSyncClientTypes.Dataset?
}

extension DescribeDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataset = "Dataset"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.Dataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

enum DescribeDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeIdentityPoolUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())"
    }
}

/// A request for usage information about the identity pool.
public struct DescribeIdentityPoolUsageInput: Swift.Equatable {
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct DescribeIdentityPoolUsageInputBody: Swift.Equatable {
}

extension DescribeIdentityPoolUsageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeIdentityPoolUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeIdentityPoolUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolUsage = output.identityPoolUsage
        } else {
            self.identityPoolUsage = nil
        }
    }
}

/// Response to a successful DescribeIdentityPoolUsage request.
public struct DescribeIdentityPoolUsageOutput: Swift.Equatable {
    /// Information about the usage of the identity pool.
    public var identityPoolUsage: CognitoSyncClientTypes.IdentityPoolUsage?

    public init(
        identityPoolUsage: CognitoSyncClientTypes.IdentityPoolUsage? = nil
    )
    {
        self.identityPoolUsage = identityPoolUsage
    }
}

struct DescribeIdentityPoolUsageOutputBody: Swift.Equatable {
    let identityPoolUsage: CognitoSyncClientTypes.IdentityPoolUsage?
}

extension DescribeIdentityPoolUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolUsage = "IdentityPoolUsage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolUsageDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.IdentityPoolUsage.self, forKey: .identityPoolUsage)
        identityPoolUsage = identityPoolUsageDecoded
    }
}

enum DescribeIdentityPoolUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeIdentityUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        guard let identityId = identityId else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())"
    }
}

/// A request for information about the usage of an identity pool.
public struct DescribeIdentityUsageInput: Swift.Equatable {
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct DescribeIdentityUsageInputBody: Swift.Equatable {
}

extension DescribeIdentityUsageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeIdentityUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeIdentityUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityUsage = output.identityUsage
        } else {
            self.identityUsage = nil
        }
    }
}

/// The response to a successful DescribeIdentityUsage request.
public struct DescribeIdentityUsageOutput: Swift.Equatable {
    /// Usage information for the identity.
    public var identityUsage: CognitoSyncClientTypes.IdentityUsage?

    public init(
        identityUsage: CognitoSyncClientTypes.IdentityUsage? = nil
    )
    {
        self.identityUsage = identityUsage
    }
}

struct DescribeIdentityUsageOutputBody: Swift.Equatable {
    let identityUsage: CognitoSyncClientTypes.IdentityUsage?
}

extension DescribeIdentityUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityUsage = "IdentityUsage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityUsageDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.IdentityUsage.self, forKey: .identityUsage)
        identityUsage = identityUsageDecoded
    }
}

enum DescribeIdentityUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DuplicateRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DuplicateRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception thrown when there is an IN_PROGRESS bulk publish operation for the given identity pool.
public struct DuplicateRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message associated with the DuplicateRequestException exception.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateRequest" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DuplicateRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetBulkPublishDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/getBulkPublishDetails"
    }
}

/// The input for the GetBulkPublishDetails operation.
public struct GetBulkPublishDetailsInput: Swift.Equatable {
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetBulkPublishDetailsInputBody: Swift.Equatable {
}

extension GetBulkPublishDetailsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBulkPublishDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBulkPublishDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.bulkPublishCompleteTime = output.bulkPublishCompleteTime
            self.bulkPublishStartTime = output.bulkPublishStartTime
            self.bulkPublishStatus = output.bulkPublishStatus
            self.failureMessage = output.failureMessage
            self.identityPoolId = output.identityPoolId
        } else {
            self.bulkPublishCompleteTime = nil
            self.bulkPublishStartTime = nil
            self.bulkPublishStatus = nil
            self.failureMessage = nil
            self.identityPoolId = nil
        }
    }
}

/// The output for the GetBulkPublishDetails operation.
public struct GetBulkPublishDetailsOutput: Swift.Equatable {
    /// If BulkPublishStatus is SUCCEEDED, the time the last bulk publish operation completed.
    public var bulkPublishCompleteTime: ClientRuntime.Date?
    /// The date/time at which the last bulk publish was initiated.
    public var bulkPublishStartTime: ClientRuntime.Date?
    /// Status of the last bulk publish operation, valid values are: NOT_STARTED - No bulk publish has been requested for this identity pool IN_PROGRESS - Data is being published to the configured stream SUCCEEDED - All data for the identity pool has been published to the configured stream FAILED - Some portion of the data has failed to publish, check FailureMessage for the cause.
    public var bulkPublishStatus: CognitoSyncClientTypes.BulkPublishStatus?
    /// If BulkPublishStatus is FAILED this field will contain the error message that caused the bulk publish to fail.
    public var failureMessage: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    public var identityPoolId: Swift.String?

    public init(
        bulkPublishCompleteTime: ClientRuntime.Date? = nil,
        bulkPublishStartTime: ClientRuntime.Date? = nil,
        bulkPublishStatus: CognitoSyncClientTypes.BulkPublishStatus? = nil,
        failureMessage: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.bulkPublishCompleteTime = bulkPublishCompleteTime
        self.bulkPublishStartTime = bulkPublishStartTime
        self.bulkPublishStatus = bulkPublishStatus
        self.failureMessage = failureMessage
        self.identityPoolId = identityPoolId
    }
}

struct GetBulkPublishDetailsOutputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let bulkPublishStartTime: ClientRuntime.Date?
    let bulkPublishCompleteTime: ClientRuntime.Date?
    let bulkPublishStatus: CognitoSyncClientTypes.BulkPublishStatus?
    let failureMessage: Swift.String?
}

extension GetBulkPublishDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bulkPublishCompleteTime = "BulkPublishCompleteTime"
        case bulkPublishStartTime = "BulkPublishStartTime"
        case bulkPublishStatus = "BulkPublishStatus"
        case failureMessage = "FailureMessage"
        case identityPoolId = "IdentityPoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let bulkPublishStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .bulkPublishStartTime)
        bulkPublishStartTime = bulkPublishStartTimeDecoded
        let bulkPublishCompleteTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .bulkPublishCompleteTime)
        bulkPublishCompleteTime = bulkPublishCompleteTimeDecoded
        let bulkPublishStatusDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.BulkPublishStatus.self, forKey: .bulkPublishStatus)
        bulkPublishStatus = bulkPublishStatusDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

enum GetBulkPublishDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCognitoEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/events"
    }
}

/// A request for a list of the configured Cognito Events
public struct GetCognitoEventsInput: Swift.Equatable {
    /// The Cognito Identity Pool ID for the request
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetCognitoEventsInputBody: Swift.Equatable {
}

extension GetCognitoEventsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCognitoEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCognitoEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
        } else {
            self.events = nil
        }
    }
}

/// The response from the GetCognitoEvents request
public struct GetCognitoEventsOutput: Swift.Equatable {
    /// The Cognito Events returned from the GetCognitoEvents request
    public var events: [Swift.String:Swift.String]?

    public init(
        events: [Swift.String:Swift.String]? = nil
    )
    {
        self.events = events
    }
}

struct GetCognitoEventsOutputBody: Swift.Equatable {
    let events: [Swift.String:Swift.String]?
}

extension GetCognitoEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .events)
        var eventsDecoded0: [Swift.String:Swift.String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String:Swift.String]()
            for (key0, lambdafunctionarn0) in eventsContainer {
                if let lambdafunctionarn0 = lambdafunctionarn0 {
                    eventsDecoded0?[key0] = lambdafunctionarn0
                }
            }
        }
        events = eventsDecoded0
    }
}

enum GetCognitoEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIdentityPoolConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/configuration"
    }
}

/// The input for the GetIdentityPoolConfiguration operation.
public struct GetIdentityPoolConfigurationInput: Swift.Equatable {
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. This is the ID of the pool for which to return a configuration.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetIdentityPoolConfigurationInputBody: Swift.Equatable {
}

extension GetIdentityPoolConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIdentityPoolConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIdentityPoolConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.cognitoStreams = output.cognitoStreams
            self.identityPoolId = output.identityPoolId
            self.pushSync = output.pushSync
        } else {
            self.cognitoStreams = nil
            self.identityPoolId = nil
            self.pushSync = nil
        }
    }
}

/// The output for the GetIdentityPoolConfiguration operation.
public struct GetIdentityPoolConfigurationOutput: Swift.Equatable {
    /// Options to apply to this identity pool for Amazon Cognito streams.
    public var cognitoStreams: CognitoSyncClientTypes.CognitoStreams?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito.
    public var identityPoolId: Swift.String?
    /// Options to apply to this identity pool for push synchronization.
    public var pushSync: CognitoSyncClientTypes.PushSync?

    public init(
        cognitoStreams: CognitoSyncClientTypes.CognitoStreams? = nil,
        identityPoolId: Swift.String? = nil,
        pushSync: CognitoSyncClientTypes.PushSync? = nil
    )
    {
        self.cognitoStreams = cognitoStreams
        self.identityPoolId = identityPoolId
        self.pushSync = pushSync
    }
}

struct GetIdentityPoolConfigurationOutputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let pushSync: CognitoSyncClientTypes.PushSync?
    let cognitoStreams: CognitoSyncClientTypes.CognitoStreams?
}

extension GetIdentityPoolConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoStreams = "CognitoStreams"
        case identityPoolId = "IdentityPoolId"
        case pushSync = "PushSync"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let pushSyncDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.PushSync.self, forKey: .pushSync)
        pushSync = pushSyncDecoded
        let cognitoStreamsDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.CognitoStreams.self, forKey: .cognitoStreams)
        cognitoStreams = cognitoStreamsDecoded
    }
}

enum GetIdentityPoolConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CognitoSyncClientTypes.IdentityPoolUsage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataStorage = "DataStorage"
        case identityPoolId = "IdentityPoolId"
        case lastModifiedDate = "LastModifiedDate"
        case syncSessionsCount = "SyncSessionsCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataStorage = self.dataStorage {
            try encodeContainer.encode(dataStorage, forKey: .dataStorage)
        }
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let syncSessionsCount = self.syncSessionsCount {
            try encodeContainer.encode(syncSessionsCount, forKey: .syncSessionsCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let syncSessionsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .syncSessionsCount)
        syncSessionsCount = syncSessionsCountDecoded
        let dataStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataStorage)
        dataStorage = dataStorageDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension CognitoSyncClientTypes {
    /// Usage information for the identity pool.
    public struct IdentityPoolUsage: Swift.Equatable {
        /// Data storage information for the identity pool.
        public var dataStorage: Swift.Int?
        /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
        public var identityPoolId: Swift.String?
        /// Date on which the identity pool was last modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// Number of sync sessions for the identity pool.
        public var syncSessionsCount: Swift.Int?

        public init(
            dataStorage: Swift.Int? = nil,
            identityPoolId: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            syncSessionsCount: Swift.Int? = nil
        )
        {
            self.dataStorage = dataStorage
            self.identityPoolId = identityPoolId
            self.lastModifiedDate = lastModifiedDate
            self.syncSessionsCount = syncSessionsCount
        }
    }

}

extension CognitoSyncClientTypes.IdentityUsage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataStorage = "DataStorage"
        case datasetCount = "DatasetCount"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case lastModifiedDate = "LastModifiedDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataStorage = self.dataStorage {
            try encodeContainer.encode(dataStorage, forKey: .dataStorage)
        }
        if datasetCount != 0 {
            try encodeContainer.encode(datasetCount, forKey: .datasetCount)
        }
        if let identityId = self.identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let datasetCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .datasetCount) ?? 0
        datasetCount = datasetCountDecoded
        let dataStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataStorage)
        dataStorage = dataStorageDecoded
    }
}

extension CognitoSyncClientTypes {
    /// Usage information for the identity.
    public struct IdentityUsage: Swift.Equatable {
        /// Total data storage for this identity.
        public var dataStorage: Swift.Int?
        /// Number of datasets for the identity.
        public var datasetCount: Swift.Int
        /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
        public var identityId: Swift.String?
        /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
        public var identityPoolId: Swift.String?
        /// Date on which the identity was last modified.
        public var lastModifiedDate: ClientRuntime.Date?

        public init(
            dataStorage: Swift.Int? = nil,
            datasetCount: Swift.Int = 0,
            identityId: Swift.String? = nil,
            identityPoolId: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil
        )
        {
            self.dataStorage = dataStorage
            self.datasetCount = datasetCount
            self.identityId = identityId
            self.identityPoolId = identityPoolId
            self.lastModifiedDate = lastModifiedDate
        }
    }

}

extension InternalErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates an internal service error.
public struct InternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Message returned by InternalErrorException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct InvalidConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Message returned by InvalidConfigurationException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidConfiguration" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLambdaFunctionOutputException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidLambdaFunctionOutputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The AWS Lambda function returned invalid output or an exception.
public struct InvalidLambdaFunctionOutputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message returned when an InvalidLambdaFunctionOutputException occurs
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLambdaFunctionOutput" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidLambdaFunctionOutputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLambdaFunctionOutputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when a request parameter does not comply with the associated constraints.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Message returned by InvalidParameterException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameter" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaThrottledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LambdaThrottledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// AWS Lambda throttled your account, please contact AWS Support
public struct LambdaThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message returned when an LambdaThrottledException is thrown
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LambdaThrottled" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LambdaThrottledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LambdaThrottledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when the limit on the number of objects or operations has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Message returned by LimitExceededException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDatasetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDatasetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        guard let identityId = identityId else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets"
    }
}

/// Request for a list of datasets for an identity.
public struct ListDatasetsInput: Swift.Equatable {
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// The maximum number of results to be returned.
    public var maxResults: Swift.Int?
    /// A pagination token for obtaining the next page of results.
    public var nextToken: Swift.String?

    public init(
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
}

extension ListDatasetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDatasetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatasetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.count = output.count
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.count = 0
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

/// Returned for a successful ListDatasets request.
public struct ListDatasetsOutput: Swift.Equatable {
    /// Number of datasets returned.
    public var count: Swift.Int
    /// A set of datasets.
    public var datasets: [CognitoSyncClientTypes.Dataset]?
    /// A pagination token for obtaining the next page of results.
    public var nextToken: Swift.String?

    public init(
        count: Swift.Int = 0,
        datasets: [CognitoSyncClientTypes.Dataset]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.count = count
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputBody: Swift.Equatable {
    let datasets: [CognitoSyncClientTypes.Dataset]?
    let count: Swift.Int
    let nextToken: Swift.String?
}

extension ListDatasetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case datasets = "Datasets"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([CognitoSyncClientTypes.Dataset?].self, forKey: .datasets)
        var datasetsDecoded0:[CognitoSyncClientTypes.Dataset]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [CognitoSyncClientTypes.Dataset]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatasetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIdentityPoolUsageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIdentityPoolUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/identitypools"
    }
}

/// A request for usage information on an identity pool.
public struct ListIdentityPoolUsageInput: Swift.Equatable {
    /// The maximum number of results to be returned.
    public var maxResults: Swift.Int?
    /// A pagination token for obtaining the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolUsageInputBody: Swift.Equatable {
}

extension ListIdentityPoolUsageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIdentityPoolUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdentityPoolUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.count = output.count
            self.identityPoolUsages = output.identityPoolUsages
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.count = 0
            self.identityPoolUsages = nil
            self.maxResults = 0
            self.nextToken = nil
        }
    }
}

/// Returned for a successful ListIdentityPoolUsage request.
public struct ListIdentityPoolUsageOutput: Swift.Equatable {
    /// Total number of identities for the identity pool.
    public var count: Swift.Int
    /// Usage information for the identity pools.
    public var identityPoolUsages: [CognitoSyncClientTypes.IdentityPoolUsage]?
    /// The maximum number of results to be returned.
    public var maxResults: Swift.Int
    /// A pagination token for obtaining the next page of results.
    public var nextToken: Swift.String?

    public init(
        count: Swift.Int = 0,
        identityPoolUsages: [CognitoSyncClientTypes.IdentityPoolUsage]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.count = count
        self.identityPoolUsages = identityPoolUsages
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolUsageOutputBody: Swift.Equatable {
    let identityPoolUsages: [CognitoSyncClientTypes.IdentityPoolUsage]?
    let maxResults: Swift.Int
    let count: Swift.Int
    let nextToken: Swift.String?
}

extension ListIdentityPoolUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case identityPoolUsages = "IdentityPoolUsages"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolUsagesContainer = try containerValues.decodeIfPresent([CognitoSyncClientTypes.IdentityPoolUsage?].self, forKey: .identityPoolUsages)
        var identityPoolUsagesDecoded0:[CognitoSyncClientTypes.IdentityPoolUsage]? = nil
        if let identityPoolUsagesContainer = identityPoolUsagesContainer {
            identityPoolUsagesDecoded0 = [CognitoSyncClientTypes.IdentityPoolUsage]()
            for structure0 in identityPoolUsagesContainer {
                if let structure0 = structure0 {
                    identityPoolUsagesDecoded0?.append(structure0)
                }
            }
        }
        identityPoolUsages = identityPoolUsagesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIdentityPoolUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecordsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let syncSessionToken = syncSessionToken {
                let syncSessionTokenQueryItem = ClientRuntime.URLQueryItem(name: "syncSessionToken".urlPercentEncoding(), value: Swift.String(syncSessionToken).urlPercentEncoding())
                items.append(syncSessionTokenQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let lastSyncCount = lastSyncCount {
                let lastSyncCountQueryItem = ClientRuntime.URLQueryItem(name: "lastSyncCount".urlPercentEncoding(), value: Swift.String(lastSyncCount).urlPercentEncoding())
                items.append(lastSyncCountQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRecordsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        guard let identityId = identityId else {
            return nil
        }
        guard let datasetName = datasetName else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets/\(datasetName.urlPercentEncoding())/records"
    }
}

/// A request for a list of records.
public struct ListRecordsInput: Swift.Equatable {
    /// A string of up to 128 characters. Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.' (dot).
    /// This member is required.
    public var datasetName: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// The last server sync count for this record.
    public var lastSyncCount: Swift.Int?
    /// The maximum number of results to be returned.
    public var maxResults: Swift.Int?
    /// A pagination token for obtaining the next page of results.
    public var nextToken: Swift.String?
    /// A token containing a session ID, identity ID, and expiration.
    public var syncSessionToken: Swift.String?

    public init(
        datasetName: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        lastSyncCount: Swift.Int? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        syncSessionToken: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.lastSyncCount = lastSyncCount
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.syncSessionToken = syncSessionToken
    }
}

struct ListRecordsInputBody: Swift.Equatable {
}

extension ListRecordsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRecordsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecordsOutputBody = try responseDecoder.decode(responseBody: data)
            self.count = output.count
            self.datasetDeletedAfterRequestedSyncCount = output.datasetDeletedAfterRequestedSyncCount
            self.datasetExists = output.datasetExists
            self.datasetSyncCount = output.datasetSyncCount
            self.lastModifiedBy = output.lastModifiedBy
            self.mergedDatasetNames = output.mergedDatasetNames
            self.nextToken = output.nextToken
            self.records = output.records
            self.syncSessionToken = output.syncSessionToken
        } else {
            self.count = 0
            self.datasetDeletedAfterRequestedSyncCount = false
            self.datasetExists = false
            self.datasetSyncCount = nil
            self.lastModifiedBy = nil
            self.mergedDatasetNames = nil
            self.nextToken = nil
            self.records = nil
            self.syncSessionToken = nil
        }
    }
}

/// Returned for a successful ListRecordsRequest.
public struct ListRecordsOutput: Swift.Equatable {
    /// Total number of records.
    public var count: Swift.Int
    /// A boolean value specifying whether to delete the dataset locally.
    public var datasetDeletedAfterRequestedSyncCount: Swift.Bool
    /// Indicates whether the dataset exists.
    public var datasetExists: Swift.Bool
    /// Server sync count for this dataset.
    public var datasetSyncCount: Swift.Int?
    /// The user/device that made the last change to this record.
    public var lastModifiedBy: Swift.String?
    /// Names of merged datasets.
    public var mergedDatasetNames: [Swift.String]?
    /// A pagination token for obtaining the next page of results.
    public var nextToken: Swift.String?
    /// A list of all records.
    public var records: [CognitoSyncClientTypes.Record]?
    /// A token containing a session ID, identity ID, and expiration.
    public var syncSessionToken: Swift.String?

    public init(
        count: Swift.Int = 0,
        datasetDeletedAfterRequestedSyncCount: Swift.Bool = false,
        datasetExists: Swift.Bool = false,
        datasetSyncCount: Swift.Int? = nil,
        lastModifiedBy: Swift.String? = nil,
        mergedDatasetNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        records: [CognitoSyncClientTypes.Record]? = nil,
        syncSessionToken: Swift.String? = nil
    )
    {
        self.count = count
        self.datasetDeletedAfterRequestedSyncCount = datasetDeletedAfterRequestedSyncCount
        self.datasetExists = datasetExists
        self.datasetSyncCount = datasetSyncCount
        self.lastModifiedBy = lastModifiedBy
        self.mergedDatasetNames = mergedDatasetNames
        self.nextToken = nextToken
        self.records = records
        self.syncSessionToken = syncSessionToken
    }
}

struct ListRecordsOutputBody: Swift.Equatable {
    let records: [CognitoSyncClientTypes.Record]?
    let nextToken: Swift.String?
    let count: Swift.Int
    let datasetSyncCount: Swift.Int?
    let lastModifiedBy: Swift.String?
    let mergedDatasetNames: [Swift.String]?
    let datasetExists: Swift.Bool
    let datasetDeletedAfterRequestedSyncCount: Swift.Bool
    let syncSessionToken: Swift.String?
}

extension ListRecordsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case datasetDeletedAfterRequestedSyncCount = "DatasetDeletedAfterRequestedSyncCount"
        case datasetExists = "DatasetExists"
        case datasetSyncCount = "DatasetSyncCount"
        case lastModifiedBy = "LastModifiedBy"
        case mergedDatasetNames = "MergedDatasetNames"
        case nextToken = "NextToken"
        case records = "Records"
        case syncSessionToken = "SyncSessionToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([CognitoSyncClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[CognitoSyncClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [CognitoSyncClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let datasetSyncCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .datasetSyncCount)
        datasetSyncCount = datasetSyncCountDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let mergedDatasetNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .mergedDatasetNames)
        var mergedDatasetNamesDecoded0:[Swift.String]? = nil
        if let mergedDatasetNamesContainer = mergedDatasetNamesContainer {
            mergedDatasetNamesDecoded0 = [Swift.String]()
            for string0 in mergedDatasetNamesContainer {
                if let string0 = string0 {
                    mergedDatasetNamesDecoded0?.append(string0)
                }
            }
        }
        mergedDatasetNames = mergedDatasetNamesDecoded0
        let datasetExistsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .datasetExists) ?? false
        datasetExists = datasetExistsDecoded
        let datasetDeletedAfterRequestedSyncCountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .datasetDeletedAfterRequestedSyncCount) ?? false
        datasetDeletedAfterRequestedSyncCount = datasetDeletedAfterRequestedSyncCountDecoded
        let syncSessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSessionToken)
        syncSessionToken = syncSessionTokenDecoded
    }
}

enum ListRecordsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotAuthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown when a user is not authorized to access the requested resource.
public struct NotAuthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message returned by a NotAuthorizedException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotAuthorizedError" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CognitoSyncClientTypes {
    public enum Operation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case remove
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [Operation] {
            return [
                .remove,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .remove: return "remove"
            case .replace: return "replace"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operation(rawValue: rawValue) ?? Operation.sdkUnknown(rawValue)
        }
    }
}

extension CognitoSyncClientTypes {
    public enum Platform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adm
        case apns
        case apnsSandbox
        case gcm
        case sdkUnknown(Swift.String)

        public static var allCases: [Platform] {
            return [
                .adm,
                .apns,
                .apnsSandbox,
                .gcm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adm: return "ADM"
            case .apns: return "APNS"
            case .apnsSandbox: return "APNS_SANDBOX"
            case .gcm: return "GCM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
        }
    }
}

extension CognitoSyncClientTypes.PushSync: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArns = "ApplicationArns"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArns = applicationArns {
            var applicationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationArns)
            for applicationarn0 in applicationArns {
                try applicationArnsContainer.encode(applicationarn0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationArns)
        var applicationArnsDecoded0:[Swift.String]? = nil
        if let applicationArnsContainer = applicationArnsContainer {
            applicationArnsDecoded0 = [Swift.String]()
            for string0 in applicationArnsContainer {
                if let string0 = string0 {
                    applicationArnsDecoded0?.append(string0)
                }
            }
        }
        applicationArns = applicationArnsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CognitoSyncClientTypes {
    /// Configuration options to be applied to the identity pool.
    public struct PushSync: Swift.Equatable {
        /// List of SNS platform application ARNs that could be used by clients.
        public var applicationArns: [Swift.String]?
        /// A role configured to allow Cognito to call SNS on behalf of the developer.
        public var roleArn: Swift.String?

        public init(
            applicationArns: [Swift.String]? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.applicationArns = applicationArns
            self.roleArn = roleArn
        }
    }

}

extension CognitoSyncClientTypes.Record: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceLastModifiedDate = "DeviceLastModifiedDate"
        case key = "Key"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case syncCount = "SyncCount"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceLastModifiedDate = self.deviceLastModifiedDate {
            try encodeContainer.encodeTimestamp(deviceLastModifiedDate, format: .epochSeconds, forKey: .deviceLastModifiedDate)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let syncCount = self.syncCount {
            try encodeContainer.encode(syncCount, forKey: .syncCount)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let syncCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .syncCount)
        syncCount = syncCountDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let deviceLastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deviceLastModifiedDate)
        deviceLastModifiedDate = deviceLastModifiedDateDecoded
    }
}

extension CognitoSyncClientTypes {
    /// The basic data structure of a dataset.
    public struct Record: Swift.Equatable {
        /// The last modified date of the client device.
        public var deviceLastModifiedDate: ClientRuntime.Date?
        /// The key for the record.
        public var key: Swift.String?
        /// The user/device that made the last change to this record.
        public var lastModifiedBy: Swift.String?
        /// The date on which the record was last modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The server sync count for this record.
        public var syncCount: Swift.Int?
        /// The value for the record.
        public var value: Swift.String?

        public init(
            deviceLastModifiedDate: ClientRuntime.Date? = nil,
            key: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            syncCount: Swift.Int? = nil,
            value: Swift.String? = nil
        )
        {
            self.deviceLastModifiedDate = deviceLastModifiedDate
            self.key = key
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.syncCount = syncCount
            self.value = value
        }
    }

}

extension CognitoSyncClientTypes.RecordPatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceLastModifiedDate = "DeviceLastModifiedDate"
        case key = "Key"
        case op = "Op"
        case syncCount = "SyncCount"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceLastModifiedDate = self.deviceLastModifiedDate {
            try encodeContainer.encodeTimestamp(deviceLastModifiedDate, format: .epochSeconds, forKey: .deviceLastModifiedDate)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let op = self.op {
            try encodeContainer.encode(op.rawValue, forKey: .op)
        }
        if let syncCount = self.syncCount {
            try encodeContainer.encode(syncCount, forKey: .syncCount)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.Operation.self, forKey: .op)
        op = opDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let syncCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .syncCount)
        syncCount = syncCountDecoded
        let deviceLastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deviceLastModifiedDate)
        deviceLastModifiedDate = deviceLastModifiedDateDecoded
    }
}

extension CognitoSyncClientTypes {
    /// An update operation for a record.
    public struct RecordPatch: Swift.Equatable {
        /// The last modified date of the client device.
        public var deviceLastModifiedDate: ClientRuntime.Date?
        /// The key associated with the record patch.
        /// This member is required.
        public var key: Swift.String?
        /// An operation, either replace or remove.
        /// This member is required.
        public var op: CognitoSyncClientTypes.Operation?
        /// Last known server sync count for this record. Set to 0 if unknown.
        /// This member is required.
        public var syncCount: Swift.Int?
        /// The value associated with the record patch.
        public var value: Swift.String?

        public init(
            deviceLastModifiedDate: ClientRuntime.Date? = nil,
            key: Swift.String? = nil,
            op: CognitoSyncClientTypes.Operation? = nil,
            syncCount: Swift.Int? = nil,
            value: Swift.String? = nil
        )
        {
            self.deviceLastModifiedDate = deviceLastModifiedDate
            self.key = key
            self.op = op
            self.syncCount = syncCount
            self.value = value
        }
    }

}

extension RegisterDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platform = "Platform"
        case token = "Token"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }
}

extension RegisterDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        guard let identityId = identityId else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/identity/\(identityId.urlPercentEncoding())/device"
    }
}

/// A request to RegisterDevice.
public struct RegisterDeviceInput: Swift.Equatable {
    /// The unique ID for this identity.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. Here, the ID of the pool that the identity belongs to.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
    /// This member is required.
    public var platform: CognitoSyncClientTypes.Platform?
    /// The push token.
    /// This member is required.
    public var token: Swift.String?

    public init(
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        platform: CognitoSyncClientTypes.Platform? = nil,
        token: Swift.String? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.platform = platform
        self.token = token
    }
}

struct RegisterDeviceInputBody: Swift.Equatable {
    let platform: CognitoSyncClientTypes.Platform?
    let token: Swift.String?
}

extension RegisterDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platform = "Platform"
        case token = "Token"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension RegisterDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceId = output.deviceId
        } else {
            self.deviceId = nil
        }
    }
}

/// Response to a RegisterDevice request.
public struct RegisterDeviceOutput: Swift.Equatable {
    /// The unique ID generated for this device by Cognito.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct RegisterDeviceOutputBody: Swift.Equatable {
    let deviceId: Swift.String?
}

extension RegisterDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

enum RegisterDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConfiguration": return try await InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown if an update can't be applied because the resource was changed by another call and this would result in a conflict.
public struct ResourceConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message returned by a ResourceConflictException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConflict" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown if the resource doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Message returned by a ResourceNotFoundException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SetCognitoEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .events)
            for (dictKey0, events0) in events {
                try eventsContainer.encode(events0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension SetCognitoEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/events"
    }
}

/// A request to configure Cognito Events""
public struct SetCognitoEventsInput: Swift.Equatable {
    /// The events to configure
    /// This member is required.
    public var events: [Swift.String:Swift.String]?
    /// The Cognito Identity Pool to use when configuring Cognito Events
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        events: [Swift.String:Swift.String]? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.events = events
        self.identityPoolId = identityPoolId
    }
}

struct SetCognitoEventsInputBody: Swift.Equatable {
    let events: [Swift.String:Swift.String]?
}

extension SetCognitoEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .events)
        var eventsDecoded0: [Swift.String:Swift.String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String:Swift.String]()
            for (key0, lambdafunctionarn0) in eventsContainer {
                if let lambdafunctionarn0 = lambdafunctionarn0 {
                    eventsDecoded0?[key0] = lambdafunctionarn0
                }
            }
        }
        events = eventsDecoded0
    }
}

extension SetCognitoEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetCognitoEventsOutput: Swift.Equatable {

    public init() { }
}

enum SetCognitoEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetIdentityPoolConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoStreams = "CognitoStreams"
        case pushSync = "PushSync"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cognitoStreams = self.cognitoStreams {
            try encodeContainer.encode(cognitoStreams, forKey: .cognitoStreams)
        }
        if let pushSync = self.pushSync {
            try encodeContainer.encode(pushSync, forKey: .pushSync)
        }
    }
}

extension SetIdentityPoolConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/configuration"
    }
}

/// The input for the SetIdentityPoolConfiguration operation.
public struct SetIdentityPoolConfigurationInput: Swift.Equatable {
    /// Options to apply to this identity pool for Amazon Cognito streams.
    public var cognitoStreams: CognitoSyncClientTypes.CognitoStreams?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. This is the ID of the pool to modify.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// Options to apply to this identity pool for push synchronization.
    public var pushSync: CognitoSyncClientTypes.PushSync?

    public init(
        cognitoStreams: CognitoSyncClientTypes.CognitoStreams? = nil,
        identityPoolId: Swift.String? = nil,
        pushSync: CognitoSyncClientTypes.PushSync? = nil
    )
    {
        self.cognitoStreams = cognitoStreams
        self.identityPoolId = identityPoolId
        self.pushSync = pushSync
    }
}

struct SetIdentityPoolConfigurationInputBody: Swift.Equatable {
    let pushSync: CognitoSyncClientTypes.PushSync?
    let cognitoStreams: CognitoSyncClientTypes.CognitoStreams?
}

extension SetIdentityPoolConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoStreams = "CognitoStreams"
        case pushSync = "PushSync"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pushSyncDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.PushSync.self, forKey: .pushSync)
        pushSync = pushSyncDecoded
        let cognitoStreamsDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.CognitoStreams.self, forKey: .cognitoStreams)
        cognitoStreams = cognitoStreamsDecoded
    }
}

extension SetIdentityPoolConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetIdentityPoolConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.cognitoStreams = output.cognitoStreams
            self.identityPoolId = output.identityPoolId
            self.pushSync = output.pushSync
        } else {
            self.cognitoStreams = nil
            self.identityPoolId = nil
            self.pushSync = nil
        }
    }
}

/// The output for the SetIdentityPoolConfiguration operation
public struct SetIdentityPoolConfigurationOutput: Swift.Equatable {
    /// Options to apply to this identity pool for Amazon Cognito streams.
    public var cognitoStreams: CognitoSyncClientTypes.CognitoStreams?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito.
    public var identityPoolId: Swift.String?
    /// Options to apply to this identity pool for push synchronization.
    public var pushSync: CognitoSyncClientTypes.PushSync?

    public init(
        cognitoStreams: CognitoSyncClientTypes.CognitoStreams? = nil,
        identityPoolId: Swift.String? = nil,
        pushSync: CognitoSyncClientTypes.PushSync? = nil
    )
    {
        self.cognitoStreams = cognitoStreams
        self.identityPoolId = identityPoolId
        self.pushSync = pushSync
    }
}

struct SetIdentityPoolConfigurationOutputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let pushSync: CognitoSyncClientTypes.PushSync?
    let cognitoStreams: CognitoSyncClientTypes.CognitoStreams?
}

extension SetIdentityPoolConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoStreams = "CognitoStreams"
        case identityPoolId = "IdentityPoolId"
        case pushSync = "PushSync"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let pushSyncDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.PushSync.self, forKey: .pushSync)
        pushSync = pushSyncDecoded
        let cognitoStreamsDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.CognitoStreams.self, forKey: .cognitoStreams)
        cognitoStreams = cognitoStreamsDecoded
    }
}

enum SetIdentityPoolConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModification": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CognitoSyncClientTypes {
    public enum StreamingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingStatus(rawValue: rawValue) ?? StreamingStatus.sdkUnknown(rawValue)
        }
    }
}

extension SubscribeToDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        guard let identityId = identityId else {
            return nil
        }
        guard let datasetName = datasetName else {
            return nil
        }
        guard let deviceId = deviceId else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets/\(datasetName.urlPercentEncoding())/subscriptions/\(deviceId.urlPercentEncoding())"
    }
}

/// A request to SubscribeToDatasetRequest.
public struct SubscribeToDatasetInput: Swift.Equatable {
    /// The name of the dataset to subcribe to.
    /// This member is required.
    public var datasetName: Swift.String?
    /// The unique ID generated for this device by Cognito.
    /// This member is required.
    public var deviceId: Swift.String?
    /// Unique ID for this identity.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. The ID of the pool to which the identity belongs.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        datasetName: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.deviceId = deviceId
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct SubscribeToDatasetInputBody: Swift.Equatable {
}

extension SubscribeToDatasetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension SubscribeToDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Response to a SubscribeToDataset request.
public struct SubscribeToDatasetOutput: Swift.Equatable {

    public init() { }
}

enum SubscribeToDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConfiguration": return try await InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Thrown if the request is throttled.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Message returned by a TooManyRequestsException.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequests" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsubscribeFromDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        guard let identityId = identityId else {
            return nil
        }
        guard let datasetName = datasetName else {
            return nil
        }
        guard let deviceId = deviceId else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets/\(datasetName.urlPercentEncoding())/subscriptions/\(deviceId.urlPercentEncoding())"
    }
}

/// A request to UnsubscribeFromDataset.
public struct UnsubscribeFromDatasetInput: Swift.Equatable {
    /// The name of the dataset from which to unsubcribe.
    /// This member is required.
    public var datasetName: Swift.String?
    /// The unique ID generated for this device by Cognito.
    /// This member is required.
    public var deviceId: Swift.String?
    /// Unique ID for this identity.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. The ID of the pool to which this identity belongs.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init(
        datasetName: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.deviceId = deviceId
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct UnsubscribeFromDatasetInputBody: Swift.Equatable {
}

extension UnsubscribeFromDatasetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UnsubscribeFromDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Response to an UnsubscribeFromDataset request.
public struct UnsubscribeFromDatasetOutput: Swift.Equatable {

    public init() { }
}

enum UnsubscribeFromDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidConfiguration": return try await InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRecordsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case recordPatches = "RecordPatches"
        case syncSessionToken = "SyncSessionToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let recordPatches = recordPatches {
            var recordPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordPatches)
            for recordpatch0 in recordPatches {
                try recordPatchesContainer.encode(recordpatch0)
            }
        }
        if let syncSessionToken = self.syncSessionToken {
            try encodeContainer.encode(syncSessionToken, forKey: .syncSessionToken)
        }
    }
}

extension UpdateRecordsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientContext = clientContext {
            items.add(Header(name: "x-amz-Client-Context", value: Swift.String(clientContext)))
        }
        return items
    }
}

extension UpdateRecordsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identityPoolId = identityPoolId else {
            return nil
        }
        guard let identityId = identityId else {
            return nil
        }
        guard let datasetName = datasetName else {
            return nil
        }
        return "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets/\(datasetName.urlPercentEncoding())"
    }
}

/// A request to post updates to records or add and delete records for a dataset and user.
public struct UpdateRecordsInput: Swift.Equatable {
    /// Intended to supply a device ID that will populate the lastModifiedBy field referenced in other methods. The ClientContext field is not yet implemented.
    public var clientContext: Swift.String?
    /// A string of up to 128 characters. Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.' (dot).
    /// This member is required.
    public var datasetName: Swift.String?
    /// The unique ID generated for this device by Cognito.
    public var deviceId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A list of patch operations.
    public var recordPatches: [CognitoSyncClientTypes.RecordPatch]?
    /// The SyncSessionToken returned by a previous call to ListRecords for this dataset and identity.
    /// This member is required.
    public var syncSessionToken: Swift.String?

    public init(
        clientContext: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        recordPatches: [CognitoSyncClientTypes.RecordPatch]? = nil,
        syncSessionToken: Swift.String? = nil
    )
    {
        self.clientContext = clientContext
        self.datasetName = datasetName
        self.deviceId = deviceId
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.recordPatches = recordPatches
        self.syncSessionToken = syncSessionToken
    }
}

struct UpdateRecordsInputBody: Swift.Equatable {
    let deviceId: Swift.String?
    let recordPatches: [CognitoSyncClientTypes.RecordPatch]?
    let syncSessionToken: Swift.String?
}

extension UpdateRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case recordPatches = "RecordPatches"
        case syncSessionToken = "SyncSessionToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let recordPatchesContainer = try containerValues.decodeIfPresent([CognitoSyncClientTypes.RecordPatch?].self, forKey: .recordPatches)
        var recordPatchesDecoded0:[CognitoSyncClientTypes.RecordPatch]? = nil
        if let recordPatchesContainer = recordPatchesContainer {
            recordPatchesDecoded0 = [CognitoSyncClientTypes.RecordPatch]()
            for structure0 in recordPatchesContainer {
                if let structure0 = structure0 {
                    recordPatchesDecoded0?.append(structure0)
                }
            }
        }
        recordPatches = recordPatchesDecoded0
        let syncSessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSessionToken)
        syncSessionToken = syncSessionTokenDecoded
    }
}

extension UpdateRecordsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRecordsOutputBody = try responseDecoder.decode(responseBody: data)
            self.records = output.records
        } else {
            self.records = nil
        }
    }
}

/// Returned for a successful UpdateRecordsRequest.
public struct UpdateRecordsOutput: Swift.Equatable {
    /// A list of records that have been updated.
    public var records: [CognitoSyncClientTypes.Record]?

    public init(
        records: [CognitoSyncClientTypes.Record]? = nil
    )
    {
        self.records = records
    }
}

struct UpdateRecordsOutputBody: Swift.Equatable {
    let records: [CognitoSyncClientTypes.Record]?
}

extension UpdateRecordsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case records = "Records"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([CognitoSyncClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[CognitoSyncClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [CognitoSyncClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
    }
}

enum UpdateRecordsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidLambdaFunctionOutput": return try await InvalidLambdaFunctionOutputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LambdaThrottled": return try await LambdaThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceeded": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedError": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflict": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
