// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AmplifyBackendClientTypes {
    public enum AdditionalConstraintsElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case requireDigit
        case requireLowercase
        case requireSymbol
        case requireUppercase
        case sdkUnknown(Swift.String)

        public static var allCases: [AdditionalConstraintsElement] {
            return [
                .requireDigit,
                .requireLowercase,
                .requireSymbol,
                .requireUppercase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .requireDigit: return "REQUIRE_DIGIT"
            case .requireLowercase: return "REQUIRE_LOWERCASE"
            case .requireSymbol: return "REQUIRE_SYMBOL"
            case .requireUppercase: return "REQUIRE_UPPERCASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdditionalConstraintsElement(rawValue: rawValue) ?? AdditionalConstraintsElement.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum AuthResources: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case identityPoolAndUserPool
        case userPoolOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthResources] {
            return [
                .identityPoolAndUserPool,
                .userPoolOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .identityPoolAndUserPool: return "IDENTITY_POOL_AND_USER_POOL"
            case .userPoolOnly: return "USER_POOL_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthResources(rawValue: rawValue) ?? AuthResources.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum AuthenticatedElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createAndUpdate
        case delete
        case read
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticatedElement] {
            return [
                .createAndUpdate,
                .delete,
                .read,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createAndUpdate: return "CREATE_AND_UPDATE"
            case .delete: return "DELETE"
            case .read: return "READ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticatedElement(rawValue: rawValue) ?? AuthenticatedElement.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoUserPoolId = "cognitoUserPoolId"
        case description = "description"
        case expirationTime = "expirationTime"
        case openIDAuthTTL = "openIDAuthTTL"
        case openIDClientId = "openIDClientId"
        case openIDIatTTL = "openIDIatTTL"
        case openIDIssueURL = "openIDIssueURL"
        case openIDProviderName = "openIDProviderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cognitoUserPoolId = self.cognitoUserPoolId {
            try encodeContainer.encode(cognitoUserPoolId, forKey: .cognitoUserPoolId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encode(expirationTime, forKey: .expirationTime)
        }
        if let openIDAuthTTL = self.openIDAuthTTL {
            try encodeContainer.encode(openIDAuthTTL, forKey: .openIDAuthTTL)
        }
        if let openIDClientId = self.openIDClientId {
            try encodeContainer.encode(openIDClientId, forKey: .openIDClientId)
        }
        if let openIDIatTTL = self.openIDIatTTL {
            try encodeContainer.encode(openIDIatTTL, forKey: .openIDIatTTL)
        }
        if let openIDIssueURL = self.openIDIssueURL {
            try encodeContainer.encode(openIDIssueURL, forKey: .openIDIssueURL)
        }
        if let openIDProviderName = self.openIDProviderName {
            try encodeContainer.encode(openIDProviderName, forKey: .openIDProviderName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cognitoUserPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cognitoUserPoolId)
        cognitoUserPoolId = cognitoUserPoolIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let openIDAuthTTLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDAuthTTL)
        openIDAuthTTL = openIDAuthTTLDecoded
        let openIDClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDClientId)
        openIDClientId = openIDClientIdDecoded
        let openIDIatTTLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDIatTTL)
        openIDIatTTL = openIDIatTTLDecoded
        let openIDIssueURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDIssueURL)
        openIDIssueURL = openIDIssueURLDecoded
        let openIDProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDProviderName)
        openIDProviderName = openIDProviderNameDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The authentication settings for accessing provisioned data models in your Amplify project.
    public struct BackendAPIAppSyncAuthSettings: Swift.Equatable {
        /// The Amazon Cognito user pool ID, if Amazon Cognito was used as an authentication setting to access your data models.
        public var cognitoUserPoolId: Swift.String?
        /// The API key description for API_KEY, if it was used as an authentication mechanism to access your data models.
        public var description: Swift.String?
        /// The API key expiration time for API_KEY, if it was used as an authentication mechanism to access your data models.
        public var expirationTime: Swift.Double?
        /// The expiry time for the OpenID authentication mechanism.
        public var openIDAuthTTL: Swift.String?
        /// The clientID for openID, if openID was used as an authentication setting to access your data models.
        public var openIDClientId: Swift.String?
        /// The expiry time for the OpenID authentication mechanism.
        public var openIDIatTTL: Swift.String?
        /// The openID issuer URL, if openID was used as an authentication setting to access your data models.
        public var openIDIssueURL: Swift.String?
        /// The OpenID provider name, if OpenID was used as an authentication mechanism to access your data models.
        public var openIDProviderName: Swift.String?

        public init(
            cognitoUserPoolId: Swift.String? = nil,
            description: Swift.String? = nil,
            expirationTime: Swift.Double? = nil,
            openIDAuthTTL: Swift.String? = nil,
            openIDClientId: Swift.String? = nil,
            openIDIatTTL: Swift.String? = nil,
            openIDIssueURL: Swift.String? = nil,
            openIDProviderName: Swift.String? = nil
        )
        {
            self.cognitoUserPoolId = cognitoUserPoolId
            self.description = description
            self.expirationTime = expirationTime
            self.openIDAuthTTL = openIDAuthTTL
            self.openIDClientId = openIDClientId
            self.openIDIatTTL = openIDIatTTL
            self.openIDIssueURL = openIDIssueURL
            self.openIDProviderName = openIDProviderName
        }
    }

}

extension AmplifyBackendClientTypes.BackendAPIAuthType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "mode"
        case settings = "settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Mode.self, forKey: .mode)
        mode = modeDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the auth types for your configured data models.
    public struct BackendAPIAuthType: Swift.Equatable {
        /// Describes the authentication mode.
        public var mode: AmplifyBackendClientTypes.Mode?
        /// Describes settings for the authentication mode.
        public var settings: AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings?

        public init(
            mode: AmplifyBackendClientTypes.Mode? = nil,
            settings: AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings? = nil
        )
        {
            self.mode = mode
            self.settings = settings
        }
    }

}

extension AmplifyBackendClientTypes.BackendAPIConflictResolution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolutionStrategy = "resolutionStrategy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolutionStrategy = self.resolutionStrategy {
            try encodeContainer.encode(resolutionStrategy.rawValue, forKey: .resolutionStrategy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolutionStrategyDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ResolutionStrategy.self, forKey: .resolutionStrategy)
        resolutionStrategy = resolutionStrategyDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the conflict resolution configuration for your data model configured in your Amplify project.
    public struct BackendAPIConflictResolution: Swift.Equatable {
        /// The strategy for conflict resolution.
        public var resolutionStrategy: AmplifyBackendClientTypes.ResolutionStrategy?

        public init(
            resolutionStrategy: AmplifyBackendClientTypes.ResolutionStrategy? = nil
        )
        {
            self.resolutionStrategy = resolutionStrategy
        }
    }

}

extension AmplifyBackendClientTypes.BackendAPIResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthTypes = "additionalAuthTypes"
        case apiName = "apiName"
        case conflictResolution = "conflictResolution"
        case defaultAuthType = "defaultAuthType"
        case service = "service"
        case transformSchema = "transformSchema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthTypes = additionalAuthTypes {
            var additionalAuthTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthTypes)
            for backendapiauthtype0 in additionalAuthTypes {
                try additionalAuthTypesContainer.encode(backendapiauthtype0)
            }
        }
        if let apiName = self.apiName {
            try encodeContainer.encode(apiName, forKey: .apiName)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let defaultAuthType = self.defaultAuthType {
            try encodeContainer.encode(defaultAuthType, forKey: .defaultAuthType)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let transformSchema = self.transformSchema {
            try encodeContainer.encode(transformSchema, forKey: .transformSchema)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalAuthTypesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.BackendAPIAuthType?].self, forKey: .additionalAuthTypes)
        var additionalAuthTypesDecoded0:[AmplifyBackendClientTypes.BackendAPIAuthType]? = nil
        if let additionalAuthTypesContainer = additionalAuthTypesContainer {
            additionalAuthTypesDecoded0 = [AmplifyBackendClientTypes.BackendAPIAuthType]()
            for structure0 in additionalAuthTypesContainer {
                if let structure0 = structure0 {
                    additionalAuthTypesDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthTypes = additionalAuthTypesDecoded0
        let apiNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiName)
        apiName = apiNameDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
        let defaultAuthTypeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIAuthType.self, forKey: .defaultAuthType)
        defaultAuthType = defaultAuthTypeDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let transformSchemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformSchema)
        transformSchema = transformSchemaDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The resource config for the data model, configured as a part of the Amplify project.
    public struct BackendAPIResourceConfig: Swift.Equatable {
        /// Additional authentication methods used to interact with your data models.
        public var additionalAuthTypes: [AmplifyBackendClientTypes.BackendAPIAuthType]?
        /// The API name used to interact with the data model, configured as a part of your Amplify project.
        public var apiName: Swift.String?
        /// The conflict resolution strategy for your data stored in the data models.
        public var conflictResolution: AmplifyBackendClientTypes.BackendAPIConflictResolution?
        /// The default authentication type for interacting with the configured data models in your Amplify project.
        public var defaultAuthType: AmplifyBackendClientTypes.BackendAPIAuthType?
        /// The service used to provision and interact with the data model.
        public var service: Swift.String?
        /// The definition of the data model in the annotated transform of the GraphQL schema.
        public var transformSchema: Swift.String?

        public init(
            additionalAuthTypes: [AmplifyBackendClientTypes.BackendAPIAuthType]? = nil,
            apiName: Swift.String? = nil,
            conflictResolution: AmplifyBackendClientTypes.BackendAPIConflictResolution? = nil,
            defaultAuthType: AmplifyBackendClientTypes.BackendAPIAuthType? = nil,
            service: Swift.String? = nil,
            transformSchema: Swift.String? = nil
        )
        {
            self.additionalAuthTypes = additionalAuthTypes
            self.apiName = apiName
            self.conflictResolution = conflictResolution
            self.defaultAuthType = defaultAuthType
            self.service = service
            self.transformSchema = transformSchema
        }
    }

}

extension AmplifyBackendClientTypes.BackendAuthAppleProviderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId = "client_id"
        case keyId = "key_id"
        case privateKey = "private_key"
        case teamId = "team_id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let keyId = self.keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let privateKey = self.privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
    }
}

extension AmplifyBackendClientTypes.BackendAuthAppleProviderConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AmplifyBackendClientTypes {
    /// Describes Apple social federation configurations for allowing your app users to sign in using OAuth.
    public struct BackendAuthAppleProviderConfig: Swift.Equatable {
        /// Describes the client_id (also called Services ID) that comes from Apple.
        public var clientId: Swift.String?
        /// Describes the key_id that comes from Apple.
        public var keyId: Swift.String?
        /// Describes the private_key that comes from Apple.
        public var privateKey: Swift.String?
        /// Describes the team_id that comes from Apple.
        public var teamId: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            keyId: Swift.String? = nil,
            privateKey: Swift.String? = nil,
            teamId: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.keyId = keyId
            self.privateKey = privateKey
            self.teamId = teamId
        }
    }

}

extension AmplifyBackendClientTypes.BackendAuthSocialProviderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId = "client_id"
        case clientSecret = "client_secret"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
    }
}

extension AmplifyBackendClientTypes.BackendAuthSocialProviderConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AmplifyBackendClientTypes {
    /// Describes third-party social federation configurations for allowing your app users to sign in using OAuth.
    public struct BackendAuthSocialProviderConfig: Swift.Equatable {
        /// Describes the client_id, which can be obtained from the third-party social federation provider.
        public var clientId: Swift.String?
        /// Describes the client_secret, which can be obtained from third-party social federation providers.
        public var clientSecret: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }
    }

}

extension AmplifyBackendClientTypes.BackendJobRespObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case createTime = "createTime"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
        case updateTime = "updateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let backendEnvironmentName = self.backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let createTime = self.createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encode(updateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The response object for this operation.
    public struct BackendJobRespObj: Swift.Equatable {
        /// The app ID.
        /// This member is required.
        public var appId: Swift.String?
        /// The name of the backend environment.
        /// This member is required.
        public var backendEnvironmentName: Swift.String?
        /// The time when the job was created.
        public var createTime: Swift.String?
        /// If the request fails, this error is returned.
        public var error: Swift.String?
        /// The ID for the job.
        public var jobId: Swift.String?
        /// The name of the operation.
        public var operation: Swift.String?
        /// The current status of the request.
        public var status: Swift.String?
        /// The time when the job was last updated.
        public var updateTime: Swift.String?

        public init(
            appId: Swift.String? = nil,
            backendEnvironmentName: Swift.String? = nil,
            createTime: Swift.String? = nil,
            error: Swift.String? = nil,
            jobId: Swift.String? = nil,
            operation: Swift.String? = nil,
            status: Swift.String? = nil,
            updateTime: Swift.String? = nil
        )
        {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.createTime = createTime
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension AmplifyBackendClientTypes.BackendStoragePermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticated = "authenticated"
        case unAuthenticated = "unAuthenticated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticated = authenticated {
            var authenticatedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authenticated)
            for authenticatedelement0 in authenticated {
                try authenticatedContainer.encode(authenticatedelement0.rawValue)
            }
        }
        if let unAuthenticated = unAuthenticated {
            var unAuthenticatedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .unAuthenticated)
            for unauthenticatedelement0 in unAuthenticated {
                try unAuthenticatedContainer.encode(unauthenticatedelement0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticatedContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.AuthenticatedElement?].self, forKey: .authenticated)
        var authenticatedDecoded0:[AmplifyBackendClientTypes.AuthenticatedElement]? = nil
        if let authenticatedContainer = authenticatedContainer {
            authenticatedDecoded0 = [AmplifyBackendClientTypes.AuthenticatedElement]()
            for enum0 in authenticatedContainer {
                if let enum0 = enum0 {
                    authenticatedDecoded0?.append(enum0)
                }
            }
        }
        authenticated = authenticatedDecoded0
        let unAuthenticatedContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.UnAuthenticatedElement?].self, forKey: .unAuthenticated)
        var unAuthenticatedDecoded0:[AmplifyBackendClientTypes.UnAuthenticatedElement]? = nil
        if let unAuthenticatedContainer = unAuthenticatedContainer {
            unAuthenticatedDecoded0 = [AmplifyBackendClientTypes.UnAuthenticatedElement]()
            for enum0 in unAuthenticatedContainer {
                if let enum0 = enum0 {
                    unAuthenticatedDecoded0?.append(enum0)
                }
            }
        }
        unAuthenticated = unAuthenticatedDecoded0
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the read, write, and delete permissions users have against your storage S3 bucket.
    public struct BackendStoragePermissions: Swift.Equatable {
        /// Lists all authenticated user read, write, and delete permissions for your S3 bucket.
        /// This member is required.
        public var authenticated: [AmplifyBackendClientTypes.AuthenticatedElement]?
        /// Lists all unauthenticated user read, write, and delete permissions for your S3 bucket.
        public var unAuthenticated: [AmplifyBackendClientTypes.UnAuthenticatedElement]?

        public init(
            authenticated: [AmplifyBackendClientTypes.AuthenticatedElement]? = nil,
            unAuthenticated: [AmplifyBackendClientTypes.UnAuthenticatedElement]? = nil
        )
        {
            self.authenticated = authenticated
            self.unAuthenticated = unAuthenticated
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error returned if a request is not formed properly.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// An error message to inform that the request failed.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloneBackendInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetEnvironmentName = "targetEnvironmentName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetEnvironmentName = self.targetEnvironmentName {
            try encodeContainer.encode(targetEnvironmentName, forKey: .targetEnvironmentName)
        }
    }
}

extension CloneBackendInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/environments/\(backendEnvironmentName.urlPercentEncoding())/clone"
    }
}

/// The request body for CloneBackend.
public struct CloneBackendInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of the destination backend environment to be created.
    /// This member is required.
    public var targetEnvironmentName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        targetEnvironmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.targetEnvironmentName = targetEnvironmentName
    }
}

struct CloneBackendInputBody: Swift.Equatable {
    let targetEnvironmentName: Swift.String?
}

extension CloneBackendInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetEnvironmentName = "targetEnvironmentName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEnvironmentName)
        targetEnvironmentName = targetEnvironmentNameDecoded
    }
}

extension CloneBackendOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloneBackendOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CloneBackendOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CloneBackendOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension CloneBackendOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum CloneBackendOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBackendAPIInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = self.backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension CreateBackendAPIInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/api"
    }
}

/// The request body for CreateBackendAPI.
public struct CreateBackendAPIInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for this request.
    /// This member is required.
    public var resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendAPIInputBody: Swift.Equatable {
    let backendEnvironmentName: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    let resourceName: Swift.String?
}

extension CreateBackendAPIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CreateBackendAPIOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBackendAPIOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CreateBackendAPIOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CreateBackendAPIOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension CreateBackendAPIOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateBackendAPIOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryMethod = "deliveryMethod"
        case emailSettings = "emailSettings"
        case smsSettings = "smsSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryMethod = self.deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let emailSettings = self.emailSettings {
            try encodeContainer.encode(emailSettings, forKey: .emailSettings)
        }
        if let smsSettings = self.smsSettings {
            try encodeContainer.encode(smsSettings, forKey: .smsSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.DeliveryMethod.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let emailSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.EmailSettings.self, forKey: .emailSettings)
        emailSettings = emailSettingsDecoded
        let smsSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SmsSettings.self, forKey: .smsSettings)
        smsSettings = smsSettingsDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAuthForgotPasswordConfig(deliveryMethod: \(Swift.String(describing: deliveryMethod)), emailSettings: \"CONTENT_REDACTED\", smsSettings: \"CONTENT_REDACTED\")"}
}

extension AmplifyBackendClientTypes {
    /// (DEPRECATED) Describes the forgot password policy for authenticating into the Amplify app.
    public struct CreateBackendAuthForgotPasswordConfig: Swift.Equatable {
        /// (DEPRECATED) Describes which mode to use (either SMS or email) to deliver messages to app users who want to recover their password.
        /// This member is required.
        public var deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod?
        /// (DEPRECATED) The configuration for the email sent when an app user forgets their password.
        public var emailSettings: AmplifyBackendClientTypes.EmailSettings?
        /// (DEPRECATED) The configuration for the SMS message sent when an app user forgets their password.
        public var smsSettings: AmplifyBackendClientTypes.SmsSettings?

        public init(
            deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod? = nil,
            emailSettings: AmplifyBackendClientTypes.EmailSettings? = nil,
            smsSettings: AmplifyBackendClientTypes.SmsSettings? = nil
        )
        {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolName = "identityPoolName"
        case unauthenticatedLogin = "unauthenticatedLogin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolName = self.identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
        if let unauthenticatedLogin = self.unauthenticatedLogin {
            try encodeContainer.encode(unauthenticatedLogin, forKey: .unauthenticatedLogin)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let unauthenticatedLoginDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .unauthenticatedLogin)
        unauthenticatedLogin = unauthenticatedLoginDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes authorization configurations for the auth resources, configured as a part of your Amplify project.
    public struct CreateBackendAuthIdentityPoolConfig: Swift.Equatable {
        /// Name of the Amazon Cognito identity pool used for authorization.
        /// This member is required.
        public var identityPoolName: Swift.String?
        /// Set to true or false based on whether you want to enable guest authorization to your Amplify app.
        /// This member is required.
        public var unauthenticatedLogin: Swift.Bool?

        public init(
            identityPoolName: Swift.String? = nil,
            unauthenticatedLogin: Swift.Bool? = nil
        )
        {
            self.identityPoolName = identityPoolName
            self.unauthenticatedLogin = unauthenticatedLogin
        }
    }

}

extension CreateBackendAuthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = self.backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension CreateBackendAuthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/auth"
    }
}

/// The request body for CreateBackendAuth.
public struct CreateBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for this request object.
    /// This member is required.
    public var resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendAuthInputBody: Swift.Equatable {
    let backendEnvironmentName: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig?
    let resourceName: Swift.String?
}

extension CreateBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthMFAConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mfaMode = "MFAMode"
        case settings = "settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mfaMode = self.mfaMode {
            try encodeContainer.encode(mfaMode.rawValue, forKey: .mfaMode)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mfaModeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.MFAMode.self, forKey: .mfaMode)
        mfaMode = mfaModeDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes whether to apply multi-factor authentication policies for your Amazon Cognito user pool configured as a part of your Amplify project.
    public struct CreateBackendAuthMFAConfig: Swift.Equatable {
        /// Describes whether MFA should be [ON, OFF, or OPTIONAL] for authentication in your Amplify project.
        /// This member is required.
        public var mfaMode: AmplifyBackendClientTypes.MFAMode?
        /// Describes the configuration settings and methods for your Amplify app users to use MFA.
        public var settings: AmplifyBackendClientTypes.Settings?

        public init(
            mfaMode: AmplifyBackendClientTypes.MFAMode? = nil,
            settings: AmplifyBackendClientTypes.Settings? = nil
        )
        {
            self.mfaMode = mfaMode
            self.settings = settings
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainPrefix = "domainPrefix"
        case oAuthGrantType = "oAuthGrantType"
        case oAuthScopes = "oAuthScopes"
        case redirectSignInURIs = "redirectSignInURIs"
        case redirectSignOutURIs = "redirectSignOutURIs"
        case socialProviderSettings = "socialProviderSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainPrefix = self.domainPrefix {
            try encodeContainer.encode(domainPrefix, forKey: .domainPrefix)
        }
        if let oAuthGrantType = self.oAuthGrantType {
            try encodeContainer.encode(oAuthGrantType.rawValue, forKey: .oAuthGrantType)
        }
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopeselement0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopeselement0.rawValue)
            }
        }
        if let redirectSignInURIs = redirectSignInURIs {
            var redirectSignInURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignInURIs)
            for __string0 in redirectSignInURIs {
                try redirectSignInURIsContainer.encode(__string0)
            }
        }
        if let redirectSignOutURIs = redirectSignOutURIs {
            var redirectSignOutURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignOutURIs)
            for __string0 in redirectSignOutURIs {
                try redirectSignOutURIsContainer.encode(__string0)
            }
        }
        if let socialProviderSettings = self.socialProviderSettings {
            try encodeContainer.encode(socialProviderSettings, forKey: .socialProviderSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainPrefix)
        domainPrefix = domainPrefixDecoded
        let oAuthGrantTypeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.OAuthGrantType.self, forKey: .oAuthGrantType)
        oAuthGrantType = oAuthGrantTypeDecoded
        let oAuthScopesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.OAuthScopesElement?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[AmplifyBackendClientTypes.OAuthScopesElement]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [AmplifyBackendClientTypes.OAuthScopesElement]()
            for enum0 in oAuthScopesContainer {
                if let enum0 = enum0 {
                    oAuthScopesDecoded0?.append(enum0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
        let redirectSignInURIsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectSignInURIs)
        var redirectSignInURIsDecoded0:[Swift.String]? = nil
        if let redirectSignInURIsContainer = redirectSignInURIsContainer {
            redirectSignInURIsDecoded0 = [Swift.String]()
            for string0 in redirectSignInURIsContainer {
                if let string0 = string0 {
                    redirectSignInURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignInURIs = redirectSignInURIsDecoded0
        let redirectSignOutURIsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectSignOutURIs)
        var redirectSignOutURIsDecoded0:[Swift.String]? = nil
        if let redirectSignOutURIsContainer = redirectSignOutURIsContainer {
            redirectSignOutURIsDecoded0 = [Swift.String]()
            for string0 in redirectSignOutURIsContainer {
                if let string0 = string0 {
                    redirectSignOutURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignOutURIs = redirectSignOutURIsDecoded0
        let socialProviderSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SocialProviderSettings.self, forKey: .socialProviderSettings)
        socialProviderSettings = socialProviderSettingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Creates the OAuth configuration for your Amplify project.
    public struct CreateBackendAuthOAuthConfig: Swift.Equatable {
        /// The domain prefix for your Amplify app.
        public var domainPrefix: Swift.String?
        /// The OAuth grant type that you use to allow app users to authenticate from your Amplify app.
        /// This member is required.
        public var oAuthGrantType: AmplifyBackendClientTypes.OAuthGrantType?
        /// List of OAuth-related flows used to allow your app users to authenticate from your Amplify app.
        /// This member is required.
        public var oAuthScopes: [AmplifyBackendClientTypes.OAuthScopesElement]?
        /// The redirected URI for signing in to your Amplify app.
        /// This member is required.
        public var redirectSignInURIs: [Swift.String]?
        /// Redirect URLs that OAuth uses when a user signs out of an Amplify app.
        /// This member is required.
        public var redirectSignOutURIs: [Swift.String]?
        /// The settings for using social providers to access your Amplify app.
        public var socialProviderSettings: AmplifyBackendClientTypes.SocialProviderSettings?

        public init(
            domainPrefix: Swift.String? = nil,
            oAuthGrantType: AmplifyBackendClientTypes.OAuthGrantType? = nil,
            oAuthScopes: [AmplifyBackendClientTypes.OAuthScopesElement]? = nil,
            redirectSignInURIs: [Swift.String]? = nil,
            redirectSignOutURIs: [Swift.String]? = nil,
            socialProviderSettings: AmplifyBackendClientTypes.SocialProviderSettings? = nil
        )
        {
            self.domainPrefix = domainPrefix
            self.oAuthGrantType = oAuthGrantType
            self.oAuthScopes = oAuthScopes
            self.redirectSignInURIs = redirectSignInURIs
            self.redirectSignOutURIs = redirectSignOutURIs
            self.socialProviderSettings = socialProviderSettings
        }
    }

}

extension CreateBackendAuthOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBackendAuthOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CreateBackendAuthOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CreateBackendAuthOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension CreateBackendAuthOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateBackendAuthOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConstraints = "additionalConstraints"
        case minimumLength = "minimumLength"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConstraints = additionalConstraints {
            var additionalConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConstraints)
            for additionalconstraintselement0 in additionalConstraints {
                try additionalConstraintsContainer.encode(additionalconstraintselement0.rawValue)
            }
        }
        if let minimumLength = self.minimumLength {
            try encodeContainer.encode(minimumLength, forKey: .minimumLength)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalConstraintsContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.AdditionalConstraintsElement?].self, forKey: .additionalConstraints)
        var additionalConstraintsDecoded0:[AmplifyBackendClientTypes.AdditionalConstraintsElement]? = nil
        if let additionalConstraintsContainer = additionalConstraintsContainer {
            additionalConstraintsDecoded0 = [AmplifyBackendClientTypes.AdditionalConstraintsElement]()
            for enum0 in additionalConstraintsContainer {
                if let enum0 = enum0 {
                    additionalConstraintsDecoded0?.append(enum0)
                }
            }
        }
        additionalConstraints = additionalConstraintsDecoded0
        let minimumLengthDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimumLength)
        minimumLength = minimumLengthDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The password policy configuration for the backend to your Amplify project.
    public struct CreateBackendAuthPasswordPolicyConfig: Swift.Equatable {
        /// Additional constraints for the password used to access the backend of your Amplify project.
        public var additionalConstraints: [AmplifyBackendClientTypes.AdditionalConstraintsElement]?
        /// The minimum length of the password used to access the backend of your Amplify project.
        /// This member is required.
        public var minimumLength: Swift.Double?

        public init(
            additionalConstraints: [AmplifyBackendClientTypes.AdditionalConstraintsElement]? = nil,
            minimumLength: Swift.Double? = nil
        )
        {
            self.additionalConstraints = additionalConstraints
            self.minimumLength = minimumLength
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authResources = "authResources"
        case identityPoolConfigs = "identityPoolConfigs"
        case service = "service"
        case userPoolConfigs = "userPoolConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authResources = self.authResources {
            try encodeContainer.encode(authResources.rawValue, forKey: .authResources)
        }
        if let identityPoolConfigs = self.identityPoolConfigs {
            try encodeContainer.encode(identityPoolConfigs, forKey: .identityPoolConfigs)
        }
        if let service = self.service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
        if let userPoolConfigs = self.userPoolConfigs {
            try encodeContainer.encode(userPoolConfigs, forKey: .userPoolConfigs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authResourcesDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.AuthResources.self, forKey: .authResources)
        authResources = authResourcesDecoded
        let identityPoolConfigsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig.self, forKey: .identityPoolConfigs)
        identityPoolConfigs = identityPoolConfigsDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let userPoolConfigsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig.self, forKey: .userPoolConfigs)
        userPoolConfigs = userPoolConfigsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Defines the resource configuration when creating an auth resource in your Amplify project.
    public struct CreateBackendAuthResourceConfig: Swift.Equatable {
        /// Defines whether you want to configure only authentication or both authentication and authorization settings.
        /// This member is required.
        public var authResources: AmplifyBackendClientTypes.AuthResources?
        /// Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of your auth resource in the Amplify project.
        public var identityPoolConfigs: AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig?
        /// Defines the service name to use when configuring an authentication resource in your Amplify project.
        /// This member is required.
        public var service: AmplifyBackendClientTypes.Service?
        /// Describes authentication configuration for the Amazon Cognito user pool, provisioned as a part of your auth resource in the Amplify project.
        /// This member is required.
        public var userPoolConfigs: AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig?

        public init(
            authResources: AmplifyBackendClientTypes.AuthResources? = nil,
            identityPoolConfigs: AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig? = nil,
            service: AmplifyBackendClientTypes.Service? = nil,
            userPoolConfigs: AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig? = nil
        )
        {
            self.authResources = authResources
            self.identityPoolConfigs = identityPoolConfigs
            self.service = service
            self.userPoolConfigs = userPoolConfigs
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPassword = "forgotPassword"
        case mfa = "mfa"
        case oAuth = "oAuth"
        case passwordPolicy = "passwordPolicy"
        case requiredSignUpAttributes = "requiredSignUpAttributes"
        case signInMethod = "signInMethod"
        case userPoolName = "userPoolName"
        case verificationMessage = "verificationMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPassword = self.forgotPassword {
            try encodeContainer.encode(forgotPassword, forKey: .forgotPassword)
        }
        if let mfa = self.mfa {
            try encodeContainer.encode(mfa, forKey: .mfa)
        }
        if let oAuth = self.oAuth {
            try encodeContainer.encode(oAuth, forKey: .oAuth)
        }
        if let passwordPolicy = self.passwordPolicy {
            try encodeContainer.encode(passwordPolicy, forKey: .passwordPolicy)
        }
        if let requiredSignUpAttributes = requiredSignUpAttributes {
            var requiredSignUpAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredSignUpAttributes)
            for requiredsignupattributeselement0 in requiredSignUpAttributes {
                try requiredSignUpAttributesContainer.encode(requiredsignupattributeselement0.rawValue)
            }
        }
        if let signInMethod = self.signInMethod {
            try encodeContainer.encode(signInMethod.rawValue, forKey: .signInMethod)
        }
        if let userPoolName = self.userPoolName {
            try encodeContainer.encode(userPoolName, forKey: .userPoolName)
        }
        if let verificationMessage = self.verificationMessage {
            try encodeContainer.encode(verificationMessage, forKey: .verificationMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forgotPasswordDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig.self, forKey: .forgotPassword)
        forgotPassword = forgotPasswordDecoded
        let mfaDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthMFAConfig.self, forKey: .mfa)
        mfa = mfaDecoded
        let oAuthDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig.self, forKey: .oAuth)
        oAuth = oAuthDecoded
        let passwordPolicyDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig.self, forKey: .passwordPolicy)
        passwordPolicy = passwordPolicyDecoded
        let requiredSignUpAttributesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.RequiredSignUpAttributesElement?].self, forKey: .requiredSignUpAttributes)
        var requiredSignUpAttributesDecoded0:[AmplifyBackendClientTypes.RequiredSignUpAttributesElement]? = nil
        if let requiredSignUpAttributesContainer = requiredSignUpAttributesContainer {
            requiredSignUpAttributesDecoded0 = [AmplifyBackendClientTypes.RequiredSignUpAttributesElement]()
            for enum0 in requiredSignUpAttributesContainer {
                if let enum0 = enum0 {
                    requiredSignUpAttributesDecoded0?.append(enum0)
                }
            }
        }
        requiredSignUpAttributes = requiredSignUpAttributesDecoded0
        let signInMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SignInMethod.self, forKey: .signInMethod)
        signInMethod = signInMethodDecoded
        let userPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolName)
        userPoolName = userPoolNameDecoded
        let verificationMessageDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthVerificationMessageConfig.self, forKey: .verificationMessage)
        verificationMessage = verificationMessageDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the Amazon Cognito user pool configuration for the auth resource to be configured for your Amplify project.
    public struct CreateBackendAuthUserPoolConfig: Swift.Equatable {
        /// (DEPRECATED) Describes the forgotten password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var forgotPassword: AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig?
        /// Describes whether to apply multi-factor authentication policies for your Amazon Cognito user pool configured as a part of your Amplify project.
        public var mfa: AmplifyBackendClientTypes.CreateBackendAuthMFAConfig?
        /// Describes the OAuth policy and rules for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var oAuth: AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig?
        /// Describes the password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var passwordPolicy: AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig?
        /// The required attributes to sign up new users in the user pool.
        /// This member is required.
        public var requiredSignUpAttributes: [AmplifyBackendClientTypes.RequiredSignUpAttributesElement]?
        /// Describes the sign-in methods that your Amplify app users use to log in using the Amazon Cognito user pool, configured as a part of your Amplify project.
        /// This member is required.
        public var signInMethod: AmplifyBackendClientTypes.SignInMethod?
        /// The Amazon Cognito user pool name.
        /// This member is required.
        public var userPoolName: Swift.String?
        /// Describes the email or SMS verification message for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var verificationMessage: AmplifyBackendClientTypes.CreateBackendAuthVerificationMessageConfig?

        public init(
            forgotPassword: AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig? = nil,
            mfa: AmplifyBackendClientTypes.CreateBackendAuthMFAConfig? = nil,
            oAuth: AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig? = nil,
            passwordPolicy: AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig? = nil,
            requiredSignUpAttributes: [AmplifyBackendClientTypes.RequiredSignUpAttributesElement]? = nil,
            signInMethod: AmplifyBackendClientTypes.SignInMethod? = nil,
            userPoolName: Swift.String? = nil,
            verificationMessage: AmplifyBackendClientTypes.CreateBackendAuthVerificationMessageConfig? = nil
        )
        {
            self.forgotPassword = forgotPassword
            self.mfa = mfa
            self.oAuth = oAuth
            self.passwordPolicy = passwordPolicy
            self.requiredSignUpAttributes = requiredSignUpAttributes
            self.signInMethod = signInMethod
            self.userPoolName = userPoolName
            self.verificationMessage = verificationMessage
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthVerificationMessageConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryMethod = "deliveryMethod"
        case emailSettings = "emailSettings"
        case smsSettings = "smsSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryMethod = self.deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let emailSettings = self.emailSettings {
            try encodeContainer.encode(emailSettings, forKey: .emailSettings)
        }
        if let smsSettings = self.smsSettings {
            try encodeContainer.encode(smsSettings, forKey: .smsSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.DeliveryMethod.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let emailSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.EmailSettings.self, forKey: .emailSettings)
        emailSettings = emailSettingsDecoded
        let smsSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SmsSettings.self, forKey: .smsSettings)
        smsSettings = smsSettingsDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthVerificationMessageConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAuthVerificationMessageConfig(deliveryMethod: \(Swift.String(describing: deliveryMethod)), emailSettings: \"CONTENT_REDACTED\", smsSettings: \"CONTENT_REDACTED\")"}
}

extension AmplifyBackendClientTypes {
    /// Creates an email or SMS verification message for the auth resource configured for your Amplify project.
    public struct CreateBackendAuthVerificationMessageConfig: Swift.Equatable {
        /// The type of verification message to send.
        /// This member is required.
        public var deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod?
        /// The settings for the email message.
        public var emailSettings: AmplifyBackendClientTypes.EmailSettings?
        /// The settings for the SMS message.
        public var smsSettings: AmplifyBackendClientTypes.SmsSettings?

        public init(
            deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod? = nil,
            emailSettings: AmplifyBackendClientTypes.EmailSettings? = nil,
            smsSettings: AmplifyBackendClientTypes.SmsSettings? = nil
        )
        {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }
    }

}

extension CreateBackendConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendManagerAppId = "backendManagerAppId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendManagerAppId = self.backendManagerAppId {
            try encodeContainer.encode(backendManagerAppId, forKey: .backendManagerAppId)
        }
    }
}

extension CreateBackendConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/config"
    }
}

/// The request body for CreateBackendConfig.
public struct CreateBackendConfigInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The app ID for the backend manager.
    public var backendManagerAppId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendManagerAppId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendManagerAppId = backendManagerAppId
    }
}

struct CreateBackendConfigInputBody: Swift.Equatable {
    let backendManagerAppId: Swift.String?
}

extension CreateBackendConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendManagerAppId = "backendManagerAppId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendManagerAppIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendManagerAppId)
        backendManagerAppId = backendManagerAppIdDecoded
    }
}

extension CreateBackendConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBackendConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct CreateBackendConfigOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.status = status
    }
}

struct CreateBackendConfigOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let jobId: Swift.String?
    let status: Swift.String?
}

extension CreateBackendConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case jobId = "jobId"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateBackendConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBackendInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case appName = "appName"
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appName = self.appName {
            try encodeContainer.encode(appName, forKey: .appName)
        }
        if let backendEnvironmentName = self.backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension CreateBackendInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backend"
    }
}

/// The request body for CreateBackend.
public struct CreateBackendInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the app.
    /// This member is required.
    public var appName: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for creating a backend.
    public var resourceConfig: AmplifyBackendClientTypes.ResourceConfig?
    /// The name of the resource.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        appName: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.ResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.appName = appName
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendInputBody: Swift.Equatable {
    let appId: Swift.String?
    let appName: Swift.String?
    let backendEnvironmentName: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.ResourceConfig?
    let resourceName: Swift.String?
}

extension CreateBackendInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case appName = "appName"
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let appNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appName)
        appName = appNameDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CreateBackendOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBackendOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CreateBackendOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CreateBackendOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension CreateBackendOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateBackendOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBackendStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = self.backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension CreateBackendStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/storage"
    }
}

/// The request body for CreateBackendStorage.
public struct CreateBackendStorageInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for creating backend storage.
    /// This member is required.
    public var resourceConfig: AmplifyBackendClientTypes.CreateBackendStorageResourceConfig?
    /// The name of the storage resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.CreateBackendStorageResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendStorageInputBody: Swift.Equatable {
    let backendEnvironmentName: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.CreateBackendStorageResourceConfig?
    let resourceName: Swift.String?
}

extension CreateBackendStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendStorageResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CreateBackendStorageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBackendStorageOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct CreateBackendStorageOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.status = status
    }
}

struct CreateBackendStorageOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let jobId: Swift.String?
    let status: Swift.String?
}

extension CreateBackendStorageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case jobId = "jobId"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateBackendStorageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyBackendClientTypes.CreateBackendStorageResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "bucketName"
        case permissions = "permissions"
        case serviceName = "serviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let permissions = self.permissions {
            try encodeContainer.encode(permissions, forKey: .permissions)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendStoragePermissions.self, forKey: .permissions)
        permissions = permissionsDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The resource configuration for creating backend storage.
    public struct CreateBackendStorageResourceConfig: Swift.Equatable {
        /// The name of the S3 bucket.
        public var bucketName: Swift.String?
        /// The authorization configuration for the storage S3 bucket.
        /// This member is required.
        public var permissions: AmplifyBackendClientTypes.BackendStoragePermissions?
        /// The name of the storage service.
        /// This member is required.
        public var serviceName: AmplifyBackendClientTypes.ServiceName?

        public init(
            bucketName: Swift.String? = nil,
            permissions: AmplifyBackendClientTypes.BackendStoragePermissions? = nil,
            serviceName: AmplifyBackendClientTypes.ServiceName? = nil
        )
        {
            self.bucketName = bucketName
            self.permissions = permissions
            self.serviceName = serviceName
        }
    }

}

extension CreateTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/challenge"
    }
}

public struct CreateTokenInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct CreateTokenInputBody: Swift.Equatable {
}

extension CreateTokenInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CreateTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.challengeCode = output.challengeCode
            self.sessionId = output.sessionId
            self.ttl = output.ttl
        } else {
            self.appId = nil
            self.challengeCode = nil
            self.sessionId = nil
            self.ttl = nil
        }
    }
}

public struct CreateTokenOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// One-time challenge code for authenticating into the Amplify Admin UI.
    public var challengeCode: Swift.String?
    /// A unique ID provided when creating a new challenge token.
    public var sessionId: Swift.String?
    /// The expiry time for the one-time generated token code.
    public var ttl: Swift.String?

    public init(
        appId: Swift.String? = nil,
        challengeCode: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        ttl: Swift.String? = nil
    )
    {
        self.appId = appId
        self.challengeCode = challengeCode
        self.sessionId = sessionId
        self.ttl = ttl
    }
}

struct CreateTokenOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let challengeCode: Swift.String?
    let sessionId: Swift.String?
    let ttl: Swift.String?
}

extension CreateTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case challengeCode = "challengeCode"
        case sessionId = "sessionId"
        case ttl = "ttl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let challengeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .challengeCode)
        challengeCode = challengeCodeDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ttl)
        ttl = ttlDecoded
    }
}

enum CreateTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBackendAPIInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension DeleteBackendAPIInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/api/\(backendEnvironmentName.urlPercentEncoding())/remove"
    }
}

/// The request body for DeleteBackendAPI.
public struct DeleteBackendAPIInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// Defines the resource configuration for the data model in your Amplify project.
    public var resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct DeleteBackendAPIInputBody: Swift.Equatable {
    let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    let resourceName: Swift.String?
}

extension DeleteBackendAPIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DeleteBackendAPIOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBackendAPIOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendAPIOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct DeleteBackendAPIOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension DeleteBackendAPIOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteBackendAPIOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBackendAuthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension DeleteBackendAuthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/auth/\(backendEnvironmentName.urlPercentEncoding())/remove"
    }
}

/// The request body for DeleteBackendAuth.
public struct DeleteBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct DeleteBackendAuthInputBody: Swift.Equatable {
    let resourceName: Swift.String?
}

extension DeleteBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DeleteBackendAuthOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBackendAuthOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendAuthOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct DeleteBackendAuthOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension DeleteBackendAuthOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteBackendAuthOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBackendInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/environments/\(backendEnvironmentName.urlPercentEncoding())/remove"
    }
}

public struct DeleteBackendInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
    }
}

struct DeleteBackendInputBody: Swift.Equatable {
}

extension DeleteBackendInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackendOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBackendOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct DeleteBackendOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension DeleteBackendOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteBackendOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBackendStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
        case serviceName = "serviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }
}

extension DeleteBackendStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/storage/\(backendEnvironmentName.urlPercentEncoding())/remove"
    }
}

/// The request body for DeleteBackendStorage.
public struct DeleteBackendStorageInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of the storage resource.
    /// This member is required.
    public var resourceName: Swift.String?
    /// The name of the storage service.
    /// This member is required.
    public var serviceName: AmplifyBackendClientTypes.ServiceName?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        serviceName: AmplifyBackendClientTypes.ServiceName? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
        self.serviceName = serviceName
    }
}

struct DeleteBackendStorageInputBody: Swift.Equatable {
    let resourceName: Swift.String?
    let serviceName: AmplifyBackendClientTypes.ServiceName?
}

extension DeleteBackendStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
        case serviceName = "serviceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension DeleteBackendStorageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBackendStorageOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendStorageOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.status = status
    }
}

struct DeleteBackendStorageOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let jobId: Swift.String?
    let status: Swift.String?
}

extension DeleteBackendStorageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case jobId = "jobId"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteBackendStorageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/challenge/\(sessionId.urlPercentEncoding())/remove"
    }
}

public struct DeleteTokenInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.sessionId = sessionId
    }
}

struct DeleteTokenInputBody: Swift.Equatable {
}

extension DeleteTokenInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.isSuccess = output.isSuccess
        } else {
            self.isSuccess = nil
        }
    }
}

public struct DeleteTokenOutput: Swift.Equatable {
    /// Indicates whether the request succeeded or failed.
    public var isSuccess: Swift.Bool?

    public init(
        isSuccess: Swift.Bool? = nil
    )
    {
        self.isSuccess = isSuccess
    }
}

struct DeleteTokenOutputBody: Swift.Equatable {
    let isSuccess: Swift.Bool?
}

extension DeleteTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isSuccess = "isSuccess"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isSuccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSuccess)
        isSuccess = isSuccessDecoded
    }
}

enum DeleteTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyBackendClientTypes {
    /// The type of verification message to send.
    public enum DeliveryMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sms
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliveryMethod] {
            return [
                .email,
                .sms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sms: return "SMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeliveryMethod(rawValue: rawValue) ?? DeliveryMethod.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.EmailSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailMessage = "emailMessage"
        case emailSubject = "emailSubject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailMessage = self.emailMessage {
            try encodeContainer.encode(emailMessage, forKey: .emailMessage)
        }
        if let emailSubject = self.emailSubject {
            try encodeContainer.encode(emailSubject, forKey: .emailSubject)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailMessage)
        emailMessage = emailMessageDecoded
        let emailSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailSubject)
        emailSubject = emailSubjectDecoded
    }
}

extension AmplifyBackendClientTypes.EmailSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AmplifyBackendClientTypes {
    /// The configuration for the email sent when an app user forgets their password.
    public struct EmailSettings: Swift.Equatable {
        /// The contents of the email message.
        public var emailMessage: Swift.String?
        /// The contents of the subject line of the email message.
        public var emailSubject: Swift.String?

        public init(
            emailMessage: Swift.String? = nil,
            emailSubject: Swift.String? = nil
        )
        {
            self.emailMessage = emailMessage
            self.emailSubject = emailSubject
        }
    }

}

extension GatewayTimeoutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GatewayTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error returned if there's a temporary issue with the service.
public struct GatewayTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// An error message to inform that the request failed.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GatewayTimeoutException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct GatewayTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension GatewayTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GenerateBackendAPIModelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension GenerateBackendAPIModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/api/\(backendEnvironmentName.urlPercentEncoding())/generateModels"
    }
}

/// The request body for GenerateBackendAPIModels.
public struct GenerateBackendAPIModelsInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GenerateBackendAPIModelsInputBody: Swift.Equatable {
    let resourceName: Swift.String?
}

extension GenerateBackendAPIModelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GenerateBackendAPIModelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GenerateBackendAPIModelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct GenerateBackendAPIModelsOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct GenerateBackendAPIModelsOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension GenerateBackendAPIModelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum GenerateBackendAPIModelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBackendAPIInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension GetBackendAPIInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/api/\(backendEnvironmentName.urlPercentEncoding())/details"
    }
}

/// The request body for GetBackendAPI.
public struct GetBackendAPIInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// Defines the resource configuration for the data model in your Amplify project.
    public var resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendAPIInputBody: Swift.Equatable {
    let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    let resourceName: Swift.String?
}

extension GetBackendAPIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendAPIModelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension GetBackendAPIModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/api/\(backendEnvironmentName.urlPercentEncoding())/getModels"
    }
}

/// The request body for GetBackendAPIModels.
public struct GetBackendAPIModelsInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GetBackendAPIModelsInputBody: Swift.Equatable {
    let resourceName: Swift.String?
}

extension GetBackendAPIModelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendAPIModelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackendAPIModelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.modelIntrospectionSchema = output.modelIntrospectionSchema
            self.models = output.models
            self.status = output.status
        } else {
            self.modelIntrospectionSchema = nil
            self.models = nil
            self.status = nil
        }
    }
}

public struct GetBackendAPIModelsOutput: Swift.Equatable {
    /// Stringified JSON of the model introspection schema for an existing backend API resource.
    public var modelIntrospectionSchema: Swift.String?
    /// Stringified JSON of the datastore model.
    public var models: Swift.String?
    /// The current status of the request.
    public var status: AmplifyBackendClientTypes.Status?

    public init(
        modelIntrospectionSchema: Swift.String? = nil,
        models: Swift.String? = nil,
        status: AmplifyBackendClientTypes.Status? = nil
    )
    {
        self.modelIntrospectionSchema = modelIntrospectionSchema
        self.models = models
        self.status = status
    }
}

struct GetBackendAPIModelsOutputBody: Swift.Equatable {
    let models: Swift.String?
    let status: AmplifyBackendClientTypes.Status?
    let modelIntrospectionSchema: Swift.String?
}

extension GetBackendAPIModelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelIntrospectionSchema = "modelIntrospectionSchema"
        case models = "models"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .models)
        models = modelsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let modelIntrospectionSchemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelIntrospectionSchema)
        modelIntrospectionSchema = modelIntrospectionSchemaDecoded
    }
}

enum GetBackendAPIModelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBackendAPIOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackendAPIOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.resourceConfig = output.resourceConfig
            self.resourceName = output.resourceName
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.resourceConfig = nil
            self.resourceName = nil
        }
    }
}

public struct GetBackendAPIOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The resource configuration for this response object.
    public var resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendAPIOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    let resourceName: Swift.String?
}

extension GetBackendAPIOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

enum GetBackendAPIOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBackendAuthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension GetBackendAuthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/auth/\(backendEnvironmentName.urlPercentEncoding())/details"
    }
}

/// The request body for GetBackendAuth.
public struct GetBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GetBackendAuthInputBody: Swift.Equatable {
    let resourceName: Swift.String?
}

extension GetBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendAuthOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackendAuthOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.resourceConfig = output.resourceConfig
            self.resourceName = output.resourceName
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.resourceConfig = nil
            self.resourceName = nil
        }
    }
}

public struct GetBackendAuthOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The resource configuration for authorization requests to the backend of your Amplify project.
    public var resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig?
    /// The name of this resource.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendAuthOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig?
    let resourceName: Swift.String?
}

extension GetBackendAuthOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

enum GetBackendAuthOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBackendInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = self.backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
    }
}

extension GetBackendInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/details"
    }
}

/// The request body for GetBackend.
public struct GetBackendInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
    }
}

struct GetBackendInputBody: Swift.Equatable {
    let backendEnvironmentName: Swift.String?
}

extension GetBackendInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
    }
}

extension GetBackendJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/job/\(backendEnvironmentName.urlPercentEncoding())/\(jobId.urlPercentEncoding())"
    }
}

public struct GetBackendJobInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
    }
}

struct GetBackendJobInputBody: Swift.Equatable {
}

extension GetBackendJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBackendJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackendJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.createTime = output.createTime
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.createTime = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct GetBackendJobOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The time when the job was created.
    public var createTime: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?
    /// The time when the job was last updated.
    public var updateTime: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        createTime: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil,
        updateTime: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.createTime = createTime
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
        self.updateTime = updateTime
    }
}

struct GetBackendJobOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let createTime: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
    let updateTime: Swift.String?
}

extension GetBackendJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case createTime = "createTime"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
        case updateTime = "updateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

enum GetBackendJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBackendOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackendOutputBody = try responseDecoder.decode(responseBody: data)
            self.amplifyFeatureFlags = output.amplifyFeatureFlags
            self.amplifyMetaConfig = output.amplifyMetaConfig
            self.appId = output.appId
            self.appName = output.appName
            self.backendEnvironmentList = output.backendEnvironmentList
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
        } else {
            self.amplifyFeatureFlags = nil
            self.amplifyMetaConfig = nil
            self.appId = nil
            self.appName = nil
            self.backendEnvironmentList = nil
            self.backendEnvironmentName = nil
            self.error = nil
        }
    }
}

public struct GetBackendOutput: Swift.Equatable {
    /// A stringified version of the cli.json file for your Amplify project.
    public var amplifyFeatureFlags: Swift.String?
    /// A stringified version of the current configs for your Amplify project.
    public var amplifyMetaConfig: Swift.String?
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the app.
    public var appName: Swift.String?
    /// A list of backend environments in an array.
    public var backendEnvironmentList: [Swift.String]?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request failed, this is the returned error.
    public var error: Swift.String?

    public init(
        amplifyFeatureFlags: Swift.String? = nil,
        amplifyMetaConfig: Swift.String? = nil,
        appId: Swift.String? = nil,
        appName: Swift.String? = nil,
        backendEnvironmentList: [Swift.String]? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil
    )
    {
        self.amplifyFeatureFlags = amplifyFeatureFlags
        self.amplifyMetaConfig = amplifyMetaConfig
        self.appId = appId
        self.appName = appName
        self.backendEnvironmentList = backendEnvironmentList
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
    }
}

struct GetBackendOutputBody: Swift.Equatable {
    let amplifyFeatureFlags: Swift.String?
    let amplifyMetaConfig: Swift.String?
    let appId: Swift.String?
    let appName: Swift.String?
    let backendEnvironmentList: [Swift.String]?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
}

extension GetBackendOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplifyFeatureFlags = "amplifyFeatureFlags"
        case amplifyMetaConfig = "amplifyMetaConfig"
        case appId = "appId"
        case appName = "appName"
        case backendEnvironmentList = "backendEnvironmentList"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplifyFeatureFlagsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amplifyFeatureFlags)
        amplifyFeatureFlags = amplifyFeatureFlagsDecoded
        let amplifyMetaConfigDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amplifyMetaConfig)
        amplifyMetaConfig = amplifyMetaConfigDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let appNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appName)
        appName = appNameDecoded
        let backendEnvironmentListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .backendEnvironmentList)
        var backendEnvironmentListDecoded0:[Swift.String]? = nil
        if let backendEnvironmentListContainer = backendEnvironmentListContainer {
            backendEnvironmentListDecoded0 = [Swift.String]()
            for string0 in backendEnvironmentListContainer {
                if let string0 = string0 {
                    backendEnvironmentListDecoded0?.append(string0)
                }
            }
        }
        backendEnvironmentList = backendEnvironmentListDecoded0
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

enum GetBackendOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBackendStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension GetBackendStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/storage/\(backendEnvironmentName.urlPercentEncoding())/details"
    }
}

/// The request body for GetBackendStorage.
public struct GetBackendStorageInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of the storage resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GetBackendStorageInputBody: Swift.Equatable {
    let resourceName: Swift.String?
}

extension GetBackendStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendStorageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBackendStorageOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.resourceConfig = output.resourceConfig
            self.resourceName = output.resourceName
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.resourceConfig = nil
            self.resourceName = nil
        }
    }
}

public struct GetBackendStorageOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for the backend storage resource.
    public var resourceConfig: AmplifyBackendClientTypes.GetBackendStorageResourceConfig?
    /// The name of the storage resource.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.GetBackendStorageResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendStorageOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.GetBackendStorageResourceConfig?
    let resourceName: Swift.String?
}

extension GetBackendStorageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.GetBackendStorageResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

enum GetBackendStorageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyBackendClientTypes.GetBackendStorageResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "bucketName"
        case imported = "imported"
        case permissions = "permissions"
        case serviceName = "serviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let imported = self.imported {
            try encodeContainer.encode(imported, forKey: .imported)
        }
        if let permissions = self.permissions {
            try encodeContainer.encode(permissions, forKey: .permissions)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let importedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .imported)
        imported = importedDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendStoragePermissions.self, forKey: .permissions)
        permissions = permissionsDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The details for a backend storage resource.
    public struct GetBackendStorageResourceConfig: Swift.Equatable {
        /// The name of the S3 bucket.
        public var bucketName: Swift.String?
        /// Returns True if the storage resource has been imported.
        /// This member is required.
        public var imported: Swift.Bool?
        /// The authorization configuration for the storage S3 bucket.
        public var permissions: AmplifyBackendClientTypes.BackendStoragePermissions?
        /// The name of the storage service.
        /// This member is required.
        public var serviceName: AmplifyBackendClientTypes.ServiceName?

        public init(
            bucketName: Swift.String? = nil,
            imported: Swift.Bool? = nil,
            permissions: AmplifyBackendClientTypes.BackendStoragePermissions? = nil,
            serviceName: AmplifyBackendClientTypes.ServiceName? = nil
        )
        {
            self.bucketName = bucketName
            self.imported = imported
            self.permissions = permissions
            self.serviceName = serviceName
        }
    }

}

extension GetTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/challenge/\(sessionId.urlPercentEncoding())"
    }
}

public struct GetTokenInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.sessionId = sessionId
    }
}

struct GetTokenInputBody: Swift.Equatable {
}

extension GetTokenInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.challengeCode = output.challengeCode
            self.sessionId = output.sessionId
            self.ttl = output.ttl
        } else {
            self.appId = nil
            self.challengeCode = nil
            self.sessionId = nil
            self.ttl = nil
        }
    }
}

public struct GetTokenOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The one-time challenge code for authenticating into the Amplify Admin UI.
    public var challengeCode: Swift.String?
    /// A unique ID provided when creating a new challenge token.
    public var sessionId: Swift.String?
    /// The expiry time for the one-time generated token code.
    public var ttl: Swift.String?

    public init(
        appId: Swift.String? = nil,
        challengeCode: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        ttl: Swift.String? = nil
    )
    {
        self.appId = appId
        self.challengeCode = challengeCode
        self.sessionId = sessionId
        self.ttl = ttl
    }
}

struct GetTokenOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let challengeCode: Swift.String?
    let sessionId: Swift.String?
    let ttl: Swift.String?
}

extension GetTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case challengeCode = "challengeCode"
        case sessionId = "sessionId"
        case ttl = "ttl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let challengeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .challengeCode)
        challengeCode = challengeCodeDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ttl)
        ttl = ttlDecoded
    }
}

enum GetTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportBackendAuthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "identityPoolId"
        case nativeClientId = "nativeClientId"
        case userPoolId = "userPoolId"
        case webClientId = "webClientId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let nativeClientId = self.nativeClientId {
            try encodeContainer.encode(nativeClientId, forKey: .nativeClientId)
        }
        if let userPoolId = self.userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let webClientId = self.webClientId {
            try encodeContainer.encode(webClientId, forKey: .webClientId)
        }
    }
}

extension ImportBackendAuthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/auth/\(backendEnvironmentName.urlPercentEncoding())/import"
    }
}

/// The request body for ImportBackendAuth.
public struct ImportBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The ID of the Amazon Cognito identity pool.
    public var identityPoolId: Swift.String?
    /// The ID of the Amazon Cognito native client.
    /// This member is required.
    public var nativeClientId: Swift.String?
    /// The ID of the Amazon Cognito user pool.
    /// This member is required.
    public var userPoolId: Swift.String?
    /// The ID of the Amazon Cognito web client.
    /// This member is required.
    public var webClientId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        nativeClientId: Swift.String? = nil,
        userPoolId: Swift.String? = nil,
        webClientId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.identityPoolId = identityPoolId
        self.nativeClientId = nativeClientId
        self.userPoolId = userPoolId
        self.webClientId = webClientId
    }
}

struct ImportBackendAuthInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let nativeClientId: Swift.String?
    let userPoolId: Swift.String?
    let webClientId: Swift.String?
}

extension ImportBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "identityPoolId"
        case nativeClientId = "nativeClientId"
        case userPoolId = "userPoolId"
        case webClientId = "webClientId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let nativeClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nativeClientId)
        nativeClientId = nativeClientIdDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let webClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webClientId)
        webClientId = webClientIdDecoded
    }
}

extension ImportBackendAuthOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportBackendAuthOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct ImportBackendAuthOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct ImportBackendAuthOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension ImportBackendAuthOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum ImportBackendAuthOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportBackendStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "bucketName"
        case serviceName = "serviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }
}

extension ImportBackendStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/storage/\(backendEnvironmentName.urlPercentEncoding())/import"
    }
}

/// The request body for ImportBackendStorage.
public struct ImportBackendStorageInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of the S3 bucket.
    public var bucketName: Swift.String?
    /// The name of the storage service.
    /// This member is required.
    public var serviceName: AmplifyBackendClientTypes.ServiceName?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        bucketName: Swift.String? = nil,
        serviceName: AmplifyBackendClientTypes.ServiceName? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.bucketName = bucketName
        self.serviceName = serviceName
    }
}

struct ImportBackendStorageInputBody: Swift.Equatable {
    let bucketName: Swift.String?
    let serviceName: AmplifyBackendClientTypes.ServiceName?
}

extension ImportBackendStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "bucketName"
        case serviceName = "serviceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension ImportBackendStorageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportBackendStorageOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct ImportBackendStorageOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.status = status
    }
}

struct ImportBackendStorageOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let jobId: Swift.String?
    let status: Swift.String?
}

extension ImportBackendStorageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case jobId = "jobId"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum ImportBackendStorageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBackendJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "jobId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case operation = "operation"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }
}

extension ListBackendJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/job/\(backendEnvironmentName.urlPercentEncoding())"
    }
}

/// The request body for ListBackendJobs.
public struct ListBackendJobsInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The maximum number of results that you want in the response.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Filters the list of response objects to include only those with the specified operation name.
    public var operation: Swift.String?
    /// Filters the list of response objects to include only those with the specified status.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operation = operation
        self.status = status
    }
}

struct ListBackendJobsInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension ListBackendJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "jobId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListBackendJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBackendJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackendJobsOutput: Swift.Equatable {
    /// An array of jobs and their properties.
    public var jobs: [AmplifyBackendClientTypes.BackendJobRespObj]?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        jobs: [AmplifyBackendClientTypes.BackendJobRespObj]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListBackendJobsOutputBody: Swift.Equatable {
    let jobs: [AmplifyBackendClientTypes.BackendJobRespObj]?
    let nextToken: Swift.String?
}

extension ListBackendJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "jobs"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.BackendJobRespObj?].self, forKey: .jobs)
        var jobsDecoded0:[AmplifyBackendClientTypes.BackendJobRespObj]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [AmplifyBackendClientTypes.BackendJobRespObj]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBackendJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListS3BucketsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListS3BucketsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/s3Buckets"
    }
}

/// The request body for S3Buckets.
public struct ListS3BucketsInput: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListS3BucketsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListS3BucketsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListS3BucketsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListS3BucketsOutputBody = try responseDecoder.decode(responseBody: data)
            self.buckets = output.buckets
            self.nextToken = output.nextToken
        } else {
            self.buckets = nil
            self.nextToken = nil
        }
    }
}

public struct ListS3BucketsOutput: Swift.Equatable {
    /// The list of S3 buckets.
    public var buckets: [AmplifyBackendClientTypes.S3BucketInfo]?
    /// Reserved for future use.
    public var nextToken: Swift.String?

    public init(
        buckets: [AmplifyBackendClientTypes.S3BucketInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.buckets = buckets
        self.nextToken = nextToken
    }
}

struct ListS3BucketsOutputBody: Swift.Equatable {
    let buckets: [AmplifyBackendClientTypes.S3BucketInfo]?
    let nextToken: Swift.String?
}

extension ListS3BucketsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buckets = "buckets"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketsContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.S3BucketInfo?].self, forKey: .buckets)
        var bucketsDecoded0:[AmplifyBackendClientTypes.S3BucketInfo]? = nil
        if let bucketsContainer = bucketsContainer {
            bucketsDecoded0 = [AmplifyBackendClientTypes.S3BucketInfo]()
            for structure0 in bucketsContainer {
                if let structure0 = structure0 {
                    bucketsDecoded0?.append(structure0)
                }
            }
        }
        buckets = bucketsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListS3BucketsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyBackendClientTypes.LoginAuthConfigReqObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsCognitoIdentityPoolId = "aws_cognito_identity_pool_id"
        case awsCognitoRegion = "aws_cognito_region"
        case awsUserPoolsId = "aws_user_pools_id"
        case awsUserPoolsWebClientId = "aws_user_pools_web_client_id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsCognitoIdentityPoolId = self.awsCognitoIdentityPoolId {
            try encodeContainer.encode(awsCognitoIdentityPoolId, forKey: .awsCognitoIdentityPoolId)
        }
        if let awsCognitoRegion = self.awsCognitoRegion {
            try encodeContainer.encode(awsCognitoRegion, forKey: .awsCognitoRegion)
        }
        if let awsUserPoolsId = self.awsUserPoolsId {
            try encodeContainer.encode(awsUserPoolsId, forKey: .awsUserPoolsId)
        }
        if let awsUserPoolsWebClientId = self.awsUserPoolsWebClientId {
            try encodeContainer.encode(awsUserPoolsWebClientId, forKey: .awsUserPoolsWebClientId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsCognitoIdentityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsCognitoIdentityPoolId)
        awsCognitoIdentityPoolId = awsCognitoIdentityPoolIdDecoded
        let awsCognitoRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsCognitoRegion)
        awsCognitoRegion = awsCognitoRegionDecoded
        let awsUserPoolsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsUserPoolsId)
        awsUserPoolsId = awsUserPoolsIdDecoded
        let awsUserPoolsWebClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsUserPoolsWebClientId)
        awsUserPoolsWebClientId = awsUserPoolsWebClientIdDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The request object for this operation.
    public struct LoginAuthConfigReqObj: Swift.Equatable {
        /// The Amazon Cognito identity pool ID used for the Amplify Admin UI login authorization.
        public var awsCognitoIdentityPoolId: Swift.String?
        /// The AWS Region for the Amplify Admin UI login.
        public var awsCognitoRegion: Swift.String?
        /// The Amazon Cognito user pool ID used for Amplify Admin UI login authentication.
        public var awsUserPoolsId: Swift.String?
        /// The web client ID for the Amazon Cognito user pools.
        public var awsUserPoolsWebClientId: Swift.String?

        public init(
            awsCognitoIdentityPoolId: Swift.String? = nil,
            awsCognitoRegion: Swift.String? = nil,
            awsUserPoolsId: Swift.String? = nil,
            awsUserPoolsWebClientId: Swift.String? = nil
        )
        {
            self.awsCognitoIdentityPoolId = awsCognitoIdentityPoolId
            self.awsCognitoRegion = awsCognitoRegion
            self.awsUserPoolsId = awsUserPoolsId
            self.awsUserPoolsWebClientId = awsUserPoolsWebClientId
        }
    }

}

extension AmplifyBackendClientTypes {
    public enum MFAMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case `optional`
        case sdkUnknown(Swift.String)

        public static var allCases: [MFAMode] {
            return [
                .off,
                .on,
                .optional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .on: return "ON"
            case .optional: return "OPTIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MFAMode(rawValue: rawValue) ?? MFAMode.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum MfaTypesElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sms
        case totp
        case sdkUnknown(Swift.String)

        public static var allCases: [MfaTypesElement] {
            return [
                .sms,
                .totp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sms: return "SMS"
            case .totp: return "TOTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MfaTypesElement(rawValue: rawValue) ?? MfaTypesElement.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum Mode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonCognitoUserPools
        case apiKey
        case awsIam
        case openidConnect
        case sdkUnknown(Swift.String)

        public static var allCases: [Mode] {
            return [
                .amazonCognitoUserPools,
                .apiKey,
                .awsIam,
                .openidConnect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonCognitoUserPools: return "AMAZON_COGNITO_USER_POOLS"
            case .apiKey: return "API_KEY"
            case .awsIam: return "AWS_IAM"
            case .openidConnect: return "OPENID_CONNECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error returned when a specific resource type is not found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// An error message to inform that the request has failed.
        public internal(set) var message: Swift.String? = nil
        /// The type of resource that is not found.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case resourceType = "resourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AmplifyBackendClientTypes {
    public enum OAuthGrantType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case code
        case implicit
        case sdkUnknown(Swift.String)

        public static var allCases: [OAuthGrantType] {
            return [
                .code,
                .implicit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .code: return "CODE"
            case .implicit: return "IMPLICIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OAuthGrantType(rawValue: rawValue) ?? OAuthGrantType.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum OAuthScopesElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsCognitoSigninUserAdmin
        case email
        case openid
        case phone
        case profile
        case sdkUnknown(Swift.String)

        public static var allCases: [OAuthScopesElement] {
            return [
                .awsCognitoSigninUserAdmin,
                .email,
                .openid,
                .phone,
                .profile,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsCognitoSigninUserAdmin: return "AWS_COGNITO_SIGNIN_USER_ADMIN"
            case .email: return "EMAIL"
            case .openid: return "OPENID"
            case .phone: return "PHONE"
            case .profile: return "PROFILE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OAuthScopesElement(rawValue: rawValue) ?? OAuthScopesElement.sdkUnknown(rawValue)
        }
    }
}

extension RemoveAllBackendsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cleanAmplifyApp = "cleanAmplifyApp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cleanAmplifyApp = self.cleanAmplifyApp {
            try encodeContainer.encode(cleanAmplifyApp, forKey: .cleanAmplifyApp)
        }
    }
}

extension RemoveAllBackendsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/remove"
    }
}

/// The request body for RemoveAllBackends.
public struct RemoveAllBackendsInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// Cleans up the Amplify Console app if this value is set to true.
    public var cleanAmplifyApp: Swift.Bool?

    public init(
        appId: Swift.String? = nil,
        cleanAmplifyApp: Swift.Bool? = nil
    )
    {
        self.appId = appId
        self.cleanAmplifyApp = cleanAmplifyApp
    }
}

struct RemoveAllBackendsInputBody: Swift.Equatable {
    let cleanAmplifyApp: Swift.Bool?
}

extension RemoveAllBackendsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cleanAmplifyApp = "cleanAmplifyApp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cleanAmplifyAppDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cleanAmplifyApp)
        cleanAmplifyApp = cleanAmplifyAppDecoded
    }
}

extension RemoveAllBackendsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveAllBackendsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct RemoveAllBackendsOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct RemoveAllBackendsOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension RemoveAllBackendsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum RemoveAllBackendsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveBackendConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/config/remove"
    }
}

public struct RemoveBackendConfigInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct RemoveBackendConfigInputBody: Swift.Equatable {
}

extension RemoveBackendConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveBackendConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveBackendConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
        } else {
            self.error = nil
        }
    }
}

public struct RemoveBackendConfigOutput: Swift.Equatable {
    /// If the request fails, this error is returned.
    public var error: Swift.String?

    public init(
        error: Swift.String? = nil
    )
    {
        self.error = error
    }
}

struct RemoveBackendConfigOutputBody: Swift.Equatable {
    let error: Swift.String?
}

extension RemoveBackendConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "error"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

enum RemoveBackendConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum RequiredSignUpAttributesElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case address
        case birthdate
        case email
        case familyName
        case gender
        case givenName
        case locale
        case middleName
        case name
        case nickname
        case phoneNumber
        case picture
        case preferredUsername
        case profile
        case updatedAt
        case website
        case zoneInfo
        case sdkUnknown(Swift.String)

        public static var allCases: [RequiredSignUpAttributesElement] {
            return [
                .address,
                .birthdate,
                .email,
                .familyName,
                .gender,
                .givenName,
                .locale,
                .middleName,
                .name,
                .nickname,
                .phoneNumber,
                .picture,
                .preferredUsername,
                .profile,
                .updatedAt,
                .website,
                .zoneInfo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .birthdate: return "BIRTHDATE"
            case .email: return "EMAIL"
            case .familyName: return "FAMILY_NAME"
            case .gender: return "GENDER"
            case .givenName: return "GIVEN_NAME"
            case .locale: return "LOCALE"
            case .middleName: return "MIDDLE_NAME"
            case .name: return "NAME"
            case .nickname: return "NICKNAME"
            case .phoneNumber: return "PHONE_NUMBER"
            case .picture: return "PICTURE"
            case .preferredUsername: return "PREFERRED_USERNAME"
            case .profile: return "PROFILE"
            case .updatedAt: return "UPDATED_AT"
            case .website: return "WEBSITE"
            case .zoneInfo: return "ZONE_INFO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequiredSignUpAttributesElement(rawValue: rawValue) ?? RequiredSignUpAttributesElement.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum ResolutionStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automerge
        case lambda
        case `none`
        case optimisticConcurrency
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolutionStrategy] {
            return [
                .automerge,
                .lambda,
                .none,
                .optimisticConcurrency,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automerge: return "AUTOMERGE"
            case .lambda: return "LAMBDA"
            case .none: return "NONE"
            case .optimisticConcurrency: return "OPTIMISTIC_CONCURRENCY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolutionStrategy(rawValue: rawValue) ?? ResolutionStrategy.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.ResourceConfig: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AmplifyBackendClientTypes {
    /// Defines the resource configuration for the data model in your Amplify project.
    public struct ResourceConfig: Swift.Equatable {

        public init() { }
    }

}

extension AmplifyBackendClientTypes.S3BucketInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "creationDate"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the metadata of the S3 bucket.
    public struct S3BucketInfo: Swift.Equatable {
        /// The creation date of the S3 bucket.
        public var creationDate: Swift.String?
        /// The name of the S3 bucket.
        public var name: Swift.String?

        public init(
            creationDate: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.name = name
        }
    }

}

extension AmplifyBackendClientTypes {
    public enum Service: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cognito
        case sdkUnknown(Swift.String)

        public static var allCases: [Service] {
            return [
                .cognito,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cognito: return "COGNITO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Service(rawValue: rawValue) ?? Service.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum ServiceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceName] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceName(rawValue: rawValue) ?? ServiceName.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mfaTypes = "mfaTypes"
        case smsMessage = "smsMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mfaTypes = mfaTypes {
            var mfaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mfaTypes)
            for mfatypeselement0 in mfaTypes {
                try mfaTypesContainer.encode(mfatypeselement0.rawValue)
            }
        }
        if let smsMessage = self.smsMessage {
            try encodeContainer.encode(smsMessage, forKey: .smsMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mfaTypesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.MfaTypesElement?].self, forKey: .mfaTypes)
        var mfaTypesDecoded0:[AmplifyBackendClientTypes.MfaTypesElement]? = nil
        if let mfaTypesContainer = mfaTypesContainer {
            mfaTypesDecoded0 = [AmplifyBackendClientTypes.MfaTypesElement]()
            for enum0 in mfaTypesContainer {
                if let enum0 = enum0 {
                    mfaTypesDecoded0?.append(enum0)
                }
            }
        }
        mfaTypes = mfaTypesDecoded0
        let smsMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .smsMessage)
        smsMessage = smsMessageDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The settings of your MFA configuration for the backend of your Amplify project.
    public struct Settings: Swift.Equatable {
        /// The supported MFA types.
        public var mfaTypes: [AmplifyBackendClientTypes.MfaTypesElement]?
        /// The body of the SMS message.
        public var smsMessage: Swift.String?

        public init(
            mfaTypes: [AmplifyBackendClientTypes.MfaTypesElement]? = nil,
            smsMessage: Swift.String? = nil
        )
        {
            self.mfaTypes = mfaTypes
            self.smsMessage = smsMessage
        }
    }

}

extension AmplifyBackendClientTypes {
    public enum SignInMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case emailAndPhoneNumber
        case phoneNumber
        case username
        case sdkUnknown(Swift.String)

        public static var allCases: [SignInMethod] {
            return [
                .email,
                .emailAndPhoneNumber,
                .phoneNumber,
                .username,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .emailAndPhoneNumber: return "EMAIL_AND_PHONE_NUMBER"
            case .phoneNumber: return "PHONE_NUMBER"
            case .username: return "USERNAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SignInMethod(rawValue: rawValue) ?? SignInMethod.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.SmsSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case smsMessage = "smsMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let smsMessage = self.smsMessage {
            try encodeContainer.encode(smsMessage, forKey: .smsMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let smsMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .smsMessage)
        smsMessage = smsMessageDecoded
    }
}

extension AmplifyBackendClientTypes.SmsSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension AmplifyBackendClientTypes {
    /// SMS settings for authentication.
    public struct SmsSettings: Swift.Equatable {
        /// The contents of the SMS message.
        public var smsMessage: Swift.String?

        public init(
            smsMessage: Swift.String? = nil
        )
        {
            self.smsMessage = smsMessage
        }
    }

}

extension AmplifyBackendClientTypes.SocialProviderSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facebook = "Facebook"
        case google = "Google"
        case loginWithAmazon = "LoginWithAmazon"
        case signInWithApple = "SignInWithApple"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facebook = self.facebook {
            try encodeContainer.encode(facebook, forKey: .facebook)
        }
        if let google = self.google {
            try encodeContainer.encode(google, forKey: .google)
        }
        if let loginWithAmazon = self.loginWithAmazon {
            try encodeContainer.encode(loginWithAmazon, forKey: .loginWithAmazon)
        }
        if let signInWithApple = self.signInWithApple {
            try encodeContainer.encode(signInWithApple, forKey: .signInWithApple)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facebookDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAuthSocialProviderConfig.self, forKey: .facebook)
        facebook = facebookDecoded
        let googleDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAuthSocialProviderConfig.self, forKey: .google)
        google = googleDecoded
        let loginWithAmazonDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAuthSocialProviderConfig.self, forKey: .loginWithAmazon)
        loginWithAmazon = loginWithAmazonDecoded
        let signInWithAppleDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAuthAppleProviderConfig.self, forKey: .signInWithApple)
        signInWithApple = signInWithAppleDecoded
    }
}

extension AmplifyBackendClientTypes.SocialProviderSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SocialProviderSettings(facebook: \"CONTENT_REDACTED\", google: \"CONTENT_REDACTED\", loginWithAmazon: \"CONTENT_REDACTED\", signInWithApple: \"CONTENT_REDACTED\")"}
}

extension AmplifyBackendClientTypes {
    /// The settings for using the social identity providers for access to your Amplify app.
    public struct SocialProviderSettings: Swift.Equatable {
        /// Describes third-party social federation configurations for allowing your app users to sign in using OAuth.
        public var facebook: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig?
        /// Describes third-party social federation configurations for allowing your app users to sign in using OAuth.
        public var google: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig?
        /// Describes third-party social federation configurations for allowing your app users to sign in using OAuth.
        public var loginWithAmazon: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig?
        /// Describes Apple social federation configurations for allowing your app users to sign in using OAuth.
        public var signInWithApple: AmplifyBackendClientTypes.BackendAuthAppleProviderConfig?

        public init(
            facebook: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig? = nil,
            google: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig? = nil,
            loginWithAmazon: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig? = nil,
            signInWithApple: AmplifyBackendClientTypes.BackendAuthAppleProviderConfig? = nil
        )
        {
            self.facebook = facebook
            self.google = google
            self.loginWithAmazon = loginWithAmazon
            self.signInWithApple = signInWithApple
        }
    }

}

extension AmplifyBackendClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case latest
        case stale
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .latest,
                .stale,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .latest: return "LATEST"
            case .stale: return "STALE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.limitType = output.limitType
            self.properties.message = output.message
        } else {
            self.properties.limitType = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error that is returned when a limit of a specific type has been exceeded.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The type of limit that was exceeded.
        public internal(set) var limitType: Swift.String? = nil
        /// An error message to inform that the request has failed.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limitType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.limitType = limitType
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let limitType: Swift.String?
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitType = "limitType"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyBackendClientTypes {
    public enum UnAuthenticatedElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createAndUpdate
        case delete
        case read
        case sdkUnknown(Swift.String)

        public static var allCases: [UnAuthenticatedElement] {
            return [
                .createAndUpdate,
                .delete,
                .read,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createAndUpdate: return "CREATE_AND_UPDATE"
            case .delete: return "DELETE"
            case .read: return "READ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UnAuthenticatedElement(rawValue: rawValue) ?? UnAuthenticatedElement.sdkUnknown(rawValue)
        }
    }
}

extension UpdateBackendAPIInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension UpdateBackendAPIInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/api/\(backendEnvironmentName.urlPercentEncoding())"
    }
}

/// The request body for UpdateBackendAPI.
public struct UpdateBackendAPIInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// Defines the resource configuration for the data model in your Amplify project.
    public var resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct UpdateBackendAPIInputBody: Swift.Equatable {
    let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    let resourceName: Swift.String?
}

extension UpdateBackendAPIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UpdateBackendAPIOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBackendAPIOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct UpdateBackendAPIOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct UpdateBackendAPIOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension UpdateBackendAPIOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdateBackendAPIOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryMethod = "deliveryMethod"
        case emailSettings = "emailSettings"
        case smsSettings = "smsSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryMethod = self.deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let emailSettings = self.emailSettings {
            try encodeContainer.encode(emailSettings, forKey: .emailSettings)
        }
        if let smsSettings = self.smsSettings {
            try encodeContainer.encode(smsSettings, forKey: .smsSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.DeliveryMethod.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let emailSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.EmailSettings.self, forKey: .emailSettings)
        emailSettings = emailSettingsDecoded
        let smsSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SmsSettings.self, forKey: .smsSettings)
        smsSettings = smsSettingsDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAuthForgotPasswordConfig(deliveryMethod: \(Swift.String(describing: deliveryMethod)), emailSettings: \"CONTENT_REDACTED\", smsSettings: \"CONTENT_REDACTED\")"}
}

extension AmplifyBackendClientTypes {
    /// (DEPRECATED) Describes the forgot password policy for authenticating into the Amplify app.
    public struct UpdateBackendAuthForgotPasswordConfig: Swift.Equatable {
        /// (DEPRECATED) Describes which mode to use (either SMS or email) to deliver messages to app users that want to recover their password.
        public var deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod?
        /// (DEPRECATED) The configuration for the email sent when an app user forgets their password.
        public var emailSettings: AmplifyBackendClientTypes.EmailSettings?
        /// (DEPRECATED) The configuration for the SMS message sent when an Amplify app user forgets their password.
        public var smsSettings: AmplifyBackendClientTypes.SmsSettings?

        public init(
            deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod? = nil,
            emailSettings: AmplifyBackendClientTypes.EmailSettings? = nil,
            smsSettings: AmplifyBackendClientTypes.SmsSettings? = nil
        )
        {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unauthenticatedLogin = "unauthenticatedLogin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unauthenticatedLogin = self.unauthenticatedLogin {
            try encodeContainer.encode(unauthenticatedLogin, forKey: .unauthenticatedLogin)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unauthenticatedLoginDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .unauthenticatedLogin)
        unauthenticatedLogin = unauthenticatedLoginDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of your auth resource in the Amplify project.
    public struct UpdateBackendAuthIdentityPoolConfig: Swift.Equatable {
        /// A boolean value that can be set to allow or disallow guest-level authorization into your Amplify app.
        public var unauthenticatedLogin: Swift.Bool?

        public init(
            unauthenticatedLogin: Swift.Bool? = nil
        )
        {
            self.unauthenticatedLogin = unauthenticatedLogin
        }
    }

}

extension UpdateBackendAuthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension UpdateBackendAuthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/auth/\(backendEnvironmentName.urlPercentEncoding())"
    }
}

/// The request body for UpdateBackendAuth.
public struct UpdateBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for this request object.
    /// This member is required.
    public var resourceConfig: AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct UpdateBackendAuthInputBody: Swift.Equatable {
    let resourceConfig: AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig?
    let resourceName: Swift.String?
}

extension UpdateBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mfaMode = "MFAMode"
        case settings = "settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mfaMode = self.mfaMode {
            try encodeContainer.encode(mfaMode.rawValue, forKey: .mfaMode)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mfaModeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.MFAMode.self, forKey: .mfaMode)
        mfaMode = mfaModeDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Updates the multi-factor authentication (MFA) configuration for the backend of your Amplify project.
    public struct UpdateBackendAuthMFAConfig: Swift.Equatable {
        /// The MFA mode for the backend of your Amplify project.
        public var mfaMode: AmplifyBackendClientTypes.MFAMode?
        /// The settings of your MFA configuration for the backend of your Amplify project.
        public var settings: AmplifyBackendClientTypes.Settings?

        public init(
            mfaMode: AmplifyBackendClientTypes.MFAMode? = nil,
            settings: AmplifyBackendClientTypes.Settings? = nil
        )
        {
            self.mfaMode = mfaMode
            self.settings = settings
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainPrefix = "domainPrefix"
        case oAuthGrantType = "oAuthGrantType"
        case oAuthScopes = "oAuthScopes"
        case redirectSignInURIs = "redirectSignInURIs"
        case redirectSignOutURIs = "redirectSignOutURIs"
        case socialProviderSettings = "socialProviderSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainPrefix = self.domainPrefix {
            try encodeContainer.encode(domainPrefix, forKey: .domainPrefix)
        }
        if let oAuthGrantType = self.oAuthGrantType {
            try encodeContainer.encode(oAuthGrantType.rawValue, forKey: .oAuthGrantType)
        }
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopeselement0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopeselement0.rawValue)
            }
        }
        if let redirectSignInURIs = redirectSignInURIs {
            var redirectSignInURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignInURIs)
            for __string0 in redirectSignInURIs {
                try redirectSignInURIsContainer.encode(__string0)
            }
        }
        if let redirectSignOutURIs = redirectSignOutURIs {
            var redirectSignOutURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignOutURIs)
            for __string0 in redirectSignOutURIs {
                try redirectSignOutURIsContainer.encode(__string0)
            }
        }
        if let socialProviderSettings = self.socialProviderSettings {
            try encodeContainer.encode(socialProviderSettings, forKey: .socialProviderSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainPrefix)
        domainPrefix = domainPrefixDecoded
        let oAuthGrantTypeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.OAuthGrantType.self, forKey: .oAuthGrantType)
        oAuthGrantType = oAuthGrantTypeDecoded
        let oAuthScopesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.OAuthScopesElement?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[AmplifyBackendClientTypes.OAuthScopesElement]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [AmplifyBackendClientTypes.OAuthScopesElement]()
            for enum0 in oAuthScopesContainer {
                if let enum0 = enum0 {
                    oAuthScopesDecoded0?.append(enum0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
        let redirectSignInURIsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectSignInURIs)
        var redirectSignInURIsDecoded0:[Swift.String]? = nil
        if let redirectSignInURIsContainer = redirectSignInURIsContainer {
            redirectSignInURIsDecoded0 = [Swift.String]()
            for string0 in redirectSignInURIsContainer {
                if let string0 = string0 {
                    redirectSignInURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignInURIs = redirectSignInURIsDecoded0
        let redirectSignOutURIsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectSignOutURIs)
        var redirectSignOutURIsDecoded0:[Swift.String]? = nil
        if let redirectSignOutURIsContainer = redirectSignOutURIsContainer {
            redirectSignOutURIsDecoded0 = [Swift.String]()
            for string0 in redirectSignOutURIsContainer {
                if let string0 = string0 {
                    redirectSignOutURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignOutURIs = redirectSignOutURIsDecoded0
        let socialProviderSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SocialProviderSettings.self, forKey: .socialProviderSettings)
        socialProviderSettings = socialProviderSettingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The OAuth configurations for authenticating users into your Amplify app.
    public struct UpdateBackendAuthOAuthConfig: Swift.Equatable {
        /// The Amazon Cognito domain prefix used to create a hosted UI for authentication.
        public var domainPrefix: Swift.String?
        /// The OAuth grant type to allow app users to authenticate from your Amplify app.
        public var oAuthGrantType: AmplifyBackendClientTypes.OAuthGrantType?
        /// The list of OAuth-related flows that can allow users to authenticate from your Amplify app.
        public var oAuthScopes: [AmplifyBackendClientTypes.OAuthScopesElement]?
        /// Redirect URLs that OAuth uses when a user signs in to an Amplify app.
        public var redirectSignInURIs: [Swift.String]?
        /// Redirect URLs that OAuth uses when a user signs out of an Amplify app.
        public var redirectSignOutURIs: [Swift.String]?
        /// Describes third-party social federation configurations for allowing your users to sign in with OAuth.
        public var socialProviderSettings: AmplifyBackendClientTypes.SocialProviderSettings?

        public init(
            domainPrefix: Swift.String? = nil,
            oAuthGrantType: AmplifyBackendClientTypes.OAuthGrantType? = nil,
            oAuthScopes: [AmplifyBackendClientTypes.OAuthScopesElement]? = nil,
            redirectSignInURIs: [Swift.String]? = nil,
            redirectSignOutURIs: [Swift.String]? = nil,
            socialProviderSettings: AmplifyBackendClientTypes.SocialProviderSettings? = nil
        )
        {
            self.domainPrefix = domainPrefix
            self.oAuthGrantType = oAuthGrantType
            self.oAuthScopes = oAuthScopes
            self.redirectSignInURIs = redirectSignInURIs
            self.redirectSignOutURIs = redirectSignOutURIs
            self.socialProviderSettings = socialProviderSettings
        }
    }

}

extension UpdateBackendAuthOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBackendAuthOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct UpdateBackendAuthOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct UpdateBackendAuthOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension UpdateBackendAuthOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdateBackendAuthOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConstraints = "additionalConstraints"
        case minimumLength = "minimumLength"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConstraints = additionalConstraints {
            var additionalConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConstraints)
            for additionalconstraintselement0 in additionalConstraints {
                try additionalConstraintsContainer.encode(additionalconstraintselement0.rawValue)
            }
        }
        if let minimumLength = self.minimumLength {
            try encodeContainer.encode(minimumLength, forKey: .minimumLength)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalConstraintsContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.AdditionalConstraintsElement?].self, forKey: .additionalConstraints)
        var additionalConstraintsDecoded0:[AmplifyBackendClientTypes.AdditionalConstraintsElement]? = nil
        if let additionalConstraintsContainer = additionalConstraintsContainer {
            additionalConstraintsDecoded0 = [AmplifyBackendClientTypes.AdditionalConstraintsElement]()
            for enum0 in additionalConstraintsContainer {
                if let enum0 = enum0 {
                    additionalConstraintsDecoded0?.append(enum0)
                }
            }
        }
        additionalConstraints = additionalConstraintsDecoded0
        let minimumLengthDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimumLength)
        minimumLength = minimumLengthDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the password policy for your Amazon Cognito user pool configured as a part of your Amplify project.
    public struct UpdateBackendAuthPasswordPolicyConfig: Swift.Equatable {
        /// Describes additional constraints on password requirements to sign in to the auth resource, configured as a part of your Amplify project.
        public var additionalConstraints: [AmplifyBackendClientTypes.AdditionalConstraintsElement]?
        /// Describes the minimum length of the password required to sign in to the auth resource, configured as a part of your Amplify project.
        public var minimumLength: Swift.Double?

        public init(
            additionalConstraints: [AmplifyBackendClientTypes.AdditionalConstraintsElement]? = nil,
            minimumLength: Swift.Double? = nil
        )
        {
            self.additionalConstraints = additionalConstraints
            self.minimumLength = minimumLength
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authResources = "authResources"
        case identityPoolConfigs = "identityPoolConfigs"
        case service = "service"
        case userPoolConfigs = "userPoolConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authResources = self.authResources {
            try encodeContainer.encode(authResources.rawValue, forKey: .authResources)
        }
        if let identityPoolConfigs = self.identityPoolConfigs {
            try encodeContainer.encode(identityPoolConfigs, forKey: .identityPoolConfigs)
        }
        if let service = self.service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
        if let userPoolConfigs = self.userPoolConfigs {
            try encodeContainer.encode(userPoolConfigs, forKey: .userPoolConfigs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authResourcesDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.AuthResources.self, forKey: .authResources)
        authResources = authResourcesDecoded
        let identityPoolConfigsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig.self, forKey: .identityPoolConfigs)
        identityPoolConfigs = identityPoolConfigsDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let userPoolConfigsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig.self, forKey: .userPoolConfigs)
        userPoolConfigs = userPoolConfigsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Defines the resource configuration when updating an authentication resource in your Amplify project.
    public struct UpdateBackendAuthResourceConfig: Swift.Equatable {
        /// Defines the service name to use when configuring an authentication resource in your Amplify project.
        /// This member is required.
        public var authResources: AmplifyBackendClientTypes.AuthResources?
        /// Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of your auth resource in the Amplify project.
        public var identityPoolConfigs: AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig?
        /// Defines the service name to use when configuring an authentication resource in your Amplify project.
        /// This member is required.
        public var service: AmplifyBackendClientTypes.Service?
        /// Describes the authentication configuration for the Amazon Cognito user pool, provisioned as a part of your auth resource in the Amplify project.
        /// This member is required.
        public var userPoolConfigs: AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig?

        public init(
            authResources: AmplifyBackendClientTypes.AuthResources? = nil,
            identityPoolConfigs: AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig? = nil,
            service: AmplifyBackendClientTypes.Service? = nil,
            userPoolConfigs: AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig? = nil
        )
        {
            self.authResources = authResources
            self.identityPoolConfigs = identityPoolConfigs
            self.service = service
            self.userPoolConfigs = userPoolConfigs
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPassword = "forgotPassword"
        case mfa = "mfa"
        case oAuth = "oAuth"
        case passwordPolicy = "passwordPolicy"
        case verificationMessage = "verificationMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPassword = self.forgotPassword {
            try encodeContainer.encode(forgotPassword, forKey: .forgotPassword)
        }
        if let mfa = self.mfa {
            try encodeContainer.encode(mfa, forKey: .mfa)
        }
        if let oAuth = self.oAuth {
            try encodeContainer.encode(oAuth, forKey: .oAuth)
        }
        if let passwordPolicy = self.passwordPolicy {
            try encodeContainer.encode(passwordPolicy, forKey: .passwordPolicy)
        }
        if let verificationMessage = self.verificationMessage {
            try encodeContainer.encode(verificationMessage, forKey: .verificationMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forgotPasswordDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig.self, forKey: .forgotPassword)
        forgotPassword = forgotPasswordDecoded
        let mfaDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig.self, forKey: .mfa)
        mfa = mfaDecoded
        let oAuthDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig.self, forKey: .oAuth)
        oAuth = oAuthDecoded
        let passwordPolicyDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig.self, forKey: .passwordPolicy)
        passwordPolicy = passwordPolicyDecoded
        let verificationMessageDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthVerificationMessageConfig.self, forKey: .verificationMessage)
        verificationMessage = verificationMessageDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the Amazon Cognito user pool configuration for the authorization resource to be configured for your Amplify project on an update.
    public struct UpdateBackendAuthUserPoolConfig: Swift.Equatable {
        /// (DEPRECATED) Describes the forgot password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var forgotPassword: AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig?
        /// Describes whether to apply multi-factor authentication policies for your Amazon Cognito user pool configured as a part of your Amplify project.
        public var mfa: AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig?
        /// Describes the OAuth policy and rules for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var oAuth: AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig?
        /// Describes the password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var passwordPolicy: AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig?
        /// Describes the email or SMS verification message for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var verificationMessage: AmplifyBackendClientTypes.UpdateBackendAuthVerificationMessageConfig?

        public init(
            forgotPassword: AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig? = nil,
            mfa: AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig? = nil,
            oAuth: AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig? = nil,
            passwordPolicy: AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig? = nil,
            verificationMessage: AmplifyBackendClientTypes.UpdateBackendAuthVerificationMessageConfig? = nil
        )
        {
            self.forgotPassword = forgotPassword
            self.mfa = mfa
            self.oAuth = oAuth
            self.passwordPolicy = passwordPolicy
            self.verificationMessage = verificationMessage
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthVerificationMessageConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryMethod = "deliveryMethod"
        case emailSettings = "emailSettings"
        case smsSettings = "smsSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryMethod = self.deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let emailSettings = self.emailSettings {
            try encodeContainer.encode(emailSettings, forKey: .emailSettings)
        }
        if let smsSettings = self.smsSettings {
            try encodeContainer.encode(smsSettings, forKey: .smsSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.DeliveryMethod.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let emailSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.EmailSettings.self, forKey: .emailSettings)
        emailSettings = emailSettingsDecoded
        let smsSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SmsSettings.self, forKey: .smsSettings)
        smsSettings = smsSettingsDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthVerificationMessageConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAuthVerificationMessageConfig(deliveryMethod: \(Swift.String(describing: deliveryMethod)), emailSettings: \"CONTENT_REDACTED\", smsSettings: \"CONTENT_REDACTED\")"}
}

extension AmplifyBackendClientTypes {
    /// Updates the configuration of the email or SMS message for the auth resource configured for your Amplify project.
    public struct UpdateBackendAuthVerificationMessageConfig: Swift.Equatable {
        /// The type of verification message to send.
        /// This member is required.
        public var deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod?
        /// The settings for the email message.
        public var emailSettings: AmplifyBackendClientTypes.EmailSettings?
        /// The settings for the SMS message.
        public var smsSettings: AmplifyBackendClientTypes.SmsSettings?

        public init(
            deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod? = nil,
            emailSettings: AmplifyBackendClientTypes.EmailSettings? = nil,
            smsSettings: AmplifyBackendClientTypes.SmsSettings? = nil
        )
        {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }
    }

}

extension UpdateBackendConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loginAuthConfig = "loginAuthConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loginAuthConfig = self.loginAuthConfig {
            try encodeContainer.encode(loginAuthConfig, forKey: .loginAuthConfig)
        }
    }
}

extension UpdateBackendConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/config/update"
    }
}

/// The request body for UpdateBackendConfig.
public struct UpdateBackendConfigInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// Describes the Amazon Cognito configuration for Admin UI access.
    public var loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj?

    public init(
        appId: Swift.String? = nil,
        loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj? = nil
    )
    {
        self.appId = appId
        self.loginAuthConfig = loginAuthConfig
    }
}

struct UpdateBackendConfigInputBody: Swift.Equatable {
    let loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj?
}

extension UpdateBackendConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loginAuthConfig = "loginAuthConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loginAuthConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.LoginAuthConfigReqObj.self, forKey: .loginAuthConfig)
        loginAuthConfig = loginAuthConfigDecoded
    }
}

extension UpdateBackendConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBackendConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendManagerAppId = output.backendManagerAppId
            self.error = output.error
            self.loginAuthConfig = output.loginAuthConfig
        } else {
            self.appId = nil
            self.backendManagerAppId = nil
            self.error = nil
            self.loginAuthConfig = nil
        }
    }
}

public struct UpdateBackendConfigOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The app ID for the backend manager.
    public var backendManagerAppId: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// Describes the Amazon Cognito configurations for the Admin UI auth resource to log in with.
    public var loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj?

    public init(
        appId: Swift.String? = nil,
        backendManagerAppId: Swift.String? = nil,
        error: Swift.String? = nil,
        loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj? = nil
    )
    {
        self.appId = appId
        self.backendManagerAppId = backendManagerAppId
        self.error = error
        self.loginAuthConfig = loginAuthConfig
    }
}

struct UpdateBackendConfigOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendManagerAppId: Swift.String?
    let error: Swift.String?
    let loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj?
}

extension UpdateBackendConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendManagerAppId = "backendManagerAppId"
        case error = "error"
        case loginAuthConfig = "loginAuthConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendManagerAppIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendManagerAppId)
        backendManagerAppId = backendManagerAppIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let loginAuthConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.LoginAuthConfigReqObj.self, forKey: .loginAuthConfig)
        loginAuthConfig = loginAuthConfigDecoded
    }
}

enum UpdateBackendConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBackendJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "operation"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }
}

extension UpdateBackendJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/job/\(backendEnvironmentName.urlPercentEncoding())/\(jobId.urlPercentEncoding())"
    }
}

/// The request body for GetBackendJob.
public struct UpdateBackendJobInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// Filters the list of response objects to include only those with the specified operation name.
    public var operation: Swift.String?
    /// Filters the list of response objects to include only those with the specified status.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct UpdateBackendJobInputBody: Swift.Equatable {
    let operation: Swift.String?
    let status: Swift.String?
}

extension UpdateBackendJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "operation"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateBackendJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBackendJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.createTime = output.createTime
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.createTime = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateBackendJobOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The time when the job was created.
    public var createTime: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?
    /// The time when the job was last updated.
    public var updateTime: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        createTime: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil,
        updateTime: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.createTime = createTime
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
        self.updateTime = updateTime
    }
}

struct UpdateBackendJobOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let createTime: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
    let updateTime: Swift.String?
}

extension UpdateBackendJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case createTime = "createTime"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
        case updateTime = "updateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

enum UpdateBackendJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBackendStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension UpdateBackendStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/storage/\(backendEnvironmentName.urlPercentEncoding())"
    }
}

/// The request body for UpdateBackendStorage.
public struct UpdateBackendStorageInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for updating backend storage.
    /// This member is required.
    public var resourceConfig: AmplifyBackendClientTypes.UpdateBackendStorageResourceConfig?
    /// The name of the storage resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.UpdateBackendStorageResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct UpdateBackendStorageInputBody: Swift.Equatable {
    let resourceConfig: AmplifyBackendClientTypes.UpdateBackendStorageResourceConfig?
    let resourceName: Swift.String?
}

extension UpdateBackendStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendStorageResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UpdateBackendStorageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBackendStorageOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct UpdateBackendStorageOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init(
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.status = status
    }
}

struct UpdateBackendStorageOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let jobId: Swift.String?
    let status: Swift.String?
}

extension UpdateBackendStorageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case jobId = "jobId"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdateBackendStorageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GatewayTimeoutException": return try await GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyBackendClientTypes.UpdateBackendStorageResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "permissions"
        case serviceName = "serviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissions = self.permissions {
            try encodeContainer.encode(permissions, forKey: .permissions)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendStoragePermissions.self, forKey: .permissions)
        permissions = permissionsDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The resource configuration for updating backend storage.
    public struct UpdateBackendStorageResourceConfig: Swift.Equatable {
        /// The authorization configuration for the storage S3 bucket.
        /// This member is required.
        public var permissions: AmplifyBackendClientTypes.BackendStoragePermissions?
        /// The name of the storage service.
        /// This member is required.
        public var serviceName: AmplifyBackendClientTypes.ServiceName?

        public init(
            permissions: AmplifyBackendClientTypes.BackendStoragePermissions? = nil,
            serviceName: AmplifyBackendClientTypes.ServiceName? = nil
        )
        {
            self.permissions = permissions
            self.serviceName = serviceName
        }
    }

}
