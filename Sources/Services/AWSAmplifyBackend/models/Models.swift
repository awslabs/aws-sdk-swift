// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AmplifyBackendClientTypes {
    public enum AdditionalConstraintsElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case requireDigit
        case requireLowercase
        case requireSymbol
        case requireUppercase
        case sdkUnknown(Swift.String)

        public static var allCases: [AdditionalConstraintsElement] {
            return [
                .requireDigit,
                .requireLowercase,
                .requireSymbol,
                .requireUppercase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .requireDigit: return "REQUIRE_DIGIT"
            case .requireLowercase: return "REQUIRE_LOWERCASE"
            case .requireSymbol: return "REQUIRE_SYMBOL"
            case .requireUppercase: return "REQUIRE_UPPERCASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdditionalConstraintsElement(rawValue: rawValue) ?? AdditionalConstraintsElement.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum AuthResources: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case identityPoolAndUserPool
        case userPoolOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthResources] {
            return [
                .identityPoolAndUserPool,
                .userPoolOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .identityPoolAndUserPool: return "IDENTITY_POOL_AND_USER_POOL"
            case .userPoolOnly: return "USER_POOL_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthResources(rawValue: rawValue) ?? AuthResources.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum AuthenticatedElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createAndUpdate
        case delete
        case read
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticatedElement] {
            return [
                .createAndUpdate,
                .delete,
                .read,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createAndUpdate: return "CREATE_AND_UPDATE"
            case .delete: return "DELETE"
            case .read: return "READ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticatedElement(rawValue: rawValue) ?? AuthenticatedElement.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoUserPoolId = "cognitoUserPoolId"
        case description = "description"
        case expirationTime = "expirationTime"
        case openIDAuthTTL = "openIDAuthTTL"
        case openIDClientId = "openIDClientId"
        case openIDIatTTL = "openIDIatTTL"
        case openIDIssueURL = "openIDIssueURL"
        case openIDProviderName = "openIDProviderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cognitoUserPoolId = self.cognitoUserPoolId {
            try encodeContainer.encode(cognitoUserPoolId, forKey: .cognitoUserPoolId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encode(expirationTime, forKey: .expirationTime)
        }
        if let openIDAuthTTL = self.openIDAuthTTL {
            try encodeContainer.encode(openIDAuthTTL, forKey: .openIDAuthTTL)
        }
        if let openIDClientId = self.openIDClientId {
            try encodeContainer.encode(openIDClientId, forKey: .openIDClientId)
        }
        if let openIDIatTTL = self.openIDIatTTL {
            try encodeContainer.encode(openIDIatTTL, forKey: .openIDIatTTL)
        }
        if let openIDIssueURL = self.openIDIssueURL {
            try encodeContainer.encode(openIDIssueURL, forKey: .openIDIssueURL)
        }
        if let openIDProviderName = self.openIDProviderName {
            try encodeContainer.encode(openIDProviderName, forKey: .openIDProviderName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cognitoUserPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cognitoUserPoolId)
        cognitoUserPoolId = cognitoUserPoolIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let openIDAuthTTLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDAuthTTL)
        openIDAuthTTL = openIDAuthTTLDecoded
        let openIDClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDClientId)
        openIDClientId = openIDClientIdDecoded
        let openIDIatTTLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDIatTTL)
        openIDIatTTL = openIDIatTTLDecoded
        let openIDIssueURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDIssueURL)
        openIDIssueURL = openIDIssueURLDecoded
        let openIDProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDProviderName)
        openIDProviderName = openIDProviderNameDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The authentication settings for accessing provisioned data models in your Amplify project.
    public struct BackendAPIAppSyncAuthSettings: Swift.Equatable {
        /// The Amazon Cognito user pool ID, if Amazon Cognito was used as an authentication setting to access your data models.
        public var cognitoUserPoolId: Swift.String?
        /// The API key description for API_KEY, if it was used as an authentication mechanism to access your data models.
        public var description: Swift.String?
        /// The API key expiration time for API_KEY, if it was used as an authentication mechanism to access your data models.
        public var expirationTime: Swift.Double?
        /// The expiry time for the OpenID authentication mechanism.
        public var openIDAuthTTL: Swift.String?
        /// The clientID for openID, if openID was used as an authentication setting to access your data models.
        public var openIDClientId: Swift.String?
        /// The expiry time for the OpenID authentication mechanism.
        public var openIDIatTTL: Swift.String?
        /// The openID issuer URL, if openID was used as an authentication setting to access your data models.
        public var openIDIssueURL: Swift.String?
        /// The OpenID provider name, if OpenID was used as an authentication mechanism to access your data models.
        public var openIDProviderName: Swift.String?

        public init (
            cognitoUserPoolId: Swift.String? = nil,
            description: Swift.String? = nil,
            expirationTime: Swift.Double? = nil,
            openIDAuthTTL: Swift.String? = nil,
            openIDClientId: Swift.String? = nil,
            openIDIatTTL: Swift.String? = nil,
            openIDIssueURL: Swift.String? = nil,
            openIDProviderName: Swift.String? = nil
        )
        {
            self.cognitoUserPoolId = cognitoUserPoolId
            self.description = description
            self.expirationTime = expirationTime
            self.openIDAuthTTL = openIDAuthTTL
            self.openIDClientId = openIDClientId
            self.openIDIatTTL = openIDIatTTL
            self.openIDIssueURL = openIDIssueURL
            self.openIDProviderName = openIDProviderName
        }
    }

}

extension AmplifyBackendClientTypes.BackendAPIAuthType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "mode"
        case settings = "settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Mode.self, forKey: .mode)
        mode = modeDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the auth types for your configured data models.
    public struct BackendAPIAuthType: Swift.Equatable {
        /// Describes the authentication mode.
        public var mode: AmplifyBackendClientTypes.Mode?
        /// Describes settings for the authentication mode.
        public var settings: AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings?

        public init (
            mode: AmplifyBackendClientTypes.Mode? = nil,
            settings: AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings? = nil
        )
        {
            self.mode = mode
            self.settings = settings
        }
    }

}

extension AmplifyBackendClientTypes.BackendAPIConflictResolution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolutionStrategy = "resolutionStrategy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolutionStrategy = self.resolutionStrategy {
            try encodeContainer.encode(resolutionStrategy.rawValue, forKey: .resolutionStrategy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolutionStrategyDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ResolutionStrategy.self, forKey: .resolutionStrategy)
        resolutionStrategy = resolutionStrategyDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the conflict resolution configuration for your data model configured in your Amplify project.
    public struct BackendAPIConflictResolution: Swift.Equatable {
        /// The strategy for conflict resolution.
        public var resolutionStrategy: AmplifyBackendClientTypes.ResolutionStrategy?

        public init (
            resolutionStrategy: AmplifyBackendClientTypes.ResolutionStrategy? = nil
        )
        {
            self.resolutionStrategy = resolutionStrategy
        }
    }

}

extension AmplifyBackendClientTypes.BackendAPIResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthTypes = "additionalAuthTypes"
        case apiName = "apiName"
        case conflictResolution = "conflictResolution"
        case defaultAuthType = "defaultAuthType"
        case service = "service"
        case transformSchema = "transformSchema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthTypes = additionalAuthTypes {
            var additionalAuthTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthTypes)
            for backendapiauthtype0 in additionalAuthTypes {
                try additionalAuthTypesContainer.encode(backendapiauthtype0)
            }
        }
        if let apiName = self.apiName {
            try encodeContainer.encode(apiName, forKey: .apiName)
        }
        if let conflictResolution = self.conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let defaultAuthType = self.defaultAuthType {
            try encodeContainer.encode(defaultAuthType, forKey: .defaultAuthType)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let transformSchema = self.transformSchema {
            try encodeContainer.encode(transformSchema, forKey: .transformSchema)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalAuthTypesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.BackendAPIAuthType?].self, forKey: .additionalAuthTypes)
        var additionalAuthTypesDecoded0:[AmplifyBackendClientTypes.BackendAPIAuthType]? = nil
        if let additionalAuthTypesContainer = additionalAuthTypesContainer {
            additionalAuthTypesDecoded0 = [AmplifyBackendClientTypes.BackendAPIAuthType]()
            for structure0 in additionalAuthTypesContainer {
                if let structure0 = structure0 {
                    additionalAuthTypesDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthTypes = additionalAuthTypesDecoded0
        let apiNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiName)
        apiName = apiNameDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
        let defaultAuthTypeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIAuthType.self, forKey: .defaultAuthType)
        defaultAuthType = defaultAuthTypeDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let transformSchemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformSchema)
        transformSchema = transformSchemaDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The resource config for the data model, configured as a part of the Amplify project.
    public struct BackendAPIResourceConfig: Swift.Equatable {
        /// Additional authentication methods used to interact with your data models.
        public var additionalAuthTypes: [AmplifyBackendClientTypes.BackendAPIAuthType]?
        /// The API name used to interact with the data model, configured as a part of your Amplify project.
        public var apiName: Swift.String?
        /// The conflict resolution strategy for your data stored in the data models.
        public var conflictResolution: AmplifyBackendClientTypes.BackendAPIConflictResolution?
        /// The default authentication type for interacting with the configured data models in your Amplify project.
        public var defaultAuthType: AmplifyBackendClientTypes.BackendAPIAuthType?
        /// The service used to provision and interact with the data model.
        public var service: Swift.String?
        /// The definition of the data model in the annotated transform of the GraphQL schema.
        public var transformSchema: Swift.String?

        public init (
            additionalAuthTypes: [AmplifyBackendClientTypes.BackendAPIAuthType]? = nil,
            apiName: Swift.String? = nil,
            conflictResolution: AmplifyBackendClientTypes.BackendAPIConflictResolution? = nil,
            defaultAuthType: AmplifyBackendClientTypes.BackendAPIAuthType? = nil,
            service: Swift.String? = nil,
            transformSchema: Swift.String? = nil
        )
        {
            self.additionalAuthTypes = additionalAuthTypes
            self.apiName = apiName
            self.conflictResolution = conflictResolution
            self.defaultAuthType = defaultAuthType
            self.service = service
            self.transformSchema = transformSchema
        }
    }

}

extension AmplifyBackendClientTypes.BackendAuthAppleProviderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId = "client_id"
        case keyId = "key_id"
        case privateKey = "private_key"
        case teamId = "team_id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let keyId = self.keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let privateKey = self.privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes Apple social federation configurations for allowing your app users to sign in using OAuth.
    public struct BackendAuthAppleProviderConfig: Swift.Equatable {
        /// Describes the client_id (also called Services ID) that comes from Apple.
        public var clientId: Swift.String?
        /// Describes the key_id that comes from Apple.
        public var keyId: Swift.String?
        /// Describes the private_key that comes from Apple.
        public var privateKey: Swift.String?
        /// Describes the team_id that comes from Apple.
        public var teamId: Swift.String?

        public init (
            clientId: Swift.String? = nil,
            keyId: Swift.String? = nil,
            privateKey: Swift.String? = nil,
            teamId: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.keyId = keyId
            self.privateKey = privateKey
            self.teamId = teamId
        }
    }

}

extension AmplifyBackendClientTypes.BackendAuthSocialProviderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId = "client_id"
        case clientSecret = "client_secret"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes third-party social federation configurations for allowing your app users to sign in using OAuth.
    public struct BackendAuthSocialProviderConfig: Swift.Equatable {
        /// Describes the client_id, which can be obtained from the third-party social federation provider.
        public var clientId: Swift.String?
        /// Describes the client_secret, which can be obtained from third-party social federation providers.
        public var clientSecret: Swift.String?

        public init (
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }
    }

}

extension AmplifyBackendClientTypes.BackendJobRespObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case createTime = "createTime"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
        case updateTime = "updateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let backendEnvironmentName = self.backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let createTime = self.createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encode(updateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The response object for this operation.
    public struct BackendJobRespObj: Swift.Equatable {
        /// The app ID.
        /// This member is required.
        public var appId: Swift.String?
        /// The name of the backend environment.
        /// This member is required.
        public var backendEnvironmentName: Swift.String?
        /// The time when the job was created.
        public var createTime: Swift.String?
        /// If the request fails, this error is returned.
        public var error: Swift.String?
        /// The ID for the job.
        public var jobId: Swift.String?
        /// The name of the operation.
        public var operation: Swift.String?
        /// The current status of the request.
        public var status: Swift.String?
        /// The time when the job was last updated.
        public var updateTime: Swift.String?

        public init (
            appId: Swift.String? = nil,
            backendEnvironmentName: Swift.String? = nil,
            createTime: Swift.String? = nil,
            error: Swift.String? = nil,
            jobId: Swift.String? = nil,
            operation: Swift.String? = nil,
            status: Swift.String? = nil,
            updateTime: Swift.String? = nil
        )
        {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.createTime = createTime
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension AmplifyBackendClientTypes.BackendStoragePermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticated = "authenticated"
        case unAuthenticated = "unAuthenticated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticated = authenticated {
            var authenticatedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authenticated)
            for authenticatedelement0 in authenticated {
                try authenticatedContainer.encode(authenticatedelement0.rawValue)
            }
        }
        if let unAuthenticated = unAuthenticated {
            var unAuthenticatedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .unAuthenticated)
            for unauthenticatedelement0 in unAuthenticated {
                try unAuthenticatedContainer.encode(unauthenticatedelement0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticatedContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.AuthenticatedElement?].self, forKey: .authenticated)
        var authenticatedDecoded0:[AmplifyBackendClientTypes.AuthenticatedElement]? = nil
        if let authenticatedContainer = authenticatedContainer {
            authenticatedDecoded0 = [AmplifyBackendClientTypes.AuthenticatedElement]()
            for enum0 in authenticatedContainer {
                if let enum0 = enum0 {
                    authenticatedDecoded0?.append(enum0)
                }
            }
        }
        authenticated = authenticatedDecoded0
        let unAuthenticatedContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.UnAuthenticatedElement?].self, forKey: .unAuthenticated)
        var unAuthenticatedDecoded0:[AmplifyBackendClientTypes.UnAuthenticatedElement]? = nil
        if let unAuthenticatedContainer = unAuthenticatedContainer {
            unAuthenticatedDecoded0 = [AmplifyBackendClientTypes.UnAuthenticatedElement]()
            for enum0 in unAuthenticatedContainer {
                if let enum0 = enum0 {
                    unAuthenticatedDecoded0?.append(enum0)
                }
            }
        }
        unAuthenticated = unAuthenticatedDecoded0
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the read, write, and delete permissions users have against your storage S3 bucket.
    public struct BackendStoragePermissions: Swift.Equatable {
        /// Lists all authenticated user read, write, and delete permissions for your S3 bucket.
        /// This member is required.
        public var authenticated: [AmplifyBackendClientTypes.AuthenticatedElement]?
        /// Lists all unauthenticated user read, write, and delete permissions for your S3 bucket.
        public var unAuthenticated: [AmplifyBackendClientTypes.UnAuthenticatedElement]?

        public init (
            authenticated: [AmplifyBackendClientTypes.AuthenticatedElement]? = nil,
            unAuthenticated: [AmplifyBackendClientTypes.UnAuthenticatedElement]? = nil
        )
        {
            self.authenticated = authenticated
            self.unAuthenticated = unAuthenticated
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error returned if a request is not formed properly.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// An error message to inform that the request failed.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloneBackendInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetEnvironmentName = "targetEnvironmentName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetEnvironmentName = self.targetEnvironmentName {
            try encodeContainer.encode(targetEnvironmentName, forKey: .targetEnvironmentName)
        }
    }
}

extension CloneBackendInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/environments/\(backendEnvironmentName.urlPercentEncoding())/clone"
    }
}

/// The request body for CloneBackend.
public struct CloneBackendInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of the destination backend environment to be created.
    /// This member is required.
    public var targetEnvironmentName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        targetEnvironmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.targetEnvironmentName = targetEnvironmentName
    }
}

struct CloneBackendInputBody: Swift.Equatable {
    let targetEnvironmentName: Swift.String?
}

extension CloneBackendInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetEnvironmentName = "targetEnvironmentName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEnvironmentName)
        targetEnvironmentName = targetEnvironmentNameDecoded
    }
}

extension CloneBackendOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CloneBackendOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CloneBackendOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CloneBackendOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CloneBackendOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CloneBackendOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CloneBackendOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension CloneBackendOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateBackendAPIInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = self.backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension CreateBackendAPIInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/api"
    }
}

/// The request body for CreateBackendAPI.
public struct CreateBackendAPIInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for this request.
    /// This member is required.
    public var resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendAPIInputBody: Swift.Equatable {
    let backendEnvironmentName: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    let resourceName: Swift.String?
}

extension CreateBackendAPIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CreateBackendAPIOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendAPIOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBackendAPIOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendAPIOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBackendAPIOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CreateBackendAPIOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CreateBackendAPIOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension CreateBackendAPIOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryMethod = "deliveryMethod"
        case emailSettings = "emailSettings"
        case smsSettings = "smsSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryMethod = self.deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let emailSettings = self.emailSettings {
            try encodeContainer.encode(emailSettings, forKey: .emailSettings)
        }
        if let smsSettings = self.smsSettings {
            try encodeContainer.encode(smsSettings, forKey: .smsSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.DeliveryMethod.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let emailSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.EmailSettings.self, forKey: .emailSettings)
        emailSettings = emailSettingsDecoded
        let smsSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SmsSettings.self, forKey: .smsSettings)
        smsSettings = smsSettingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// (DEPRECATED) Describes the forgot password policy for authenticating into the Amplify app.
    public struct CreateBackendAuthForgotPasswordConfig: Swift.Equatable {
        /// (DEPRECATED) Describes which mode to use (either SMS or email) to deliver messages to app users who want to recover their password.
        /// This member is required.
        public var deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod?
        /// (DEPRECATED) The configuration for the email sent when an app user forgets their password.
        public var emailSettings: AmplifyBackendClientTypes.EmailSettings?
        /// (DEPRECATED) The configuration for the SMS message sent when an app user forgets their password.
        public var smsSettings: AmplifyBackendClientTypes.SmsSettings?

        public init (
            deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod? = nil,
            emailSettings: AmplifyBackendClientTypes.EmailSettings? = nil,
            smsSettings: AmplifyBackendClientTypes.SmsSettings? = nil
        )
        {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolName = "identityPoolName"
        case unauthenticatedLogin = "unauthenticatedLogin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolName = self.identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
        if let unauthenticatedLogin = self.unauthenticatedLogin {
            try encodeContainer.encode(unauthenticatedLogin, forKey: .unauthenticatedLogin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let unauthenticatedLoginDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .unauthenticatedLogin)
        unauthenticatedLogin = unauthenticatedLoginDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes authorization configurations for the auth resources, configured as a part of your Amplify project.
    public struct CreateBackendAuthIdentityPoolConfig: Swift.Equatable {
        /// Name of the Amazon Cognito identity pool used for authorization.
        /// This member is required.
        public var identityPoolName: Swift.String?
        /// Set to true or false based on whether you want to enable guest authorization to your Amplify app.
        /// This member is required.
        public var unauthenticatedLogin: Swift.Bool?

        public init (
            identityPoolName: Swift.String? = nil,
            unauthenticatedLogin: Swift.Bool? = nil
        )
        {
            self.identityPoolName = identityPoolName
            self.unauthenticatedLogin = unauthenticatedLogin
        }
    }

}

extension CreateBackendAuthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = self.backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension CreateBackendAuthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/auth"
    }
}

/// The request body for CreateBackendAuth.
public struct CreateBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for this request object.
    /// This member is required.
    public var resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendAuthInputBody: Swift.Equatable {
    let backendEnvironmentName: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig?
    let resourceName: Swift.String?
}

extension CreateBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthMFAConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mfaMode = "MFAMode"
        case settings = "settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mfaMode = self.mfaMode {
            try encodeContainer.encode(mfaMode.rawValue, forKey: .mfaMode)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mfaModeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.MFAMode.self, forKey: .mfaMode)
        mfaMode = mfaModeDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes whether to apply multi-factor authentication policies for your Amazon Cognito user pool configured as a part of your Amplify project.
    public struct CreateBackendAuthMFAConfig: Swift.Equatable {
        /// Describes whether MFA should be [ON, OFF, or OPTIONAL] for authentication in your Amplify project.
        /// This member is required.
        public var mfaMode: AmplifyBackendClientTypes.MFAMode?
        /// Describes the configuration settings and methods for your Amplify app users to use MFA.
        public var settings: AmplifyBackendClientTypes.Settings?

        public init (
            mfaMode: AmplifyBackendClientTypes.MFAMode? = nil,
            settings: AmplifyBackendClientTypes.Settings? = nil
        )
        {
            self.mfaMode = mfaMode
            self.settings = settings
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainPrefix = "domainPrefix"
        case oAuthGrantType = "oAuthGrantType"
        case oAuthScopes = "oAuthScopes"
        case redirectSignInURIs = "redirectSignInURIs"
        case redirectSignOutURIs = "redirectSignOutURIs"
        case socialProviderSettings = "socialProviderSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainPrefix = self.domainPrefix {
            try encodeContainer.encode(domainPrefix, forKey: .domainPrefix)
        }
        if let oAuthGrantType = self.oAuthGrantType {
            try encodeContainer.encode(oAuthGrantType.rawValue, forKey: .oAuthGrantType)
        }
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopeselement0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopeselement0.rawValue)
            }
        }
        if let redirectSignInURIs = redirectSignInURIs {
            var redirectSignInURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignInURIs)
            for __string0 in redirectSignInURIs {
                try redirectSignInURIsContainer.encode(__string0)
            }
        }
        if let redirectSignOutURIs = redirectSignOutURIs {
            var redirectSignOutURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignOutURIs)
            for __string0 in redirectSignOutURIs {
                try redirectSignOutURIsContainer.encode(__string0)
            }
        }
        if let socialProviderSettings = self.socialProviderSettings {
            try encodeContainer.encode(socialProviderSettings, forKey: .socialProviderSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainPrefix)
        domainPrefix = domainPrefixDecoded
        let oAuthGrantTypeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.OAuthGrantType.self, forKey: .oAuthGrantType)
        oAuthGrantType = oAuthGrantTypeDecoded
        let oAuthScopesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.OAuthScopesElement?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[AmplifyBackendClientTypes.OAuthScopesElement]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [AmplifyBackendClientTypes.OAuthScopesElement]()
            for enum0 in oAuthScopesContainer {
                if let enum0 = enum0 {
                    oAuthScopesDecoded0?.append(enum0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
        let redirectSignInURIsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectSignInURIs)
        var redirectSignInURIsDecoded0:[Swift.String]? = nil
        if let redirectSignInURIsContainer = redirectSignInURIsContainer {
            redirectSignInURIsDecoded0 = [Swift.String]()
            for string0 in redirectSignInURIsContainer {
                if let string0 = string0 {
                    redirectSignInURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignInURIs = redirectSignInURIsDecoded0
        let redirectSignOutURIsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectSignOutURIs)
        var redirectSignOutURIsDecoded0:[Swift.String]? = nil
        if let redirectSignOutURIsContainer = redirectSignOutURIsContainer {
            redirectSignOutURIsDecoded0 = [Swift.String]()
            for string0 in redirectSignOutURIsContainer {
                if let string0 = string0 {
                    redirectSignOutURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignOutURIs = redirectSignOutURIsDecoded0
        let socialProviderSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SocialProviderSettings.self, forKey: .socialProviderSettings)
        socialProviderSettings = socialProviderSettingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Creates the OAuth configuration for your Amplify project.
    public struct CreateBackendAuthOAuthConfig: Swift.Equatable {
        /// The domain prefix for your Amplify app.
        public var domainPrefix: Swift.String?
        /// The OAuth grant type that you use to allow app users to authenticate from your Amplify app.
        /// This member is required.
        public var oAuthGrantType: AmplifyBackendClientTypes.OAuthGrantType?
        /// List of OAuth-related flows used to allow your app users to authenticate from your Amplify app.
        /// This member is required.
        public var oAuthScopes: [AmplifyBackendClientTypes.OAuthScopesElement]?
        /// The redirected URI for signing in to your Amplify app.
        /// This member is required.
        public var redirectSignInURIs: [Swift.String]?
        /// Redirect URLs that OAuth uses when a user signs out of an Amplify app.
        /// This member is required.
        public var redirectSignOutURIs: [Swift.String]?
        /// The settings for using social providers to access your Amplify app.
        public var socialProviderSettings: AmplifyBackendClientTypes.SocialProviderSettings?

        public init (
            domainPrefix: Swift.String? = nil,
            oAuthGrantType: AmplifyBackendClientTypes.OAuthGrantType? = nil,
            oAuthScopes: [AmplifyBackendClientTypes.OAuthScopesElement]? = nil,
            redirectSignInURIs: [Swift.String]? = nil,
            redirectSignOutURIs: [Swift.String]? = nil,
            socialProviderSettings: AmplifyBackendClientTypes.SocialProviderSettings? = nil
        )
        {
            self.domainPrefix = domainPrefix
            self.oAuthGrantType = oAuthGrantType
            self.oAuthScopes = oAuthScopes
            self.redirectSignInURIs = redirectSignInURIs
            self.redirectSignOutURIs = redirectSignOutURIs
            self.socialProviderSettings = socialProviderSettings
        }
    }

}

extension CreateBackendAuthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendAuthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBackendAuthOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendAuthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CreateBackendAuthOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CreateBackendAuthOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension CreateBackendAuthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConstraints = "additionalConstraints"
        case minimumLength = "minimumLength"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConstraints = additionalConstraints {
            var additionalConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConstraints)
            for additionalconstraintselement0 in additionalConstraints {
                try additionalConstraintsContainer.encode(additionalconstraintselement0.rawValue)
            }
        }
        if let minimumLength = self.minimumLength {
            try encodeContainer.encode(minimumLength, forKey: .minimumLength)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalConstraintsContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.AdditionalConstraintsElement?].self, forKey: .additionalConstraints)
        var additionalConstraintsDecoded0:[AmplifyBackendClientTypes.AdditionalConstraintsElement]? = nil
        if let additionalConstraintsContainer = additionalConstraintsContainer {
            additionalConstraintsDecoded0 = [AmplifyBackendClientTypes.AdditionalConstraintsElement]()
            for enum0 in additionalConstraintsContainer {
                if let enum0 = enum0 {
                    additionalConstraintsDecoded0?.append(enum0)
                }
            }
        }
        additionalConstraints = additionalConstraintsDecoded0
        let minimumLengthDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimumLength)
        minimumLength = minimumLengthDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The password policy configuration for the backend to your Amplify project.
    public struct CreateBackendAuthPasswordPolicyConfig: Swift.Equatable {
        /// Additional constraints for the password used to access the backend of your Amplify project.
        public var additionalConstraints: [AmplifyBackendClientTypes.AdditionalConstraintsElement]?
        /// The minimum length of the password used to access the backend of your Amplify project.
        /// This member is required.
        public var minimumLength: Swift.Double?

        public init (
            additionalConstraints: [AmplifyBackendClientTypes.AdditionalConstraintsElement]? = nil,
            minimumLength: Swift.Double? = nil
        )
        {
            self.additionalConstraints = additionalConstraints
            self.minimumLength = minimumLength
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authResources = "authResources"
        case identityPoolConfigs = "identityPoolConfigs"
        case service = "service"
        case userPoolConfigs = "userPoolConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authResources = self.authResources {
            try encodeContainer.encode(authResources.rawValue, forKey: .authResources)
        }
        if let identityPoolConfigs = self.identityPoolConfigs {
            try encodeContainer.encode(identityPoolConfigs, forKey: .identityPoolConfigs)
        }
        if let service = self.service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
        if let userPoolConfigs = self.userPoolConfigs {
            try encodeContainer.encode(userPoolConfigs, forKey: .userPoolConfigs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authResourcesDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.AuthResources.self, forKey: .authResources)
        authResources = authResourcesDecoded
        let identityPoolConfigsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig.self, forKey: .identityPoolConfigs)
        identityPoolConfigs = identityPoolConfigsDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let userPoolConfigsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig.self, forKey: .userPoolConfigs)
        userPoolConfigs = userPoolConfigsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Defines the resource configuration when creating an auth resource in your Amplify project.
    public struct CreateBackendAuthResourceConfig: Swift.Equatable {
        /// Defines whether you want to configure only authentication or both authentication and authorization settings.
        /// This member is required.
        public var authResources: AmplifyBackendClientTypes.AuthResources?
        /// Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of your auth resource in the Amplify project.
        public var identityPoolConfigs: AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig?
        /// Defines the service name to use when configuring an authentication resource in your Amplify project.
        /// This member is required.
        public var service: AmplifyBackendClientTypes.Service?
        /// Describes authentication configuration for the Amazon Cognito user pool, provisioned as a part of your auth resource in the Amplify project.
        /// This member is required.
        public var userPoolConfigs: AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig?

        public init (
            authResources: AmplifyBackendClientTypes.AuthResources? = nil,
            identityPoolConfigs: AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig? = nil,
            service: AmplifyBackendClientTypes.Service? = nil,
            userPoolConfigs: AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig? = nil
        )
        {
            self.authResources = authResources
            self.identityPoolConfigs = identityPoolConfigs
            self.service = service
            self.userPoolConfigs = userPoolConfigs
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPassword = "forgotPassword"
        case mfa = "mfa"
        case oAuth = "oAuth"
        case passwordPolicy = "passwordPolicy"
        case requiredSignUpAttributes = "requiredSignUpAttributes"
        case signInMethod = "signInMethod"
        case userPoolName = "userPoolName"
        case verificationMessage = "verificationMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPassword = self.forgotPassword {
            try encodeContainer.encode(forgotPassword, forKey: .forgotPassword)
        }
        if let mfa = self.mfa {
            try encodeContainer.encode(mfa, forKey: .mfa)
        }
        if let oAuth = self.oAuth {
            try encodeContainer.encode(oAuth, forKey: .oAuth)
        }
        if let passwordPolicy = self.passwordPolicy {
            try encodeContainer.encode(passwordPolicy, forKey: .passwordPolicy)
        }
        if let requiredSignUpAttributes = requiredSignUpAttributes {
            var requiredSignUpAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredSignUpAttributes)
            for requiredsignupattributeselement0 in requiredSignUpAttributes {
                try requiredSignUpAttributesContainer.encode(requiredsignupattributeselement0.rawValue)
            }
        }
        if let signInMethod = self.signInMethod {
            try encodeContainer.encode(signInMethod.rawValue, forKey: .signInMethod)
        }
        if let userPoolName = self.userPoolName {
            try encodeContainer.encode(userPoolName, forKey: .userPoolName)
        }
        if let verificationMessage = self.verificationMessage {
            try encodeContainer.encode(verificationMessage, forKey: .verificationMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forgotPasswordDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig.self, forKey: .forgotPassword)
        forgotPassword = forgotPasswordDecoded
        let mfaDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthMFAConfig.self, forKey: .mfa)
        mfa = mfaDecoded
        let oAuthDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig.self, forKey: .oAuth)
        oAuth = oAuthDecoded
        let passwordPolicyDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig.self, forKey: .passwordPolicy)
        passwordPolicy = passwordPolicyDecoded
        let requiredSignUpAttributesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.RequiredSignUpAttributesElement?].self, forKey: .requiredSignUpAttributes)
        var requiredSignUpAttributesDecoded0:[AmplifyBackendClientTypes.RequiredSignUpAttributesElement]? = nil
        if let requiredSignUpAttributesContainer = requiredSignUpAttributesContainer {
            requiredSignUpAttributesDecoded0 = [AmplifyBackendClientTypes.RequiredSignUpAttributesElement]()
            for enum0 in requiredSignUpAttributesContainer {
                if let enum0 = enum0 {
                    requiredSignUpAttributesDecoded0?.append(enum0)
                }
            }
        }
        requiredSignUpAttributes = requiredSignUpAttributesDecoded0
        let signInMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SignInMethod.self, forKey: .signInMethod)
        signInMethod = signInMethodDecoded
        let userPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolName)
        userPoolName = userPoolNameDecoded
        let verificationMessageDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthVerificationMessageConfig.self, forKey: .verificationMessage)
        verificationMessage = verificationMessageDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the Amazon Cognito user pool configuration for the auth resource to be configured for your Amplify project.
    public struct CreateBackendAuthUserPoolConfig: Swift.Equatable {
        /// (DEPRECATED) Describes the forgotten password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var forgotPassword: AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig?
        /// Describes whether to apply multi-factor authentication policies for your Amazon Cognito user pool configured as a part of your Amplify project.
        public var mfa: AmplifyBackendClientTypes.CreateBackendAuthMFAConfig?
        /// Describes the OAuth policy and rules for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var oAuth: AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig?
        /// Describes the password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var passwordPolicy: AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig?
        /// The required attributes to sign up new users in the user pool.
        /// This member is required.
        public var requiredSignUpAttributes: [AmplifyBackendClientTypes.RequiredSignUpAttributesElement]?
        /// Describes the sign-in methods that your Amplify app users use to log in using the Amazon Cognito user pool, configured as a part of your Amplify project.
        /// This member is required.
        public var signInMethod: AmplifyBackendClientTypes.SignInMethod?
        /// The Amazon Cognito user pool name.
        /// This member is required.
        public var userPoolName: Swift.String?
        /// Describes the email or SMS verification message for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var verificationMessage: AmplifyBackendClientTypes.CreateBackendAuthVerificationMessageConfig?

        public init (
            forgotPassword: AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig? = nil,
            mfa: AmplifyBackendClientTypes.CreateBackendAuthMFAConfig? = nil,
            oAuth: AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig? = nil,
            passwordPolicy: AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig? = nil,
            requiredSignUpAttributes: [AmplifyBackendClientTypes.RequiredSignUpAttributesElement]? = nil,
            signInMethod: AmplifyBackendClientTypes.SignInMethod? = nil,
            userPoolName: Swift.String? = nil,
            verificationMessage: AmplifyBackendClientTypes.CreateBackendAuthVerificationMessageConfig? = nil
        )
        {
            self.forgotPassword = forgotPassword
            self.mfa = mfa
            self.oAuth = oAuth
            self.passwordPolicy = passwordPolicy
            self.requiredSignUpAttributes = requiredSignUpAttributes
            self.signInMethod = signInMethod
            self.userPoolName = userPoolName
            self.verificationMessage = verificationMessage
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthVerificationMessageConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryMethod = "deliveryMethod"
        case emailSettings = "emailSettings"
        case smsSettings = "smsSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryMethod = self.deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let emailSettings = self.emailSettings {
            try encodeContainer.encode(emailSettings, forKey: .emailSettings)
        }
        if let smsSettings = self.smsSettings {
            try encodeContainer.encode(smsSettings, forKey: .smsSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.DeliveryMethod.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let emailSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.EmailSettings.self, forKey: .emailSettings)
        emailSettings = emailSettingsDecoded
        let smsSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SmsSettings.self, forKey: .smsSettings)
        smsSettings = smsSettingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Creates an email or SMS verification message for the auth resource configured for your Amplify project.
    public struct CreateBackendAuthVerificationMessageConfig: Swift.Equatable {
        /// The type of verification message to send.
        /// This member is required.
        public var deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod?
        /// The settings for the email message.
        public var emailSettings: AmplifyBackendClientTypes.EmailSettings?
        /// The settings for the SMS message.
        public var smsSettings: AmplifyBackendClientTypes.SmsSettings?

        public init (
            deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod? = nil,
            emailSettings: AmplifyBackendClientTypes.EmailSettings? = nil,
            smsSettings: AmplifyBackendClientTypes.SmsSettings? = nil
        )
        {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }
    }

}

extension CreateBackendConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendManagerAppId = "backendManagerAppId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendManagerAppId = self.backendManagerAppId {
            try encodeContainer.encode(backendManagerAppId, forKey: .backendManagerAppId)
        }
    }
}

extension CreateBackendConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/config"
    }
}

/// The request body for CreateBackendConfig.
public struct CreateBackendConfigInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The app ID for the backend manager.
    public var backendManagerAppId: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendManagerAppId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendManagerAppId = backendManagerAppId
    }
}

struct CreateBackendConfigInputBody: Swift.Equatable {
    let backendManagerAppId: Swift.String?
}

extension CreateBackendConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendManagerAppId = "backendManagerAppId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendManagerAppIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendManagerAppId)
        backendManagerAppId = backendManagerAppIdDecoded
    }
}

extension CreateBackendConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBackendConfigOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBackendConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct CreateBackendConfigOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.status = status
    }
}

struct CreateBackendConfigOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let jobId: Swift.String?
    let status: Swift.String?
}

extension CreateBackendConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case jobId = "jobId"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateBackendInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case appName = "appName"
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appName = self.appName {
            try encodeContainer.encode(appName, forKey: .appName)
        }
        if let backendEnvironmentName = self.backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension CreateBackendInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/backend"
    }
}

/// The request body for CreateBackend.
public struct CreateBackendInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the app.
    /// This member is required.
    public var appName: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for creating a backend.
    public var resourceConfig: AmplifyBackendClientTypes.ResourceConfig?
    /// The name of the resource.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        appName: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.ResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.appName = appName
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendInputBody: Swift.Equatable {
    let appId: Swift.String?
    let appName: Swift.String?
    let backendEnvironmentName: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.ResourceConfig?
    let resourceName: Swift.String?
}

extension CreateBackendInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case appName = "appName"
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let appNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appName)
        appName = appNameDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CreateBackendOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBackendOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBackendOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CreateBackendOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CreateBackendOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension CreateBackendOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateBackendStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = self.backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension CreateBackendStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/storage"
    }
}

/// The request body for CreateBackendStorage.
public struct CreateBackendStorageInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for creating backend storage.
    /// This member is required.
    public var resourceConfig: AmplifyBackendClientTypes.CreateBackendStorageResourceConfig?
    /// The name of the storage resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.CreateBackendStorageResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendStorageInputBody: Swift.Equatable {
    let backendEnvironmentName: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.CreateBackendStorageResourceConfig?
    let resourceName: Swift.String?
}

extension CreateBackendStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendStorageResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CreateBackendStorageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendStorageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBackendStorageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendStorageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBackendStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct CreateBackendStorageOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.status = status
    }
}

struct CreateBackendStorageOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let jobId: Swift.String?
    let status: Swift.String?
}

extension CreateBackendStorageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case jobId = "jobId"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendStorageResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "bucketName"
        case permissions = "permissions"
        case serviceName = "serviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let permissions = self.permissions {
            try encodeContainer.encode(permissions, forKey: .permissions)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendStoragePermissions.self, forKey: .permissions)
        permissions = permissionsDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The resource configuration for creating backend storage.
    public struct CreateBackendStorageResourceConfig: Swift.Equatable {
        /// The name of the S3 bucket.
        public var bucketName: Swift.String?
        /// The authorization configuration for the storage S3 bucket.
        /// This member is required.
        public var permissions: AmplifyBackendClientTypes.BackendStoragePermissions?
        /// The name of the storage service.
        /// This member is required.
        public var serviceName: AmplifyBackendClientTypes.ServiceName?

        public init (
            bucketName: Swift.String? = nil,
            permissions: AmplifyBackendClientTypes.BackendStoragePermissions? = nil,
            serviceName: AmplifyBackendClientTypes.ServiceName? = nil
        )
        {
            self.bucketName = bucketName
            self.permissions = permissions
            self.serviceName = serviceName
        }
    }

}

extension CreateTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/challenge"
    }
}

public struct CreateTokenInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?

    public init (
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct CreateTokenInputBody: Swift.Equatable {
}

extension CreateTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTokenOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.challengeCode = output.challengeCode
            self.sessionId = output.sessionId
            self.ttl = output.ttl
        } else {
            self.appId = nil
            self.challengeCode = nil
            self.sessionId = nil
            self.ttl = nil
        }
    }
}

public struct CreateTokenOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// One-time challenge code for authenticating into the Amplify Admin UI.
    public var challengeCode: Swift.String?
    /// A unique ID provided when creating a new challenge token.
    public var sessionId: Swift.String?
    /// The expiry time for the one-time generated token code.
    public var ttl: Swift.String?

    public init (
        appId: Swift.String? = nil,
        challengeCode: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        ttl: Swift.String? = nil
    )
    {
        self.appId = appId
        self.challengeCode = challengeCode
        self.sessionId = sessionId
        self.ttl = ttl
    }
}

struct CreateTokenOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let challengeCode: Swift.String?
    let sessionId: Swift.String?
    let ttl: Swift.String?
}

extension CreateTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case challengeCode = "challengeCode"
        case sessionId = "sessionId"
        case ttl = "ttl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let challengeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .challengeCode)
        challengeCode = challengeCodeDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ttl)
        ttl = ttlDecoded
    }
}

extension DeleteBackendAPIInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension DeleteBackendAPIInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/api/\(backendEnvironmentName.urlPercentEncoding())/remove"
    }
}

/// The request body for DeleteBackendAPI.
public struct DeleteBackendAPIInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// Defines the resource configuration for the data model in your Amplify project.
    public var resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct DeleteBackendAPIInputBody: Swift.Equatable {
    let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    let resourceName: Swift.String?
}

extension DeleteBackendAPIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DeleteBackendAPIOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackendAPIOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBackendAPIOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackendAPIOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteBackendAPIOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendAPIOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct DeleteBackendAPIOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension DeleteBackendAPIOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteBackendAuthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension DeleteBackendAuthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/auth/\(backendEnvironmentName.urlPercentEncoding())/remove"
    }
}

/// The request body for DeleteBackendAuth.
public struct DeleteBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct DeleteBackendAuthInputBody: Swift.Equatable {
    let resourceName: Swift.String?
}

extension DeleteBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DeleteBackendAuthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackendAuthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBackendAuthOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackendAuthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendAuthOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct DeleteBackendAuthOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension DeleteBackendAuthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteBackendInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/environments/\(backendEnvironmentName.urlPercentEncoding())/remove"
    }
}

public struct DeleteBackendInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
    }
}

struct DeleteBackendInputBody: Swift.Equatable {
}

extension DeleteBackendInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackendOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackendOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBackendOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackendOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteBackendOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct DeleteBackendOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension DeleteBackendOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteBackendStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
        case serviceName = "serviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }
}

extension DeleteBackendStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/storage/\(backendEnvironmentName.urlPercentEncoding())/remove"
    }
}

/// The request body for DeleteBackendStorage.
public struct DeleteBackendStorageInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of the storage resource.
    /// This member is required.
    public var resourceName: Swift.String?
    /// The name of the storage service.
    /// This member is required.
    public var serviceName: AmplifyBackendClientTypes.ServiceName?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        serviceName: AmplifyBackendClientTypes.ServiceName? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
        self.serviceName = serviceName
    }
}

struct DeleteBackendStorageInputBody: Swift.Equatable {
    let resourceName: Swift.String?
    let serviceName: AmplifyBackendClientTypes.ServiceName?
}

extension DeleteBackendStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
        case serviceName = "serviceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension DeleteBackendStorageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackendStorageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBackendStorageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackendStorageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteBackendStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendStorageOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.status = status
    }
}

struct DeleteBackendStorageOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let jobId: Swift.String?
    let status: Swift.String?
}

extension DeleteBackendStorageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case jobId = "jobId"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/challenge/\(sessionId.urlPercentEncoding())/remove"
    }
}

public struct DeleteTokenInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        appId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.sessionId = sessionId
    }
}

struct DeleteTokenInputBody: Swift.Equatable {
}

extension DeleteTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTokenOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isSuccess = output.isSuccess
        } else {
            self.isSuccess = nil
        }
    }
}

public struct DeleteTokenOutputResponse: Swift.Equatable {
    /// Indicates whether the request succeeded or failed.
    public var isSuccess: Swift.Bool?

    public init (
        isSuccess: Swift.Bool? = nil
    )
    {
        self.isSuccess = isSuccess
    }
}

struct DeleteTokenOutputResponseBody: Swift.Equatable {
    let isSuccess: Swift.Bool?
}

extension DeleteTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isSuccess = "isSuccess"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isSuccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSuccess)
        isSuccess = isSuccessDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The type of verification message to send.
    public enum DeliveryMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sms
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliveryMethod] {
            return [
                .email,
                .sms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sms: return "SMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeliveryMethod(rawValue: rawValue) ?? DeliveryMethod.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.EmailSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailMessage = "emailMessage"
        case emailSubject = "emailSubject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailMessage = self.emailMessage {
            try encodeContainer.encode(emailMessage, forKey: .emailMessage)
        }
        if let emailSubject = self.emailSubject {
            try encodeContainer.encode(emailSubject, forKey: .emailSubject)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailMessage)
        emailMessage = emailMessageDecoded
        let emailSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailSubject)
        emailSubject = emailSubjectDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The configuration for the email sent when an app user forgets their password.
    public struct EmailSettings: Swift.Equatable {
        /// The contents of the email message.
        public var emailMessage: Swift.String?
        /// The contents of the subject line of the email message.
        public var emailSubject: Swift.String?

        public init (
            emailMessage: Swift.String? = nil,
            emailSubject: Swift.String? = nil
        )
        {
            self.emailMessage = emailMessage
            self.emailSubject = emailSubject
        }
    }

}

extension GatewayTimeoutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GatewayTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error returned if there's a temporary issue with the service.
public struct GatewayTimeoutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// An error message to inform that the request failed.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct GatewayTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension GatewayTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GenerateBackendAPIModelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension GenerateBackendAPIModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/api/\(backendEnvironmentName.urlPercentEncoding())/generateModels"
    }
}

/// The request body for GenerateBackendAPIModels.
public struct GenerateBackendAPIModelsInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GenerateBackendAPIModelsInputBody: Swift.Equatable {
    let resourceName: Swift.String?
}

extension GenerateBackendAPIModelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GenerateBackendAPIModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateBackendAPIModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GenerateBackendAPIModelsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateBackendAPIModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GenerateBackendAPIModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct GenerateBackendAPIModelsOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct GenerateBackendAPIModelsOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension GenerateBackendAPIModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetBackendAPIInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension GetBackendAPIInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/api/\(backendEnvironmentName.urlPercentEncoding())/details"
    }
}

/// The request body for GetBackendAPI.
public struct GetBackendAPIInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// Defines the resource configuration for the data model in your Amplify project.
    public var resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendAPIInputBody: Swift.Equatable {
    let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    let resourceName: Swift.String?
}

extension GetBackendAPIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendAPIModelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension GetBackendAPIModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/api/\(backendEnvironmentName.urlPercentEncoding())/getModels"
    }
}

/// The request body for GetBackendAPIModels.
public struct GetBackendAPIModelsInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GetBackendAPIModelsInputBody: Swift.Equatable {
    let resourceName: Swift.String?
}

extension GetBackendAPIModelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendAPIModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendAPIModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBackendAPIModelsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendAPIModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBackendAPIModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.modelIntrospectionSchema = output.modelIntrospectionSchema
            self.models = output.models
            self.status = output.status
        } else {
            self.modelIntrospectionSchema = nil
            self.models = nil
            self.status = nil
        }
    }
}

public struct GetBackendAPIModelsOutputResponse: Swift.Equatable {
    /// Stringified JSON of the model introspection schema for an existing backend API resource.
    public var modelIntrospectionSchema: Swift.String?
    /// Stringified JSON of the datastore model.
    public var models: Swift.String?
    /// The current status of the request.
    public var status: AmplifyBackendClientTypes.Status?

    public init (
        modelIntrospectionSchema: Swift.String? = nil,
        models: Swift.String? = nil,
        status: AmplifyBackendClientTypes.Status? = nil
    )
    {
        self.modelIntrospectionSchema = modelIntrospectionSchema
        self.models = models
        self.status = status
    }
}

struct GetBackendAPIModelsOutputResponseBody: Swift.Equatable {
    let models: Swift.String?
    let status: AmplifyBackendClientTypes.Status?
    let modelIntrospectionSchema: Swift.String?
}

extension GetBackendAPIModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelIntrospectionSchema = "modelIntrospectionSchema"
        case models = "models"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .models)
        models = modelsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let modelIntrospectionSchemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelIntrospectionSchema)
        modelIntrospectionSchema = modelIntrospectionSchemaDecoded
    }
}

extension GetBackendAPIOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendAPIOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBackendAPIOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendAPIOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBackendAPIOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.resourceConfig = output.resourceConfig
            self.resourceName = output.resourceName
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.resourceConfig = nil
            self.resourceName = nil
        }
    }
}

public struct GetBackendAPIOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The resource configuration for this response object.
    public var resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendAPIOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    let resourceName: Swift.String?
}

extension GetBackendAPIOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendAuthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension GetBackendAuthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/auth/\(backendEnvironmentName.urlPercentEncoding())/details"
    }
}

/// The request body for GetBackendAuth.
public struct GetBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GetBackendAuthInputBody: Swift.Equatable {
    let resourceName: Swift.String?
}

extension GetBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendAuthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendAuthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBackendAuthOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendAuthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.resourceConfig = output.resourceConfig
            self.resourceName = output.resourceName
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.resourceConfig = nil
            self.resourceName = nil
        }
    }
}

public struct GetBackendAuthOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The resource configuration for authorization requests to the backend of your Amplify project.
    public var resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig?
    /// The name of this resource.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendAuthOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig?
    let resourceName: Swift.String?
}

extension GetBackendAuthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = self.backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
    }
}

extension GetBackendInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/details"
    }
}

/// The request body for GetBackend.
public struct GetBackendInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
    }
}

struct GetBackendInputBody: Swift.Equatable {
    let backendEnvironmentName: Swift.String?
}

extension GetBackendInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
    }
}

extension GetBackendJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/job/\(backendEnvironmentName.urlPercentEncoding())/\(jobId.urlPercentEncoding())"
    }
}

public struct GetBackendJobInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
    }
}

struct GetBackendJobInputBody: Swift.Equatable {
}

extension GetBackendJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBackendJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBackendJobOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBackendJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.createTime = output.createTime
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.createTime = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct GetBackendJobOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The time when the job was created.
    public var createTime: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?
    /// The time when the job was last updated.
    public var updateTime: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        createTime: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil,
        updateTime: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.createTime = createTime
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
        self.updateTime = updateTime
    }
}

struct GetBackendJobOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let createTime: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
    let updateTime: Swift.String?
}

extension GetBackendJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case createTime = "createTime"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
        case updateTime = "updateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension GetBackendOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBackendOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBackendOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.amplifyFeatureFlags = output.amplifyFeatureFlags
            self.amplifyMetaConfig = output.amplifyMetaConfig
            self.appId = output.appId
            self.appName = output.appName
            self.backendEnvironmentList = output.backendEnvironmentList
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
        } else {
            self.amplifyFeatureFlags = nil
            self.amplifyMetaConfig = nil
            self.appId = nil
            self.appName = nil
            self.backendEnvironmentList = nil
            self.backendEnvironmentName = nil
            self.error = nil
        }
    }
}

public struct GetBackendOutputResponse: Swift.Equatable {
    /// A stringified version of the cli.json file for your Amplify project.
    public var amplifyFeatureFlags: Swift.String?
    /// A stringified version of the current configs for your Amplify project.
    public var amplifyMetaConfig: Swift.String?
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the app.
    public var appName: Swift.String?
    /// A list of backend environments in an array.
    public var backendEnvironmentList: [Swift.String]?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request failed, this is the returned error.
    public var error: Swift.String?

    public init (
        amplifyFeatureFlags: Swift.String? = nil,
        amplifyMetaConfig: Swift.String? = nil,
        appId: Swift.String? = nil,
        appName: Swift.String? = nil,
        backendEnvironmentList: [Swift.String]? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil
    )
    {
        self.amplifyFeatureFlags = amplifyFeatureFlags
        self.amplifyMetaConfig = amplifyMetaConfig
        self.appId = appId
        self.appName = appName
        self.backendEnvironmentList = backendEnvironmentList
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
    }
}

struct GetBackendOutputResponseBody: Swift.Equatable {
    let amplifyFeatureFlags: Swift.String?
    let amplifyMetaConfig: Swift.String?
    let appId: Swift.String?
    let appName: Swift.String?
    let backendEnvironmentList: [Swift.String]?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
}

extension GetBackendOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplifyFeatureFlags = "amplifyFeatureFlags"
        case amplifyMetaConfig = "amplifyMetaConfig"
        case appId = "appId"
        case appName = "appName"
        case backendEnvironmentList = "backendEnvironmentList"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplifyFeatureFlagsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amplifyFeatureFlags)
        amplifyFeatureFlags = amplifyFeatureFlagsDecoded
        let amplifyMetaConfigDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amplifyMetaConfig)
        amplifyMetaConfig = amplifyMetaConfigDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let appNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appName)
        appName = appNameDecoded
        let backendEnvironmentListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .backendEnvironmentList)
        var backendEnvironmentListDecoded0:[Swift.String]? = nil
        if let backendEnvironmentListContainer = backendEnvironmentListContainer {
            backendEnvironmentListDecoded0 = [Swift.String]()
            for string0 in backendEnvironmentListContainer {
                if let string0 = string0 {
                    backendEnvironmentListDecoded0?.append(string0)
                }
            }
        }
        backendEnvironmentList = backendEnvironmentListDecoded0
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

extension GetBackendStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension GetBackendStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/storage/\(backendEnvironmentName.urlPercentEncoding())/details"
    }
}

/// The request body for GetBackendStorage.
public struct GetBackendStorageInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of the storage resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GetBackendStorageInputBody: Swift.Equatable {
    let resourceName: Swift.String?
}

extension GetBackendStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendStorageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendStorageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetBackendStorageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendStorageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetBackendStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.resourceConfig = output.resourceConfig
            self.resourceName = output.resourceName
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.resourceConfig = nil
            self.resourceName = nil
        }
    }
}

public struct GetBackendStorageOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for the backend storage resource.
    public var resourceConfig: AmplifyBackendClientTypes.GetBackendStorageResourceConfig?
    /// The name of the storage resource.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.GetBackendStorageResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendStorageOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let resourceConfig: AmplifyBackendClientTypes.GetBackendStorageResourceConfig?
    let resourceName: Swift.String?
}

extension GetBackendStorageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.GetBackendStorageResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension AmplifyBackendClientTypes.GetBackendStorageResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "bucketName"
        case imported = "imported"
        case permissions = "permissions"
        case serviceName = "serviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let imported = self.imported {
            try encodeContainer.encode(imported, forKey: .imported)
        }
        if let permissions = self.permissions {
            try encodeContainer.encode(permissions, forKey: .permissions)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let importedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .imported)
        imported = importedDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendStoragePermissions.self, forKey: .permissions)
        permissions = permissionsDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The details for a backend storage resource.
    public struct GetBackendStorageResourceConfig: Swift.Equatable {
        /// The name of the S3 bucket.
        public var bucketName: Swift.String?
        /// Returns True if the storage resource has been imported.
        /// This member is required.
        public var imported: Swift.Bool?
        /// The authorization configuration for the storage S3 bucket.
        public var permissions: AmplifyBackendClientTypes.BackendStoragePermissions?
        /// The name of the storage service.
        /// This member is required.
        public var serviceName: AmplifyBackendClientTypes.ServiceName?

        public init (
            bucketName: Swift.String? = nil,
            imported: Swift.Bool? = nil,
            permissions: AmplifyBackendClientTypes.BackendStoragePermissions? = nil,
            serviceName: AmplifyBackendClientTypes.ServiceName? = nil
        )
        {
            self.bucketName = bucketName
            self.imported = imported
            self.permissions = permissions
            self.serviceName = serviceName
        }
    }

}

extension GetTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/challenge/\(sessionId.urlPercentEncoding())"
    }
}

public struct GetTokenInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        appId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.sessionId = sessionId
    }
}

struct GetTokenInputBody: Swift.Equatable {
}

extension GetTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTokenOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.challengeCode = output.challengeCode
            self.sessionId = output.sessionId
            self.ttl = output.ttl
        } else {
            self.appId = nil
            self.challengeCode = nil
            self.sessionId = nil
            self.ttl = nil
        }
    }
}

public struct GetTokenOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The one-time challenge code for authenticating into the Amplify Admin UI.
    public var challengeCode: Swift.String?
    /// A unique ID provided when creating a new challenge token.
    public var sessionId: Swift.String?
    /// The expiry time for the one-time generated token code.
    public var ttl: Swift.String?

    public init (
        appId: Swift.String? = nil,
        challengeCode: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        ttl: Swift.String? = nil
    )
    {
        self.appId = appId
        self.challengeCode = challengeCode
        self.sessionId = sessionId
        self.ttl = ttl
    }
}

struct GetTokenOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let challengeCode: Swift.String?
    let sessionId: Swift.String?
    let ttl: Swift.String?
}

extension GetTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case challengeCode = "challengeCode"
        case sessionId = "sessionId"
        case ttl = "ttl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let challengeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .challengeCode)
        challengeCode = challengeCodeDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ttl)
        ttl = ttlDecoded
    }
}

extension ImportBackendAuthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "identityPoolId"
        case nativeClientId = "nativeClientId"
        case userPoolId = "userPoolId"
        case webClientId = "webClientId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let nativeClientId = self.nativeClientId {
            try encodeContainer.encode(nativeClientId, forKey: .nativeClientId)
        }
        if let userPoolId = self.userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let webClientId = self.webClientId {
            try encodeContainer.encode(webClientId, forKey: .webClientId)
        }
    }
}

extension ImportBackendAuthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/auth/\(backendEnvironmentName.urlPercentEncoding())/import"
    }
}

/// The request body for ImportBackendAuth.
public struct ImportBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The ID of the Amazon Cognito identity pool.
    public var identityPoolId: Swift.String?
    /// The ID of the Amazon Cognito native client.
    /// This member is required.
    public var nativeClientId: Swift.String?
    /// The ID of the Amazon Cognito user pool.
    /// This member is required.
    public var userPoolId: Swift.String?
    /// The ID of the Amazon Cognito web client.
    /// This member is required.
    public var webClientId: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        nativeClientId: Swift.String? = nil,
        userPoolId: Swift.String? = nil,
        webClientId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.identityPoolId = identityPoolId
        self.nativeClientId = nativeClientId
        self.userPoolId = userPoolId
        self.webClientId = webClientId
    }
}

struct ImportBackendAuthInputBody: Swift.Equatable {
    let identityPoolId: Swift.String?
    let nativeClientId: Swift.String?
    let userPoolId: Swift.String?
    let webClientId: Swift.String?
}

extension ImportBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "identityPoolId"
        case nativeClientId = "nativeClientId"
        case userPoolId = "userPoolId"
        case webClientId = "webClientId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let nativeClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nativeClientId)
        nativeClientId = nativeClientIdDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let webClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webClientId)
        webClientId = webClientIdDecoded
    }
}

extension ImportBackendAuthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportBackendAuthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportBackendAuthOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportBackendAuthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct ImportBackendAuthOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct ImportBackendAuthOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension ImportBackendAuthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ImportBackendStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "bucketName"
        case serviceName = "serviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }
}

extension ImportBackendStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/storage/\(backendEnvironmentName.urlPercentEncoding())/import"
    }
}

/// The request body for ImportBackendStorage.
public struct ImportBackendStorageInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The name of the S3 bucket.
    public var bucketName: Swift.String?
    /// The name of the storage service.
    /// This member is required.
    public var serviceName: AmplifyBackendClientTypes.ServiceName?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        bucketName: Swift.String? = nil,
        serviceName: AmplifyBackendClientTypes.ServiceName? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.bucketName = bucketName
        self.serviceName = serviceName
    }
}

struct ImportBackendStorageInputBody: Swift.Equatable {
    let bucketName: Swift.String?
    let serviceName: AmplifyBackendClientTypes.ServiceName?
}

extension ImportBackendStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "bucketName"
        case serviceName = "serviceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension ImportBackendStorageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportBackendStorageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportBackendStorageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportBackendStorageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportBackendStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct ImportBackendStorageOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.status = status
    }
}

struct ImportBackendStorageOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let jobId: Swift.String?
    let status: Swift.String?
}

extension ImportBackendStorageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case jobId = "jobId"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListBackendJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "jobId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case operation = "operation"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }
}

extension ListBackendJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/job/\(backendEnvironmentName.urlPercentEncoding())"
    }
}

/// The request body for ListBackendJobs.
public struct ListBackendJobsInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The maximum number of results that you want in the response.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Filters the list of response objects to include only those with the specified operation name.
    public var operation: Swift.String?
    /// Filters the list of response objects to include only those with the specified status.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operation = operation
        self.status = status
    }
}

struct ListBackendJobsInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension ListBackendJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "jobId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListBackendJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackendJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBackendJobsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackendJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBackendJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackendJobsOutputResponse: Swift.Equatable {
    /// An array of jobs and their properties.
    public var jobs: [AmplifyBackendClientTypes.BackendJobRespObj]?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        jobs: [AmplifyBackendClientTypes.BackendJobRespObj]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListBackendJobsOutputResponseBody: Swift.Equatable {
    let jobs: [AmplifyBackendClientTypes.BackendJobRespObj]?
    let nextToken: Swift.String?
}

extension ListBackendJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "jobs"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.BackendJobRespObj?].self, forKey: .jobs)
        var jobsDecoded0:[AmplifyBackendClientTypes.BackendJobRespObj]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [AmplifyBackendClientTypes.BackendJobRespObj]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListS3BucketsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListS3BucketsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/s3Buckets"
    }
}

/// The request body for S3Buckets.
public struct ListS3BucketsInput: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListS3BucketsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListS3BucketsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListS3BucketsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListS3BucketsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListS3BucketsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListS3BucketsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListS3BucketsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.buckets = output.buckets
            self.nextToken = output.nextToken
        } else {
            self.buckets = nil
            self.nextToken = nil
        }
    }
}

public struct ListS3BucketsOutputResponse: Swift.Equatable {
    /// The list of S3 buckets.
    public var buckets: [AmplifyBackendClientTypes.S3BucketInfo]?
    /// Reserved for future use.
    public var nextToken: Swift.String?

    public init (
        buckets: [AmplifyBackendClientTypes.S3BucketInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.buckets = buckets
        self.nextToken = nextToken
    }
}

struct ListS3BucketsOutputResponseBody: Swift.Equatable {
    let buckets: [AmplifyBackendClientTypes.S3BucketInfo]?
    let nextToken: Swift.String?
}

extension ListS3BucketsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buckets = "buckets"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketsContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.S3BucketInfo?].self, forKey: .buckets)
        var bucketsDecoded0:[AmplifyBackendClientTypes.S3BucketInfo]? = nil
        if let bucketsContainer = bucketsContainer {
            bucketsDecoded0 = [AmplifyBackendClientTypes.S3BucketInfo]()
            for structure0 in bucketsContainer {
                if let structure0 = structure0 {
                    bucketsDecoded0?.append(structure0)
                }
            }
        }
        buckets = bucketsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AmplifyBackendClientTypes.LoginAuthConfigReqObj: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsCognitoIdentityPoolId = "aws_cognito_identity_pool_id"
        case awsCognitoRegion = "aws_cognito_region"
        case awsUserPoolsId = "aws_user_pools_id"
        case awsUserPoolsWebClientId = "aws_user_pools_web_client_id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsCognitoIdentityPoolId = self.awsCognitoIdentityPoolId {
            try encodeContainer.encode(awsCognitoIdentityPoolId, forKey: .awsCognitoIdentityPoolId)
        }
        if let awsCognitoRegion = self.awsCognitoRegion {
            try encodeContainer.encode(awsCognitoRegion, forKey: .awsCognitoRegion)
        }
        if let awsUserPoolsId = self.awsUserPoolsId {
            try encodeContainer.encode(awsUserPoolsId, forKey: .awsUserPoolsId)
        }
        if let awsUserPoolsWebClientId = self.awsUserPoolsWebClientId {
            try encodeContainer.encode(awsUserPoolsWebClientId, forKey: .awsUserPoolsWebClientId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsCognitoIdentityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsCognitoIdentityPoolId)
        awsCognitoIdentityPoolId = awsCognitoIdentityPoolIdDecoded
        let awsCognitoRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsCognitoRegion)
        awsCognitoRegion = awsCognitoRegionDecoded
        let awsUserPoolsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsUserPoolsId)
        awsUserPoolsId = awsUserPoolsIdDecoded
        let awsUserPoolsWebClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsUserPoolsWebClientId)
        awsUserPoolsWebClientId = awsUserPoolsWebClientIdDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The request object for this operation.
    public struct LoginAuthConfigReqObj: Swift.Equatable {
        /// The Amazon Cognito identity pool ID used for the Amplify Admin UI login authorization.
        public var awsCognitoIdentityPoolId: Swift.String?
        /// The AWS Region for the Amplify Admin UI login.
        public var awsCognitoRegion: Swift.String?
        /// The Amazon Cognito user pool ID used for Amplify Admin UI login authentication.
        public var awsUserPoolsId: Swift.String?
        /// The web client ID for the Amazon Cognito user pools.
        public var awsUserPoolsWebClientId: Swift.String?

        public init (
            awsCognitoIdentityPoolId: Swift.String? = nil,
            awsCognitoRegion: Swift.String? = nil,
            awsUserPoolsId: Swift.String? = nil,
            awsUserPoolsWebClientId: Swift.String? = nil
        )
        {
            self.awsCognitoIdentityPoolId = awsCognitoIdentityPoolId
            self.awsCognitoRegion = awsCognitoRegion
            self.awsUserPoolsId = awsUserPoolsId
            self.awsUserPoolsWebClientId = awsUserPoolsWebClientId
        }
    }

}

extension AmplifyBackendClientTypes {
    public enum MFAMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case `optional`
        case sdkUnknown(Swift.String)

        public static var allCases: [MFAMode] {
            return [
                .off,
                .on,
                .optional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .on: return "ON"
            case .optional: return "OPTIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MFAMode(rawValue: rawValue) ?? MFAMode.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum MfaTypesElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sms
        case totp
        case sdkUnknown(Swift.String)

        public static var allCases: [MfaTypesElement] {
            return [
                .sms,
                .totp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sms: return "SMS"
            case .totp: return "TOTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MfaTypesElement(rawValue: rawValue) ?? MfaTypesElement.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum Mode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonCognitoUserPools
        case apiKey
        case awsIam
        case openidConnect
        case sdkUnknown(Swift.String)

        public static var allCases: [Mode] {
            return [
                .amazonCognitoUserPools,
                .apiKey,
                .awsIam,
                .openidConnect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonCognitoUserPools: return "AMAZON_COGNITO_USER_POOLS"
            case .apiKey: return "API_KEY"
            case .awsIam: return "AWS_IAM"
            case .openidConnect: return "OPENID_CONNECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error returned when a specific resource type is not found.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// An error message to inform that the request has failed.
    public var message: Swift.String?
    /// The type of resource that is not found.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case resourceType = "resourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AmplifyBackendClientTypes {
    public enum OAuthGrantType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case code
        case implicit
        case sdkUnknown(Swift.String)

        public static var allCases: [OAuthGrantType] {
            return [
                .code,
                .implicit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .code: return "CODE"
            case .implicit: return "IMPLICIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OAuthGrantType(rawValue: rawValue) ?? OAuthGrantType.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum OAuthScopesElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsCognitoSigninUserAdmin
        case email
        case openid
        case phone
        case profile
        case sdkUnknown(Swift.String)

        public static var allCases: [OAuthScopesElement] {
            return [
                .awsCognitoSigninUserAdmin,
                .email,
                .openid,
                .phone,
                .profile,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsCognitoSigninUserAdmin: return "AWS_COGNITO_SIGNIN_USER_ADMIN"
            case .email: return "EMAIL"
            case .openid: return "OPENID"
            case .phone: return "PHONE"
            case .profile: return "PROFILE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OAuthScopesElement(rawValue: rawValue) ?? OAuthScopesElement.sdkUnknown(rawValue)
        }
    }
}

extension RemoveAllBackendsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cleanAmplifyApp = "cleanAmplifyApp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cleanAmplifyApp = self.cleanAmplifyApp {
            try encodeContainer.encode(cleanAmplifyApp, forKey: .cleanAmplifyApp)
        }
    }
}

extension RemoveAllBackendsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/remove"
    }
}

/// The request body for RemoveAllBackends.
public struct RemoveAllBackendsInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// Cleans up the Amplify Console app if this value is set to true.
    public var cleanAmplifyApp: Swift.Bool?

    public init (
        appId: Swift.String? = nil,
        cleanAmplifyApp: Swift.Bool? = nil
    )
    {
        self.appId = appId
        self.cleanAmplifyApp = cleanAmplifyApp
    }
}

struct RemoveAllBackendsInputBody: Swift.Equatable {
    let cleanAmplifyApp: Swift.Bool?
}

extension RemoveAllBackendsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cleanAmplifyApp = "cleanAmplifyApp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cleanAmplifyAppDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cleanAmplifyApp)
        cleanAmplifyApp = cleanAmplifyAppDecoded
    }
}

extension RemoveAllBackendsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveAllBackendsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveAllBackendsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveAllBackendsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RemoveAllBackendsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct RemoveAllBackendsOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct RemoveAllBackendsOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension RemoveAllBackendsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RemoveBackendConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/config/remove"
    }
}

public struct RemoveBackendConfigInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?

    public init (
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct RemoveBackendConfigInputBody: Swift.Equatable {
}

extension RemoveBackendConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveBackendConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveBackendConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveBackendConfigOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveBackendConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RemoveBackendConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
        } else {
            self.error = nil
        }
    }
}

public struct RemoveBackendConfigOutputResponse: Swift.Equatable {
    /// If the request fails, this error is returned.
    public var error: Swift.String?

    public init (
        error: Swift.String? = nil
    )
    {
        self.error = error
    }
}

struct RemoveBackendConfigOutputResponseBody: Swift.Equatable {
    let error: Swift.String?
}

extension RemoveBackendConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "error"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

extension AmplifyBackendClientTypes {
    public enum RequiredSignUpAttributesElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case address
        case birthdate
        case email
        case familyName
        case gender
        case givenName
        case locale
        case middleName
        case name
        case nickname
        case phoneNumber
        case picture
        case preferredUsername
        case profile
        case updatedAt
        case website
        case zoneInfo
        case sdkUnknown(Swift.String)

        public static var allCases: [RequiredSignUpAttributesElement] {
            return [
                .address,
                .birthdate,
                .email,
                .familyName,
                .gender,
                .givenName,
                .locale,
                .middleName,
                .name,
                .nickname,
                .phoneNumber,
                .picture,
                .preferredUsername,
                .profile,
                .updatedAt,
                .website,
                .zoneInfo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .birthdate: return "BIRTHDATE"
            case .email: return "EMAIL"
            case .familyName: return "FAMILY_NAME"
            case .gender: return "GENDER"
            case .givenName: return "GIVEN_NAME"
            case .locale: return "LOCALE"
            case .middleName: return "MIDDLE_NAME"
            case .name: return "NAME"
            case .nickname: return "NICKNAME"
            case .phoneNumber: return "PHONE_NUMBER"
            case .picture: return "PICTURE"
            case .preferredUsername: return "PREFERRED_USERNAME"
            case .profile: return "PROFILE"
            case .updatedAt: return "UPDATED_AT"
            case .website: return "WEBSITE"
            case .zoneInfo: return "ZONE_INFO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequiredSignUpAttributesElement(rawValue: rawValue) ?? RequiredSignUpAttributesElement.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum ResolutionStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automerge
        case lambda
        case `none`
        case optimisticConcurrency
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolutionStrategy] {
            return [
                .automerge,
                .lambda,
                .none,
                .optimisticConcurrency,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automerge: return "AUTOMERGE"
            case .lambda: return "LAMBDA"
            case .none: return "NONE"
            case .optimisticConcurrency: return "OPTIMISTIC_CONCURRENCY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolutionStrategy(rawValue: rawValue) ?? ResolutionStrategy.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.ResourceConfig: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AmplifyBackendClientTypes {
    /// Defines the resource configuration for the data model in your Amplify project.
    public struct ResourceConfig: Swift.Equatable {

        public init () { }
    }

}

extension AmplifyBackendClientTypes.S3BucketInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "creationDate"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the metadata of the S3 bucket.
    public struct S3BucketInfo: Swift.Equatable {
        /// The creation date of the S3 bucket.
        public var creationDate: Swift.String?
        /// The name of the S3 bucket.
        public var name: Swift.String?

        public init (
            creationDate: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.name = name
        }
    }

}

extension AmplifyBackendClientTypes {
    public enum Service: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cognito
        case sdkUnknown(Swift.String)

        public static var allCases: [Service] {
            return [
                .cognito,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cognito: return "COGNITO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Service(rawValue: rawValue) ?? Service.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum ServiceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceName] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceName(rawValue: rawValue) ?? ServiceName.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mfaTypes = "mfaTypes"
        case smsMessage = "smsMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mfaTypes = mfaTypes {
            var mfaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mfaTypes)
            for mfatypeselement0 in mfaTypes {
                try mfaTypesContainer.encode(mfatypeselement0.rawValue)
            }
        }
        if let smsMessage = self.smsMessage {
            try encodeContainer.encode(smsMessage, forKey: .smsMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mfaTypesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.MfaTypesElement?].self, forKey: .mfaTypes)
        var mfaTypesDecoded0:[AmplifyBackendClientTypes.MfaTypesElement]? = nil
        if let mfaTypesContainer = mfaTypesContainer {
            mfaTypesDecoded0 = [AmplifyBackendClientTypes.MfaTypesElement]()
            for enum0 in mfaTypesContainer {
                if let enum0 = enum0 {
                    mfaTypesDecoded0?.append(enum0)
                }
            }
        }
        mfaTypes = mfaTypesDecoded0
        let smsMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .smsMessage)
        smsMessage = smsMessageDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The settings of your MFA configuration for the backend of your Amplify project.
    public struct Settings: Swift.Equatable {
        /// The supported MFA types.
        public var mfaTypes: [AmplifyBackendClientTypes.MfaTypesElement]?
        /// The body of the SMS message.
        public var smsMessage: Swift.String?

        public init (
            mfaTypes: [AmplifyBackendClientTypes.MfaTypesElement]? = nil,
            smsMessage: Swift.String? = nil
        )
        {
            self.mfaTypes = mfaTypes
            self.smsMessage = smsMessage
        }
    }

}

extension AmplifyBackendClientTypes {
    public enum SignInMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case emailAndPhoneNumber
        case phoneNumber
        case username
        case sdkUnknown(Swift.String)

        public static var allCases: [SignInMethod] {
            return [
                .email,
                .emailAndPhoneNumber,
                .phoneNumber,
                .username,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .emailAndPhoneNumber: return "EMAIL_AND_PHONE_NUMBER"
            case .phoneNumber: return "PHONE_NUMBER"
            case .username: return "USERNAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SignInMethod(rawValue: rawValue) ?? SignInMethod.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.SmsSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case smsMessage = "smsMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let smsMessage = self.smsMessage {
            try encodeContainer.encode(smsMessage, forKey: .smsMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let smsMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .smsMessage)
        smsMessage = smsMessageDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// SMS settings for authentication.
    public struct SmsSettings: Swift.Equatable {
        /// The contents of the SMS message.
        public var smsMessage: Swift.String?

        public init (
            smsMessage: Swift.String? = nil
        )
        {
            self.smsMessage = smsMessage
        }
    }

}

extension AmplifyBackendClientTypes.SocialProviderSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facebook = "Facebook"
        case google = "Google"
        case loginWithAmazon = "LoginWithAmazon"
        case signInWithApple = "SignInWithApple"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facebook = self.facebook {
            try encodeContainer.encode(facebook, forKey: .facebook)
        }
        if let google = self.google {
            try encodeContainer.encode(google, forKey: .google)
        }
        if let loginWithAmazon = self.loginWithAmazon {
            try encodeContainer.encode(loginWithAmazon, forKey: .loginWithAmazon)
        }
        if let signInWithApple = self.signInWithApple {
            try encodeContainer.encode(signInWithApple, forKey: .signInWithApple)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facebookDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAuthSocialProviderConfig.self, forKey: .facebook)
        facebook = facebookDecoded
        let googleDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAuthSocialProviderConfig.self, forKey: .google)
        google = googleDecoded
        let loginWithAmazonDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAuthSocialProviderConfig.self, forKey: .loginWithAmazon)
        loginWithAmazon = loginWithAmazonDecoded
        let signInWithAppleDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAuthAppleProviderConfig.self, forKey: .signInWithApple)
        signInWithApple = signInWithAppleDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The settings for using the social identity providers for access to your Amplify app.
    public struct SocialProviderSettings: Swift.Equatable {
        /// Describes third-party social federation configurations for allowing your app users to sign in using OAuth.
        public var facebook: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig?
        /// Describes third-party social federation configurations for allowing your app users to sign in using OAuth.
        public var google: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig?
        /// Describes third-party social federation configurations for allowing your app users to sign in using OAuth.
        public var loginWithAmazon: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig?
        /// Describes Apple social federation configurations for allowing your app users to sign in using OAuth.
        public var signInWithApple: AmplifyBackendClientTypes.BackendAuthAppleProviderConfig?

        public init (
            facebook: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig? = nil,
            google: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig? = nil,
            loginWithAmazon: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig? = nil,
            signInWithApple: AmplifyBackendClientTypes.BackendAuthAppleProviderConfig? = nil
        )
        {
            self.facebook = facebook
            self.google = google
            self.loginWithAmazon = loginWithAmazon
            self.signInWithApple = signInWithApple
        }
    }

}

extension AmplifyBackendClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case latest
        case stale
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .latest,
                .stale,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .latest: return "LATEST"
            case .stale: return "STALE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limitType = output.limitType
            self.message = output.message
        } else {
            self.limitType = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error that is returned when a limit of a specific type has been exceeded.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The type of limit that was exceeded.
    public var limitType: Swift.String?
    /// An error message to inform that the request has failed.
    public var message: Swift.String?

    public init (
        limitType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.limitType = limitType
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let limitType: Swift.String?
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitType = "limitType"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyBackendClientTypes {
    public enum UnAuthenticatedElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createAndUpdate
        case delete
        case read
        case sdkUnknown(Swift.String)

        public static var allCases: [UnAuthenticatedElement] {
            return [
                .createAndUpdate,
                .delete,
                .read,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createAndUpdate: return "CREATE_AND_UPDATE"
            case .delete: return "DELETE"
            case .read: return "READ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UnAuthenticatedElement(rawValue: rawValue) ?? UnAuthenticatedElement.sdkUnknown(rawValue)
        }
    }
}

extension UpdateBackendAPIInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension UpdateBackendAPIInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/api/\(backendEnvironmentName.urlPercentEncoding())"
    }
}

/// The request body for UpdateBackendAPI.
public struct UpdateBackendAPIInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// Defines the resource configuration for the data model in your Amplify project.
    public var resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct UpdateBackendAPIInputBody: Swift.Equatable {
    let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    let resourceName: Swift.String?
}

extension UpdateBackendAPIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UpdateBackendAPIOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendAPIOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateBackendAPIOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendAPIOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateBackendAPIOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct UpdateBackendAPIOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct UpdateBackendAPIOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension UpdateBackendAPIOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryMethod = "deliveryMethod"
        case emailSettings = "emailSettings"
        case smsSettings = "smsSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryMethod = self.deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let emailSettings = self.emailSettings {
            try encodeContainer.encode(emailSettings, forKey: .emailSettings)
        }
        if let smsSettings = self.smsSettings {
            try encodeContainer.encode(smsSettings, forKey: .smsSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.DeliveryMethod.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let emailSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.EmailSettings.self, forKey: .emailSettings)
        emailSettings = emailSettingsDecoded
        let smsSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SmsSettings.self, forKey: .smsSettings)
        smsSettings = smsSettingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// (DEPRECATED) Describes the forgot password policy for authenticating into the Amplify app.
    public struct UpdateBackendAuthForgotPasswordConfig: Swift.Equatable {
        /// (DEPRECATED) Describes which mode to use (either SMS or email) to deliver messages to app users that want to recover their password.
        public var deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod?
        /// (DEPRECATED) The configuration for the email sent when an app user forgets their password.
        public var emailSettings: AmplifyBackendClientTypes.EmailSettings?
        /// (DEPRECATED) The configuration for the SMS message sent when an Amplify app user forgets their password.
        public var smsSettings: AmplifyBackendClientTypes.SmsSettings?

        public init (
            deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod? = nil,
            emailSettings: AmplifyBackendClientTypes.EmailSettings? = nil,
            smsSettings: AmplifyBackendClientTypes.SmsSettings? = nil
        )
        {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unauthenticatedLogin = "unauthenticatedLogin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unauthenticatedLogin = self.unauthenticatedLogin {
            try encodeContainer.encode(unauthenticatedLogin, forKey: .unauthenticatedLogin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unauthenticatedLoginDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .unauthenticatedLogin)
        unauthenticatedLogin = unauthenticatedLoginDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of your auth resource in the Amplify project.
    public struct UpdateBackendAuthIdentityPoolConfig: Swift.Equatable {
        /// A boolean value that can be set to allow or disallow guest-level authorization into your Amplify app.
        public var unauthenticatedLogin: Swift.Bool?

        public init (
            unauthenticatedLogin: Swift.Bool? = nil
        )
        {
            self.unauthenticatedLogin = unauthenticatedLogin
        }
    }

}

extension UpdateBackendAuthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension UpdateBackendAuthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/auth/\(backendEnvironmentName.urlPercentEncoding())"
    }
}

/// The request body for UpdateBackendAuth.
public struct UpdateBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for this request object.
    /// This member is required.
    public var resourceConfig: AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct UpdateBackendAuthInputBody: Swift.Equatable {
    let resourceConfig: AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig?
    let resourceName: Swift.String?
}

extension UpdateBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mfaMode = "MFAMode"
        case settings = "settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mfaMode = self.mfaMode {
            try encodeContainer.encode(mfaMode.rawValue, forKey: .mfaMode)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mfaModeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.MFAMode.self, forKey: .mfaMode)
        mfaMode = mfaModeDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Updates the multi-factor authentication (MFA) configuration for the backend of your Amplify project.
    public struct UpdateBackendAuthMFAConfig: Swift.Equatable {
        /// The MFA mode for the backend of your Amplify project.
        public var mfaMode: AmplifyBackendClientTypes.MFAMode?
        /// The settings of your MFA configuration for the backend of your Amplify project.
        public var settings: AmplifyBackendClientTypes.Settings?

        public init (
            mfaMode: AmplifyBackendClientTypes.MFAMode? = nil,
            settings: AmplifyBackendClientTypes.Settings? = nil
        )
        {
            self.mfaMode = mfaMode
            self.settings = settings
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainPrefix = "domainPrefix"
        case oAuthGrantType = "oAuthGrantType"
        case oAuthScopes = "oAuthScopes"
        case redirectSignInURIs = "redirectSignInURIs"
        case redirectSignOutURIs = "redirectSignOutURIs"
        case socialProviderSettings = "socialProviderSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainPrefix = self.domainPrefix {
            try encodeContainer.encode(domainPrefix, forKey: .domainPrefix)
        }
        if let oAuthGrantType = self.oAuthGrantType {
            try encodeContainer.encode(oAuthGrantType.rawValue, forKey: .oAuthGrantType)
        }
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscopeselement0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscopeselement0.rawValue)
            }
        }
        if let redirectSignInURIs = redirectSignInURIs {
            var redirectSignInURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignInURIs)
            for __string0 in redirectSignInURIs {
                try redirectSignInURIsContainer.encode(__string0)
            }
        }
        if let redirectSignOutURIs = redirectSignOutURIs {
            var redirectSignOutURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignOutURIs)
            for __string0 in redirectSignOutURIs {
                try redirectSignOutURIsContainer.encode(__string0)
            }
        }
        if let socialProviderSettings = self.socialProviderSettings {
            try encodeContainer.encode(socialProviderSettings, forKey: .socialProviderSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainPrefix)
        domainPrefix = domainPrefixDecoded
        let oAuthGrantTypeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.OAuthGrantType.self, forKey: .oAuthGrantType)
        oAuthGrantType = oAuthGrantTypeDecoded
        let oAuthScopesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.OAuthScopesElement?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[AmplifyBackendClientTypes.OAuthScopesElement]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [AmplifyBackendClientTypes.OAuthScopesElement]()
            for enum0 in oAuthScopesContainer {
                if let enum0 = enum0 {
                    oAuthScopesDecoded0?.append(enum0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
        let redirectSignInURIsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectSignInURIs)
        var redirectSignInURIsDecoded0:[Swift.String]? = nil
        if let redirectSignInURIsContainer = redirectSignInURIsContainer {
            redirectSignInURIsDecoded0 = [Swift.String]()
            for string0 in redirectSignInURIsContainer {
                if let string0 = string0 {
                    redirectSignInURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignInURIs = redirectSignInURIsDecoded0
        let redirectSignOutURIsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectSignOutURIs)
        var redirectSignOutURIsDecoded0:[Swift.String]? = nil
        if let redirectSignOutURIsContainer = redirectSignOutURIsContainer {
            redirectSignOutURIsDecoded0 = [Swift.String]()
            for string0 in redirectSignOutURIsContainer {
                if let string0 = string0 {
                    redirectSignOutURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignOutURIs = redirectSignOutURIsDecoded0
        let socialProviderSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SocialProviderSettings.self, forKey: .socialProviderSettings)
        socialProviderSettings = socialProviderSettingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The OAuth configurations for authenticating users into your Amplify app.
    public struct UpdateBackendAuthOAuthConfig: Swift.Equatable {
        /// The Amazon Cognito domain prefix used to create a hosted UI for authentication.
        public var domainPrefix: Swift.String?
        /// The OAuth grant type to allow app users to authenticate from your Amplify app.
        public var oAuthGrantType: AmplifyBackendClientTypes.OAuthGrantType?
        /// The list of OAuth-related flows that can allow users to authenticate from your Amplify app.
        public var oAuthScopes: [AmplifyBackendClientTypes.OAuthScopesElement]?
        /// Redirect URLs that OAuth uses when a user signs in to an Amplify app.
        public var redirectSignInURIs: [Swift.String]?
        /// Redirect URLs that OAuth uses when a user signs out of an Amplify app.
        public var redirectSignOutURIs: [Swift.String]?
        /// Describes third-party social federation configurations for allowing your users to sign in with OAuth.
        public var socialProviderSettings: AmplifyBackendClientTypes.SocialProviderSettings?

        public init (
            domainPrefix: Swift.String? = nil,
            oAuthGrantType: AmplifyBackendClientTypes.OAuthGrantType? = nil,
            oAuthScopes: [AmplifyBackendClientTypes.OAuthScopesElement]? = nil,
            redirectSignInURIs: [Swift.String]? = nil,
            redirectSignOutURIs: [Swift.String]? = nil,
            socialProviderSettings: AmplifyBackendClientTypes.SocialProviderSettings? = nil
        )
        {
            self.domainPrefix = domainPrefix
            self.oAuthGrantType = oAuthGrantType
            self.oAuthScopes = oAuthScopes
            self.redirectSignInURIs = redirectSignInURIs
            self.redirectSignOutURIs = redirectSignOutURIs
            self.socialProviderSettings = socialProviderSettings
        }
    }

}

extension UpdateBackendAuthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendAuthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateBackendAuthOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendAuthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct UpdateBackendAuthOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct UpdateBackendAuthOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
}

extension UpdateBackendAuthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConstraints = "additionalConstraints"
        case minimumLength = "minimumLength"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConstraints = additionalConstraints {
            var additionalConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConstraints)
            for additionalconstraintselement0 in additionalConstraints {
                try additionalConstraintsContainer.encode(additionalconstraintselement0.rawValue)
            }
        }
        if let minimumLength = self.minimumLength {
            try encodeContainer.encode(minimumLength, forKey: .minimumLength)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalConstraintsContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.AdditionalConstraintsElement?].self, forKey: .additionalConstraints)
        var additionalConstraintsDecoded0:[AmplifyBackendClientTypes.AdditionalConstraintsElement]? = nil
        if let additionalConstraintsContainer = additionalConstraintsContainer {
            additionalConstraintsDecoded0 = [AmplifyBackendClientTypes.AdditionalConstraintsElement]()
            for enum0 in additionalConstraintsContainer {
                if let enum0 = enum0 {
                    additionalConstraintsDecoded0?.append(enum0)
                }
            }
        }
        additionalConstraints = additionalConstraintsDecoded0
        let minimumLengthDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimumLength)
        minimumLength = minimumLengthDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the password policy for your Amazon Cognito user pool configured as a part of your Amplify project.
    public struct UpdateBackendAuthPasswordPolicyConfig: Swift.Equatable {
        /// Describes additional constraints on password requirements to sign in to the auth resource, configured as a part of your Amplify project.
        public var additionalConstraints: [AmplifyBackendClientTypes.AdditionalConstraintsElement]?
        /// Describes the minimum length of the password required to sign in to the auth resource, configured as a part of your Amplify project.
        public var minimumLength: Swift.Double?

        public init (
            additionalConstraints: [AmplifyBackendClientTypes.AdditionalConstraintsElement]? = nil,
            minimumLength: Swift.Double? = nil
        )
        {
            self.additionalConstraints = additionalConstraints
            self.minimumLength = minimumLength
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authResources = "authResources"
        case identityPoolConfigs = "identityPoolConfigs"
        case service = "service"
        case userPoolConfigs = "userPoolConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authResources = self.authResources {
            try encodeContainer.encode(authResources.rawValue, forKey: .authResources)
        }
        if let identityPoolConfigs = self.identityPoolConfigs {
            try encodeContainer.encode(identityPoolConfigs, forKey: .identityPoolConfigs)
        }
        if let service = self.service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
        if let userPoolConfigs = self.userPoolConfigs {
            try encodeContainer.encode(userPoolConfigs, forKey: .userPoolConfigs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authResourcesDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.AuthResources.self, forKey: .authResources)
        authResources = authResourcesDecoded
        let identityPoolConfigsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig.self, forKey: .identityPoolConfigs)
        identityPoolConfigs = identityPoolConfigsDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let userPoolConfigsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig.self, forKey: .userPoolConfigs)
        userPoolConfigs = userPoolConfigsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Defines the resource configuration when updating an authentication resource in your Amplify project.
    public struct UpdateBackendAuthResourceConfig: Swift.Equatable {
        /// Defines the service name to use when configuring an authentication resource in your Amplify project.
        /// This member is required.
        public var authResources: AmplifyBackendClientTypes.AuthResources?
        /// Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of your auth resource in the Amplify project.
        public var identityPoolConfigs: AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig?
        /// Defines the service name to use when configuring an authentication resource in your Amplify project.
        /// This member is required.
        public var service: AmplifyBackendClientTypes.Service?
        /// Describes the authentication configuration for the Amazon Cognito user pool, provisioned as a part of your auth resource in the Amplify project.
        /// This member is required.
        public var userPoolConfigs: AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig?

        public init (
            authResources: AmplifyBackendClientTypes.AuthResources? = nil,
            identityPoolConfigs: AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig? = nil,
            service: AmplifyBackendClientTypes.Service? = nil,
            userPoolConfigs: AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig? = nil
        )
        {
            self.authResources = authResources
            self.identityPoolConfigs = identityPoolConfigs
            self.service = service
            self.userPoolConfigs = userPoolConfigs
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPassword = "forgotPassword"
        case mfa = "mfa"
        case oAuth = "oAuth"
        case passwordPolicy = "passwordPolicy"
        case verificationMessage = "verificationMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPassword = self.forgotPassword {
            try encodeContainer.encode(forgotPassword, forKey: .forgotPassword)
        }
        if let mfa = self.mfa {
            try encodeContainer.encode(mfa, forKey: .mfa)
        }
        if let oAuth = self.oAuth {
            try encodeContainer.encode(oAuth, forKey: .oAuth)
        }
        if let passwordPolicy = self.passwordPolicy {
            try encodeContainer.encode(passwordPolicy, forKey: .passwordPolicy)
        }
        if let verificationMessage = self.verificationMessage {
            try encodeContainer.encode(verificationMessage, forKey: .verificationMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forgotPasswordDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig.self, forKey: .forgotPassword)
        forgotPassword = forgotPasswordDecoded
        let mfaDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig.self, forKey: .mfa)
        mfa = mfaDecoded
        let oAuthDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig.self, forKey: .oAuth)
        oAuth = oAuthDecoded
        let passwordPolicyDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig.self, forKey: .passwordPolicy)
        passwordPolicy = passwordPolicyDecoded
        let verificationMessageDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthVerificationMessageConfig.self, forKey: .verificationMessage)
        verificationMessage = verificationMessageDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Describes the Amazon Cognito user pool configuration for the authorization resource to be configured for your Amplify project on an update.
    public struct UpdateBackendAuthUserPoolConfig: Swift.Equatable {
        /// (DEPRECATED) Describes the forgot password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var forgotPassword: AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig?
        /// Describes whether to apply multi-factor authentication policies for your Amazon Cognito user pool configured as a part of your Amplify project.
        public var mfa: AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig?
        /// Describes the OAuth policy and rules for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var oAuth: AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig?
        /// Describes the password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var passwordPolicy: AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig?
        /// Describes the email or SMS verification message for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public var verificationMessage: AmplifyBackendClientTypes.UpdateBackendAuthVerificationMessageConfig?

        public init (
            forgotPassword: AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig? = nil,
            mfa: AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig? = nil,
            oAuth: AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig? = nil,
            passwordPolicy: AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig? = nil,
            verificationMessage: AmplifyBackendClientTypes.UpdateBackendAuthVerificationMessageConfig? = nil
        )
        {
            self.forgotPassword = forgotPassword
            self.mfa = mfa
            self.oAuth = oAuth
            self.passwordPolicy = passwordPolicy
            self.verificationMessage = verificationMessage
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthVerificationMessageConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryMethod = "deliveryMethod"
        case emailSettings = "emailSettings"
        case smsSettings = "smsSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryMethod = self.deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let emailSettings = self.emailSettings {
            try encodeContainer.encode(emailSettings, forKey: .emailSettings)
        }
        if let smsSettings = self.smsSettings {
            try encodeContainer.encode(smsSettings, forKey: .smsSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.DeliveryMethod.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let emailSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.EmailSettings.self, forKey: .emailSettings)
        emailSettings = emailSettingsDecoded
        let smsSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SmsSettings.self, forKey: .smsSettings)
        smsSettings = smsSettingsDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// Updates the configuration of the email or SMS message for the auth resource configured for your Amplify project.
    public struct UpdateBackendAuthVerificationMessageConfig: Swift.Equatable {
        /// The type of verification message to send.
        /// This member is required.
        public var deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod?
        /// The settings for the email message.
        public var emailSettings: AmplifyBackendClientTypes.EmailSettings?
        /// The settings for the SMS message.
        public var smsSettings: AmplifyBackendClientTypes.SmsSettings?

        public init (
            deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod? = nil,
            emailSettings: AmplifyBackendClientTypes.EmailSettings? = nil,
            smsSettings: AmplifyBackendClientTypes.SmsSettings? = nil
        )
        {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }
    }

}

extension UpdateBackendConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loginAuthConfig = "loginAuthConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loginAuthConfig = self.loginAuthConfig {
            try encodeContainer.encode(loginAuthConfig, forKey: .loginAuthConfig)
        }
    }
}

extension UpdateBackendConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/config/update"
    }
}

/// The request body for UpdateBackendConfig.
public struct UpdateBackendConfigInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// Describes the Amazon Cognito configuration for Admin UI access.
    public var loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj?

    public init (
        appId: Swift.String? = nil,
        loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj? = nil
    )
    {
        self.appId = appId
        self.loginAuthConfig = loginAuthConfig
    }
}

struct UpdateBackendConfigInputBody: Swift.Equatable {
    let loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj?
}

extension UpdateBackendConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loginAuthConfig = "loginAuthConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loginAuthConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.LoginAuthConfigReqObj.self, forKey: .loginAuthConfig)
        loginAuthConfig = loginAuthConfigDecoded
    }
}

extension UpdateBackendConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateBackendConfigOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateBackendConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendManagerAppId = output.backendManagerAppId
            self.error = output.error
            self.loginAuthConfig = output.loginAuthConfig
        } else {
            self.appId = nil
            self.backendManagerAppId = nil
            self.error = nil
            self.loginAuthConfig = nil
        }
    }
}

public struct UpdateBackendConfigOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The app ID for the backend manager.
    public var backendManagerAppId: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// Describes the Amazon Cognito configurations for the Admin UI auth resource to log in with.
    public var loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj?

    public init (
        appId: Swift.String? = nil,
        backendManagerAppId: Swift.String? = nil,
        error: Swift.String? = nil,
        loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj? = nil
    )
    {
        self.appId = appId
        self.backendManagerAppId = backendManagerAppId
        self.error = error
        self.loginAuthConfig = loginAuthConfig
    }
}

struct UpdateBackendConfigOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendManagerAppId: Swift.String?
    let error: Swift.String?
    let loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj?
}

extension UpdateBackendConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendManagerAppId = "backendManagerAppId"
        case error = "error"
        case loginAuthConfig = "loginAuthConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendManagerAppIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendManagerAppId)
        backendManagerAppId = backendManagerAppIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let loginAuthConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.LoginAuthConfigReqObj.self, forKey: .loginAuthConfig)
        loginAuthConfig = loginAuthConfigDecoded
    }
}

extension UpdateBackendJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "operation"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }
}

extension UpdateBackendJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/job/\(backendEnvironmentName.urlPercentEncoding())/\(jobId.urlPercentEncoding())"
    }
}

/// The request body for GetBackendJob.
public struct UpdateBackendJobInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// Filters the list of response objects to include only those with the specified operation name.
    public var operation: Swift.String?
    /// Filters the list of response objects to include only those with the specified status.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct UpdateBackendJobInputBody: Swift.Equatable {
    let operation: Swift.String?
    let status: Swift.String?
}

extension UpdateBackendJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateBackendJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateBackendJobOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateBackendJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.createTime = output.createTime
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.createTime = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateBackendJobOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The time when the job was created.
    public var createTime: Swift.String?
    /// If the request fails, this error is returned.
    public var error: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The name of the operation.
    public var operation: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?
    /// The time when the job was last updated.
    public var updateTime: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        createTime: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil,
        updateTime: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.createTime = createTime
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
        self.updateTime = updateTime
    }
}

struct UpdateBackendJobOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let createTime: Swift.String?
    let error: Swift.String?
    let jobId: Swift.String?
    let operation: Swift.String?
    let status: Swift.String?
    let updateTime: Swift.String?
}

extension UpdateBackendJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case createTime = "createTime"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
        case updateTime = "updateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension UpdateBackendStorageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = self.resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension UpdateBackendStorageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let backendEnvironmentName = backendEnvironmentName else {
            return nil
        }
        return "/backend/\(appId.urlPercentEncoding())/storage/\(backendEnvironmentName.urlPercentEncoding())"
    }
}

/// The request body for UpdateBackendStorage.
public struct UpdateBackendStorageInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public var backendEnvironmentName: Swift.String?
    /// The resource configuration for updating backend storage.
    /// This member is required.
    public var resourceConfig: AmplifyBackendClientTypes.UpdateBackendStorageResourceConfig?
    /// The name of the storage resource.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.UpdateBackendStorageResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct UpdateBackendStorageInputBody: Swift.Equatable {
    let resourceConfig: AmplifyBackendClientTypes.UpdateBackendStorageResourceConfig?
    let resourceName: Swift.String?
}

extension UpdateBackendStorageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendStorageResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UpdateBackendStorageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendStorageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateBackendStorageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendStorageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateBackendStorageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct UpdateBackendStorageOutputResponse: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?
    /// The name of the backend environment.
    public var backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public var jobId: Swift.String?
    /// The current status of the request.
    public var status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.status = status
    }
}

struct UpdateBackendStorageOutputResponseBody: Swift.Equatable {
    let appId: Swift.String?
    let backendEnvironmentName: Swift.String?
    let jobId: Swift.String?
    let status: Swift.String?
}

extension UpdateBackendStorageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case jobId = "jobId"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendStorageResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "permissions"
        case serviceName = "serviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissions = self.permissions {
            try encodeContainer.encode(permissions, forKey: .permissions)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendStoragePermissions.self, forKey: .permissions)
        permissions = permissionsDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension AmplifyBackendClientTypes {
    /// The resource configuration for updating backend storage.
    public struct UpdateBackendStorageResourceConfig: Swift.Equatable {
        /// The authorization configuration for the storage S3 bucket.
        /// This member is required.
        public var permissions: AmplifyBackendClientTypes.BackendStoragePermissions?
        /// The name of the storage service.
        /// This member is required.
        public var serviceName: AmplifyBackendClientTypes.ServiceName?

        public init (
            permissions: AmplifyBackendClientTypes.BackendStoragePermissions? = nil,
            serviceName: AmplifyBackendClientTypes.ServiceName? = nil
        )
        {
            self.permissions = permissions
            self.serviceName = serviceName
        }
    }

}
