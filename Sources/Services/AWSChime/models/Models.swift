// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have permissions to perform the requested operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let code: ChimeClientTypes.ErrorCode?
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes.Account: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case accountStatus = "AccountStatus"
        case accountType = "AccountType"
        case awsAccountId = "AwsAccountId"
        case createdTimestamp = "CreatedTimestamp"
        case defaultLicense = "DefaultLicense"
        case name = "Name"
        case signinDelegateGroups = "SigninDelegateGroups"
        case supportedLicenses = "SupportedLicenses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let accountStatus = self.accountStatus {
            try encodeContainer.encode(accountStatus.rawValue, forKey: .accountStatus)
        }
        if let accountType = self.accountType {
            try encodeContainer.encode(accountType.rawValue, forKey: .accountType)
        }
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let defaultLicense = self.defaultLicense {
            try encodeContainer.encode(defaultLicense.rawValue, forKey: .defaultLicense)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signinDelegateGroups = signinDelegateGroups {
            var signinDelegateGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signinDelegateGroups)
            for signindelegategroup0 in signinDelegateGroups {
                try signinDelegateGroupsContainer.encode(signindelegategroup0)
            }
        }
        if let supportedLicenses = supportedLicenses {
            var supportedLicensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedLicenses)
            for license0 in supportedLicenses {
                try supportedLicensesContainer.encode(license0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let accountTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AccountType.self, forKey: .accountType)
        accountType = accountTypeDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let defaultLicenseDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.License.self, forKey: .defaultLicense)
        defaultLicense = defaultLicenseDecoded
        let supportedLicensesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.License?].self, forKey: .supportedLicenses)
        var supportedLicensesDecoded0:[ChimeClientTypes.License]? = nil
        if let supportedLicensesContainer = supportedLicensesContainer {
            supportedLicensesDecoded0 = [ChimeClientTypes.License]()
            for enum0 in supportedLicensesContainer {
                if let enum0 = enum0 {
                    supportedLicensesDecoded0?.append(enum0)
                }
            }
        }
        supportedLicenses = supportedLicensesDecoded0
        let accountStatusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AccountStatus.self, forKey: .accountStatus)
        accountStatus = accountStatusDecoded
        let signinDelegateGroupsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SigninDelegateGroup?].self, forKey: .signinDelegateGroups)
        var signinDelegateGroupsDecoded0:[ChimeClientTypes.SigninDelegateGroup]? = nil
        if let signinDelegateGroupsContainer = signinDelegateGroupsContainer {
            signinDelegateGroupsDecoded0 = [ChimeClientTypes.SigninDelegateGroup]()
            for structure0 in signinDelegateGroupsContainer {
                if let structure0 = structure0 {
                    signinDelegateGroupsDecoded0?.append(structure0)
                }
            }
        }
        signinDelegateGroups = signinDelegateGroupsDecoded0
    }
}

extension ChimeClientTypes {
    /// The Amazon Chime account details. An AWS account can have multiple Amazon Chime accounts.
    public struct Account: Swift.Equatable {
        /// The Amazon Chime account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The status of the account.
        public var accountStatus: ChimeClientTypes.AccountStatus?
        /// The Amazon Chime account type. For more information about different account types, see [Managing Your Amazon Chime Accounts](https://docs.aws.amazon.com/chime/latest/ag/manage-chime-account.html) in the Amazon Chime Administration Guide.
        public var accountType: ChimeClientTypes.AccountType?
        /// The AWS account ID.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// The Amazon Chime account creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The default license for the Amazon Chime account.
        public var defaultLicense: ChimeClientTypes.License?
        /// The Amazon Chime account name.
        /// This member is required.
        public var name: Swift.String?
        /// The sign-in delegate groups associated with the account.
        public var signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]?
        /// Supported licenses for the Amazon Chime account.
        public var supportedLicenses: [ChimeClientTypes.License]?

        public init(
            accountId: Swift.String? = nil,
            accountStatus: ChimeClientTypes.AccountStatus? = nil,
            accountType: ChimeClientTypes.AccountType? = nil,
            awsAccountId: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            defaultLicense: ChimeClientTypes.License? = nil,
            name: Swift.String? = nil,
            signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]? = nil,
            supportedLicenses: [ChimeClientTypes.License]? = nil
        )
        {
            self.accountId = accountId
            self.accountStatus = accountStatus
            self.accountType = accountType
            self.awsAccountId = awsAccountId
            self.createdTimestamp = createdTimestamp
            self.defaultLicense = defaultLicense
            self.name = name
            self.signinDelegateGroups = signinDelegateGroups
            self.supportedLicenses = supportedLicenses
        }
    }

}

extension ChimeClientTypes.AccountSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableRemoteControl = "DisableRemoteControl"
        case enableDialOut = "EnableDialOut"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disableRemoteControl = self.disableRemoteControl {
            try encodeContainer.encode(disableRemoteControl, forKey: .disableRemoteControl)
        }
        if let enableDialOut = self.enableDialOut {
            try encodeContainer.encode(enableDialOut, forKey: .enableDialOut)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableRemoteControlDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableRemoteControl)
        disableRemoteControl = disableRemoteControlDecoded
        let enableDialOutDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDialOut)
        enableDialOut = enableDialOutDecoded
    }
}

extension ChimeClientTypes {
    /// Settings related to the Amazon Chime account. This includes settings that start or stop remote control of shared screens, or start or stop the dial-out option in the Amazon Chime web application. For more information about these settings, see [Use the Policies Page](https://docs.aws.amazon.com/chime/latest/ag/policies.html) in the Amazon Chime Administration Guide.
    public struct AccountSettings: Swift.Equatable {
        /// Setting that stops or starts remote control of shared screens during meetings.
        public var disableRemoteControl: Swift.Bool?
        /// Setting that allows meeting participants to choose the Call me at a phone number option. For more information, see [Join a Meeting without the Amazon Chime App](https://docs.aws.amazon.com/chime/latest/ug/chime-join-meeting.html).
        public var enableDialOut: Swift.Bool?

        public init(
            disableRemoteControl: Swift.Bool? = nil,
            enableDialOut: Swift.Bool? = nil
        )
        {
            self.disableRemoteControl = disableRemoteControl
            self.enableDialOut = enableDialOut
        }
    }

}

extension ChimeClientTypes {
    public enum AccountStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountStatus] {
            return [
                .active,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountStatus(rawValue: rawValue) ?? AccountStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum AccountType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enterprisedirectory
        case enterpriselwa
        case enterpriseoidc
        case team
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountType] {
            return [
                .enterprisedirectory,
                .enterpriselwa,
                .enterpriseoidc,
                .team,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enterprisedirectory: return "EnterpriseDirectory"
            case .enterpriselwa: return "EnterpriseLWA"
            case .enterpriseoidc: return "EnterpriseOIDC"
            case .team: return "Team"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountType(rawValue: rawValue) ?? AccountType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.Address: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city
        case country
        case postDirectional
        case postalCode
        case postalCodePlus4
        case preDirectional
        case state
        case streetName
        case streetNumber
        case streetSuffix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let postDirectional = self.postDirectional {
            try encodeContainer.encode(postDirectional, forKey: .postDirectional)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let postalCodePlus4 = self.postalCodePlus4 {
            try encodeContainer.encode(postalCodePlus4, forKey: .postalCodePlus4)
        }
        if let preDirectional = self.preDirectional {
            try encodeContainer.encode(preDirectional, forKey: .preDirectional)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let streetName = self.streetName {
            try encodeContainer.encode(streetName, forKey: .streetName)
        }
        if let streetNumber = self.streetNumber {
            try encodeContainer.encode(streetNumber, forKey: .streetNumber)
        }
        if let streetSuffix = self.streetSuffix {
            try encodeContainer.encode(streetSuffix, forKey: .streetSuffix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetName)
        streetName = streetNameDecoded
        let streetSuffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetSuffix)
        streetSuffix = streetSuffixDecoded
        let postDirectionalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postDirectional)
        postDirectional = postDirectionalDecoded
        let preDirectionalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preDirectional)
        preDirectional = preDirectionalDecoded
        let streetNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetNumber)
        streetNumber = streetNumberDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let postalCodePlus4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCodePlus4)
        postalCodePlus4 = postalCodePlus4Decoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
    }
}

extension ChimeClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postDirectional: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", postalCodePlus4: \"CONTENT_REDACTED\", preDirectional: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetName: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\", streetSuffix: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// A validated address.
    public struct Address: Swift.Equatable {
        /// The city of an address.
        public var city: Swift.String?
        /// The country of an address.
        public var country: Swift.String?
        /// An address suffix location, such as the S. Unit A in Central Park S. Unit A.
        public var postDirectional: Swift.String?
        /// The postal code of an address.
        public var postalCode: Swift.String?
        /// The Zip + 4 or postal code + 4 of an address.
        public var postalCodePlus4: Swift.String?
        /// An address prefix location, such as the N in N. Third St..
        public var preDirectional: Swift.String?
        /// The state of an address.
        public var state: Swift.String?
        /// The address street, such as 8th Avenue.
        public var streetName: Swift.String?
        /// The numeric portion of an address.
        public var streetNumber: Swift.String?
        /// The address suffix, such as the N in 8th Avenue N.
        public var streetSuffix: Swift.String?

        public init(
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            postDirectional: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            postalCodePlus4: Swift.String? = nil,
            preDirectional: Swift.String? = nil,
            state: Swift.String? = nil,
            streetName: Swift.String? = nil,
            streetNumber: Swift.String? = nil,
            streetSuffix: Swift.String? = nil
        )
        {
            self.city = city
            self.country = country
            self.postDirectional = postDirectional
            self.postalCode = postalCode
            self.postalCodePlus4 = postalCodePlus4
            self.preDirectional = preDirectional
            self.state = state
            self.streetName = streetName
            self.streetNumber = streetNumber
            self.streetSuffix = streetSuffix
        }
    }

}

extension ChimeClientTypes.AlexaForBusinessMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alexaForBusinessRoomArn = "AlexaForBusinessRoomArn"
        case isAlexaForBusinessEnabled = "IsAlexaForBusinessEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alexaForBusinessRoomArn = self.alexaForBusinessRoomArn {
            try encodeContainer.encode(alexaForBusinessRoomArn, forKey: .alexaForBusinessRoomArn)
        }
        if let isAlexaForBusinessEnabled = self.isAlexaForBusinessEnabled {
            try encodeContainer.encode(isAlexaForBusinessEnabled, forKey: .isAlexaForBusinessEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isAlexaForBusinessEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAlexaForBusinessEnabled)
        isAlexaForBusinessEnabled = isAlexaForBusinessEnabledDecoded
        let alexaForBusinessRoomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alexaForBusinessRoomArn)
        alexaForBusinessRoomArn = alexaForBusinessRoomArnDecoded
    }
}

extension ChimeClientTypes.AlexaForBusinessMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlexaForBusinessMetadata(isAlexaForBusinessEnabled: \(Swift.String(describing: isAlexaForBusinessEnabled)), alexaForBusinessRoomArn: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The Alexa for Business metadata associated with an Amazon Chime user, used to integrate Alexa for Business with a device.
    public struct AlexaForBusinessMetadata: Swift.Equatable {
        /// The ARN of the room resource.
        public var alexaForBusinessRoomArn: Swift.String?
        /// Starts or stops Alexa for Business.
        public var isAlexaForBusinessEnabled: Swift.Bool?

        public init(
            alexaForBusinessRoomArn: Swift.String? = nil,
            isAlexaForBusinessEnabled: Swift.Bool? = nil
        )
        {
            self.alexaForBusinessRoomArn = alexaForBusinessRoomArn
            self.isAlexaForBusinessEnabled = isAlexaForBusinessEnabled
        }
    }

}

extension ChimeClientTypes.AppInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case createdTimestamp = "CreatedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = self.appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeClientTypes.AppInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstance(appInstanceArn: \(Swift.String(describing: appInstanceArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The details of an AppInstance, an instance of an Amazon Chime SDK messaging application.
    public struct AppInstance: Swift.Equatable {
        /// The ARN of the messaging instance.
        public var appInstanceArn: Swift.String?
        /// The time at which an AppInstance was created. In epoch milliseconds.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time an AppInstance was last updated. In epoch milliseconds.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The metadata of an AppInstance.
        public var metadata: Swift.String?
        /// The name of an AppInstance.
        public var name: Swift.String?

        public init(
            appInstanceArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceArn = appInstanceArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeClientTypes.AppInstanceAdmin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case admin = "Admin"
        case appInstanceArn = "AppInstanceArn"
        case createdTimestamp = "CreatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let admin = self.admin {
            try encodeContainer.encode(admin, forKey: .admin)
        }
        if let appInstanceArn = self.appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .admin)
        admin = adminDecoded
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension ChimeClientTypes {
    /// The details of an AppInstanceAdmin.
    public struct AppInstanceAdmin: Swift.Equatable {
        /// The AppInstanceAdmin data.
        public var admin: ChimeClientTypes.Identity?
        /// The ARN of the AppInstance for which the user is an administrator.
        public var appInstanceArn: Swift.String?
        /// The time at which an administrator was created.
        public var createdTimestamp: ClientRuntime.Date?

        public init(
            admin: ChimeClientTypes.Identity? = nil,
            appInstanceArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.admin = admin
            self.appInstanceArn = appInstanceArn
            self.createdTimestamp = createdTimestamp
        }
    }

}

extension ChimeClientTypes.AppInstanceAdminSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case admin = "Admin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let admin = self.admin {
            try encodeContainer.encode(admin, forKey: .admin)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .admin)
        admin = adminDecoded
    }
}

extension ChimeClientTypes {
    /// Summary of the details of an AppInstanceAdmin.
    public struct AppInstanceAdminSummary: Swift.Equatable {
        /// The details of the AppInstanceAdmin.
        public var admin: ChimeClientTypes.Identity?

        public init(
            admin: ChimeClientTypes.Identity? = nil
        )
        {
            self.admin = admin
        }
    }

}

extension ChimeClientTypes {
    public enum AppInstanceDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case channel
        case channelmessage
        case sdkUnknown(Swift.String)

        public static var allCases: [AppInstanceDataType] {
            return [
                .channel,
                .channelmessage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .channel: return "Channel"
            case .channelmessage: return "ChannelMessage"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppInstanceDataType(rawValue: rawValue) ?? AppInstanceDataType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.AppInstanceRetentionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelRetentionSettings = "ChannelRetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelRetentionSettings = self.channelRetentionSettings {
            try encodeContainer.encode(channelRetentionSettings, forKey: .channelRetentionSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelRetentionSettings.self, forKey: .channelRetentionSettings)
        channelRetentionSettings = channelRetentionSettingsDecoded
    }
}

extension ChimeClientTypes {
    /// The details of the data-retention settings for an AppInstance.
    public struct AppInstanceRetentionSettings: Swift.Equatable {
        /// The length of time in days to retain the messages in a channel.
        public var channelRetentionSettings: ChimeClientTypes.ChannelRetentionSettings?

        public init(
            channelRetentionSettings: ChimeClientTypes.ChannelRetentionSettings? = nil
        )
        {
            self.channelRetentionSettings = channelRetentionSettings
        }
    }

}

extension ChimeClientTypes.AppInstanceStreamingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceDataType = "AppInstanceDataType"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceDataType = self.appInstanceDataType {
            try encodeContainer.encode(appInstanceDataType.rawValue, forKey: .appInstanceDataType)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceDataTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceDataType.self, forKey: .appInstanceDataType)
        appInstanceDataType = appInstanceDataTypeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ChimeClientTypes.AppInstanceStreamingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceStreamingConfiguration(appInstanceDataType: \(Swift.String(describing: appInstanceDataType)), resourceArn: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The details of the streaming configuration of an AppInstance.
    public struct AppInstanceStreamingConfiguration: Swift.Equatable {
        /// The type of data to be streamed.
        /// This member is required.
        public var appInstanceDataType: ChimeClientTypes.AppInstanceDataType?
        /// The resource ARN.
        /// This member is required.
        public var resourceArn: Swift.String?

        public init(
            appInstanceDataType: ChimeClientTypes.AppInstanceDataType? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.appInstanceDataType = appInstanceDataType
            self.resourceArn = resourceArn
        }
    }

}

extension ChimeClientTypes.AppInstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = self.appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeClientTypes.AppInstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceSummary(appInstanceArn: \(Swift.String(describing: appInstanceArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Summary of the data for an AppInstance.
    public struct AppInstanceSummary: Swift.Equatable {
        /// The AppInstance ARN.
        public var appInstanceArn: Swift.String?
        /// The metadata of the AppInstance.
        public var metadata: Swift.String?
        /// The name of the AppInstance.
        public var name: Swift.String?

        public init(
            appInstanceArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceArn = appInstanceArn
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeClientTypes.AppInstanceUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case createdTimestamp = "CreatedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserArn = self.appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeClientTypes.AppInstanceUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUser(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The details of an AppInstanceUser.
    public struct AppInstanceUser: Swift.Equatable {
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The time at which the AppInstanceUser was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which the AppInstanceUser was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The metadata of the AppInstanceUser.
        public var metadata: Swift.String?
        /// The name of the AppInstanceUser.
        public var name: Swift.String?

        public init(
            appInstanceUserArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceUserArn = appInstanceUserArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeClientTypes.AppInstanceUserMembershipSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readMarkerTimestamp = "ReadMarkerTimestamp"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readMarkerTimestamp = self.readMarkerTimestamp {
            try encodeContainer.encodeTimestamp(readMarkerTimestamp, format: .epochSeconds, forKey: .readMarkerTimestamp)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let readMarkerTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .readMarkerTimestamp)
        readMarkerTimestamp = readMarkerTimestampDecoded
    }
}

extension ChimeClientTypes {
    /// Summary of the membership details of an AppInstanceUser.
    public struct AppInstanceUserMembershipSummary: Swift.Equatable {
        /// The time at which a message was last read.
        public var readMarkerTimestamp: ClientRuntime.Date?
        /// The type of ChannelMembership.
        public var type: ChimeClientTypes.ChannelMembershipType?

        public init(
            readMarkerTimestamp: ClientRuntime.Date? = nil,
            type: ChimeClientTypes.ChannelMembershipType? = nil
        )
        {
            self.readMarkerTimestamp = readMarkerTimestamp
            self.type = type
        }
    }

}

extension ChimeClientTypes.AppInstanceUserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserArn = self.appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeClientTypes.AppInstanceUserSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUserSummary(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Summary of the details of an AppInstanceUser.
    public struct AppInstanceUserSummary: Swift.Equatable {
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The metadata of the AppInstanceUser.
        public var metadata: Swift.String?
        /// The name of an AppInstanceUser.
        public var name: Swift.String?

        public init(
            appInstanceUserArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceUserArn = appInstanceUserArn
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeClientTypes.ArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio = "Audio"
        case content = "Content"
        case video = "Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = self.audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let video = self.video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AudioArtifactsConfiguration.self, forKey: .audio)
        audio = audioDecoded
        let videoDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VideoArtifactsConfiguration.self, forKey: .video)
        video = videoDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ContentArtifactsConfiguration.self, forKey: .content)
        content = contentDecoded
    }
}

extension ChimeClientTypes {
    /// The configuration for the artifacts.
    public struct ArtifactsConfiguration: Swift.Equatable {
        /// The configuration for the audio artifacts.
        /// This member is required.
        public var audio: ChimeClientTypes.AudioArtifactsConfiguration?
        /// The configuration for the content artifacts.
        /// This member is required.
        public var content: ChimeClientTypes.ContentArtifactsConfiguration?
        /// The configuration for the video artifacts.
        /// This member is required.
        public var video: ChimeClientTypes.VideoArtifactsConfiguration?

        public init(
            audio: ChimeClientTypes.AudioArtifactsConfiguration? = nil,
            content: ChimeClientTypes.ContentArtifactsConfiguration? = nil,
            video: ChimeClientTypes.VideoArtifactsConfiguration? = nil
        )
        {
            self.audio = audio
            self.content = content
            self.video = video
        }
    }

}

extension ChimeClientTypes {
    public enum ArtifactsState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactsState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactsState(rawValue: rawValue) ?? ArtifactsState.sdkUnknown(rawValue)
        }
    }
}

extension AssociatePhoneNumberWithUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatePhoneNumberWithUserInput(accountId: \(Swift.String(describing: accountId)), userId: \(Swift.String(describing: userId)), e164PhoneNumber: \"CONTENT_REDACTED\")"}
}

extension AssociatePhoneNumberWithUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumber = "E164PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumber = self.e164PhoneNumber {
            try encodeContainer.encode(e164PhoneNumber, forKey: .e164PhoneNumber)
        }
    }
}

extension AssociatePhoneNumberWithUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "associate-phone-number"))
            return items
        }
    }
}

extension AssociatePhoneNumberWithUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct AssociatePhoneNumberWithUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The phone number, in E.164 format.
    /// This member is required.
    public var e164PhoneNumber: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        e164PhoneNumber: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.e164PhoneNumber = e164PhoneNumber
        self.userId = userId
    }
}

struct AssociatePhoneNumberWithUserInputBody: Swift.Equatable {
    let e164PhoneNumber: Swift.String?
}

extension AssociatePhoneNumberWithUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumber = "E164PhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .e164PhoneNumber)
        e164PhoneNumber = e164PhoneNumberDecoded
    }
}

extension AssociatePhoneNumberWithUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociatePhoneNumberWithUserOutput: Swift.Equatable {

    public init() { }
}

enum AssociatePhoneNumberWithUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
        if let forceAssociate = self.forceAssociate {
            try encodeContainer.encode(forceAssociate, forKey: .forceAssociate)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "associate-phone-numbers"))
            return items
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector Group and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.
    public var forceAssociate: Swift.Bool?
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        forceAssociate: Swift.Bool? = nil,
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.forceAssociate = forceAssociate
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorGroupInputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
    let forceAssociate: Swift.Bool?
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let forceAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceAssociate)
        forceAssociate = forceAssociateDecoded
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociatePhoneNumbersWithVoiceConnectorGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupOutput: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorGroupOutputBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

enum AssociatePhoneNumbersWithVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
        if let forceAssociate = self.forceAssociate {
            try encodeContainer.encode(forceAssociate, forKey: .forceAssociate)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "associate-phone-numbers"))
            return items
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.
    public var forceAssociate: Swift.Bool?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        forceAssociate: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.forceAssociate = forceAssociate
        self.voiceConnectorId = voiceConnectorId
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorInputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
    let forceAssociate: Swift.Bool?
}

extension AssociatePhoneNumbersWithVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let forceAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceAssociate)
        forceAssociate = forceAssociateDecoded
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociatePhoneNumbersWithVoiceConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorOutput: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorOutputBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

enum AssociatePhoneNumbersWithVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateSigninDelegateGroupsWithAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signinDelegateGroups = "SigninDelegateGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signinDelegateGroups = signinDelegateGroups {
            var signinDelegateGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signinDelegateGroups)
            for signindelegategroup0 in signinDelegateGroups {
                try signinDelegateGroupsContainer.encode(signindelegategroup0)
            }
        }
    }
}

extension AssociateSigninDelegateGroupsWithAccountInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "associate-signin-delegate-groups"))
            return items
        }
    }
}

extension AssociateSigninDelegateGroupsWithAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())"
    }
}

public struct AssociateSigninDelegateGroupsWithAccountInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The sign-in delegate groups.
    /// This member is required.
    public var signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]?

    public init(
        accountId: Swift.String? = nil,
        signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]? = nil
    )
    {
        self.accountId = accountId
        self.signinDelegateGroups = signinDelegateGroups
    }
}

struct AssociateSigninDelegateGroupsWithAccountInputBody: Swift.Equatable {
    let signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]?
}

extension AssociateSigninDelegateGroupsWithAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signinDelegateGroups = "SigninDelegateGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signinDelegateGroupsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SigninDelegateGroup?].self, forKey: .signinDelegateGroups)
        var signinDelegateGroupsDecoded0:[ChimeClientTypes.SigninDelegateGroup]? = nil
        if let signinDelegateGroupsContainer = signinDelegateGroupsContainer {
            signinDelegateGroupsDecoded0 = [ChimeClientTypes.SigninDelegateGroup]()
            for structure0 in signinDelegateGroupsContainer {
                if let structure0 = structure0 {
                    signinDelegateGroupsDecoded0?.append(structure0)
                }
            }
        }
        signinDelegateGroups = signinDelegateGroupsDecoded0
    }
}

extension AssociateSigninDelegateGroupsWithAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateSigninDelegateGroupsWithAccountOutput: Swift.Equatable {

    public init() { }
}

enum AssociateSigninDelegateGroupsWithAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.Attendee: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendeeId = "AttendeeId"
        case externalUserId = "ExternalUserId"
        case joinToken = "JoinToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendeeId = self.attendeeId {
            try encodeContainer.encode(attendeeId, forKey: .attendeeId)
        }
        if let externalUserId = self.externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
        if let joinToken = self.joinToken {
            try encodeContainer.encode(joinToken, forKey: .joinToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let attendeeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attendeeId)
        attendeeId = attendeeIdDecoded
        let joinTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .joinToken)
        joinToken = joinTokenDecoded
    }
}

extension ChimeClientTypes.Attendee: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attendee(attendeeId: \(Swift.String(describing: attendeeId)), externalUserId: \"CONTENT_REDACTED\", joinToken: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// An Amazon Chime SDK meeting attendee. Includes a unique AttendeeId and JoinToken . The JoinToken allows a client to authenticate and join as the specified attendee. The JoinToken expires when the meeting ends or when [DeleteAttendee] is called. After that, the attendee is unable to join the meeting. We recommend securely transferring each JoinToken from your server application to the client so that no other client has access to the token except for the one authorized to represent the attendee.
    public struct Attendee: Swift.Equatable {
        /// The Amazon Chime SDK attendee ID.
        public var attendeeId: Swift.String?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
        public var externalUserId: Swift.String?
        /// The join token used by the Amazon Chime SDK attendee.
        public var joinToken: Swift.String?

        public init(
            attendeeId: Swift.String? = nil,
            externalUserId: Swift.String? = nil,
            joinToken: Swift.String? = nil
        )
        {
            self.attendeeId = attendeeId
            self.externalUserId = externalUserId
            self.joinToken = joinToken
        }
    }

}

extension ChimeClientTypes.AudioArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case muxType = "MuxType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AudioMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
    }
}

extension ChimeClientTypes {
    /// The audio artifact configuration object.
    public struct AudioArtifactsConfiguration: Swift.Equatable {
        /// The MUX type of the audio artifact configuration object.
        /// This member is required.
        public var muxType: ChimeClientTypes.AudioMuxType?

        public init(
            muxType: ChimeClientTypes.AudioMuxType? = nil
        )
        {
            self.muxType = muxType
        }
    }

}

extension ChimeClientTypes {
    public enum AudioMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case audioonly
        case audiowithactivespeakervideo
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioMuxType] {
            return [
                .audioonly,
                .audiowithactivespeakervideo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .audioonly: return "AudioOnly"
            case .audiowithactivespeakervideo: return "AudioWithActiveSpeakerVideo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudioMuxType(rawValue: rawValue) ?? AudioMuxType.sdkUnknown(rawValue)
        }
    }
}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: ChimeClientTypes.ErrorCode?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes.BatchChannelMemberships: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case invitedBy = "InvitedBy"
        case members = "Members"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let invitedBy = self.invitedBy {
            try encodeContainer.encode(invitedBy, forKey: .invitedBy)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for identity0 in members {
                try membersContainer.encode(identity0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitedByDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .invitedBy)
        invitedBy = invitedByDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let membersContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Identity?].self, forKey: .members)
        var membersDecoded0:[ChimeClientTypes.Identity]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [ChimeClientTypes.Identity]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension ChimeClientTypes {
    /// The membership information, including member ARNs, the channel ARN, and membership types.
    public struct BatchChannelMemberships: Swift.Equatable {
        /// The ARN of the channel to which you're adding users.
        public var channelArn: Swift.String?
        /// The identifier of the member who invited another member.
        public var invitedBy: ChimeClientTypes.Identity?
        /// The users successfully added to the request.
        public var members: [ChimeClientTypes.Identity]?
        /// The membership types set for the channel users.
        public var type: ChimeClientTypes.ChannelMembershipType?

        public init(
            channelArn: Swift.String? = nil,
            invitedBy: ChimeClientTypes.Identity? = nil,
            members: [ChimeClientTypes.Identity]? = nil,
            type: ChimeClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.invitedBy = invitedBy
            self.members = members
            self.type = type
        }
    }

}

extension BatchCreateAttendeeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendees = attendees {
            var attendeesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attendees)
            for createattendeerequestitem0 in attendees {
                try attendeesContainer.encode(createattendeerequestitem0)
            }
        }
    }
}

extension BatchCreateAttendeeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-create"))
            return items
        }
    }
}

extension BatchCreateAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

public struct BatchCreateAttendeeInput: Swift.Equatable {
    /// The request containing the attendees to create.
    /// This member is required.
    public var attendees: [ChimeClientTypes.CreateAttendeeRequestItem]?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendees: [ChimeClientTypes.CreateAttendeeRequestItem]? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendees = attendees
        self.meetingId = meetingId
    }
}

struct BatchCreateAttendeeInputBody: Swift.Equatable {
    let attendees: [ChimeClientTypes.CreateAttendeeRequestItem]?
}

extension BatchCreateAttendeeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.CreateAttendeeRequestItem?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeClientTypes.CreateAttendeeRequestItem]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeClientTypes.CreateAttendeeRequestItem]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
    }
}

extension BatchCreateAttendeeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchCreateAttendeeOutputBody = try responseDecoder.decode(responseBody: data)
            self.attendees = output.attendees
            self.errors = output.errors
        } else {
            self.attendees = nil
            self.errors = nil
        }
    }
}

public struct BatchCreateAttendeeOutput: Swift.Equatable {
    /// The attendee information, including attendees IDs and join tokens.
    public var attendees: [ChimeClientTypes.Attendee]?
    /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
    public var errors: [ChimeClientTypes.CreateAttendeeError]?

    public init(
        attendees: [ChimeClientTypes.Attendee]? = nil,
        errors: [ChimeClientTypes.CreateAttendeeError]? = nil
    )
    {
        self.attendees = attendees
        self.errors = errors
    }
}

struct BatchCreateAttendeeOutputBody: Swift.Equatable {
    let attendees: [ChimeClientTypes.Attendee]?
    let errors: [ChimeClientTypes.CreateAttendeeError]?
}

extension BatchCreateAttendeeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Attendee?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeClientTypes.Attendee]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeClientTypes.Attendee]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.CreateAttendeeError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeClientTypes.CreateAttendeeError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeClientTypes.CreateAttendeeError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchCreateAttendeeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.BatchCreateChannelMembershipError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case memberArn = "MemberArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let memberArn = self.memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeClientTypes {
    /// A list of failed member ARNs, error codes, and error messages.
    public struct BatchCreateChannelMembershipError: Swift.Equatable {
        /// The error code.
        public var errorCode: ChimeClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The ARN of the member that the service couldn't add.
        public var memberArn: Swift.String?

        public init(
            errorCode: ChimeClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            memberArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memberArn = memberArn
        }
    }

}

extension BatchCreateChannelMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArns = "MemberArns"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArns = memberArns {
            var memberArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberArns)
            for chimearn0 in memberArns {
                try memberArnsContainer.encode(chimearn0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension BatchCreateChannelMembershipInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension BatchCreateChannelMembershipInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-create"))
            return items
        }
    }
}

extension BatchCreateChannelMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

public struct BatchCreateChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARNs of the members you want to add to the channel.
    /// This member is required.
    public var memberArns: [Swift.String]?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
    public var type: ChimeClientTypes.ChannelMembershipType?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArns: [Swift.String]? = nil,
        type: ChimeClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArns = memberArns
        self.type = type
    }
}

struct BatchCreateChannelMembershipInputBody: Swift.Equatable {
    let type: ChimeClientTypes.ChannelMembershipType?
    let memberArns: [Swift.String]?
}

extension BatchCreateChannelMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArns = "MemberArns"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let memberArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .memberArns)
        var memberArnsDecoded0:[Swift.String]? = nil
        if let memberArnsContainer = memberArnsContainer {
            memberArnsDecoded0 = [Swift.String]()
            for string0 in memberArnsContainer {
                if let string0 = string0 {
                    memberArnsDecoded0?.append(string0)
                }
            }
        }
        memberArns = memberArnsDecoded0
    }
}

extension BatchCreateChannelMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchCreateChannelMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchChannelMemberships = output.batchChannelMemberships
            self.errors = output.errors
        } else {
            self.batchChannelMemberships = nil
            self.errors = nil
        }
    }
}

public struct BatchCreateChannelMembershipOutput: Swift.Equatable {
    /// The list of channel memberships in the response.
    public var batchChannelMemberships: ChimeClientTypes.BatchChannelMemberships?
    /// If the action fails for one or more of the memberships in the request, a list of the memberships is returned, along with error codes and error messages.
    public var errors: [ChimeClientTypes.BatchCreateChannelMembershipError]?

    public init(
        batchChannelMemberships: ChimeClientTypes.BatchChannelMemberships? = nil,
        errors: [ChimeClientTypes.BatchCreateChannelMembershipError]? = nil
    )
    {
        self.batchChannelMemberships = batchChannelMemberships
        self.errors = errors
    }
}

struct BatchCreateChannelMembershipOutputBody: Swift.Equatable {
    let batchChannelMemberships: ChimeClientTypes.BatchChannelMemberships?
    let errors: [ChimeClientTypes.BatchCreateChannelMembershipError]?
}

extension BatchCreateChannelMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchChannelMemberships = "BatchChannelMemberships"
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchChannelMembershipsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.BatchChannelMemberships.self, forKey: .batchChannelMemberships)
        batchChannelMemberships = batchChannelMembershipsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.BatchCreateChannelMembershipError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeClientTypes.BatchCreateChannelMembershipError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeClientTypes.BatchCreateChannelMembershipError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchCreateChannelMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchCreateRoomMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membershipItemList = "MembershipItemList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let membershipItemList = membershipItemList {
            var membershipItemListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .membershipItemList)
            for membershipitem0 in membershipItemList {
                try membershipItemListContainer.encode(membershipitem0)
            }
        }
    }
}

extension BatchCreateRoomMembershipInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-create"))
            return items
        }
    }
}

extension BatchCreateRoomMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let roomId = roomId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships"
    }
}

public struct BatchCreateRoomMembershipInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The list of membership items.
    /// This member is required.
    public var membershipItemList: [ChimeClientTypes.MembershipItem]?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        membershipItemList: [ChimeClientTypes.MembershipItem]? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.membershipItemList = membershipItemList
        self.roomId = roomId
    }
}

struct BatchCreateRoomMembershipInputBody: Swift.Equatable {
    let membershipItemList: [ChimeClientTypes.MembershipItem]?
}

extension BatchCreateRoomMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membershipItemList = "MembershipItemList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipItemListContainer = try containerValues.decodeIfPresent([ChimeClientTypes.MembershipItem?].self, forKey: .membershipItemList)
        var membershipItemListDecoded0:[ChimeClientTypes.MembershipItem]? = nil
        if let membershipItemListContainer = membershipItemListContainer {
            membershipItemListDecoded0 = [ChimeClientTypes.MembershipItem]()
            for structure0 in membershipItemListContainer {
                if let structure0 = structure0 {
                    membershipItemListDecoded0?.append(structure0)
                }
            }
        }
        membershipItemList = membershipItemListDecoded0
    }
}

extension BatchCreateRoomMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchCreateRoomMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchCreateRoomMembershipOutput: Swift.Equatable {
    /// If the action fails for one or more of the member IDs in the request, a list of the member IDs is returned, along with error codes and error messages.
    public var errors: [ChimeClientTypes.MemberError]?

    public init(
        errors: [ChimeClientTypes.MemberError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchCreateRoomMembershipOutputBody: Swift.Equatable {
    let errors: [ChimeClientTypes.MemberError]?
}

extension BatchCreateRoomMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.MemberError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeClientTypes.MemberError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeClientTypes.MemberError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchCreateRoomMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDeletePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberIds = "PhoneNumberIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumberIds = phoneNumberIds {
            var phoneNumberIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberIds)
            for string0 in phoneNumberIds {
                try phoneNumberIdsContainer.encode(string0)
            }
        }
    }
}

extension BatchDeletePhoneNumberInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-delete"))
            return items
        }
    }
}

extension BatchDeletePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-numbers"
    }
}

public struct BatchDeletePhoneNumberInput: Swift.Equatable {
    /// List of phone number IDs.
    /// This member is required.
    public var phoneNumberIds: [Swift.String]?

    public init(
        phoneNumberIds: [Swift.String]? = nil
    )
    {
        self.phoneNumberIds = phoneNumberIds
    }
}

struct BatchDeletePhoneNumberInputBody: Swift.Equatable {
    let phoneNumberIds: [Swift.String]?
}

extension BatchDeletePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberIds = "PhoneNumberIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberIds)
        var phoneNumberIdsDecoded0:[Swift.String]? = nil
        if let phoneNumberIdsContainer = phoneNumberIdsContainer {
            phoneNumberIdsDecoded0 = [Swift.String]()
            for string0 in phoneNumberIdsContainer {
                if let string0 = string0 {
                    phoneNumberIdsDecoded0?.append(string0)
                }
            }
        }
        phoneNumberIds = phoneNumberIdsDecoded0
    }
}

extension BatchDeletePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeletePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct BatchDeletePhoneNumberOutput: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct BatchDeletePhoneNumberOutputBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?
}

extension BatchDeletePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

enum BatchDeletePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchSuspendUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userIdList = "UserIdList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userIdList = userIdList {
            var userIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIdList)
            for nonemptystring0 in userIdList {
                try userIdListContainer.encode(nonemptystring0)
            }
        }
    }
}

extension BatchSuspendUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "suspend"))
            return items
        }
    }
}

extension BatchSuspendUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users"
    }
}

public struct BatchSuspendUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The request containing the user IDs to suspend.
    /// This member is required.
    public var userIdList: [Swift.String]?

    public init(
        accountId: Swift.String? = nil,
        userIdList: [Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.userIdList = userIdList
    }
}

struct BatchSuspendUserInputBody: Swift.Equatable {
    let userIdList: [Swift.String]?
}

extension BatchSuspendUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userIdList = "UserIdList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIdList)
        var userIdListDecoded0:[Swift.String]? = nil
        if let userIdListContainer = userIdListContainer {
            userIdListDecoded0 = [Swift.String]()
            for string0 in userIdListContainer {
                if let string0 = string0 {
                    userIdListDecoded0?.append(string0)
                }
            }
        }
        userIdList = userIdListDecoded0
    }
}

extension BatchSuspendUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchSuspendUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.userErrors = output.userErrors
        } else {
            self.userErrors = nil
        }
    }
}

public struct BatchSuspendUserOutput: Swift.Equatable {
    /// If the [BatchSuspendUser] action fails for one or more of the user IDs in the request, a list of the user IDs is returned, along with error codes and error messages.
    public var userErrors: [ChimeClientTypes.UserError]?

    public init(
        userErrors: [ChimeClientTypes.UserError]? = nil
    )
    {
        self.userErrors = userErrors
    }
}

struct BatchSuspendUserOutputBody: Swift.Equatable {
    let userErrors: [ChimeClientTypes.UserError]?
}

extension BatchSuspendUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userErrors = "UserErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.UserError?].self, forKey: .userErrors)
        var userErrorsDecoded0:[ChimeClientTypes.UserError]? = nil
        if let userErrorsContainer = userErrorsContainer {
            userErrorsDecoded0 = [ChimeClientTypes.UserError]()
            for structure0 in userErrorsContainer {
                if let structure0 = structure0 {
                    userErrorsDecoded0?.append(structure0)
                }
            }
        }
        userErrors = userErrorsDecoded0
    }
}

enum BatchSuspendUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchUnsuspendUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userIdList = "UserIdList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userIdList = userIdList {
            var userIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIdList)
            for nonemptystring0 in userIdList {
                try userIdListContainer.encode(nonemptystring0)
            }
        }
    }
}

extension BatchUnsuspendUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "unsuspend"))
            return items
        }
    }
}

extension BatchUnsuspendUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users"
    }
}

public struct BatchUnsuspendUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The request containing the user IDs to unsuspend.
    /// This member is required.
    public var userIdList: [Swift.String]?

    public init(
        accountId: Swift.String? = nil,
        userIdList: [Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.userIdList = userIdList
    }
}

struct BatchUnsuspendUserInputBody: Swift.Equatable {
    let userIdList: [Swift.String]?
}

extension BatchUnsuspendUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userIdList = "UserIdList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIdList)
        var userIdListDecoded0:[Swift.String]? = nil
        if let userIdListContainer = userIdListContainer {
            userIdListDecoded0 = [Swift.String]()
            for string0 in userIdListContainer {
                if let string0 = string0 {
                    userIdListDecoded0?.append(string0)
                }
            }
        }
        userIdList = userIdListDecoded0
    }
}

extension BatchUnsuspendUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUnsuspendUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.userErrors = output.userErrors
        } else {
            self.userErrors = nil
        }
    }
}

public struct BatchUnsuspendUserOutput: Swift.Equatable {
    /// If the [BatchUnsuspendUser] action fails for one or more of the user IDs in the request, a list of the user IDs is returned, along with error codes and error messages.
    public var userErrors: [ChimeClientTypes.UserError]?

    public init(
        userErrors: [ChimeClientTypes.UserError]? = nil
    )
    {
        self.userErrors = userErrors
    }
}

struct BatchUnsuspendUserOutputBody: Swift.Equatable {
    let userErrors: [ChimeClientTypes.UserError]?
}

extension BatchUnsuspendUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userErrors = "UserErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.UserError?].self, forKey: .userErrors)
        var userErrorsDecoded0:[ChimeClientTypes.UserError]? = nil
        if let userErrorsContainer = userErrorsContainer {
            userErrorsDecoded0 = [ChimeClientTypes.UserError]()
            for structure0 in userErrorsContainer {
                if let structure0 = structure0 {
                    userErrorsDecoded0?.append(structure0)
                }
            }
        }
        userErrors = userErrorsDecoded0
    }
}

enum BatchUnsuspendUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchUpdatePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatePhoneNumberRequestItems = "UpdatePhoneNumberRequestItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatePhoneNumberRequestItems = updatePhoneNumberRequestItems {
            var updatePhoneNumberRequestItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updatePhoneNumberRequestItems)
            for updatephonenumberrequestitem0 in updatePhoneNumberRequestItems {
                try updatePhoneNumberRequestItemsContainer.encode(updatephonenumberrequestitem0)
            }
        }
    }
}

extension BatchUpdatePhoneNumberInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-update"))
            return items
        }
    }
}

extension BatchUpdatePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-numbers"
    }
}

public struct BatchUpdatePhoneNumberInput: Swift.Equatable {
    /// The request containing the phone number IDs and product types or calling names to update.
    /// This member is required.
    public var updatePhoneNumberRequestItems: [ChimeClientTypes.UpdatePhoneNumberRequestItem]?

    public init(
        updatePhoneNumberRequestItems: [ChimeClientTypes.UpdatePhoneNumberRequestItem]? = nil
    )
    {
        self.updatePhoneNumberRequestItems = updatePhoneNumberRequestItems
    }
}

struct BatchUpdatePhoneNumberInputBody: Swift.Equatable {
    let updatePhoneNumberRequestItems: [ChimeClientTypes.UpdatePhoneNumberRequestItem]?
}

extension BatchUpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatePhoneNumberRequestItems = "UpdatePhoneNumberRequestItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatePhoneNumberRequestItemsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.UpdatePhoneNumberRequestItem?].self, forKey: .updatePhoneNumberRequestItems)
        var updatePhoneNumberRequestItemsDecoded0:[ChimeClientTypes.UpdatePhoneNumberRequestItem]? = nil
        if let updatePhoneNumberRequestItemsContainer = updatePhoneNumberRequestItemsContainer {
            updatePhoneNumberRequestItemsDecoded0 = [ChimeClientTypes.UpdatePhoneNumberRequestItem]()
            for structure0 in updatePhoneNumberRequestItemsContainer {
                if let structure0 = structure0 {
                    updatePhoneNumberRequestItemsDecoded0?.append(structure0)
                }
            }
        }
        updatePhoneNumberRequestItems = updatePhoneNumberRequestItemsDecoded0
    }
}

extension BatchUpdatePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdatePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct BatchUpdatePhoneNumberOutput: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct BatchUpdatePhoneNumberOutputBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?
}

extension BatchUpdatePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

enum BatchUpdatePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchUpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateUserRequestItems = "UpdateUserRequestItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updateUserRequestItems = updateUserRequestItems {
            var updateUserRequestItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateUserRequestItems)
            for updateuserrequestitem0 in updateUserRequestItems {
                try updateUserRequestItemsContainer.encode(updateuserrequestitem0)
            }
        }
    }
}

extension BatchUpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users"
    }
}

public struct BatchUpdateUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The request containing the user IDs and details to update.
    /// This member is required.
    public var updateUserRequestItems: [ChimeClientTypes.UpdateUserRequestItem]?

    public init(
        accountId: Swift.String? = nil,
        updateUserRequestItems: [ChimeClientTypes.UpdateUserRequestItem]? = nil
    )
    {
        self.accountId = accountId
        self.updateUserRequestItems = updateUserRequestItems
    }
}

struct BatchUpdateUserInputBody: Swift.Equatable {
    let updateUserRequestItems: [ChimeClientTypes.UpdateUserRequestItem]?
}

extension BatchUpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateUserRequestItems = "UpdateUserRequestItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateUserRequestItemsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.UpdateUserRequestItem?].self, forKey: .updateUserRequestItems)
        var updateUserRequestItemsDecoded0:[ChimeClientTypes.UpdateUserRequestItem]? = nil
        if let updateUserRequestItemsContainer = updateUserRequestItemsContainer {
            updateUserRequestItemsDecoded0 = [ChimeClientTypes.UpdateUserRequestItem]()
            for structure0 in updateUserRequestItemsContainer {
                if let structure0 = structure0 {
                    updateUserRequestItemsDecoded0?.append(structure0)
                }
            }
        }
        updateUserRequestItems = updateUserRequestItemsDecoded0
    }
}

extension BatchUpdateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.userErrors = output.userErrors
        } else {
            self.userErrors = nil
        }
    }
}

public struct BatchUpdateUserOutput: Swift.Equatable {
    /// If the [BatchUpdateUser] action fails for one or more of the user IDs in the request, a list of the user IDs is returned, along with error codes and error messages.
    public var userErrors: [ChimeClientTypes.UserError]?

    public init(
        userErrors: [ChimeClientTypes.UserError]? = nil
    )
    {
        self.userErrors = userErrors
    }
}

struct BatchUpdateUserOutputBody: Swift.Equatable {
    let userErrors: [ChimeClientTypes.UserError]?
}

extension BatchUpdateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userErrors = "UserErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.UserError?].self, forKey: .userErrors)
        var userErrorsDecoded0:[ChimeClientTypes.UserError]? = nil
        if let userErrorsContainer = userErrorsContainer {
            userErrorsDecoded0 = [ChimeClientTypes.UserError]()
            for structure0 in userErrorsContainer {
                if let structure0 = structure0 {
                    userErrorsDecoded0?.append(structure0)
                }
            }
        }
        userErrors = userErrorsDecoded0
    }
}

enum BatchUpdateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.Bot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botEmail = "BotEmail"
        case botId = "BotId"
        case botType = "BotType"
        case createdTimestamp = "CreatedTimestamp"
        case disabled = "Disabled"
        case displayName = "DisplayName"
        case securityToken = "SecurityToken"
        case updatedTimestamp = "UpdatedTimestamp"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botEmail = self.botEmail {
            try encodeContainer.encode(botEmail, forKey: .botEmail)
        }
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let botType = self.botType {
            try encodeContainer.encode(botType.rawValue, forKey: .botType)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let securityToken = self.securityToken {
            try encodeContainer.encode(securityToken, forKey: .securityToken)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let botTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.BotType.self, forKey: .botType)
        botType = botTypeDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let botEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botEmail)
        botEmail = botEmailDecoded
        let securityTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityToken)
        securityToken = securityTokenDecoded
    }
}

extension ChimeClientTypes.Bot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Bot(botId: \(Swift.String(describing: botId)), botType: \(Swift.String(describing: botType)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), disabled: \(Swift.String(describing: disabled)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), userId: \(Swift.String(describing: userId)), botEmail: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", securityToken: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// A resource that allows Enterprise account administrators to configure an interface to receive events from Amazon Chime.
    public struct Bot: Swift.Equatable {
        /// The bot email address.
        public var botEmail: Swift.String?
        /// The bot ID.
        public var botId: Swift.String?
        /// The bot type.
        public var botType: ChimeClientTypes.BotType?
        /// The bot creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// When true, the bot is stopped from running in your account.
        public var disabled: Swift.Bool?
        /// The bot display name.
        public var displayName: Swift.String?
        /// The security token used to authenticate Amazon Chime with the outgoing event endpoint.
        public var securityToken: Swift.String?
        /// The updated bot timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The unique ID for the bot user.
        public var userId: Swift.String?

        public init(
            botEmail: Swift.String? = nil,
            botId: Swift.String? = nil,
            botType: ChimeClientTypes.BotType? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            disabled: Swift.Bool? = nil,
            displayName: Swift.String? = nil,
            securityToken: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            userId: Swift.String? = nil
        )
        {
            self.botEmail = botEmail
            self.botId = botId
            self.botType = botType
            self.createdTimestamp = createdTimestamp
            self.disabled = disabled
            self.displayName = displayName
            self.securityToken = securityToken
            self.updatedTimestamp = updatedTimestamp
            self.userId = userId
        }
    }

}

extension ChimeClientTypes {
    public enum BotType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chatbot
        case sdkUnknown(Swift.String)

        public static var allCases: [BotType] {
            return [
                .chatbot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chatbot: return "ChatBot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BotType(rawValue: rawValue) ?? BotType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.BusinessCallingSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdrBucket = "CdrBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdrBucket = self.cdrBucket {
            try encodeContainer.encode(cdrBucket, forKey: .cdrBucket)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cdrBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdrBucket)
        cdrBucket = cdrBucketDecoded
    }
}

extension ChimeClientTypes {
    /// The Amazon Chime Business Calling settings for the administrator's AWS account. Includes any Amazon S3 buckets designated for storing call detail records.
    public struct BusinessCallingSettings: Swift.Equatable {
        /// The Amazon S3 bucket designated for call detail record storage.
        public var cdrBucket: Swift.String?

        public init(
            cdrBucket: Swift.String? = nil
        )
        {
            self.cdrBucket = cdrBucket
        }
    }

}

extension ChimeClientTypes {
    public enum CallingNameStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case unassigned
        case updatefailed
        case updateinprogress
        case updatesucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CallingNameStatus] {
            return [
                .unassigned,
                .updatefailed,
                .updateinprogress,
                .updatesucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .unassigned: return "Unassigned"
            case .updatefailed: return "UpdateFailed"
            case .updateinprogress: return "UpdateInProgress"
            case .updatesucceeded: return "UpdateSucceeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CallingNameStatus(rawValue: rawValue) ?? CallingNameStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.CandidateAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city
        case country
        case postalCode
        case postalCodePlus4
        case state
        case streetInfo
        case streetNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let postalCodePlus4 = self.postalCodePlus4 {
            try encodeContainer.encode(postalCodePlus4, forKey: .postalCodePlus4)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let streetInfo = self.streetInfo {
            try encodeContainer.encode(streetInfo, forKey: .streetInfo)
        }
        if let streetNumber = self.streetNumber {
            try encodeContainer.encode(streetNumber, forKey: .streetNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streetInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetInfo)
        streetInfo = streetInfoDecoded
        let streetNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetNumber)
        streetNumber = streetNumberDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let postalCodePlus4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCodePlus4)
        postalCodePlus4 = postalCodePlus4Decoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
    }
}

extension ChimeClientTypes.CandidateAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CandidateAddress(city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", postalCodePlus4: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetInfo: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// A suggested address.
    public struct CandidateAddress: Swift.Equatable {
        /// The city of a candidate address.
        public var city: Swift.String?
        /// The country of a candidate address.
        public var country: Swift.String?
        /// The postal code of a candidate address.
        public var postalCode: Swift.String?
        /// The Zip + 4 or postal code + 4 of a candidate address.
        public var postalCodePlus4: Swift.String?
        /// The state of a candidate address.
        public var state: Swift.String?
        /// The street information of a candidate address
        public var streetInfo: Swift.String?
        /// The numeric portion of a candidate address.
        public var streetNumber: Swift.String?

        public init(
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            postalCodePlus4: Swift.String? = nil,
            state: Swift.String? = nil,
            streetInfo: Swift.String? = nil,
            streetNumber: Swift.String? = nil
        )
        {
            self.city = city
            self.country = country
            self.postalCode = postalCode
            self.postalCodePlus4 = postalCodePlus4
            self.state = state
            self.streetInfo = streetInfo
            self.streetNumber = streetNumber
        }
    }

}

extension ChimeClientTypes {
    public enum Capability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [Capability] {
            return [
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sms: return "SMS"
            case .voice: return "Voice"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Capability(rawValue: rawValue) ?? Capability.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.Channel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case lastMessageTimestamp = "LastMessageTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let lastMessageTimestamp = self.lastMessageTimestamp {
            try encodeContainer.encodeTimestamp(lastMessageTimestamp, format: .epochSeconds, forKey: .lastMessageTimestamp)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = self.privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastMessageTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastMessageTimestamp)
        lastMessageTimestamp = lastMessageTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeClientTypes.Channel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Channel(channelArn: \(Swift.String(describing: channelArn)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastMessageTimestamp: \(Swift.String(describing: lastMessageTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), mode: \(Swift.String(describing: mode)), privacy: \(Swift.String(describing: privacy)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The details of a channel.
    public struct Channel: Swift.Equatable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the channel.
        public var createdBy: ChimeClientTypes.Identity?
        /// The time at which the AppInstanceUser created the channel.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a member sent the last message in the channel.
        public var lastMessageTimestamp: ClientRuntime.Date?
        /// The time at which a channel was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The channel's metadata.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeClientTypes.ChannelMode?
        /// The name of the channel.
        public var name: Swift.String?
        /// The channel's privacy setting.
        public var privacy: ChimeClientTypes.ChannelPrivacy?

        public init(
            channelArn: Swift.String? = nil,
            createdBy: ChimeClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastMessageTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.lastMessageTimestamp = lastMessageTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ChimeClientTypes.ChannelBan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let member = self.member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ChimeClientTypes {
    /// The details of a channel ban.
    public struct ChannelBan: Swift.Equatable {
        /// The ARN of the channel from which a member is being banned.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the ban.
        public var createdBy: ChimeClientTypes.Identity?
        /// The time at which the ban was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The member being banned from the channel.
        public var member: ChimeClientTypes.Identity?

        public init(
            channelArn: Swift.String? = nil,
            createdBy: ChimeClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            member: ChimeClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.member = member
        }
    }

}

extension ChimeClientTypes.ChannelBanSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let member = self.member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension ChimeClientTypes {
    /// Summary of the details of a ChannelBan.
    public struct ChannelBanSummary: Swift.Equatable {
        /// The member being banned from a channel.
        public var member: ChimeClientTypes.Identity?

        public init(
            member: ChimeClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }

}

extension ChimeClientTypes.ChannelMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdTimestamp = "CreatedTimestamp"
        case invitedBy = "InvitedBy"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case member = "Member"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let invitedBy = self.invitedBy {
            try encodeContainer.encode(invitedBy, forKey: .invitedBy)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let member = self.member {
            try encodeContainer.encode(member, forKey: .member)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitedByDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .invitedBy)
        invitedBy = invitedByDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeClientTypes {
    /// The details of a channel member.
    public struct ChannelMembership: Swift.Equatable {
        /// The ARN of the member's channel.
        public var channelArn: Swift.String?
        /// The time at which the channel membership was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The identifier of the member who invited another member.
        public var invitedBy: ChimeClientTypes.Identity?
        /// The time at which a channel membership was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The data of the channel member.
        public var member: ChimeClientTypes.Identity?
        /// The membership type set for the channel member.
        public var type: ChimeClientTypes.ChannelMembershipType?

        public init(
            channelArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            invitedBy: ChimeClientTypes.Identity? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            member: ChimeClientTypes.Identity? = nil,
            type: ChimeClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.createdTimestamp = createdTimestamp
            self.invitedBy = invitedBy
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.member = member
            self.type = type
        }
    }

}

extension ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserMembershipSummary = "AppInstanceUserMembershipSummary"
        case channelSummary = "ChannelSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserMembershipSummary = self.appInstanceUserMembershipSummary {
            try encodeContainer.encode(appInstanceUserMembershipSummary, forKey: .appInstanceUserMembershipSummary)
        }
        if let channelSummary = self.channelSummary {
            try encodeContainer.encode(channelSummary, forKey: .channelSummary)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelSummaryDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelSummary.self, forKey: .channelSummary)
        channelSummary = channelSummaryDecoded
        let appInstanceUserMembershipSummaryDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceUserMembershipSummary.self, forKey: .appInstanceUserMembershipSummary)
        appInstanceUserMembershipSummary = appInstanceUserMembershipSummaryDecoded
    }
}

extension ChimeClientTypes {
    /// Summary of the channel membership details of an AppInstanceUser.
    public struct ChannelMembershipForAppInstanceUserSummary: Swift.Equatable {
        /// Summary of the membership details of an AppInstanceUser.
        public var appInstanceUserMembershipSummary: ChimeClientTypes.AppInstanceUserMembershipSummary?
        /// Summary of the details of a Channel.
        public var channelSummary: ChimeClientTypes.ChannelSummary?

        public init(
            appInstanceUserMembershipSummary: ChimeClientTypes.AppInstanceUserMembershipSummary? = nil,
            channelSummary: ChimeClientTypes.ChannelSummary? = nil
        )
        {
            self.appInstanceUserMembershipSummary = appInstanceUserMembershipSummary
            self.channelSummary = channelSummary
        }
    }

}

extension ChimeClientTypes.ChannelMembershipSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let member = self.member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension ChimeClientTypes {
    /// Summary of the details of a ChannelMembership.
    public struct ChannelMembershipSummary: Swift.Equatable {
        /// A member's summary data.
        public var member: ChimeClientTypes.Identity?

        public init(
            member: ChimeClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }

}

extension ChimeClientTypes {
    public enum ChannelMembershipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case hidden
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMembershipType] {
            return [
                .default,
                .hidden,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .hidden: return "HIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMembershipType(rawValue: rawValue) ?? ChannelMembershipType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.ChannelMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case content = "Content"
        case createdTimestamp = "CreatedTimestamp"
        case lastEditedTimestamp = "LastEditedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case messageId = "MessageId"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case redacted = "Redacted"
        case sender = "Sender"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let lastEditedTimestamp = self.lastEditedTimestamp {
            try encodeContainer.encodeTimestamp(lastEditedTimestamp, format: .epochSeconds, forKey: .lastEditedTimestamp)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let persistence = self.persistence {
            try encodeContainer.encode(persistence.rawValue, forKey: .persistence)
        }
        if redacted != false {
            try encodeContainer.encode(redacted, forKey: .redacted)
        }
        if let sender = self.sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastEditedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastEditedTimestamp)
        lastEditedTimestamp = lastEditedTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let senderDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .sender)
        sender = senderDecoded
        let redactedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .redacted) ?? false
        redacted = redactedDecoded
        let persistenceDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMessagePersistenceType.self, forKey: .persistence)
        persistence = persistenceDecoded
    }
}

extension ChimeClientTypes.ChannelMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessage(channelArn: \(Swift.String(describing: channelArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastEditedTimestamp: \(Swift.String(describing: lastEditedTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), messageId: \(Swift.String(describing: messageId)), persistence: \(Swift.String(describing: persistence)), redacted: \(Swift.String(describing: redacted)), sender: \(Swift.String(describing: sender)), type: \(Swift.String(describing: type)), content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The details of a message in a channel.
    public struct ChannelMessage: Swift.Equatable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The message content.
        public var content: Swift.String?
        /// The time at which the message was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a message was edited.
        public var lastEditedTimestamp: ClientRuntime.Date?
        /// The time at which a message was updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The ID of a message.
        public var messageId: Swift.String?
        /// The message metadata.
        public var metadata: Swift.String?
        /// The persistence setting for a channel message.
        public var persistence: ChimeClientTypes.ChannelMessagePersistenceType?
        /// Hides the content of a message.
        public var redacted: Swift.Bool
        /// The message sender.
        public var sender: ChimeClientTypes.Identity?
        /// The message type.
        public var type: ChimeClientTypes.ChannelMessageType?

        public init(
            channelArn: Swift.String? = nil,
            content: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastEditedTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            persistence: ChimeClientTypes.ChannelMessagePersistenceType? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeClientTypes.Identity? = nil,
            type: ChimeClientTypes.ChannelMessageType? = nil
        )
        {
            self.channelArn = channelArn
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageId = messageId
            self.metadata = metadata
            self.persistence = persistence
            self.redacted = redacted
            self.sender = sender
            self.type = type
        }
    }

}

extension ChimeClientTypes {
    public enum ChannelMessagePersistenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nonPersistent
        case persistent
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessagePersistenceType] {
            return [
                .nonPersistent,
                .persistent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nonPersistent: return "NON_PERSISTENT"
            case .persistent: return "PERSISTENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMessagePersistenceType(rawValue: rawValue) ?? ChannelMessagePersistenceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.ChannelMessageSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case createdTimestamp = "CreatedTimestamp"
        case lastEditedTimestamp = "LastEditedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case messageId = "MessageId"
        case metadata = "Metadata"
        case redacted = "Redacted"
        case sender = "Sender"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let lastEditedTimestamp = self.lastEditedTimestamp {
            try encodeContainer.encodeTimestamp(lastEditedTimestamp, format: .epochSeconds, forKey: .lastEditedTimestamp)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if redacted != false {
            try encodeContainer.encode(redacted, forKey: .redacted)
        }
        if let sender = self.sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let lastEditedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastEditedTimestamp)
        lastEditedTimestamp = lastEditedTimestampDecoded
        let senderDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .sender)
        sender = senderDecoded
        let redactedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .redacted) ?? false
        redacted = redactedDecoded
    }
}

extension ChimeClientTypes.ChannelMessageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessageSummary(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastEditedTimestamp: \(Swift.String(describing: lastEditedTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), messageId: \(Swift.String(describing: messageId)), redacted: \(Swift.String(describing: redacted)), sender: \(Swift.String(describing: sender)), type: \(Swift.String(describing: type)), content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Summary of the messages in a Channel.
    public struct ChannelMessageSummary: Swift.Equatable {
        /// The content of the message.
        public var content: Swift.String?
        /// The time at which the message summary was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a message was last edited.
        public var lastEditedTimestamp: ClientRuntime.Date?
        /// The time at which a message was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The ID of the message.
        public var messageId: Swift.String?
        /// The metadata of the message.
        public var metadata: Swift.String?
        /// Indicates whether a message was redacted.
        public var redacted: Swift.Bool
        /// The message sender.
        public var sender: ChimeClientTypes.Identity?
        /// The type of message.
        public var type: ChimeClientTypes.ChannelMessageType?

        public init(
            content: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastEditedTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeClientTypes.Identity? = nil,
            type: ChimeClientTypes.ChannelMessageType? = nil
        )
        {
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageId = messageId
            self.metadata = metadata
            self.redacted = redacted
            self.sender = sender
            self.type = type
        }
    }

}

extension ChimeClientTypes {
    public enum ChannelMessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case control
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessageType] {
            return [
                .control,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .control: return "CONTROL"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMessageType(rawValue: rawValue) ?? ChannelMessageType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum ChannelMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case restricted
        case unrestricted
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMode] {
            return [
                .restricted,
                .unrestricted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .restricted: return "RESTRICTED"
            case .unrestricted: return "UNRESTRICTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMode(rawValue: rawValue) ?? ChannelMode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelSummary = "ChannelSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelSummary = self.channelSummary {
            try encodeContainer.encode(channelSummary, forKey: .channelSummary)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelSummaryDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelSummary.self, forKey: .channelSummary)
        channelSummary = channelSummaryDecoded
    }
}

extension ChimeClientTypes {
    /// Summary of the details of a moderated channel.
    public struct ChannelModeratedByAppInstanceUserSummary: Swift.Equatable {
        /// Summary of the details of a Channel.
        public var channelSummary: ChimeClientTypes.ChannelSummary?

        public init(
            channelSummary: ChimeClientTypes.ChannelSummary? = nil
        )
        {
            self.channelSummary = channelSummary
        }
    }

}

extension ChimeClientTypes.ChannelModerator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case moderator = "Moderator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let moderator = self.moderator {
            try encodeContainer.encode(moderator, forKey: .moderator)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moderatorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .moderator)
        moderator = moderatorDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ChimeClientTypes {
    /// The details of a channel moderator.
    public struct ChannelModerator: Swift.Equatable {
        /// The ARN of the moderator's channel.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the moderator.
        public var createdBy: ChimeClientTypes.Identity?
        /// The time at which the moderator was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The moderator's data.
        public var moderator: ChimeClientTypes.Identity?

        public init(
            channelArn: Swift.String? = nil,
            createdBy: ChimeClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            moderator: ChimeClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.moderator = moderator
        }
    }

}

extension ChimeClientTypes.ChannelModeratorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case moderator = "Moderator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let moderator = self.moderator {
            try encodeContainer.encode(moderator, forKey: .moderator)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moderatorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .moderator)
        moderator = moderatorDecoded
    }
}

extension ChimeClientTypes {
    /// Summary of the details of a ChannelModerator.
    public struct ChannelModeratorSummary: Swift.Equatable {
        /// The data for a moderator.
        public var moderator: ChimeClientTypes.Identity?

        public init(
            moderator: ChimeClientTypes.Identity? = nil
        )
        {
            self.moderator = moderator
        }
    }

}

extension ChimeClientTypes {
    public enum ChannelPrivacy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelPrivacy] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelPrivacy(rawValue: rawValue) ?? ChannelPrivacy.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.ChannelRetentionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionDays = self.retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension ChimeClientTypes {
    /// The details of the retention settings for a channel.
    public struct ChannelRetentionSettings: Swift.Equatable {
        /// The time in days to retain the messages in a channel.
        public var retentionDays: Swift.Int?

        public init(
            retentionDays: Swift.Int? = nil
        )
        {
            self.retentionDays = retentionDays
        }
    }

}

extension ChimeClientTypes.ChannelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case lastMessageTimestamp = "LastMessageTimestamp"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let lastMessageTimestamp = self.lastMessageTimestamp {
            try encodeContainer.encodeTimestamp(lastMessageTimestamp, format: .epochSeconds, forKey: .lastMessageTimestamp)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = self.privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let lastMessageTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastMessageTimestamp)
        lastMessageTimestamp = lastMessageTimestampDecoded
    }
}

extension ChimeClientTypes.ChannelSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelSummary(channelArn: \(Swift.String(describing: channelArn)), lastMessageTimestamp: \(Swift.String(describing: lastMessageTimestamp)), mode: \(Swift.String(describing: mode)), privacy: \(Swift.String(describing: privacy)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Summary of the details of a Channel.
    public struct ChannelSummary: Swift.Equatable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The time at which the last message in a channel was sent.
        public var lastMessageTimestamp: ClientRuntime.Date?
        /// The metadata of the channel.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeClientTypes.ChannelMode?
        /// The name of the channel.
        public var name: Swift.String?
        /// The privacy setting of the channel.
        public var privacy: ChimeClientTypes.ChannelPrivacy?

        public init(
            channelArn: Swift.String? = nil,
            lastMessageTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.lastMessageTimestamp = lastMessageTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ChimeClientTypes.ChimeSdkMeetingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactsConfiguration = "ArtifactsConfiguration"
        case sourceConfiguration = "SourceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsConfiguration = self.artifactsConfiguration {
            try encodeContainer.encode(artifactsConfiguration, forKey: .artifactsConfiguration)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let artifactsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ArtifactsConfiguration.self, forKey: .artifactsConfiguration)
        artifactsConfiguration = artifactsConfigurationDecoded
    }
}

extension ChimeClientTypes {
    /// The configuration object of the Amazon Chime SDK meeting for a specified media capture pipeline. SourceType must be ChimeSdkMeeting.
    public struct ChimeSdkMeetingConfiguration: Swift.Equatable {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting.
        public var artifactsConfiguration: ChimeClientTypes.ArtifactsConfiguration?
        /// The source configuration for a specified media capture pipeline.
        public var sourceConfiguration: ChimeClientTypes.SourceConfiguration?

        public init(
            artifactsConfiguration: ChimeClientTypes.ArtifactsConfiguration? = nil,
            sourceConfiguration: ChimeClientTypes.SourceConfiguration? = nil
        )
        {
            self.artifactsConfiguration = artifactsConfiguration
            self.sourceConfiguration = sourceConfiguration
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: ChimeClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes.ContentArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case muxType = "MuxType"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ArtifactsState.self, forKey: .state)
        state = stateDecoded
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ContentMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
    }
}

extension ChimeClientTypes {
    /// The content artifact object.
    public struct ContentArtifactsConfiguration: Swift.Equatable {
        /// The MUX type of the artifact configuration.
        public var muxType: ChimeClientTypes.ContentMuxType?
        /// Indicates whether the content artifact is enabled or disabled.
        /// This member is required.
        public var state: ChimeClientTypes.ArtifactsState?

        public init(
            muxType: ChimeClientTypes.ContentMuxType? = nil,
            state: ChimeClientTypes.ArtifactsState? = nil
        )
        {
            self.muxType = muxType
            self.state = state
        }
    }

}

extension ChimeClientTypes {
    public enum ContentMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contentonly
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentMuxType] {
            return [
                .contentonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contentonly: return "ContentOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentMuxType(rawValue: rawValue) ?? ContentMuxType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.ConversationRetentionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionDays = self.retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension ChimeClientTypes {
    /// The retention settings that determine how long to retain conversation messages for an Amazon Chime Enterprise account.
    public struct ConversationRetentionSettings: Swift.Equatable {
        /// The number of days for which to retain conversation messages.
        public var retentionDays: Swift.Int?

        public init(
            retentionDays: Swift.Int? = nil
        )
        {
            self.retentionDays = retentionDays
        }
    }

}

extension CreateAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accounts"
    }
}

public struct CreateAccountInput: Swift.Equatable {
    /// The name of the Amazon Chime account.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateAccountInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.account = output.account
        } else {
            self.account = nil
        }
    }
}

public struct CreateAccountOutput: Swift.Equatable {
    /// The Amazon Chime account details.
    public var account: ChimeClientTypes.Account?

    public init(
        account: ChimeClientTypes.Account? = nil
    )
    {
        self.account = account
    }
}

struct CreateAccountOutputBody: Swift.Equatable {
    let account: ChimeClientTypes.Account?
}

extension CreateAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Account.self, forKey: .account)
        account = accountDecoded
    }
}

enum CreateAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppInstanceAdminInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdminArn = "AppInstanceAdminArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceAdminArn = self.appInstanceAdminArn {
            try encodeContainer.encode(appInstanceAdminArn, forKey: .appInstanceAdminArn)
        }
    }
}

extension CreateAppInstanceAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins"
    }
}

public struct CreateAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the administrator of the current AppInstance.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceAdminInputBody: Swift.Equatable {
    let appInstanceAdminArn: Swift.String?
}

extension CreateAppInstanceAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdminArn = "AppInstanceAdminArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceAdminArn)
        appInstanceAdminArn = appInstanceAdminArnDecoded
    }
}

extension CreateAppInstanceAdminOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppInstanceAdminOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmin = output.appInstanceAdmin
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceAdmin = nil
            self.appInstanceArn = nil
        }
    }
}

public struct CreateAppInstanceAdminOutput: Swift.Equatable {
    /// The name and ARN of the admin for the AppInstance.
    public var appInstanceAdmin: ChimeClientTypes.Identity?
    /// The ARN of the of the admin for the AppInstance.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceAdmin: ChimeClientTypes.Identity? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdmin = appInstanceAdmin
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceAdminOutputBody: Swift.Equatable {
    let appInstanceAdmin: ChimeClientTypes.Identity?
    let appInstanceArn: Swift.String?
}

extension CreateAppInstanceAdminOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmin = "AppInstanceAdmin"
        case appInstanceArn = "AppInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .appInstanceAdmin)
        appInstanceAdmin = appInstanceAdminDecoded
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

enum CreateAppInstanceAdminOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceInput(tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAppInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAppInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instances"
    }
}

public struct CreateAppInstanceInput: Swift.Equatable {
    /// The ClientRequestToken of the AppInstance.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The metadata of the AppInstance. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The name of the AppInstance.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to the AppInstance.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

struct CreateAppInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [ChimeClientTypes.Tag]?
}

extension CreateAppInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceArn = nil
        }
    }
}

public struct CreateAppInstanceOutput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the AppInstance.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceOutputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
}

extension CreateAppInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

enum CreateAppInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceUserInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), tags: \(Swift.String(describing: tags)), appInstanceUserId: \"CONTENT_REDACTED\", clientRequestToken: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAppInstanceUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUserId = "AppInstanceUserId"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = self.appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let appInstanceUserId = self.appInstanceUserId {
            try encodeContainer.encode(appInstanceUserId, forKey: .appInstanceUserId)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instance-users"
    }
}

public struct CreateAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstance request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The user ID of the AppInstance.
    /// This member is required.
    public var appInstanceUserId: Swift.String?
    /// The token assigned to the user requesting an AppInstance.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The request's metadata. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The user's name.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to the AppInstanceUser.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        appInstanceArn: Swift.String? = nil,
        appInstanceUserId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceUserId = appInstanceUserId
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

struct CreateAppInstanceUserInputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let appInstanceUserId: Swift.String?
    let name: Swift.String?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [ChimeClientTypes.Tag]?
}

extension CreateAppInstanceUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUserId = "AppInstanceUserId"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserId)
        appInstanceUserId = appInstanceUserIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppInstanceUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppInstanceUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
        } else {
            self.appInstanceUserArn = nil
        }
    }
}

public struct CreateAppInstanceUserOutput: Swift.Equatable {
    /// The user's ARN.
    public var appInstanceUserArn: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct CreateAppInstanceUserOutputBody: Swift.Equatable {
    let appInstanceUserArn: Swift.String?
}

extension CreateAppInstanceUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
    }
}

enum CreateAppInstanceUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.CreateAttendeeError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case externalUserId = "ExternalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let externalUserId = self.externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeClientTypes.CreateAttendeeError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), externalUserId: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The list of errors returned when errors are encountered during the BatchCreateAttendee and CreateAttendee actions. This includes external user IDs, error codes, and error messages.
    public struct CreateAttendeeError: Swift.Equatable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
        public var externalUserId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            externalUserId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.externalUserId = externalUserId
        }
    }

}

extension CreateAttendeeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeInput(meetingId: \(Swift.String(describing: meetingId)), tags: \(Swift.String(describing: tags)), externalUserId: \"CONTENT_REDACTED\")"}
}

extension CreateAttendeeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalUserId = "ExternalUserId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalUserId = self.externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

public struct CreateAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
    /// This member is required.
    public var externalUserId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        externalUserId: Swift.String? = nil,
        meetingId: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.externalUserId = externalUserId
        self.meetingId = meetingId
        self.tags = tags
    }
}

struct CreateAttendeeInputBody: Swift.Equatable {
    let externalUserId: Swift.String?
    let tags: [ChimeClientTypes.Tag]?
}

extension CreateAttendeeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalUserId = "ExternalUserId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAttendeeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAttendeeOutputBody = try responseDecoder.decode(responseBody: data)
            self.attendee = output.attendee
        } else {
            self.attendee = nil
        }
    }
}

public struct CreateAttendeeOutput: Swift.Equatable {
    /// The attendee information, including attendee ID and join token.
    public var attendee: ChimeClientTypes.Attendee?

    public init(
        attendee: ChimeClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

struct CreateAttendeeOutputBody: Swift.Equatable {
    let attendee: ChimeClientTypes.Attendee?
}

extension CreateAttendeeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendee = "Attendee"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Attendee.self, forKey: .attendee)
        attendee = attendeeDecoded
    }
}

enum CreateAttendeeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.CreateAttendeeRequestItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalUserId = "ExternalUserId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalUserId = self.externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ChimeClientTypes.CreateAttendeeRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeRequestItem(tags: \(Swift.String(describing: tags)), externalUserId: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The Amazon Chime SDK attendee fields to create, used with the BatchCreateAttendee action.
    public struct CreateAttendeeRequestItem: Swift.Equatable {
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
        /// This member is required.
        public var externalUserId: Swift.String?
        /// The tag key-value pairs.
        public var tags: [ChimeClientTypes.Tag]?

        public init(
            externalUserId: Swift.String? = nil,
            tags: [ChimeClientTypes.Tag]? = nil
        )
        {
            self.externalUserId = externalUserId
            self.tags = tags
        }
    }

}

extension CreateBotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBotInput(accountId: \(Swift.String(describing: accountId)), domain: \(Swift.String(describing: domain)), displayName: \"CONTENT_REDACTED\")"}
}

extension CreateBotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case domain = "Domain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }
}

extension CreateBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots"
    }
}

public struct CreateBotInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot display name.
    /// This member is required.
    public var displayName: Swift.String?
    /// The domain of the Amazon Chime Enterprise account.
    public var domain: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domain: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.displayName = displayName
        self.domain = domain
    }
}

struct CreateBotInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let domain: Swift.String?
}

extension CreateBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case domain = "Domain"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension CreateBotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBotOutputBody = try responseDecoder.decode(responseBody: data)
            self.bot = output.bot
        } else {
            self.bot = nil
        }
    }
}

public struct CreateBotOutput: Swift.Equatable {
    /// The bot details.
    public var bot: ChimeClientTypes.Bot?

    public init(
        bot: ChimeClientTypes.Bot? = nil
    )
    {
        self.bot = bot
    }
}

struct CreateBotOutputBody: Swift.Equatable {
    let bot: ChimeClientTypes.Bot?
}

extension CreateBotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bot = "Bot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Bot.self, forKey: .bot)
        bot = botDecoded
    }
}

enum CreateBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateChannelBanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArn = self.memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
    }
}

extension CreateChannelBanInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelBanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans"
    }
}

public struct CreateChannelBanInput: Swift.Equatable {
    /// The ARN of the ban request.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member being banned.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct CreateChannelBanInputBody: Swift.Equatable {
    let memberArn: Swift.String?
}

extension CreateChannelBanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
    }
}

extension CreateChannelBanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChannelBanOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
        } else {
            self.channelArn = nil
            self.member = nil
        }
    }
}

public struct CreateChannelBanOutput: Swift.Equatable {
    /// The ARN of the response to the ban request.
    public var channelArn: Swift.String?
    /// The ChannelArn and BannedIdentity of the member in the ban response.
    public var member: ChimeClientTypes.Identity?

    public init(
        channelArn: Swift.String? = nil,
        member: ChimeClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
    }
}

struct CreateChannelBanOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let member: ChimeClientTypes.Identity?
}

extension CreateChannelBanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

enum CreateChannelBanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), mode: \(Swift.String(describing: mode)), privacy: \(Swift.String(describing: privacy)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = self.appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = self.privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct CreateChannelInput: Swift.Equatable {
    /// The ARN of the channel request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The client token for the request. An Idempotency token.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The metadata of the creation request. Limited to 1KB and UTF-8.
    public var metadata: Swift.String?
    /// The channel mode: UNRESTRICTED or RESTRICTED. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.
    public var mode: ChimeClientTypes.ChannelMode?
    /// The name of the channel.
    /// This member is required.
    public var name: Swift.String?
    /// The channel's privacy level: PUBLIC or PRIVATE. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the AppInstance.
    public var privacy: ChimeClientTypes.ChannelPrivacy?
    /// The tags for the creation request.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        appInstanceArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeClientTypes.ChannelMode? = nil,
        name: Swift.String? = nil,
        privacy: ChimeClientTypes.ChannelPrivacy? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.mode = mode
        self.name = name
        self.privacy = privacy
        self.tags = tags
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let name: Swift.String?
    let mode: ChimeClientTypes.ChannelMode?
    let privacy: ChimeClientTypes.ChannelPrivacy?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [ChimeClientTypes.Tag]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArn = self.memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateChannelMembershipInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

public struct CreateChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member you want to add to the channel.
    /// This member is required.
    public var memberArn: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
    /// This member is required.
    public var type: ChimeClientTypes.ChannelMembershipType?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        type: ChimeClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.type = type
    }
}

struct CreateChannelMembershipInputBody: Swift.Equatable {
    let memberArn: Swift.String?
    let type: ChimeClientTypes.ChannelMembershipType?
}

extension CreateChannelMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateChannelMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChannelMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
        } else {
            self.channelArn = nil
            self.member = nil
        }
    }
}

public struct CreateChannelMembershipOutput: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ARN and metadata of the member being added.
    public var member: ChimeClientTypes.Identity?

    public init(
        channelArn: Swift.String? = nil,
        member: ChimeClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
    }
}

struct CreateChannelMembershipOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let member: ChimeClientTypes.Identity?
}

extension CreateChannelMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

enum CreateChannelMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateChannelModeratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModeratorArn = "ChannelModeratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelModeratorArn = self.channelModeratorArn {
            try encodeContainer.encode(channelModeratorArn, forKey: .channelModeratorArn)
        }
    }
}

extension CreateChannelModeratorInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelModeratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators"
    }
}

public struct CreateChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the moderator.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct CreateChannelModeratorInputBody: Swift.Equatable {
    let channelModeratorArn: Swift.String?
}

extension CreateChannelModeratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModeratorArn = "ChannelModeratorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelModeratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelModeratorArn)
        channelModeratorArn = channelModeratorArnDecoded
    }
}

extension CreateChannelModeratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChannelModeratorOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelModerator = output.channelModerator
        } else {
            self.channelArn = nil
            self.channelModerator = nil
        }
    }
}

public struct CreateChannelModeratorOutput: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ARNs of the channel and the moderator.
    public var channelModerator: ChimeClientTypes.Identity?

    public init(
        channelArn: Swift.String? = nil,
        channelModerator: ChimeClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerator = channelModerator
    }
}

struct CreateChannelModeratorOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let channelModerator: ChimeClientTypes.Identity?
}

extension CreateChannelModeratorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelModerator = "ChannelModerator"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let channelModeratorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Identity.self, forKey: .channelModerator)
        channelModerator = channelModeratorDecoded
    }
}

enum CreateChannelModeratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct CreateChannelOutput: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct CreateChannelOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
}

extension CreateChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

enum CreateChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMediaCapturePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaCapturePipelineInput(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), sinkType: \(Swift.String(describing: sinkType)), sourceType: \(Swift.String(describing: sourceType)), clientRequestToken: \"CONTENT_REDACTED\", sinkArn: \"CONTENT_REDACTED\", sourceArn: \"CONTENT_REDACTED\")"}
}

extension CreateMediaCapturePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case clientRequestToken = "ClientRequestToken"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chimeSdkMeetingConfiguration = self.chimeSdkMeetingConfiguration {
            try encodeContainer.encode(chimeSdkMeetingConfiguration, forKey: .chimeSdkMeetingConfiguration)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sinkArn = self.sinkArn {
            try encodeContainer.encode(sinkArn, forKey: .sinkArn)
        }
        if let sinkType = self.sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }
}

extension CreateMediaCapturePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/media-capture-pipelines"
    }
}

public struct CreateMediaCapturePipelineInput: Swift.Equatable {
    /// The configuration for a specified media capture pipeline. SourceType must be ChimeSdkMeeting.
    public var chimeSdkMeetingConfiguration: ChimeClientTypes.ChimeSdkMeetingConfiguration?
    /// The unique identifier for the client request. The token makes the API request idempotent. Use a different token for different media pipeline requests.
    public var clientRequestToken: Swift.String?
    /// The ARN of the sink type.
    /// This member is required.
    public var sinkArn: Swift.String?
    /// Destination type to which the media artifacts are saved. You must use an S3 bucket.
    /// This member is required.
    public var sinkType: ChimeClientTypes.MediaPipelineSinkType?
    /// ARN of the source from which the media artifacts are captured.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Source type from which the media artifacts will be captured. A Chime SDK Meeting is the only supported source.
    /// This member is required.
    public var sourceType: ChimeClientTypes.MediaPipelineSourceType?

    public init(
        chimeSdkMeetingConfiguration: ChimeClientTypes.ChimeSdkMeetingConfiguration? = nil,
        clientRequestToken: Swift.String? = nil,
        sinkArn: Swift.String? = nil,
        sinkType: ChimeClientTypes.MediaPipelineSinkType? = nil,
        sourceArn: Swift.String? = nil,
        sourceType: ChimeClientTypes.MediaPipelineSourceType? = nil
    )
    {
        self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
        self.clientRequestToken = clientRequestToken
        self.sinkArn = sinkArn
        self.sinkType = sinkType
        self.sourceArn = sourceArn
        self.sourceType = sourceType
    }
}

struct CreateMediaCapturePipelineInputBody: Swift.Equatable {
    let sourceType: ChimeClientTypes.MediaPipelineSourceType?
    let sourceArn: Swift.String?
    let sinkType: ChimeClientTypes.MediaPipelineSinkType?
    let sinkArn: Swift.String?
    let clientRequestToken: Swift.String?
    let chimeSdkMeetingConfiguration: ChimeClientTypes.ChimeSdkMeetingConfiguration?
}

extension CreateMediaCapturePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case clientRequestToken = "ClientRequestToken"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaPipelineSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaPipelineSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let chimeSdkMeetingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChimeSdkMeetingConfiguration.self, forKey: .chimeSdkMeetingConfiguration)
        chimeSdkMeetingConfiguration = chimeSdkMeetingConfigurationDecoded
    }
}

extension CreateMediaCapturePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMediaCapturePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipeline = output.mediaCapturePipeline
        } else {
            self.mediaCapturePipeline = nil
        }
    }
}

public struct CreateMediaCapturePipelineOutput: Swift.Equatable {
    /// A media capture pipeline object, the ID, source type, source ARN, sink type, and sink ARN of a media capture pipeline object.
    public var mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline?

    public init(
        mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

struct CreateMediaCapturePipelineOutputBody: Swift.Equatable {
    let mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline?
}

extension CreateMediaCapturePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipeline = "MediaCapturePipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelineDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaCapturePipeline.self, forKey: .mediaCapturePipeline)
        mediaCapturePipeline = mediaCapturePipelineDecoded
    }
}

enum CreateMediaCapturePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMeetingDialOutInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingDialOutInput(meetingId: \(Swift.String(describing: meetingId)), fromPhoneNumber: \"CONTENT_REDACTED\", joinToken: \"CONTENT_REDACTED\", toPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension CreateMeetingDialOutInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPhoneNumber = "FromPhoneNumber"
        case joinToken = "JoinToken"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPhoneNumber = self.fromPhoneNumber {
            try encodeContainer.encode(fromPhoneNumber, forKey: .fromPhoneNumber)
        }
        if let joinToken = self.joinToken {
            try encodeContainer.encode(joinToken, forKey: .joinToken)
        }
        if let toPhoneNumber = self.toPhoneNumber {
            try encodeContainer.encode(toPhoneNumber, forKey: .toPhoneNumber)
        }
    }
}

extension CreateMeetingDialOutInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/dial-outs"
    }
}

public struct CreateMeetingDialOutInput: Swift.Equatable {
    /// Phone number used as the caller ID when the remote party receives a call.
    /// This member is required.
    public var fromPhoneNumber: Swift.String?
    /// Token used by the Amazon Chime SDK attendee. Call the [CreateAttendee](https://docs.aws.amazon.com/chime/latest/APIReference/API_CreateAttendee.html) action to get a join token.
    /// This member is required.
    public var joinToken: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// Phone number called when inviting someone to a meeting.
    /// This member is required.
    public var toPhoneNumber: Swift.String?

    public init(
        fromPhoneNumber: Swift.String? = nil,
        joinToken: Swift.String? = nil,
        meetingId: Swift.String? = nil,
        toPhoneNumber: Swift.String? = nil
    )
    {
        self.fromPhoneNumber = fromPhoneNumber
        self.joinToken = joinToken
        self.meetingId = meetingId
        self.toPhoneNumber = toPhoneNumber
    }
}

struct CreateMeetingDialOutInputBody: Swift.Equatable {
    let fromPhoneNumber: Swift.String?
    let toPhoneNumber: Swift.String?
    let joinToken: Swift.String?
}

extension CreateMeetingDialOutInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPhoneNumber = "FromPhoneNumber"
        case joinToken = "JoinToken"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromPhoneNumber)
        fromPhoneNumber = fromPhoneNumberDecoded
        let toPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toPhoneNumber)
        toPhoneNumber = toPhoneNumberDecoded
        let joinTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .joinToken)
        joinToken = joinTokenDecoded
    }
}

extension CreateMeetingDialOutOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMeetingDialOutOutputBody = try responseDecoder.decode(responseBody: data)
            self.transactionId = output.transactionId
        } else {
            self.transactionId = nil
        }
    }
}

public struct CreateMeetingDialOutOutput: Swift.Equatable {
    /// Unique ID that tracks API calls.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

struct CreateMeetingDialOutOutputBody: Swift.Equatable {
    let transactionId: Swift.String?
}

extension CreateMeetingDialOutOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

enum CreateMeetingDialOutOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMeetingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingInput(mediaRegion: \(Swift.String(describing: mediaRegion)), notificationsConfiguration: \(Swift.String(describing: notificationsConfiguration)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", externalMeetingId: \"CONTENT_REDACTED\", meetingHostId: \"CONTENT_REDACTED\")"}
}

extension CreateMeetingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let externalMeetingId = self.externalMeetingId {
            try encodeContainer.encode(externalMeetingId, forKey: .externalMeetingId)
        }
        if let mediaRegion = self.mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingHostId = self.meetingHostId {
            try encodeContainer.encode(meetingHostId, forKey: .meetingHostId)
        }
        if let notificationsConfiguration = self.notificationsConfiguration {
            try encodeContainer.encode(notificationsConfiguration, forKey: .notificationsConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMeetingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/meetings"
    }
}

public struct CreateMeetingInput: Swift.Equatable {
    /// The unique identifier for the client request. Use a different token for different meetings.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The external meeting ID.
    public var externalMeetingId: Swift.String?
    /// The Region in which to create the meeting. Default: us-east-1. Available values: af-south-1 , ap-northeast-1 , ap-northeast-2 , ap-south-1 , ap-southeast-1 , ap-southeast-2 , ca-central-1 , eu-central-1 , eu-north-1 , eu-south-1 , eu-west-1 , eu-west-2 , eu-west-3 , sa-east-1 , us-east-1 , us-east-2 , us-west-1 , us-west-2 .
    public var mediaRegion: Swift.String?
    /// Reserved.
    public var meetingHostId: Swift.String?
    /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
    public var notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration?
    /// The tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        externalMeetingId: Swift.String? = nil,
        mediaRegion: Swift.String? = nil,
        meetingHostId: Swift.String? = nil,
        notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.externalMeetingId = externalMeetingId
        self.mediaRegion = mediaRegion
        self.meetingHostId = meetingHostId
        self.notificationsConfiguration = notificationsConfiguration
        self.tags = tags
    }
}

struct CreateMeetingInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let externalMeetingId: Swift.String?
    let meetingHostId: Swift.String?
    let mediaRegion: Swift.String?
    let tags: [ChimeClientTypes.Tag]?
    let notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration?
}

extension CreateMeetingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let externalMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalMeetingId)
        externalMeetingId = externalMeetingIdDecoded
        let meetingHostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingHostId)
        meetingHostId = meetingHostIdDecoded
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let notificationsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MeetingNotificationConfiguration.self, forKey: .notificationsConfiguration)
        notificationsConfiguration = notificationsConfigurationDecoded
    }
}

extension CreateMeetingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMeetingOutputBody = try responseDecoder.decode(responseBody: data)
            self.meeting = output.meeting
        } else {
            self.meeting = nil
        }
    }
}

public struct CreateMeetingOutput: Swift.Equatable {
    /// The meeting information, including the meeting ID and MediaPlacement .
    public var meeting: ChimeClientTypes.Meeting?

    public init(
        meeting: ChimeClientTypes.Meeting? = nil
    )
    {
        self.meeting = meeting
    }
}

struct CreateMeetingOutputBody: Swift.Equatable {
    let meeting: ChimeClientTypes.Meeting?
}

extension CreateMeetingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meeting = "Meeting"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
    }
}

enum CreateMeetingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMeetingWithAttendeesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingWithAttendeesInput(attendees: \(Swift.String(describing: attendees)), mediaRegion: \(Swift.String(describing: mediaRegion)), notificationsConfiguration: \(Swift.String(describing: notificationsConfiguration)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", externalMeetingId: \"CONTENT_REDACTED\", meetingHostId: \"CONTENT_REDACTED\")"}
}

extension CreateMeetingWithAttendeesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendees = attendees {
            var attendeesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attendees)
            for createattendeerequestitem0 in attendees {
                try attendeesContainer.encode(createattendeerequestitem0)
            }
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let externalMeetingId = self.externalMeetingId {
            try encodeContainer.encode(externalMeetingId, forKey: .externalMeetingId)
        }
        if let mediaRegion = self.mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingHostId = self.meetingHostId {
            try encodeContainer.encode(meetingHostId, forKey: .meetingHostId)
        }
        if let notificationsConfiguration = self.notificationsConfiguration {
            try encodeContainer.encode(notificationsConfiguration, forKey: .notificationsConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMeetingWithAttendeesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "create-attendees"))
            return items
        }
    }
}

extension CreateMeetingWithAttendeesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/meetings"
    }
}

public struct CreateMeetingWithAttendeesInput: Swift.Equatable {
    /// The request containing the attendees to create.
    public var attendees: [ChimeClientTypes.CreateAttendeeRequestItem]?
    /// The unique identifier for the client request. Use a different token for different meetings.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The external meeting ID.
    public var externalMeetingId: Swift.String?
    /// The Region in which to create the meeting. Default: us-east-1 . Available values: af-south-1 , ap-northeast-1 , ap-northeast-2 , ap-south-1 , ap-southeast-1 , ap-southeast-2 , ca-central-1 , eu-central-1 , eu-north-1 , eu-south-1 , eu-west-1 , eu-west-2 , eu-west-3 , sa-east-1 , us-east-1 , us-east-2 , us-west-1 , us-west-2 .
    public var mediaRegion: Swift.String?
    /// Reserved.
    public var meetingHostId: Swift.String?
    /// The resource target configurations for receiving Amazon Chime SDK meeting and attendee event notifications. The Amazon Chime SDK supports resource targets located in the US East (N. Virginia) AWS Region (us-east-1).
    public var notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration?
    /// The tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        attendees: [ChimeClientTypes.CreateAttendeeRequestItem]? = nil,
        clientRequestToken: Swift.String? = nil,
        externalMeetingId: Swift.String? = nil,
        mediaRegion: Swift.String? = nil,
        meetingHostId: Swift.String? = nil,
        notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.attendees = attendees
        self.clientRequestToken = clientRequestToken
        self.externalMeetingId = externalMeetingId
        self.mediaRegion = mediaRegion
        self.meetingHostId = meetingHostId
        self.notificationsConfiguration = notificationsConfiguration
        self.tags = tags
    }
}

struct CreateMeetingWithAttendeesInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let externalMeetingId: Swift.String?
    let meetingHostId: Swift.String?
    let mediaRegion: Swift.String?
    let tags: [ChimeClientTypes.Tag]?
    let notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration?
    let attendees: [ChimeClientTypes.CreateAttendeeRequestItem]?
}

extension CreateMeetingWithAttendeesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let externalMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalMeetingId)
        externalMeetingId = externalMeetingIdDecoded
        let meetingHostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingHostId)
        meetingHostId = meetingHostIdDecoded
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let notificationsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MeetingNotificationConfiguration.self, forKey: .notificationsConfiguration)
        notificationsConfiguration = notificationsConfigurationDecoded
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.CreateAttendeeRequestItem?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeClientTypes.CreateAttendeeRequestItem]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeClientTypes.CreateAttendeeRequestItem]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
    }
}

extension CreateMeetingWithAttendeesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMeetingWithAttendeesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attendees = output.attendees
            self.errors = output.errors
            self.meeting = output.meeting
        } else {
            self.attendees = nil
            self.errors = nil
            self.meeting = nil
        }
    }
}

public struct CreateMeetingWithAttendeesOutput: Swift.Equatable {
    /// The attendee information, including attendees IDs and join tokens.
    public var attendees: [ChimeClientTypes.Attendee]?
    /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
    public var errors: [ChimeClientTypes.CreateAttendeeError]?
    /// A meeting created using the Amazon Chime SDK.
    public var meeting: ChimeClientTypes.Meeting?

    public init(
        attendees: [ChimeClientTypes.Attendee]? = nil,
        errors: [ChimeClientTypes.CreateAttendeeError]? = nil,
        meeting: ChimeClientTypes.Meeting? = nil
    )
    {
        self.attendees = attendees
        self.errors = errors
        self.meeting = meeting
    }
}

struct CreateMeetingWithAttendeesOutputBody: Swift.Equatable {
    let meeting: ChimeClientTypes.Meeting?
    let attendees: [ChimeClientTypes.Attendee]?
    let errors: [ChimeClientTypes.CreateAttendeeError]?
}

extension CreateMeetingWithAttendeesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case errors = "Errors"
        case meeting = "Meeting"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Attendee?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeClientTypes.Attendee]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeClientTypes.Attendee]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.CreateAttendeeError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeClientTypes.CreateAttendeeError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeClientTypes.CreateAttendeeError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum CreateMeetingWithAttendeesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePhoneNumberOrderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }
}

extension CreatePhoneNumberOrderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number-orders"
    }
}

public struct CreatePhoneNumberOrderInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The phone number product type.
    /// This member is required.
    public var productType: ChimeClientTypes.PhoneNumberProductType?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        productType: ChimeClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.productType = productType
    }
}

struct CreatePhoneNumberOrderInputBody: Swift.Equatable {
    let productType: ChimeClientTypes.PhoneNumberProductType?
    let e164PhoneNumbers: [Swift.String]?
}

extension CreatePhoneNumberOrderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case productType = "ProductType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

extension CreatePhoneNumberOrderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePhoneNumberOrderOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberOrder = output.phoneNumberOrder
        } else {
            self.phoneNumberOrder = nil
        }
    }
}

public struct CreatePhoneNumberOrderOutput: Swift.Equatable {
    /// The phone number order details.
    public var phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder?

    public init(
        phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder? = nil
    )
    {
        self.phoneNumberOrder = phoneNumberOrder
    }
}

struct CreatePhoneNumberOrderOutputBody: Swift.Equatable {
    let phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder?
}

extension CreatePhoneNumberOrderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberOrder = "PhoneNumberOrder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberOrder.self, forKey: .phoneNumberOrder)
        phoneNumberOrder = phoneNumberOrderDecoded
    }
}

enum CreatePhoneNumberOrderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProxySessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProxySessionInput(capabilities: \(Swift.String(describing: capabilities)), expiryMinutes: \(Swift.String(describing: expiryMinutes)), geoMatchLevel: \(Swift.String(describing: geoMatchLevel)), geoMatchParams: \(Swift.String(describing: geoMatchParams)), numberSelectionBehavior: \(Swift.String(describing: numberSelectionBehavior)), participantPhoneNumbers: \(Swift.String(describing: participantPhoneNumbers)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), name: \"CONTENT_REDACTED\")"}
}

extension CreateProxySessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participantPhoneNumbers = "ParticipantPhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capability0 in capabilities {
                try capabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let expiryMinutes = self.expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
        if let geoMatchLevel = self.geoMatchLevel {
            try encodeContainer.encode(geoMatchLevel.rawValue, forKey: .geoMatchLevel)
        }
        if let geoMatchParams = self.geoMatchParams {
            try encodeContainer.encode(geoMatchParams, forKey: .geoMatchParams)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberSelectionBehavior = self.numberSelectionBehavior {
            try encodeContainer.encode(numberSelectionBehavior.rawValue, forKey: .numberSelectionBehavior)
        }
        if let participantPhoneNumbers = participantPhoneNumbers {
            var participantPhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participantPhoneNumbers)
            for e164phonenumber0 in participantPhoneNumbers {
                try participantPhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
    }
}

extension CreateProxySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions"
    }
}

public struct CreateProxySessionInput: Swift.Equatable {
    /// The proxy session capabilities.
    /// This member is required.
    public var capabilities: [ChimeClientTypes.Capability]?
    /// The number of minutes allowed for the proxy session.
    public var expiryMinutes: Swift.Int?
    /// The preference for matching the country or area code of the proxy phone number with that of the first participant.
    public var geoMatchLevel: ChimeClientTypes.GeoMatchLevel?
    /// The country and area code for the proxy phone number.
    public var geoMatchParams: ChimeClientTypes.GeoMatchParams?
    /// The name of the proxy session.
    public var name: Swift.String?
    /// The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.
    public var numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior?
    /// The participant phone numbers.
    /// This member is required.
    public var participantPhoneNumbers: [Swift.String]?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        capabilities: [ChimeClientTypes.Capability]? = nil,
        expiryMinutes: Swift.Int? = nil,
        geoMatchLevel: ChimeClientTypes.GeoMatchLevel? = nil,
        geoMatchParams: ChimeClientTypes.GeoMatchParams? = nil,
        name: Swift.String? = nil,
        numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior? = nil,
        participantPhoneNumbers: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.expiryMinutes = expiryMinutes
        self.geoMatchLevel = geoMatchLevel
        self.geoMatchParams = geoMatchParams
        self.name = name
        self.numberSelectionBehavior = numberSelectionBehavior
        self.participantPhoneNumbers = participantPhoneNumbers
        self.voiceConnectorId = voiceConnectorId
    }
}

struct CreateProxySessionInputBody: Swift.Equatable {
    let participantPhoneNumbers: [Swift.String]?
    let name: Swift.String?
    let expiryMinutes: Swift.Int?
    let capabilities: [ChimeClientTypes.Capability]?
    let numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior?
    let geoMatchLevel: ChimeClientTypes.GeoMatchLevel?
    let geoMatchParams: ChimeClientTypes.GeoMatchParams?
}

extension CreateProxySessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participantPhoneNumbers = "ParticipantPhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantPhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .participantPhoneNumbers)
        var participantPhoneNumbersDecoded0:[Swift.String]? = nil
        if let participantPhoneNumbersContainer = participantPhoneNumbersContainer {
            participantPhoneNumbersDecoded0 = [Swift.String]()
            for string0 in participantPhoneNumbersContainer {
                if let string0 = string0 {
                    participantPhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        participantPhoneNumbers = participantPhoneNumbersDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeClientTypes.Capability]()
            for enum0 in capabilitiesContainer {
                if let enum0 = enum0 {
                    capabilitiesDecoded0?.append(enum0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let numberSelectionBehaviorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.NumberSelectionBehavior.self, forKey: .numberSelectionBehavior)
        numberSelectionBehavior = numberSelectionBehaviorDecoded
        let geoMatchLevelDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.GeoMatchLevel.self, forKey: .geoMatchLevel)
        geoMatchLevel = geoMatchLevelDecoded
        let geoMatchParamsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.GeoMatchParams.self, forKey: .geoMatchParams)
        geoMatchParams = geoMatchParamsDecoded
    }
}

extension CreateProxySessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProxySessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct CreateProxySessionOutput: Swift.Equatable {
    /// The proxy session details.
    public var proxySession: ChimeClientTypes.ProxySession?

    public init(
        proxySession: ChimeClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct CreateProxySessionOutputBody: Swift.Equatable {
    let proxySession: ChimeClientTypes.ProxySession?
}

extension CreateProxySessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

enum CreateProxySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRoomInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRoomInput(accountId: \(Swift.String(describing: accountId)), clientRequestToken: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms"
    }
}

public struct CreateRoomInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The idempotency token for the request.
    public var clientRequestToken: Swift.String?
    /// The room name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.clientRequestToken = clientRequestToken
        self.name = name
    }
}

struct CreateRoomInputBody: Swift.Equatable {
    let name: Swift.String?
    let clientRequestToken: Swift.String?
}

extension CreateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateRoomMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberId = "MemberId"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }
}

extension CreateRoomMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let roomId = roomId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships"
    }
}

public struct CreateRoomMembershipInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Chime member ID (user ID or bot ID).
    /// This member is required.
    public var memberId: Swift.String?
    /// The role of the member.
    public var role: ChimeClientTypes.RoomMembershipRole?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        role: ChimeClientTypes.RoomMembershipRole? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.memberId = memberId
        self.role = role
        self.roomId = roomId
    }
}

struct CreateRoomMembershipInputBody: Swift.Equatable {
    let memberId: Swift.String?
    let role: ChimeClientTypes.RoomMembershipRole?
}

extension CreateRoomMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberId = "MemberId"
        case role = "Role"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
        let roleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomMembershipRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension CreateRoomMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRoomMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.roomMembership = output.roomMembership
        } else {
            self.roomMembership = nil
        }
    }
}

public struct CreateRoomMembershipOutput: Swift.Equatable {
    /// The room membership details.
    public var roomMembership: ChimeClientTypes.RoomMembership?

    public init(
        roomMembership: ChimeClientTypes.RoomMembership? = nil
    )
    {
        self.roomMembership = roomMembership
    }
}

struct CreateRoomMembershipOutputBody: Swift.Equatable {
    let roomMembership: ChimeClientTypes.RoomMembership?
}

extension CreateRoomMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomMembership = "RoomMembership"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomMembershipDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomMembership.self, forKey: .roomMembership)
        roomMembership = roomMembershipDecoded
    }
}

enum CreateRoomMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRoomOutputBody = try responseDecoder.decode(responseBody: data)
            self.room = output.room
        } else {
            self.room = nil
        }
    }
}

public struct CreateRoomOutput: Swift.Equatable {
    /// The room details.
    public var room: ChimeClientTypes.Room?

    public init(
        room: ChimeClientTypes.Room? = nil
    )
    {
        self.room = room
    }
}

struct CreateRoomOutputBody: Swift.Equatable {
    let room: ChimeClientTypes.Room?
}

extension CreateRoomOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case room = "Room"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Room.self, forKey: .room)
        room = roomDecoded
    }
}

enum CreateRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSipMediaApplicationCallInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSipMediaApplicationCallInput(sipHeaders: \(Swift.String(describing: sipHeaders)), sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)), fromPhoneNumber: \"CONTENT_REDACTED\", toPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension CreateSipMediaApplicationCallInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPhoneNumber = "FromPhoneNumber"
        case sipHeaders = "SipHeaders"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPhoneNumber = self.fromPhoneNumber {
            try encodeContainer.encode(fromPhoneNumber, forKey: .fromPhoneNumber)
        }
        if let sipHeaders = sipHeaders {
            var sipHeadersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sipHeaders)
            for (dictKey0, sipHeadersMap0) in sipHeaders {
                try sipHeadersContainer.encode(sipHeadersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let toPhoneNumber = self.toPhoneNumber {
            try encodeContainer.encode(toPhoneNumber, forKey: .toPhoneNumber)
        }
    }
}

extension CreateSipMediaApplicationCallInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/calls"
    }
}

public struct CreateSipMediaApplicationCallInput: Swift.Equatable {
    /// The phone number that a user calls from. This is a phone number in your Amazon Chime phone number inventory.
    /// This member is required.
    public var fromPhoneNumber: Swift.String?
    /// The SIP headers added to an outbound call leg.
    public var sipHeaders: [Swift.String:Swift.String]?
    /// The ID of the SIP media application.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The phone number that the service should call.
    /// This member is required.
    public var toPhoneNumber: Swift.String?

    public init(
        fromPhoneNumber: Swift.String? = nil,
        sipHeaders: [Swift.String:Swift.String]? = nil,
        sipMediaApplicationId: Swift.String? = nil,
        toPhoneNumber: Swift.String? = nil
    )
    {
        self.fromPhoneNumber = fromPhoneNumber
        self.sipHeaders = sipHeaders
        self.sipMediaApplicationId = sipMediaApplicationId
        self.toPhoneNumber = toPhoneNumber
    }
}

struct CreateSipMediaApplicationCallInputBody: Swift.Equatable {
    let fromPhoneNumber: Swift.String?
    let toPhoneNumber: Swift.String?
    let sipHeaders: [Swift.String:Swift.String]?
}

extension CreateSipMediaApplicationCallInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPhoneNumber = "FromPhoneNumber"
        case sipHeaders = "SipHeaders"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromPhoneNumber)
        fromPhoneNumber = fromPhoneNumberDecoded
        let toPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toPhoneNumber)
        toPhoneNumber = toPhoneNumberDecoded
        let sipHeadersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sipHeaders)
        var sipHeadersDecoded0: [Swift.String:Swift.String]? = nil
        if let sipHeadersContainer = sipHeadersContainer {
            sipHeadersDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in sipHeadersContainer {
                if let sensitivestring0 = sensitivestring0 {
                    sipHeadersDecoded0?[key0] = sensitivestring0
                }
            }
        }
        sipHeaders = sipHeadersDecoded0
    }
}

extension CreateSipMediaApplicationCallOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSipMediaApplicationCallOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationCall = output.sipMediaApplicationCall
        } else {
            self.sipMediaApplicationCall = nil
        }
    }
}

public struct CreateSipMediaApplicationCallOutput: Swift.Equatable {
    /// The actual call.
    public var sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall?

    public init(
        sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall? = nil
    )
    {
        self.sipMediaApplicationCall = sipMediaApplicationCall
    }
}

struct CreateSipMediaApplicationCallOutputBody: Swift.Equatable {
    let sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall?
}

extension CreateSipMediaApplicationCallOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationCall = "SipMediaApplicationCall"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationCallDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplicationCall.self, forKey: .sipMediaApplicationCall)
        sipMediaApplicationCall = sipMediaApplicationCallDecoded
    }
}

enum CreateSipMediaApplicationCallOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSipMediaApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpoint0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateSipMediaApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sip-media-applications"
    }
}

public struct CreateSipMediaApplicationInput: Swift.Equatable {
    /// The AWS Region assigned to the SIP media application.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// List of endpoints (Lambda Amazon Resource Names) specified for the SIP media application. Currently, only one endpoint is supported.
    /// This member is required.
    public var endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
    /// The SIP media application name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]? = nil,
        name: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.endpoints = endpoints
        self.name = name
    }
}

struct CreateSipMediaApplicationInputBody: Swift.Equatable {
    let awsRegion: Swift.String?
    let name: Swift.String?
    let endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
}

extension CreateSipMediaApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension CreateSipMediaApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSipMediaApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct CreateSipMediaApplicationOutput: Swift.Equatable {
    /// The SIP media application details.
    public var sipMediaApplication: ChimeClientTypes.SipMediaApplication?

    public init(
        sipMediaApplication: ChimeClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct CreateSipMediaApplicationOutputBody: Swift.Equatable {
    let sipMediaApplication: ChimeClientTypes.SipMediaApplication?
}

extension CreateSipMediaApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

enum CreateSipMediaApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSipRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplication0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplication0)
            }
        }
        if let triggerType = self.triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
        if let triggerValue = self.triggerValue {
            try encodeContainer.encode(triggerValue, forKey: .triggerValue)
        }
    }
}

extension CreateSipRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sip-rules"
    }
}

public struct CreateSipRuleInput: Swift.Equatable {
    /// Enables or disables a rule. You must disable rules before you can delete them.
    public var disabled: Swift.Bool?
    /// The name of the SIP rule.
    /// This member is required.
    public var name: Swift.String?
    /// List of SIP media applications with priority and AWS Region. Only one SIP application per AWS Region can be used.
    /// This member is required.
    public var targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?
    /// The type of trigger assigned to the SIP rule in TriggerValue, currently RequestUriHostname or ToPhoneNumber.
    /// This member is required.
    public var triggerType: ChimeClientTypes.SipRuleTriggerType?
    /// If TriggerType is RequestUriHostname, the value can be the outbound host name of an Amazon Chime Voice Connector. If TriggerType is ToPhoneNumber, the value can be a customer-owned phone number in the E164 format. The SipMediaApplication specified in the SipRule is triggered if the request URI in an incoming SIP request matches the RequestUriHostname, or if the To header in the incoming SIP request matches the ToPhoneNumber value.
    /// This member is required.
    public var triggerValue: Swift.String?

    public init(
        disabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        targetApplications: [ChimeClientTypes.SipRuleTargetApplication]? = nil,
        triggerType: ChimeClientTypes.SipRuleTriggerType? = nil,
        triggerValue: Swift.String? = nil
    )
    {
        self.disabled = disabled
        self.name = name
        self.targetApplications = targetApplications
        self.triggerType = triggerType
        self.triggerValue = triggerValue
    }
}

struct CreateSipRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let triggerType: ChimeClientTypes.SipRuleTriggerType?
    let triggerValue: Swift.String?
    let disabled: Swift.Bool?
    let targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?
}

extension CreateSipRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipRuleTriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerValue)
        triggerValue = triggerValueDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
    }
}

extension CreateSipRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSipRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct CreateSipRuleOutput: Swift.Equatable {
    /// Returns the SIP rule information, including the rule ID, triggers, and target applications.
    public var sipRule: ChimeClientTypes.SipRule?

    public init(
        sipRule: ChimeClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct CreateSipRuleOutputBody: Swift.Equatable {
    let sipRule: ChimeClientTypes.SipRule?
}

extension CreateSipRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

enum CreateSipRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(accountId: \(Swift.String(describing: accountId)), userType: \(Swift.String(describing: userType)), username: \(Swift.String(describing: username)), email: \"CONTENT_REDACTED\")"}
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case userType = "UserType"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension CreateUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "create"))
            return items
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user's email address.
    public var email: Swift.String?
    /// The user type.
    public var userType: ChimeClientTypes.UserType?
    /// The user name.
    public var username: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        email: Swift.String? = nil,
        userType: ChimeClientTypes.UserType? = nil,
        username: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.email = email
        self.userType = userType
        self.username = username
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let username: Swift.String?
    let email: Swift.String?
    let userType: ChimeClientTypes.UserType?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case userType = "UserType"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct CreateUserOutput: Swift.Equatable {
    /// The user on the Amazon Chime account.
    public var user: ChimeClientTypes.User?

    public init(
        user: ChimeClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct CreateUserOutputBody: Swift.Equatable {
    let user: ChimeClientTypes.User?
}

extension CreateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritem0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritem0)
            }
        }
    }
}

extension CreateVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connector-groups"
    }
}

public struct CreateVoiceConnectorGroupInput: Swift.Equatable {
    /// The name of the Amazon Chime Voice Connector group.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Chime Voice Connectors to route inbound calls to.
    public var voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?

    public init(
        name: Swift.String? = nil,
        voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]? = nil
    )
    {
        self.name = name
        self.voiceConnectorItems = voiceConnectorItems
    }
}

struct CreateVoiceConnectorGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?
}

extension CreateVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
    }
}

extension CreateVoiceConnectorGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVoiceConnectorGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct CreateVoiceConnectorGroupOutput: Swift.Equatable {
    /// The Amazon Chime Voice Connector group details.
    public var voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?

    public init(
        voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct CreateVoiceConnectorGroupOutputBody: Swift.Equatable {
    let voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?
}

extension CreateVoiceConnectorGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

enum CreateVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion.rawValue, forKey: .awsRegion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requireEncryption = self.requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
    }
}

extension CreateVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connectors"
    }
}

public struct CreateVoiceConnectorInput: Swift.Equatable {
    /// The AWS Region in which the Amazon Chime Voice Connector is created. Default value: us-east-1 .
    public var awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion?
    /// The name of the Amazon Chime Voice Connector.
    /// This member is required.
    public var name: Swift.String?
    /// When enabled, requires encryption for the Amazon Chime Voice Connector.
    /// This member is required.
    public var requireEncryption: Swift.Bool?

    public init(
        awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion? = nil,
        name: Swift.String? = nil,
        requireEncryption: Swift.Bool? = nil
    )
    {
        self.awsRegion = awsRegion
        self.name = name
        self.requireEncryption = requireEncryption
    }
}

struct CreateVoiceConnectorInputBody: Swift.Equatable {
    let name: Swift.String?
    let awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion?
    let requireEncryption: Swift.Bool?
}

extension CreateVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorAwsRegion.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
    }
}

extension CreateVoiceConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVoiceConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct CreateVoiceConnectorOutput: Swift.Equatable {
    /// The Amazon Chime Voice Connector details.
    public var voiceConnector: ChimeClientTypes.VoiceConnector?

    public init(
        voiceConnector: ChimeClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct CreateVoiceConnectorOutputBody: Swift.Equatable {
    let voiceConnector: ChimeClientTypes.VoiceConnector?
}

extension CreateVoiceConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

enum CreateVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.Credential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension ChimeClientTypes.Credential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Credential(password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The SIP credentials used to authenticate requests to your Amazon Chime Voice Connector.
    public struct Credential: Swift.Equatable {
        /// The RFC2617 compliant password associated with the SIP credentials, in US-ASCII format.
        public var password: Swift.String?
        /// The RFC2617 compliant user name associated with the SIP credentials, in US-ASCII format.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension ChimeClientTypes.DNISEmergencyCallingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingCountry = "CallingCountry"
        case emergencyPhoneNumber = "EmergencyPhoneNumber"
        case testPhoneNumber = "TestPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingCountry = self.callingCountry {
            try encodeContainer.encode(callingCountry, forKey: .callingCountry)
        }
        if let emergencyPhoneNumber = self.emergencyPhoneNumber {
            try encodeContainer.encode(emergencyPhoneNumber, forKey: .emergencyPhoneNumber)
        }
        if let testPhoneNumber = self.testPhoneNumber {
            try encodeContainer.encode(testPhoneNumber, forKey: .testPhoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emergencyPhoneNumber)
        emergencyPhoneNumber = emergencyPhoneNumberDecoded
        let testPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testPhoneNumber)
        testPhoneNumber = testPhoneNumberDecoded
        let callingCountryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingCountry)
        callingCountry = callingCountryDecoded
    }
}

extension ChimeClientTypes.DNISEmergencyCallingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DNISEmergencyCallingConfiguration(callingCountry: \(Swift.String(describing: callingCountry)), emergencyPhoneNumber: \"CONTENT_REDACTED\", testPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The Dialed Number Identification Service (DNIS) emergency calling configuration details associated with an Amazon Chime Voice Connector's emergency calling configuration.
    public struct DNISEmergencyCallingConfiguration: Swift.Equatable {
        /// The country from which emergency calls are allowed, in ISO 3166-1 alpha-2 format.
        /// This member is required.
        public var callingCountry: Swift.String?
        /// The DNIS phone number to route emergency calls to, in E.164 format.
        /// This member is required.
        public var emergencyPhoneNumber: Swift.String?
        /// The DNIS phone number to route test emergency calls to, in E.164 format.
        public var testPhoneNumber: Swift.String?

        public init(
            callingCountry: Swift.String? = nil,
            emergencyPhoneNumber: Swift.String? = nil,
            testPhoneNumber: Swift.String? = nil
        )
        {
            self.callingCountry = callingCountry
            self.emergencyPhoneNumber = emergencyPhoneNumber
            self.testPhoneNumber = testPhoneNumber
        }
    }

}

extension DeleteAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())"
    }
}

public struct DeleteAccountInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct DeleteAccountInputBody: Swift.Equatable {
}

extension DeleteAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccountOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppInstanceAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        guard let appInstanceAdminArn = appInstanceAdminArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins/\(appInstanceAdminArn.urlPercentEncoding())"
    }
}

public struct DeleteAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the AppInstance's administrator.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct DeleteAppInstanceAdminInputBody: Swift.Equatable {
}

extension DeleteAppInstanceAdminInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceAdminOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppInstanceAdminOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppInstanceAdminOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())"
    }
}

public struct DeleteAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct DeleteAppInstanceInputBody: Swift.Equatable {
}

extension DeleteAppInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppInstanceStreamingConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/streaming-configurations"
    }
}

public struct DeleteAppInstanceStreamingConfigurationsInput: Swift.Equatable {
    /// The ARN of the streaming configurations being deleted.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct DeleteAppInstanceStreamingConfigurationsInputBody: Swift.Equatable {
}

extension DeleteAppInstanceStreamingConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceStreamingConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppInstanceStreamingConfigurationsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppInstanceStreamingConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
    }
}

public struct DeleteAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user request being deleted.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct DeleteAppInstanceUserInputBody: Swift.Equatable {
}

extension DeleteAppInstanceUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppInstanceUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppInstanceUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        guard let attendeeId = attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())"
    }
}

public struct DeleteAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

struct DeleteAttendeeInputBody: Swift.Equatable {
}

extension DeleteAttendeeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAttendeeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAttendeeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAttendeeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteChannelBanInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelBanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelBanInput: Swift.Equatable {
    /// The ARN of the channel from which the AppInstanceUser was banned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the AppInstanceUser that you want to reinstate.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DeleteChannelBanInputBody: Swift.Equatable {
}

extension DeleteChannelBanInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelBanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChannelBanOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChannelBanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelInput: Swift.Equatable {
    /// The ARN of the channel being deleted.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
}

extension DeleteChannelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMembershipInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel from which you want to remove the user.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member that you're removing from the channel.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DeleteChannelMembershipInputBody: Swift.Equatable {
}

extension DeleteChannelMembershipInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChannelMembershipOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChannelMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct DeleteChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ID of the message being deleted.
    /// This member is required.
    public var messageId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

struct DeleteChannelMessageInputBody: Swift.Equatable {
}

extension DeleteChannelMessageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChannelMessageOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChannelMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteChannelModeratorInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelModeratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let channelModeratorArn = channelModeratorArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the moderator being deleted.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct DeleteChannelModeratorInputBody: Swift.Equatable {
}

extension DeleteChannelModeratorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelModeratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChannelModeratorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChannelModeratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChannelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let botId = botId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())/events-configuration"
    }
}

public struct DeleteEventsConfigurationInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
    }
}

struct DeleteEventsConfigurationInputBody: Swift.Equatable {
}

extension DeleteEventsConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEventsConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEventsConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEventsConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMediaCapturePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mediaPipelineId = mediaPipelineId else {
            return nil
        }
        return "/media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

public struct DeleteMediaCapturePipelineInput: Swift.Equatable {
    /// The ID of the media capture pipeline being deleted.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init(
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct DeleteMediaCapturePipelineInputBody: Swift.Equatable {
}

extension DeleteMediaCapturePipelineInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMediaCapturePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMediaCapturePipelineOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMediaCapturePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMeetingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())"
    }
}

public struct DeleteMeetingInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct DeleteMeetingInputBody: Swift.Equatable {
}

extension DeleteMeetingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMeetingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMeetingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMeetingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct DeletePhoneNumberInput: Swift.Equatable {
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct DeletePhoneNumberInputBody: Swift.Equatable {
}

extension DeletePhoneNumberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePhoneNumberOutput: Swift.Equatable {

    public init() { }
}

enum DeletePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProxySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

public struct DeleteProxySessionInput: Swift.Equatable {
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteProxySessionInputBody: Swift.Equatable {
}

extension DeleteProxySessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProxySessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProxySessionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProxySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let roomId = roomId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())"
    }
}

public struct DeleteRoomInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The chat room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.roomId = roomId
    }
}

struct DeleteRoomInputBody: Swift.Equatable {
}

extension DeleteRoomInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRoomMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let roomId = roomId else {
            return nil
        }
        guard let memberId = memberId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships/\(memberId.urlPercentEncoding())"
    }
}

public struct DeleteRoomMembershipInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The member ID (user ID or bot ID).
    /// This member is required.
    public var memberId: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.memberId = memberId
        self.roomId = roomId
    }
}

struct DeleteRoomMembershipInputBody: Swift.Equatable {
}

extension DeleteRoomMembershipInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRoomMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRoomMembershipOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRoomMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRoomOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSipMediaApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

public struct DeleteSipMediaApplicationInput: Swift.Equatable {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct DeleteSipMediaApplicationInputBody: Swift.Equatable {
}

extension DeleteSipMediaApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSipMediaApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSipMediaApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSipMediaApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSipRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipRuleId = sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

public struct DeleteSipRuleInput: Swift.Equatable {
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?

    public init(
        sipRuleId: Swift.String? = nil
    )
    {
        self.sipRuleId = sipRuleId
    }
}

struct DeleteSipRuleInputBody: Swift.Equatable {
}

extension DeleteSipRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSipRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSipRuleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSipRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct DeleteVoiceConnectorGroupInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct DeleteVoiceConnectorGroupInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct DeleteVoiceConnectorInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorOriginationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

public struct DeleteVoiceConnectorOriginationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorOriginationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorOriginationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorOriginationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorOriginationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorProxyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

public struct DeleteVoiceConnectorProxyInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorProxyInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorProxyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorProxyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorProxyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorStreamingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

public struct DeleteVoiceConnectorStreamingConfigurationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorStreamingConfigurationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorStreamingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorStreamingConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let usernames = usernames {
            var usernamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usernames)
            for sensitivestring0 in usernames {
                try usernamesContainer.encode(sensitivestring0)
            }
        }
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "delete"))
            return items
        }
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

public struct DeleteVoiceConnectorTerminationCredentialsInput: Swift.Equatable {
    /// The RFC2617 compliant username associated with the SIP credentials, in US-ASCII format.
    /// This member is required.
    public var usernames: [Swift.String]?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        usernames: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.usernames = usernames
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorTerminationCredentialsInputBody: Swift.Equatable {
    let usernames: [Swift.String]?
}

extension DeleteVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usernames)
        var usernamesDecoded0:[Swift.String]? = nil
        if let usernamesContainer = usernamesContainer {
            usernamesDecoded0 = [Swift.String]()
            for string0 in usernamesContainer {
                if let string0 = string0 {
                    usernamesDecoded0?.append(string0)
                }
            }
        }
        usernames = usernamesDecoded0
    }
}

extension DeleteVoiceConnectorTerminationCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorTerminationCredentialsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorTerminationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

public struct DeleteVoiceConnectorTerminationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorTerminationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorTerminationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorTerminationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorTerminationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppInstanceAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        guard let appInstanceAdminArn = appInstanceAdminArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins/\(appInstanceAdminArn.urlPercentEncoding())"
    }
}

public struct DescribeAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the AppInstanceAdmin.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct DescribeAppInstanceAdminInputBody: Swift.Equatable {
}

extension DescribeAppInstanceAdminInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceAdminOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppInstanceAdminOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmin = output.appInstanceAdmin
        } else {
            self.appInstanceAdmin = nil
        }
    }
}

public struct DescribeAppInstanceAdminOutput: Swift.Equatable {
    /// The ARN and name of the AppInstanceUser, the ARN of the AppInstance, and the created and last-updated timestamps. All timestamps use epoch milliseconds.
    public var appInstanceAdmin: ChimeClientTypes.AppInstanceAdmin?

    public init(
        appInstanceAdmin: ChimeClientTypes.AppInstanceAdmin? = nil
    )
    {
        self.appInstanceAdmin = appInstanceAdmin
    }
}

struct DescribeAppInstanceAdminOutputBody: Swift.Equatable {
    let appInstanceAdmin: ChimeClientTypes.AppInstanceAdmin?
}

extension DescribeAppInstanceAdminOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmin = "AppInstanceAdmin"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceAdmin.self, forKey: .appInstanceAdmin)
        appInstanceAdmin = appInstanceAdminDecoded
    }
}

enum DescribeAppInstanceAdminOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())"
    }
}

public struct DescribeAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct DescribeAppInstanceInputBody: Swift.Equatable {
}

extension DescribeAppInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstance = output.appInstance
        } else {
            self.appInstance = nil
        }
    }
}

public struct DescribeAppInstanceOutput: Swift.Equatable {
    /// The ARN, metadata, created and last-updated timestamps, and the name of the AppInstance. All timestamps use epoch milliseconds.
    public var appInstance: ChimeClientTypes.AppInstance?

    public init(
        appInstance: ChimeClientTypes.AppInstance? = nil
    )
    {
        self.appInstance = appInstance
    }
}

struct DescribeAppInstanceOutputBody: Swift.Equatable {
    let appInstance: ChimeClientTypes.AppInstance?
}

extension DescribeAppInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstance = "AppInstance"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstance.self, forKey: .appInstance)
        appInstance = appInstanceDecoded
    }
}

enum DescribeAppInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
    }
}

public struct DescribeAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct DescribeAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeAppInstanceUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppInstanceUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUser = output.appInstanceUser
        } else {
            self.appInstanceUser = nil
        }
    }
}

public struct DescribeAppInstanceUserOutput: Swift.Equatable {
    /// The name of the AppInstanceUser.
    public var appInstanceUser: ChimeClientTypes.AppInstanceUser?

    public init(
        appInstanceUser: ChimeClientTypes.AppInstanceUser? = nil
    )
    {
        self.appInstanceUser = appInstanceUser
    }
}

struct DescribeAppInstanceUserOutputBody: Swift.Equatable {
    let appInstanceUser: ChimeClientTypes.AppInstanceUser?
}

extension DescribeAppInstanceUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUser = "AppInstanceUser"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceUser.self, forKey: .appInstanceUser)
        appInstanceUser = appInstanceUserDecoded
    }
}

enum DescribeAppInstanceUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeChannelBanInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelBanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelBanInput: Swift.Equatable {
    /// The ARN of the channel from which the user is banned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member being banned.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DescribeChannelBanInputBody: Swift.Equatable {
}

extension DescribeChannelBanInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelBanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeChannelBanOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelBan = output.channelBan
        } else {
            self.channelBan = nil
        }
    }
}

public struct DescribeChannelBanOutput: Swift.Equatable {
    /// The details of the ban.
    public var channelBan: ChimeClientTypes.ChannelBan?

    public init(
        channelBan: ChimeClientTypes.ChannelBan? = nil
    )
    {
        self.channelBan = channelBan
    }
}

struct DescribeChannelBanOutputBody: Swift.Equatable {
    let channelBan: ChimeClientTypes.ChannelBan?
}

extension DescribeChannelBanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelBan = "ChannelBan"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelBanDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelBan.self, forKey: .channelBan)
        channelBan = channelBanDecoded
    }
}

enum DescribeChannelBanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelInputBody: Swift.Equatable {
}

extension DescribeChannelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-membership"))
            guard let appInstanceUserArn = appInstanceUserArn else {
                let message = "Creating a URL Query Item failed. appInstanceUserArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            items.append(appInstanceUserArnQueryItem)
            return items
        }
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelMembershipForAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user in a channel.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the channel to which the user belongs.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelMembershipForAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeChannelMembershipForAppInstanceUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelMembershipForAppInstanceUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeChannelMembershipForAppInstanceUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelMembership = output.channelMembership
        } else {
            self.channelMembership = nil
        }
    }
}

public struct DescribeChannelMembershipForAppInstanceUserOutput: Swift.Equatable {
    /// The channel to which a user belongs.
    public var channelMembership: ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary?

    public init(
        channelMembership: ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

struct DescribeChannelMembershipForAppInstanceUserOutputBody: Swift.Equatable {
    let channelMembership: ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary?
}

extension DescribeChannelMembershipForAppInstanceUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMembership = "ChannelMembership"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary.self, forKey: .channelMembership)
        channelMembership = channelMembershipDecoded
    }
}

enum DescribeChannelMembershipForAppInstanceUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeChannelMembershipInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DescribeChannelMembershipInputBody: Swift.Equatable {
}

extension DescribeChannelMembershipInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeChannelMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelMembership = output.channelMembership
        } else {
            self.channelMembership = nil
        }
    }
}

public struct DescribeChannelMembershipOutput: Swift.Equatable {
    /// The details of the membership.
    public var channelMembership: ChimeClientTypes.ChannelMembership?

    public init(
        channelMembership: ChimeClientTypes.ChannelMembership? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

struct DescribeChannelMembershipOutputBody: Swift.Equatable {
    let channelMembership: ChimeClientTypes.ChannelMembership?
}

extension DescribeChannelMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMembership = "ChannelMembership"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMembership.self, forKey: .channelMembership)
        channelMembership = channelMembershipDecoded
    }
}

enum DescribeChannelMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-moderated-channel"))
            guard let appInstanceUserArn = appInstanceUserArn else {
                let message = "Creating a URL Query Item failed. appInstanceUserArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            items.append(appInstanceUserArnQueryItem)
            return items
        }
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelModeratedByAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser in the moderated channel.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the moderated channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelModeratedByAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeChannelModeratedByAppInstanceUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelModeratedByAppInstanceUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeChannelModeratedByAppInstanceUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct DescribeChannelModeratedByAppInstanceUserOutput: Swift.Equatable {
    /// The moderated channel.
    public var channel: ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary?

    public init(
        channel: ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary? = nil
    )
    {
        self.channel = channel
    }
}

struct DescribeChannelModeratedByAppInstanceUserOutputBody: Swift.Equatable {
    let channel: ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary?
}

extension DescribeChannelModeratedByAppInstanceUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary.self, forKey: .channel)
        channel = channelDecoded
    }
}

enum DescribeChannelModeratedByAppInstanceUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeChannelModeratorInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelModeratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let channelModeratorArn = channelModeratorArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the channel moderator.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelModeratorInputBody: Swift.Equatable {
}

extension DescribeChannelModeratorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelModeratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeChannelModeratorOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelModerator = output.channelModerator
        } else {
            self.channelModerator = nil
        }
    }
}

public struct DescribeChannelModeratorOutput: Swift.Equatable {
    /// The details of the channel moderator.
    public var channelModerator: ChimeClientTypes.ChannelModerator?

    public init(
        channelModerator: ChimeClientTypes.ChannelModerator? = nil
    )
    {
        self.channelModerator = channelModerator
    }
}

struct DescribeChannelModeratorOutputBody: Swift.Equatable {
    let channelModerator: ChimeClientTypes.ChannelModerator?
}

extension DescribeChannelModeratorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModerator = "ChannelModerator"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelModeratorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelModerator.self, forKey: .channelModerator)
        channelModerator = channelModeratorDecoded
    }
}

enum DescribeChannelModeratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct DescribeChannelOutput: Swift.Equatable {
    /// The channel details.
    public var channel: ChimeClientTypes.Channel?

    public init(
        channel: ChimeClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct DescribeChannelOutputBody: Swift.Equatable {
    let channel: ChimeClientTypes.Channel?
}

extension DescribeChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

enum DescribeChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociatePhoneNumberFromUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "disassociate-phone-number"))
            return items
        }
    }
}

extension DisassociatePhoneNumberFromUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct DisassociatePhoneNumberFromUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

struct DisassociatePhoneNumberFromUserInputBody: Swift.Equatable {
}

extension DisassociatePhoneNumberFromUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociatePhoneNumberFromUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociatePhoneNumberFromUserOutput: Swift.Equatable {

    public init() { }
}

enum DisassociatePhoneNumberFromUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "disassociate-phone-numbers"))
            return items
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorGroupInputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociatePhoneNumbersFromVoiceConnectorGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupOutput: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorGroupOutputBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

enum DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "disassociate-phone-numbers"))
            return items
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorInputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociatePhoneNumbersFromVoiceConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorOutput: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorOutputBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

enum DisassociatePhoneNumbersFromVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateSigninDelegateGroupsFromAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupNames = "GroupNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupNames = groupNames {
            var groupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupNames)
            for string0 in groupNames {
                try groupNamesContainer.encode(string0)
            }
        }
    }
}

extension DisassociateSigninDelegateGroupsFromAccountInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "disassociate-signin-delegate-groups"))
            return items
        }
    }
}

extension DisassociateSigninDelegateGroupsFromAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())"
    }
}

public struct DisassociateSigninDelegateGroupsFromAccountInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The sign-in delegate group names.
    /// This member is required.
    public var groupNames: [Swift.String]?

    public init(
        accountId: Swift.String? = nil,
        groupNames: [Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.groupNames = groupNames
    }
}

struct DisassociateSigninDelegateGroupsFromAccountInputBody: Swift.Equatable {
    let groupNames: [Swift.String]?
}

extension DisassociateSigninDelegateGroupsFromAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupNames = "GroupNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupNames)
        var groupNamesDecoded0:[Swift.String]? = nil
        if let groupNamesContainer = groupNamesContainer {
            groupNamesDecoded0 = [Swift.String]()
            for string0 in groupNamesContainer {
                if let string0 = string0 {
                    groupNamesDecoded0?.append(string0)
                }
            }
        }
        groupNames = groupNamesDecoded0
    }
}

extension DisassociateSigninDelegateGroupsFromAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateSigninDelegateGroupsFromAccountOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateSigninDelegateGroupsFromAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes {
    public enum EmailStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case notsent
        case sent
        case sdkUnknown(Swift.String)

        public static var allCases: [EmailStatus] {
            return [
                .failed,
                .notsent,
                .sent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .notsent: return "NotSent"
            case .sent: return "Sent"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EmailStatus(rawValue: rawValue) ?? EmailStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.EmergencyCallingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnis = "DNIS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnis = dnis {
            var dnisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnis)
            for dnisemergencycallingconfiguration0 in dnis {
                try dnisContainer.encode(dnisemergencycallingconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnisContainer = try containerValues.decodeIfPresent([ChimeClientTypes.DNISEmergencyCallingConfiguration?].self, forKey: .dnis)
        var dnisDecoded0:[ChimeClientTypes.DNISEmergencyCallingConfiguration]? = nil
        if let dnisContainer = dnisContainer {
            dnisDecoded0 = [ChimeClientTypes.DNISEmergencyCallingConfiguration]()
            for structure0 in dnisContainer {
                if let structure0 = structure0 {
                    dnisDecoded0?.append(structure0)
                }
            }
        }
        dnis = dnisDecoded0
    }
}

extension ChimeClientTypes {
    /// The emergency calling configuration details associated with an Amazon Chime Voice Connector.
    public struct EmergencyCallingConfiguration: Swift.Equatable {
        /// The Dialed Number Identification Service (DNIS) emergency calling configuration details.
        public var dnis: [ChimeClientTypes.DNISEmergencyCallingConfiguration]?

        public init(
            dnis: [ChimeClientTypes.DNISEmergencyCallingConfiguration]? = nil
        )
        {
            self.dnis = dnis
        }
    }

}

extension ChimeClientTypes.EngineTranscribeMedicalSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentIdentificationType = "ContentIdentificationType"
        case languageCode = "LanguageCode"
        case region = "Region"
        case specialty = "Specialty"
        case type = "Type"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentIdentificationType = self.contentIdentificationType {
            try encodeContainer.encode(contentIdentificationType.rawValue, forKey: .contentIdentificationType)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let region = self.region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
        if let specialty = self.specialty {
            try encodeContainer.encode(specialty.rawValue, forKey: .specialty)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeMedicalLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let specialtyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeMedicalSpecialty.self, forKey: .specialty)
        specialty = specialtyDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeMedicalType.self, forKey: .type)
        type = typeDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeMedicalRegion.self, forKey: .region)
        region = regionDecoded
        let contentIdentificationTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeMedicalContentIdentificationType.self, forKey: .contentIdentificationType)
        contentIdentificationType = contentIdentificationTypeDecoded
    }
}

extension ChimeClientTypes {
    /// Settings specific to the Amazon Transcribe Medical engine.
    public struct EngineTranscribeMedicalSettings: Swift.Equatable {
        /// Labels all personally identifiable information (PII) identified in your transcript. If you don't include PiiEntityTypes, all PII is identified. You cant set ContentIdentificationType and ContentRedactionType.
        public var contentIdentificationType: ChimeClientTypes.TranscribeMedicalContentIdentificationType?
        /// The language code specified for the Amazon Transcribe Medical engine.
        /// This member is required.
        public var languageCode: ChimeClientTypes.TranscribeMedicalLanguageCode?
        /// The AWS Region passed to Amazon Transcribe Medical. If you don't specify a Region, Amazon Chime uses the meeting's Region.
        public var region: ChimeClientTypes.TranscribeMedicalRegion?
        /// The specialty specified for the Amazon Transcribe Medical engine.
        /// This member is required.
        public var specialty: ChimeClientTypes.TranscribeMedicalSpecialty?
        /// The type of transcription.
        /// This member is required.
        public var type: ChimeClientTypes.TranscribeMedicalType?
        /// The name of the vocabulary passed to Amazon Transcribe Medical.
        public var vocabularyName: Swift.String?

        public init(
            contentIdentificationType: ChimeClientTypes.TranscribeMedicalContentIdentificationType? = nil,
            languageCode: ChimeClientTypes.TranscribeMedicalLanguageCode? = nil,
            region: ChimeClientTypes.TranscribeMedicalRegion? = nil,
            specialty: ChimeClientTypes.TranscribeMedicalSpecialty? = nil,
            type: ChimeClientTypes.TranscribeMedicalType? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.contentIdentificationType = contentIdentificationType
            self.languageCode = languageCode
            self.region = region
            self.specialty = specialty
            self.type = type
            self.vocabularyName = vocabularyName
        }
    }

}

extension ChimeClientTypes.EngineTranscribeSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentIdentificationType = "ContentIdentificationType"
        case contentRedactionType = "ContentRedactionType"
        case enablePartialResultsStabilization = "EnablePartialResultsStabilization"
        case identifyLanguage = "IdentifyLanguage"
        case languageCode = "LanguageCode"
        case languageModelName = "LanguageModelName"
        case languageOptions = "LanguageOptions"
        case partialResultsStability = "PartialResultsStability"
        case piiEntityTypes = "PiiEntityTypes"
        case preferredLanguage = "PreferredLanguage"
        case region = "Region"
        case vocabularyFilterMethod = "VocabularyFilterMethod"
        case vocabularyFilterName = "VocabularyFilterName"
        case vocabularyFilterNames = "VocabularyFilterNames"
        case vocabularyName = "VocabularyName"
        case vocabularyNames = "VocabularyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentIdentificationType = self.contentIdentificationType {
            try encodeContainer.encode(contentIdentificationType.rawValue, forKey: .contentIdentificationType)
        }
        if let contentRedactionType = self.contentRedactionType {
            try encodeContainer.encode(contentRedactionType.rawValue, forKey: .contentRedactionType)
        }
        if let enablePartialResultsStabilization = self.enablePartialResultsStabilization {
            try encodeContainer.encode(enablePartialResultsStabilization, forKey: .enablePartialResultsStabilization)
        }
        if let identifyLanguage = self.identifyLanguage {
            try encodeContainer.encode(identifyLanguage, forKey: .identifyLanguage)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let languageModelName = self.languageModelName {
            try encodeContainer.encode(languageModelName, forKey: .languageModelName)
        }
        if let languageOptions = self.languageOptions {
            try encodeContainer.encode(languageOptions, forKey: .languageOptions)
        }
        if let partialResultsStability = self.partialResultsStability {
            try encodeContainer.encode(partialResultsStability.rawValue, forKey: .partialResultsStability)
        }
        if let piiEntityTypes = self.piiEntityTypes {
            try encodeContainer.encode(piiEntityTypes, forKey: .piiEntityTypes)
        }
        if let preferredLanguage = self.preferredLanguage {
            try encodeContainer.encode(preferredLanguage.rawValue, forKey: .preferredLanguage)
        }
        if let region = self.region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
        if let vocabularyFilterMethod = self.vocabularyFilterMethod {
            try encodeContainer.encode(vocabularyFilterMethod.rawValue, forKey: .vocabularyFilterMethod)
        }
        if let vocabularyFilterName = self.vocabularyFilterName {
            try encodeContainer.encode(vocabularyFilterName, forKey: .vocabularyFilterName)
        }
        if let vocabularyFilterNames = self.vocabularyFilterNames {
            try encodeContainer.encode(vocabularyFilterNames, forKey: .vocabularyFilterNames)
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
        if let vocabularyNames = self.vocabularyNames {
            try encodeContainer.encode(vocabularyNames, forKey: .vocabularyNames)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyFilterMethodDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeVocabularyFilterMethod.self, forKey: .vocabularyFilterMethod)
        vocabularyFilterMethod = vocabularyFilterMethodDecoded
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeRegion.self, forKey: .region)
        region = regionDecoded
        let enablePartialResultsStabilizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePartialResultsStabilization)
        enablePartialResultsStabilization = enablePartialResultsStabilizationDecoded
        let partialResultsStabilityDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribePartialResultsStability.self, forKey: .partialResultsStability)
        partialResultsStability = partialResultsStabilityDecoded
        let contentIdentificationTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeContentIdentificationType.self, forKey: .contentIdentificationType)
        contentIdentificationType = contentIdentificationTypeDecoded
        let contentRedactionTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeContentRedactionType.self, forKey: .contentRedactionType)
        contentRedactionType = contentRedactionTypeDecoded
        let piiEntityTypesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .piiEntityTypes)
        piiEntityTypes = piiEntityTypesDecoded
        let languageModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageModelName)
        languageModelName = languageModelNameDecoded
        let identifyLanguageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .identifyLanguage)
        identifyLanguage = identifyLanguageDecoded
        let languageOptionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageOptions)
        languageOptions = languageOptionsDecoded
        let preferredLanguageDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscribeLanguageCode.self, forKey: .preferredLanguage)
        preferredLanguage = preferredLanguageDecoded
        let vocabularyNamesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyNames)
        vocabularyNames = vocabularyNamesDecoded
        let vocabularyFilterNamesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterNames)
        vocabularyFilterNames = vocabularyFilterNamesDecoded
    }
}

extension ChimeClientTypes {
    /// Settings specific for Amazon Transcribe as the live transcription engine. If you specify an invalid combination of parameters, a TranscriptFailed event will be sent with the contents of the BadRequestException generated by Amazon Transcribe. For more information on each parameter and which combinations are valid, refer to the [StartStreamTranscription](https://docs.aws.amazon.com/transcribe/latest/APIReference/API_streaming_StartStreamTranscription.html) API in the Amazon Transcribe Developer Guide.
    public struct EngineTranscribeSettings: Swift.Equatable {
        /// Labels all personally identifiable information (PII) identified in your transcript. If you don't include PiiEntityTypes, all PII is identified. You cant set ContentIdentificationType and ContentRedactionType.
        public var contentIdentificationType: ChimeClientTypes.TranscribeContentIdentificationType?
        /// Content redaction is performed at the segment level. If you don't include PiiEntityTypes, all PII is redacted. You cant set ContentIdentificationType and ContentRedactionType.
        public var contentRedactionType: ChimeClientTypes.TranscribeContentRedactionType?
        /// Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy.
        public var enablePartialResultsStabilization: Swift.Bool?
        /// Enables automatic language identification for your transcription. If you include IdentifyLanguage, you can optionally use LanguageOptions to include a list of language codes that you think may be present in your audio stream. Including language options can improve transcription accuracy. You can also use PreferredLanguage to include a preferred language. Doing so can help Amazon Transcribe identify the language faster. You must include either LanguageCode or IdentifyLanguage. Language identification can't be combined with custom language models or redaction.
        public var identifyLanguage: Swift.Bool?
        /// Specify the language code that represents the language spoken. If you're unsure of the language spoken in your audio, consider using IdentifyLanguage to enable automatic language identification.
        public var languageCode: ChimeClientTypes.TranscribeLanguageCode?
        /// Specify the name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive. The language of the specified language model must match the language code. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch. If you use Amazon Transcribe in multiple Regions, the custom language model must be available in Amazon Transcribe in each Region.
        public var languageModelName: Swift.String?
        /// Specify two or more language codes that represent the languages you think may be present in your media; including more than five is not recommended. If you're unsure what languages are present, do not include this parameter. Including language options can improve the accuracy of language identification. If you include LanguageOptions, you must also include IdentifyLanguage. You can only include one language dialect per language. For example, you cannot include en-US and en-AU.
        public var languageOptions: Swift.String?
        /// Specify the level of stability to use when you enable partial results stabilization (EnablePartialResultsStabilization). Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy.
        public var partialResultsStability: ChimeClientTypes.TranscribePartialResultsStability?
        /// Specify which types of personally identifiable information (PII) you want to redact in your transcript. You can include as many types as you'd like, or you can select ALL. Values must be comma-separated and can include: ADDRESS, BANK_ACCOUNT_NUMBER, BANK_ROUTING, CREDIT_DEBIT_CVV, CREDIT_DEBIT_EXPIRYCREDIT_DEBIT_NUMBER, EMAIL,NAME, PHONE, PIN, SSN, or ALL. Note that if you include PiiEntityTypes, you must also include ContentIdentificationType or ContentRedactionType. If you include ContentRedactionType or ContentIdentificationType, but do not include PiiEntityTypes, all PII is redacted or identified.
        public var piiEntityTypes: Swift.String?
        /// Specify a preferred language from the subset of languages codes you specified in LanguageOptions. You can only use this parameter if you include IdentifyLanguage and LanguageOptions.
        public var preferredLanguage: ChimeClientTypes.TranscribeLanguageCode?
        /// The AWS Region in which to use Amazon Transcribe. If you don't specify a Region, then the MediaRegion parameter of the [CreateMeeting.html](https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_meeting-chime_CreateMeeting.html) API will be used. However, if Amazon Transcribe is not available in the MediaRegion, then a TranscriptFailed event is sent. Use auto to use Amazon Transcribe in a Region near the meetings MediaRegion. For more information, refer to [Choosing a transcription Region](https://docs.aws.amazon.com/chime-sdk/latest/dg/transcription-options.html#choose-region) in the Amazon Chime SDK Developer Guide.
        public var region: ChimeClientTypes.TranscribeRegion?
        /// Specify how you want your vocabulary filter applied to your transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public var vocabularyFilterMethod: ChimeClientTypes.TranscribeVocabularyFilterMethod?
        /// Specify the name of the custom vocabulary filter that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region. If you include IdentifyLanguage and want to use one or more vocabulary filters with your transcription, use the VocabularyFilterNames parameter instead.
        public var vocabularyFilterName: Swift.String?
        /// Specify the names of the custom vocabulary filters that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region. If you're not including IdentifyLanguage and want to use a custom vocabulary filter with your transcription, use the VocabularyFilterName parameter instead.
        public var vocabularyFilterNames: Swift.String?
        /// Specify the name of the custom vocabulary that you want to use when processing your transcription. Note that vocabulary names are case sensitive. If you use Amazon Transcribe multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region. If you include IdentifyLanguage and want to use one or more custom vocabularies with your transcription, use the VocabularyNames parameter instead.
        public var vocabularyName: Swift.String?
        /// Specify the names of the custom vocabularies that you want to use when processing your transcription. Note that vocabulary names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region. If you don't include IdentifyLanguage and want to use a custom vocabulary with your transcription, use the VocabularyName parameter instead.
        public var vocabularyNames: Swift.String?

        public init(
            contentIdentificationType: ChimeClientTypes.TranscribeContentIdentificationType? = nil,
            contentRedactionType: ChimeClientTypes.TranscribeContentRedactionType? = nil,
            enablePartialResultsStabilization: Swift.Bool? = nil,
            identifyLanguage: Swift.Bool? = nil,
            languageCode: ChimeClientTypes.TranscribeLanguageCode? = nil,
            languageModelName: Swift.String? = nil,
            languageOptions: Swift.String? = nil,
            partialResultsStability: ChimeClientTypes.TranscribePartialResultsStability? = nil,
            piiEntityTypes: Swift.String? = nil,
            preferredLanguage: ChimeClientTypes.TranscribeLanguageCode? = nil,
            region: ChimeClientTypes.TranscribeRegion? = nil,
            vocabularyFilterMethod: ChimeClientTypes.TranscribeVocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyFilterNames: Swift.String? = nil,
            vocabularyName: Swift.String? = nil,
            vocabularyNames: Swift.String? = nil
        )
        {
            self.contentIdentificationType = contentIdentificationType
            self.contentRedactionType = contentRedactionType
            self.enablePartialResultsStabilization = enablePartialResultsStabilization
            self.identifyLanguage = identifyLanguage
            self.languageCode = languageCode
            self.languageModelName = languageModelName
            self.languageOptions = languageOptions
            self.partialResultsStability = partialResultsStability
            self.piiEntityTypes = piiEntityTypes
            self.preferredLanguage = preferredLanguage
            self.region = region
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyFilterNames = vocabularyFilterNames
            self.vocabularyName = vocabularyName
            self.vocabularyNames = vocabularyNames
        }
    }

}

extension ChimeClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.EventsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botId = "BotId"
        case lambdaFunctionArn = "LambdaFunctionArn"
        case outboundEventsHTTPSEndpoint = "OutboundEventsHTTPSEndpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let botId = self.botId {
            try encodeContainer.encode(botId, forKey: .botId)
        }
        if let lambdaFunctionArn = self.lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
        if let outboundEventsHTTPSEndpoint = self.outboundEventsHTTPSEndpoint {
            try encodeContainer.encode(outboundEventsHTTPSEndpoint, forKey: .outboundEventsHTTPSEndpoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let outboundEventsHTTPSEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundEventsHTTPSEndpoint)
        outboundEventsHTTPSEndpoint = outboundEventsHTTPSEndpointDecoded
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
    }
}

extension ChimeClientTypes.EventsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventsConfiguration(botId: \(Swift.String(describing: botId)), lambdaFunctionArn: \"CONTENT_REDACTED\", outboundEventsHTTPSEndpoint: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The configuration that allows a bot to receive outgoing events. Can be either an HTTPS endpoint or a Lambda function ARN.
    public struct EventsConfiguration: Swift.Equatable {
        /// The bot ID.
        public var botId: Swift.String?
        /// Lambda function ARN that allows a bot to receive outgoing events.
        public var lambdaFunctionArn: Swift.String?
        /// HTTPS endpoint that allows a bot to receive outgoing events.
        public var outboundEventsHTTPSEndpoint: Swift.String?

        public init(
            botId: Swift.String? = nil,
            lambdaFunctionArn: Swift.String? = nil,
            outboundEventsHTTPSEndpoint: Swift.String? = nil
        )
        {
            self.botId = botId
            self.lambdaFunctionArn = lambdaFunctionArn
            self.outboundEventsHTTPSEndpoint = outboundEventsHTTPSEndpoint
        }
    }

}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: ChimeClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes {
    public enum GeoMatchLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case areacode
        case country
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoMatchLevel] {
            return [
                .areacode,
                .country,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .areacode: return "AreaCode"
            case .country: return "Country"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoMatchLevel(rawValue: rawValue) ?? GeoMatchLevel.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.GeoMatchParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaCode = "AreaCode"
        case country = "Country"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areaCode = self.areaCode {
            try encodeContainer.encode(areaCode, forKey: .areaCode)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let areaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .areaCode)
        areaCode = areaCodeDecoded
    }
}

extension ChimeClientTypes {
    /// The country and area code for a proxy phone number in a proxy phone session.
    public struct GeoMatchParams: Swift.Equatable {
        /// The area code.
        /// This member is required.
        public var areaCode: Swift.String?
        /// The country.
        /// This member is required.
        public var country: Swift.String?

        public init(
            areaCode: Swift.String? = nil,
            country: Swift.String? = nil
        )
        {
            self.areaCode = areaCode
            self.country = country
        }
    }

}

extension GetAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())"
    }
}

public struct GetAccountInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetAccountInputBody: Swift.Equatable {
}

extension GetAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.account = output.account
        } else {
            self.account = nil
        }
    }
}

public struct GetAccountOutput: Swift.Equatable {
    /// The Amazon Chime account details.
    public var account: ChimeClientTypes.Account?

    public init(
        account: ChimeClientTypes.Account? = nil
    )
    {
        self.account = account
    }
}

struct GetAccountOutputBody: Swift.Equatable {
    let account: ChimeClientTypes.Account?
}

extension GetAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Account.self, forKey: .account)
        account = accountDecoded
    }
}

enum GetAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/settings"
    }
}

public struct GetAccountSettingsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetAccountSettingsInputBody: Swift.Equatable {
}

extension GetAccountSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountSettings = output.accountSettings
        } else {
            self.accountSettings = nil
        }
    }
}

public struct GetAccountSettingsOutput: Swift.Equatable {
    /// The Amazon Chime account settings.
    public var accountSettings: ChimeClientTypes.AccountSettings?

    public init(
        accountSettings: ChimeClientTypes.AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

struct GetAccountSettingsOutputBody: Swift.Equatable {
    let accountSettings: ChimeClientTypes.AccountSettings?
}

extension GetAccountSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings = "AccountSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

enum GetAccountSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAppInstanceRetentionSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/retention-settings"
    }
}

public struct GetAppInstanceRetentionSettingsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct GetAppInstanceRetentionSettingsInputBody: Swift.Equatable {
}

extension GetAppInstanceRetentionSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAppInstanceRetentionSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAppInstanceRetentionSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceRetentionSettings = output.appInstanceRetentionSettings
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
        } else {
            self.appInstanceRetentionSettings = nil
            self.initiateDeletionTimestamp = nil
        }
    }
}

public struct GetAppInstanceRetentionSettingsOutput: Swift.Equatable {
    /// The retention settings for the AppInstance.
    public var appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?
    /// The timestamp representing the time at which the specified items are retained, in Epoch Seconds.
    public var initiateDeletionTimestamp: ClientRuntime.Date?

    public init(
        appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings? = nil,
        initiateDeletionTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
    }
}

struct GetAppInstanceRetentionSettingsOutputBody: Swift.Equatable {
    let appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?
    let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension GetAppInstanceRetentionSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

enum GetAppInstanceRetentionSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAppInstanceStreamingConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/streaming-configurations"
    }
}

public struct GetAppInstanceStreamingConfigurationsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct GetAppInstanceStreamingConfigurationsInputBody: Swift.Equatable {
}

extension GetAppInstanceStreamingConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAppInstanceStreamingConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAppInstanceStreamingConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceStreamingConfigurations = output.appInstanceStreamingConfigurations
        } else {
            self.appInstanceStreamingConfigurations = nil
        }
    }
}

public struct GetAppInstanceStreamingConfigurationsOutput: Swift.Equatable {
    /// The streaming settings.
    public var appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?

    public init(
        appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
    )
    {
        self.appInstanceStreamingConfigurations = appInstanceStreamingConfigurations
    }
}

struct GetAppInstanceStreamingConfigurationsOutputBody: Swift.Equatable {
    let appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?
}

extension GetAppInstanceStreamingConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceStreamingConfigurations = "AppInstanceStreamingConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceStreamingConfigurationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.AppInstanceStreamingConfiguration?].self, forKey: .appInstanceStreamingConfigurations)
        var appInstanceStreamingConfigurationsDecoded0:[ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
        if let appInstanceStreamingConfigurationsContainer = appInstanceStreamingConfigurationsContainer {
            appInstanceStreamingConfigurationsDecoded0 = [ChimeClientTypes.AppInstanceStreamingConfiguration]()
            for structure0 in appInstanceStreamingConfigurationsContainer {
                if let structure0 = structure0 {
                    appInstanceStreamingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceStreamingConfigurations = appInstanceStreamingConfigurationsDecoded0
    }
}

enum GetAppInstanceStreamingConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        guard let attendeeId = attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())"
    }
}

public struct GetAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

struct GetAttendeeInputBody: Swift.Equatable {
}

extension GetAttendeeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAttendeeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAttendeeOutputBody = try responseDecoder.decode(responseBody: data)
            self.attendee = output.attendee
        } else {
            self.attendee = nil
        }
    }
}

public struct GetAttendeeOutput: Swift.Equatable {
    /// The Amazon Chime SDK attendee information.
    public var attendee: ChimeClientTypes.Attendee?

    public init(
        attendee: ChimeClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

struct GetAttendeeOutputBody: Swift.Equatable {
    let attendee: ChimeClientTypes.Attendee?
}

extension GetAttendeeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendee = "Attendee"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Attendee.self, forKey: .attendee)
        attendee = attendeeDecoded
    }
}

enum GetAttendeeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let botId = botId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())"
    }
}

public struct GetBotInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
    }
}

struct GetBotInputBody: Swift.Equatable {
}

extension GetBotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBotOutputBody = try responseDecoder.decode(responseBody: data)
            self.bot = output.bot
        } else {
            self.bot = nil
        }
    }
}

public struct GetBotOutput: Swift.Equatable {
    /// The chat bot details.
    public var bot: ChimeClientTypes.Bot?

    public init(
        bot: ChimeClientTypes.Bot? = nil
    )
    {
        self.bot = bot
    }
}

struct GetBotOutputBody: Swift.Equatable {
    let bot: ChimeClientTypes.Bot?
}

extension GetBotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bot = "Bot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Bot.self, forKey: .bot)
        bot = botDecoded
    }
}

enum GetBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension GetChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct GetChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ID of the message.
    /// This member is required.
    public var messageId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

struct GetChannelMessageInputBody: Swift.Equatable {
}

extension GetChannelMessageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetChannelMessageOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelMessage = output.channelMessage
        } else {
            self.channelMessage = nil
        }
    }
}

public struct GetChannelMessageOutput: Swift.Equatable {
    /// The details of and content in the message.
    public var channelMessage: ChimeClientTypes.ChannelMessage?

    public init(
        channelMessage: ChimeClientTypes.ChannelMessage? = nil
    )
    {
        self.channelMessage = channelMessage
    }
}

struct GetChannelMessageOutputBody: Swift.Equatable {
    let channelMessage: ChimeClientTypes.ChannelMessage?
}

extension GetChannelMessageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMessage = "ChannelMessage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMessageDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMessage.self, forKey: .channelMessage)
        channelMessage = channelMessageDecoded
    }
}

enum GetChannelMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEventsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let botId = botId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())/events-configuration"
    }
}

public struct GetEventsConfigurationInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
    }
}

struct GetEventsConfigurationInputBody: Swift.Equatable {
}

extension GetEventsConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEventsConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEventsConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventsConfiguration = output.eventsConfiguration
        } else {
            self.eventsConfiguration = nil
        }
    }
}

public struct GetEventsConfigurationOutput: Swift.Equatable {
    /// The events configuration details.
    public var eventsConfiguration: ChimeClientTypes.EventsConfiguration?

    public init(
        eventsConfiguration: ChimeClientTypes.EventsConfiguration? = nil
    )
    {
        self.eventsConfiguration = eventsConfiguration
    }
}

struct GetEventsConfigurationOutputBody: Swift.Equatable {
    let eventsConfiguration: ChimeClientTypes.EventsConfiguration?
}

extension GetEventsConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventsConfiguration = "EventsConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EventsConfiguration.self, forKey: .eventsConfiguration)
        eventsConfiguration = eventsConfigurationDecoded
    }
}

enum GetEventsConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGlobalSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings"
    }
}

public struct GetGlobalSettingsInput: Swift.Equatable {

    public init() { }
}

struct GetGlobalSettingsInputBody: Swift.Equatable {
}

extension GetGlobalSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGlobalSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGlobalSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.businessCalling = output.businessCalling
            self.voiceConnector = output.voiceConnector
        } else {
            self.businessCalling = nil
            self.voiceConnector = nil
        }
    }
}

public struct GetGlobalSettingsOutput: Swift.Equatable {
    /// The Amazon Chime Business Calling settings.
    public var businessCalling: ChimeClientTypes.BusinessCallingSettings?
    /// The Amazon Chime Voice Connector settings.
    public var voiceConnector: ChimeClientTypes.VoiceConnectorSettings?

    public init(
        businessCalling: ChimeClientTypes.BusinessCallingSettings? = nil,
        voiceConnector: ChimeClientTypes.VoiceConnectorSettings? = nil
    )
    {
        self.businessCalling = businessCalling
        self.voiceConnector = voiceConnector
    }
}

struct GetGlobalSettingsOutputBody: Swift.Equatable {
    let businessCalling: ChimeClientTypes.BusinessCallingSettings?
    let voiceConnector: ChimeClientTypes.VoiceConnectorSettings?
}

extension GetGlobalSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessCalling = "BusinessCalling"
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let businessCallingDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.BusinessCallingSettings.self, forKey: .businessCalling)
        businessCalling = businessCallingDecoded
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorSettings.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

enum GetGlobalSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMediaCapturePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mediaPipelineId = mediaPipelineId else {
            return nil
        }
        return "/media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

public struct GetMediaCapturePipelineInput: Swift.Equatable {
    /// The ID of the pipeline that you want to get.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init(
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct GetMediaCapturePipelineInputBody: Swift.Equatable {
}

extension GetMediaCapturePipelineInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMediaCapturePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMediaCapturePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipeline = output.mediaCapturePipeline
        } else {
            self.mediaCapturePipeline = nil
        }
    }
}

public struct GetMediaCapturePipelineOutput: Swift.Equatable {
    /// The media capture pipeline object.
    public var mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline?

    public init(
        mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

struct GetMediaCapturePipelineOutputBody: Swift.Equatable {
    let mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline?
}

extension GetMediaCapturePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipeline = "MediaCapturePipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelineDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaCapturePipeline.self, forKey: .mediaCapturePipeline)
        mediaCapturePipeline = mediaCapturePipelineDecoded
    }
}

enum GetMediaCapturePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMeetingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())"
    }
}

public struct GetMeetingInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct GetMeetingInputBody: Swift.Equatable {
}

extension GetMeetingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMeetingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMeetingOutputBody = try responseDecoder.decode(responseBody: data)
            self.meeting = output.meeting
        } else {
            self.meeting = nil
        }
    }
}

public struct GetMeetingOutput: Swift.Equatable {
    /// The Amazon Chime SDK meeting information.
    public var meeting: ChimeClientTypes.Meeting?

    public init(
        meeting: ChimeClientTypes.Meeting? = nil
    )
    {
        self.meeting = meeting
    }
}

struct GetMeetingOutputBody: Swift.Equatable {
    let meeting: ChimeClientTypes.Meeting?
}

extension GetMeetingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meeting = "Meeting"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
    }
}

enum GetMeetingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMessagingSessionEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/endpoints/messaging-session"
    }
}

public struct GetMessagingSessionEndpointInput: Swift.Equatable {

    public init() { }
}

struct GetMessagingSessionEndpointInputBody: Swift.Equatable {
}

extension GetMessagingSessionEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMessagingSessionEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMessagingSessionEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct GetMessagingSessionEndpointOutput: Swift.Equatable {
    /// The endpoint returned in the response.
    public var endpoint: ChimeClientTypes.MessagingSessionEndpoint?

    public init(
        endpoint: ChimeClientTypes.MessagingSessionEndpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct GetMessagingSessionEndpointOutputBody: Swift.Equatable {
    let endpoint: ChimeClientTypes.MessagingSessionEndpoint?
}

extension GetMessagingSessionEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MessagingSessionEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum GetMessagingSessionEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct GetPhoneNumberInput: Swift.Equatable {
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct GetPhoneNumberInputBody: Swift.Equatable {
}

extension GetPhoneNumberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberOrderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberOrderId = phoneNumberOrderId else {
            return nil
        }
        return "/phone-number-orders/\(phoneNumberOrderId.urlPercentEncoding())"
    }
}

public struct GetPhoneNumberOrderInput: Swift.Equatable {
    /// The ID for the phone number order.
    /// This member is required.
    public var phoneNumberOrderId: Swift.String?

    public init(
        phoneNumberOrderId: Swift.String? = nil
    )
    {
        self.phoneNumberOrderId = phoneNumberOrderId
    }
}

struct GetPhoneNumberOrderInputBody: Swift.Equatable {
}

extension GetPhoneNumberOrderInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberOrderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPhoneNumberOrderOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberOrder = output.phoneNumberOrder
        } else {
            self.phoneNumberOrder = nil
        }
    }
}

public struct GetPhoneNumberOrderOutput: Swift.Equatable {
    /// The phone number order details.
    public var phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder?

    public init(
        phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder? = nil
    )
    {
        self.phoneNumberOrder = phoneNumberOrder
    }
}

struct GetPhoneNumberOrderOutputBody: Swift.Equatable {
    let phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder?
}

extension GetPhoneNumberOrderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberOrder = "PhoneNumberOrder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberOrder.self, forKey: .phoneNumberOrder)
        phoneNumberOrder = phoneNumberOrderDecoded
    }
}

enum GetPhoneNumberOrderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct GetPhoneNumberOutput: Swift.Equatable {
    /// The phone number details.
    public var phoneNumber: ChimeClientTypes.PhoneNumber?

    public init(
        phoneNumber: ChimeClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct GetPhoneNumberOutputBody: Swift.Equatable {
    let phoneNumber: ChimeClientTypes.PhoneNumber?
}

extension GetPhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

enum GetPhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPhoneNumberSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings/phone-number"
    }
}

public struct GetPhoneNumberSettingsInput: Swift.Equatable {

    public init() { }
}

struct GetPhoneNumberSettingsInputBody: Swift.Equatable {
}

extension GetPhoneNumberSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberSettingsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberSettingsOutput(callingNameUpdatedTimestamp: \(Swift.String(describing: callingNameUpdatedTimestamp)), callingName: \"CONTENT_REDACTED\")"}
}

extension GetPhoneNumberSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPhoneNumberSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.callingName = output.callingName
            self.callingNameUpdatedTimestamp = output.callingNameUpdatedTimestamp
        } else {
            self.callingName = nil
            self.callingNameUpdatedTimestamp = nil
        }
    }
}

public struct GetPhoneNumberSettingsOutput: Swift.Equatable {
    /// The default outbound calling name for the account.
    public var callingName: Swift.String?
    /// The updated outbound calling name timestamp, in ISO 8601 format.
    public var callingNameUpdatedTimestamp: ClientRuntime.Date?

    public init(
        callingName: Swift.String? = nil,
        callingNameUpdatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.callingName = callingName
        self.callingNameUpdatedTimestamp = callingNameUpdatedTimestamp
    }
}

struct GetPhoneNumberSettingsOutputBody: Swift.Equatable {
    let callingName: Swift.String?
    let callingNameUpdatedTimestamp: ClientRuntime.Date?
}

extension GetPhoneNumberSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case callingNameUpdatedTimestamp = "CallingNameUpdatedTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
        let callingNameUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .callingNameUpdatedTimestamp)
        callingNameUpdatedTimestamp = callingNameUpdatedTimestampDecoded
    }
}

enum GetPhoneNumberSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProxySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

public struct GetProxySessionInput: Swift.Equatable {
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetProxySessionInputBody: Swift.Equatable {
}

extension GetProxySessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProxySessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProxySessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct GetProxySessionOutput: Swift.Equatable {
    /// The proxy session details.
    public var proxySession: ChimeClientTypes.ProxySession?

    public init(
        proxySession: ChimeClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct GetProxySessionOutputBody: Swift.Equatable {
    let proxySession: ChimeClientTypes.ProxySession?
}

extension GetProxySessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

enum GetProxySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRetentionSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/retention-settings"
    }
}

public struct GetRetentionSettingsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetRetentionSettingsInputBody: Swift.Equatable {
}

extension GetRetentionSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRetentionSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRetentionSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
            self.retentionSettings = output.retentionSettings
        } else {
            self.initiateDeletionTimestamp = nil
            self.retentionSettings = nil
        }
    }
}

public struct GetRetentionSettingsOutput: Swift.Equatable {
    /// The timestamp representing the time at which the specified items are permanently deleted, in ISO 8601 format.
    public var initiateDeletionTimestamp: ClientRuntime.Date?
    /// The retention settings.
    public var retentionSettings: ChimeClientTypes.RetentionSettings?

    public init(
        initiateDeletionTimestamp: ClientRuntime.Date? = nil,
        retentionSettings: ChimeClientTypes.RetentionSettings? = nil
    )
    {
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
        self.retentionSettings = retentionSettings
    }
}

struct GetRetentionSettingsOutputBody: Swift.Equatable {
    let retentionSettings: ChimeClientTypes.RetentionSettings?
    let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension GetRetentionSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
        case retentionSettings = "RetentionSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RetentionSettings.self, forKey: .retentionSettings)
        retentionSettings = retentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

enum GetRetentionSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let roomId = roomId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())"
    }
}

public struct GetRoomInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.roomId = roomId
    }
}

struct GetRoomInputBody: Swift.Equatable {
}

extension GetRoomInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRoomOutputBody = try responseDecoder.decode(responseBody: data)
            self.room = output.room
        } else {
            self.room = nil
        }
    }
}

public struct GetRoomOutput: Swift.Equatable {
    /// The room details.
    public var room: ChimeClientTypes.Room?

    public init(
        room: ChimeClientTypes.Room? = nil
    )
    {
        self.room = room
    }
}

struct GetRoomOutputBody: Swift.Equatable {
    let room: ChimeClientTypes.Room?
}

extension GetRoomOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case room = "Room"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Room.self, forKey: .room)
        room = roomDecoded
    }
}

enum GetRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSipMediaApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

public struct GetSipMediaApplicationInput: Swift.Equatable {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationInputBody: Swift.Equatable {
}

extension GetSipMediaApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSipMediaApplicationLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/logging-configuration"
    }
}

public struct GetSipMediaApplicationLoggingConfigurationInput: Swift.Equatable {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationLoggingConfigurationInputBody: Swift.Equatable {
}

extension GetSipMediaApplicationLoggingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSipMediaApplicationLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSipMediaApplicationLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationLoggingConfiguration = output.sipMediaApplicationLoggingConfiguration
        } else {
            self.sipMediaApplicationLoggingConfiguration = nil
        }
    }
}

public struct GetSipMediaApplicationLoggingConfigurationOutput: Swift.Equatable {
    /// The actual logging configuration.
    public var sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?

    public init(
        sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct GetSipMediaApplicationLoggingConfigurationOutputBody: Swift.Equatable {
    let sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension GetSipMediaApplicationLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

enum GetSipMediaApplicationLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSipMediaApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSipMediaApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct GetSipMediaApplicationOutput: Swift.Equatable {
    /// The SIP media application details.
    public var sipMediaApplication: ChimeClientTypes.SipMediaApplication?

    public init(
        sipMediaApplication: ChimeClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct GetSipMediaApplicationOutputBody: Swift.Equatable {
    let sipMediaApplication: ChimeClientTypes.SipMediaApplication?
}

extension GetSipMediaApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

enum GetSipMediaApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSipRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipRuleId = sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

public struct GetSipRuleInput: Swift.Equatable {
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?

    public init(
        sipRuleId: Swift.String? = nil
    )
    {
        self.sipRuleId = sipRuleId
    }
}

struct GetSipRuleInputBody: Swift.Equatable {
}

extension GetSipRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSipRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSipRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct GetSipRuleOutput: Swift.Equatable {
    /// The SIP rule details.
    public var sipRule: ChimeClientTypes.SipRule?

    public init(
        sipRule: ChimeClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct GetSipRuleOutputBody: Swift.Equatable {
    let sipRule: ChimeClientTypes.SipRule?
}

extension GetSipRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

enum GetSipRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct GetUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

struct GetUserInputBody: Swift.Equatable {
}

extension GetUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct GetUserOutput: Swift.Equatable {
    /// The user details.
    public var user: ChimeClientTypes.User?

    public init(
        user: ChimeClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct GetUserOutputBody: Swift.Equatable {
    let user: ChimeClientTypes.User?
}

extension GetUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum GetUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())/settings"
    }
}

public struct GetUserSettingsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

struct GetUserSettingsInputBody: Swift.Equatable {
}

extension GetUserSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.userSettings = output.userSettings
        } else {
            self.userSettings = nil
        }
    }
}

public struct GetUserSettingsOutput: Swift.Equatable {
    /// The user settings.
    public var userSettings: ChimeClientTypes.UserSettings?

    public init(
        userSettings: ChimeClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

struct GetUserSettingsOutputBody: Swift.Equatable {
    let userSettings: ChimeClientTypes.UserSettings?
}

extension GetUserSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings = "UserSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserSettings.self, forKey: .userSettings)
        userSettings = userSettingsDecoded
    }
}

enum GetUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

public struct GetVoiceConnectorEmergencyCallingConfigurationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorEmergencyCallingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.emergencyCallingConfiguration = output.emergencyCallingConfiguration
        } else {
            self.emergencyCallingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorEmergencyCallingConfigurationOutput: Swift.Equatable {
    /// The emergency calling configuration details.
    public var emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?

    public init(
        emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
    }
}

struct GetVoiceConnectorEmergencyCallingConfigurationOutputBody: Swift.Equatable {
    let emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

enum GetVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct GetVoiceConnectorGroupInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct GetVoiceConnectorGroupInputBody: Swift.Equatable {
}

extension GetVoiceConnectorGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct GetVoiceConnectorGroupOutput: Swift.Equatable {
    /// The Amazon Chime Voice Connector group details.
    public var voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?

    public init(
        voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct GetVoiceConnectorGroupOutputBody: Swift.Equatable {
    let voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?
}

extension GetVoiceConnectorGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

enum GetVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct GetVoiceConnectorInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorInputBody: Swift.Equatable {
}

extension GetVoiceConnectorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/logging-configuration"
    }
}

public struct GetVoiceConnectorLoggingConfigurationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorLoggingConfigurationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorLoggingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorLoggingConfigurationOutput: Swift.Equatable {
    /// The logging configuration details.
    public var loggingConfiguration: ChimeClientTypes.LoggingConfiguration?

    public init(
        loggingConfiguration: ChimeClientTypes.LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct GetVoiceConnectorLoggingConfigurationOutputBody: Swift.Equatable {
    let loggingConfiguration: ChimeClientTypes.LoggingConfiguration?
}

extension GetVoiceConnectorLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

enum GetVoiceConnectorLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorOriginationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

public struct GetVoiceConnectorOriginationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorOriginationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorOriginationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorOriginationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorOriginationOutputBody = try responseDecoder.decode(responseBody: data)
            self.origination = output.origination
        } else {
            self.origination = nil
        }
    }
}

public struct GetVoiceConnectorOriginationOutput: Swift.Equatable {
    /// The origination setting details.
    public var origination: ChimeClientTypes.Origination?

    public init(
        origination: ChimeClientTypes.Origination? = nil
    )
    {
        self.origination = origination
    }
}

struct GetVoiceConnectorOriginationOutputBody: Swift.Equatable {
    let origination: ChimeClientTypes.Origination?
}

extension GetVoiceConnectorOriginationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

enum GetVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct GetVoiceConnectorOutput: Swift.Equatable {
    /// The Amazon Chime Voice Connector details.
    public var voiceConnector: ChimeClientTypes.VoiceConnector?

    public init(
        voiceConnector: ChimeClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct GetVoiceConnectorOutputBody: Swift.Equatable {
    let voiceConnector: ChimeClientTypes.VoiceConnector?
}

extension GetVoiceConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

enum GetVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorProxyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

public struct GetVoiceConnectorProxyInput: Swift.Equatable {
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorProxyInputBody: Swift.Equatable {
}

extension GetVoiceConnectorProxyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorProxyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorProxyOutputBody = try responseDecoder.decode(responseBody: data)
            self.proxy = output.proxy
        } else {
            self.proxy = nil
        }
    }
}

public struct GetVoiceConnectorProxyOutput: Swift.Equatable {
    /// The proxy configuration details.
    public var proxy: ChimeClientTypes.Proxy?

    public init(
        proxy: ChimeClientTypes.Proxy? = nil
    )
    {
        self.proxy = proxy
    }
}

struct GetVoiceConnectorProxyOutputBody: Swift.Equatable {
    let proxy: ChimeClientTypes.Proxy?
}

extension GetVoiceConnectorProxyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxy = "Proxy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Proxy.self, forKey: .proxy)
        proxy = proxyDecoded
    }
}

enum GetVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorStreamingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

public struct GetVoiceConnectorStreamingConfigurationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorStreamingConfigurationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorStreamingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorStreamingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamingConfiguration = output.streamingConfiguration
        } else {
            self.streamingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorStreamingConfigurationOutput: Swift.Equatable {
    /// The streaming configuration details.
    public var streamingConfiguration: ChimeClientTypes.StreamingConfiguration?

    public init(
        streamingConfiguration: ChimeClientTypes.StreamingConfiguration? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
    }
}

struct GetVoiceConnectorStreamingConfigurationOutputBody: Swift.Equatable {
    let streamingConfiguration: ChimeClientTypes.StreamingConfiguration?
}

extension GetVoiceConnectorStreamingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

enum GetVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorTerminationHealthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/health"
    }
}

public struct GetVoiceConnectorTerminationHealthInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorTerminationHealthInputBody: Swift.Equatable {
}

extension GetVoiceConnectorTerminationHealthInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorTerminationHealthOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorTerminationHealthOutputBody = try responseDecoder.decode(responseBody: data)
            self.terminationHealth = output.terminationHealth
        } else {
            self.terminationHealth = nil
        }
    }
}

public struct GetVoiceConnectorTerminationHealthOutput: Swift.Equatable {
    /// The termination health details.
    public var terminationHealth: ChimeClientTypes.TerminationHealth?

    public init(
        terminationHealth: ChimeClientTypes.TerminationHealth? = nil
    )
    {
        self.terminationHealth = terminationHealth
    }
}

struct GetVoiceConnectorTerminationHealthOutputBody: Swift.Equatable {
    let terminationHealth: ChimeClientTypes.TerminationHealth?
}

extension GetVoiceConnectorTerminationHealthOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminationHealth = "TerminationHealth"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationHealthDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TerminationHealth.self, forKey: .terminationHealth)
        terminationHealth = terminationHealthDecoded
    }
}

enum GetVoiceConnectorTerminationHealthOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorTerminationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

public struct GetVoiceConnectorTerminationInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorTerminationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorTerminationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorTerminationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorTerminationOutputBody = try responseDecoder.decode(responseBody: data)
            self.termination = output.termination
        } else {
            self.termination = nil
        }
    }
}

public struct GetVoiceConnectorTerminationOutput: Swift.Equatable {
    /// The termination setting details.
    public var termination: ChimeClientTypes.Termination?

    public init(
        termination: ChimeClientTypes.Termination? = nil
    )
    {
        self.termination = termination
    }
}

struct GetVoiceConnectorTerminationOutputBody: Swift.Equatable {
    let termination: ChimeClientTypes.Termination?
}

extension GetVoiceConnectorTerminationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

enum GetVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.Identity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ChimeClientTypes.Identity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Identity(arn: \(Swift.String(describing: arn)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The details of a user.
    public struct Identity: Swift.Equatable {
        /// The ARN in an Identity.
        public var arn: Swift.String?
        /// The name in an Identity.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ChimeClientTypes.Invite: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailAddress = "EmailAddress"
        case emailStatus = "EmailStatus"
        case inviteId = "InviteId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let emailStatus = self.emailStatus {
            try encodeContainer.encode(emailStatus.rawValue, forKey: .emailStatus)
        }
        if let inviteId = self.inviteId {
            try encodeContainer.encode(inviteId, forKey: .inviteId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inviteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inviteId)
        inviteId = inviteIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.InviteStatus.self, forKey: .status)
        status = statusDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let emailStatusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EmailStatus.self, forKey: .emailStatus)
        emailStatus = emailStatusDecoded
    }
}

extension ChimeClientTypes.Invite: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Invite(emailStatus: \(Swift.String(describing: emailStatus)), inviteId: \(Swift.String(describing: inviteId)), status: \(Swift.String(describing: status)), emailAddress: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Invitation object returned after emailing users to invite them to join the Amazon Chime Team account.
    public struct Invite: Swift.Equatable {
        /// The email address to which the invite is sent.
        public var emailAddress: Swift.String?
        /// The status of the invite email.
        public var emailStatus: ChimeClientTypes.EmailStatus?
        /// The invite ID.
        public var inviteId: Swift.String?
        /// The status of the invite.
        public var status: ChimeClientTypes.InviteStatus?

        public init(
            emailAddress: Swift.String? = nil,
            emailStatus: ChimeClientTypes.EmailStatus? = nil,
            inviteId: Swift.String? = nil,
            status: ChimeClientTypes.InviteStatus? = nil
        )
        {
            self.emailAddress = emailAddress
            self.emailStatus = emailStatus
            self.inviteId = inviteId
            self.status = status
        }
    }

}

extension ChimeClientTypes {
    public enum InviteStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accepted
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [InviteStatus] {
            return [
                .accepted,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "Accepted"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InviteStatus(rawValue: rawValue) ?? InviteStatus.sdkUnknown(rawValue)
        }
    }
}

extension InviteUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userEmailList = "UserEmailList"
        case userType = "UserType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userEmailList = userEmailList {
            var userEmailListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userEmailList)
            for emailaddress0 in userEmailList {
                try userEmailListContainer.encode(emailaddress0)
            }
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
    }
}

extension InviteUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "add"))
            return items
        }
    }
}

extension InviteUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users"
    }
}

public struct InviteUsersInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user email addresses to which to send the email invitation.
    /// This member is required.
    public var userEmailList: [Swift.String]?
    /// The user type.
    public var userType: ChimeClientTypes.UserType?

    public init(
        accountId: Swift.String? = nil,
        userEmailList: [Swift.String]? = nil,
        userType: ChimeClientTypes.UserType? = nil
    )
    {
        self.accountId = accountId
        self.userEmailList = userEmailList
        self.userType = userType
    }
}

struct InviteUsersInputBody: Swift.Equatable {
    let userEmailList: [Swift.String]?
    let userType: ChimeClientTypes.UserType?
}

extension InviteUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userEmailList = "UserEmailList"
        case userType = "UserType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userEmailListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userEmailList)
        var userEmailListDecoded0:[Swift.String]? = nil
        if let userEmailListContainer = userEmailListContainer {
            userEmailListDecoded0 = [Swift.String]()
            for string0 in userEmailListContainer {
                if let string0 = string0 {
                    userEmailListDecoded0?.append(string0)
                }
            }
        }
        userEmailList = userEmailListDecoded0
        let userTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
    }
}

extension InviteUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InviteUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.invites = output.invites
        } else {
            self.invites = nil
        }
    }
}

public struct InviteUsersOutput: Swift.Equatable {
    /// The email invitation details.
    public var invites: [ChimeClientTypes.Invite]?

    public init(
        invites: [ChimeClientTypes.Invite]? = nil
    )
    {
        self.invites = invites
    }
}

struct InviteUsersOutputBody: Swift.Equatable {
    let invites: [ChimeClientTypes.Invite]?
}

extension InviteUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invites = "Invites"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Invite?].self, forKey: .invites)
        var invitesDecoded0:[ChimeClientTypes.Invite]? = nil
        if let invitesContainer = invitesContainer {
            invitesDecoded0 = [ChimeClientTypes.Invite]()
            for structure0 in invitesContainer {
                if let structure0 = structure0 {
                    invitesDecoded0?.append(structure0)
                }
            }
        }
        invites = invitesDecoded0
    }
}

enum InviteUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes {
    public enum License: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case plus
        case pro
        case protrial
        case sdkUnknown(Swift.String)

        public static var allCases: [License] {
            return [
                .basic,
                .plus,
                .pro,
                .protrial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "Basic"
            case .plus: return "Plus"
            case .pro: return "Pro"
            case .protrial: return "ProTrial"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = License(rawValue: rawValue) ?? License.sdkUnknown(rawValue)
        }
    }
}

extension ListAccountsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccountsInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), userEmail: \"CONTENT_REDACTED\")"}
}

extension ListAccountsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let userEmail = userEmail {
                let userEmailQueryItem = ClientRuntime.URLQueryItem(name: "user-email".urlPercentEncoding(), value: Swift.String(userEmail).urlPercentEncoding())
                items.append(userEmailQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            return items
        }
    }
}

extension ListAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accounts"
    }
}

public struct ListAccountsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// Amazon Chime account name prefix with which to filter results.
    public var name: Swift.String?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// User email address with which to filter results.
    public var userEmail: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        userEmail: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.userEmail = userEmail
    }
}

struct ListAccountsInputBody: Swift.Equatable {
}

extension ListAccountsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAccountsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.nextToken = output.nextToken
        } else {
            self.accounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountsOutput: Swift.Equatable {
    /// List of Amazon Chime accounts and account details.
    public var accounts: [ChimeClientTypes.Account]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accounts: [ChimeClientTypes.Account]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accounts = accounts
        self.nextToken = nextToken
    }
}

struct ListAccountsOutputBody: Swift.Equatable {
    let accounts: [ChimeClientTypes.Account]?
    let nextToken: Swift.String?
}

extension ListAccountsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "Accounts"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Account?].self, forKey: .accounts)
        var accountsDecoded0:[ChimeClientTypes.Account]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [ChimeClientTypes.Account]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppInstanceAdminsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceAdminsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstanceAdminsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAppInstanceAdminsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins"
    }
}

public struct ListAppInstanceAdminsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of administrators that you want to return.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of administrators is reached.
    public var nextToken: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceAdminsInputBody: Swift.Equatable {
}

extension ListAppInstanceAdminsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceAdminsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceAdminsOutput(appInstanceAdmins: \(Swift.String(describing: appInstanceAdmins)), appInstanceArn: \(Swift.String(describing: appInstanceArn)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstanceAdminsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppInstanceAdminsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmins = output.appInstanceAdmins
            self.appInstanceArn = output.appInstanceArn
            self.nextToken = output.nextToken
        } else {
            self.appInstanceAdmins = nil
            self.appInstanceArn = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceAdminsOutput: Swift.Equatable {
    /// The information for each administrator.
    public var appInstanceAdmins: [ChimeClientTypes.AppInstanceAdminSummary]?
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The token returned from previous API requests until the number of administrators is reached.
    public var nextToken: Swift.String?

    public init(
        appInstanceAdmins: [ChimeClientTypes.AppInstanceAdminSummary]? = nil,
        appInstanceArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceAdmins = appInstanceAdmins
        self.appInstanceArn = appInstanceArn
        self.nextToken = nextToken
    }
}

struct ListAppInstanceAdminsOutputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let appInstanceAdmins: [ChimeClientTypes.AppInstanceAdminSummary]?
    let nextToken: Swift.String?
}

extension ListAppInstanceAdminsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmins = "AppInstanceAdmins"
        case appInstanceArn = "AppInstanceArn"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceAdminsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.AppInstanceAdminSummary?].self, forKey: .appInstanceAdmins)
        var appInstanceAdminsDecoded0:[ChimeClientTypes.AppInstanceAdminSummary]? = nil
        if let appInstanceAdminsContainer = appInstanceAdminsContainer {
            appInstanceAdminsDecoded0 = [ChimeClientTypes.AppInstanceAdminSummary]()
            for structure0 in appInstanceAdminsContainer {
                if let structure0 = structure0 {
                    appInstanceAdminsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceAdmins = appInstanceAdminsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppInstanceAdminsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppInstanceUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUsersInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstanceUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let appInstanceArn = appInstanceArn else {
                let message = "Creating a URL Query Item failed. appInstanceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            items.append(appInstanceArnQueryItem)
            return items
        }
    }
}

extension ListAppInstanceUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instance-users"
    }
}

public struct ListAppInstanceUsersInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of requests that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUsersInputBody: Swift.Equatable {
}

extension ListAppInstanceUsersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceUsersOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUsersOutput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), appInstanceUsers: \(Swift.String(describing: appInstanceUsers)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstanceUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppInstanceUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
            self.appInstanceUsers = output.appInstanceUsers
            self.nextToken = output.nextToken
        } else {
            self.appInstanceArn = nil
            self.appInstanceUsers = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceUsersOutput: Swift.Equatable {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The information for each requested AppInstanceUser.
    public var appInstanceUsers: [ChimeClientTypes.AppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        appInstanceUsers: [ChimeClientTypes.AppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceUsers = appInstanceUsers
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUsersOutputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let appInstanceUsers: [ChimeClientTypes.AppInstanceUserSummary]?
    let nextToken: Swift.String?
}

extension ListAppInstanceUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUsers = "AppInstanceUsers"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceUsersContainer = try containerValues.decodeIfPresent([ChimeClientTypes.AppInstanceUserSummary?].self, forKey: .appInstanceUsers)
        var appInstanceUsersDecoded0:[ChimeClientTypes.AppInstanceUserSummary]? = nil
        if let appInstanceUsersContainer = appInstanceUsersContainer {
            appInstanceUsersDecoded0 = [ChimeClientTypes.AppInstanceUserSummary]()
            for structure0 in appInstanceUsersContainer {
                if let structure0 = structure0 {
                    appInstanceUsersDecoded0?.append(structure0)
                }
            }
        }
        appInstanceUsers = appInstanceUsersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppInstanceUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstancesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAppInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instances"
    }
}

public struct ListAppInstancesInput: Swift.Equatable {
    /// The maximum number of AppInstances that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API requests until you reach the maximum number of AppInstances.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstancesInputBody: Swift.Equatable {
}

extension ListAppInstancesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstancesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstancesOutput(appInstances: \(Swift.String(describing: appInstances)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstances = output.appInstances
            self.nextToken = output.nextToken
        } else {
            self.appInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstancesOutput: Swift.Equatable {
    /// The information for each AppInstance.
    public var appInstances: [ChimeClientTypes.AppInstanceSummary]?
    /// The token passed by previous API requests until the maximum number of AppInstances is reached.
    public var nextToken: Swift.String?

    public init(
        appInstances: [ChimeClientTypes.AppInstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstances = appInstances
        self.nextToken = nextToken
    }
}

struct ListAppInstancesOutputBody: Swift.Equatable {
    let appInstances: [ChimeClientTypes.AppInstanceSummary]?
    let nextToken: Swift.String?
}

extension ListAppInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstances = "AppInstances"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstancesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.AppInstanceSummary?].self, forKey: .appInstances)
        var appInstancesDecoded0:[ChimeClientTypes.AppInstanceSummary]? = nil
        if let appInstancesContainer = appInstancesContainer {
            appInstancesDecoded0 = [ChimeClientTypes.AppInstanceSummary]()
            for structure0 in appInstancesContainer {
                if let structure0 = structure0 {
                    appInstancesDecoded0?.append(structure0)
                }
            }
        }
        appInstances = appInstancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAttendeeTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        guard let attendeeId = attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())/tags"
    }
}

public struct ListAttendeeTagsInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

struct ListAttendeeTagsInputBody: Swift.Equatable {
}

extension ListAttendeeTagsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAttendeeTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAttendeeTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListAttendeeTagsOutput: Swift.Equatable {
    /// A list of tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListAttendeeTagsOutputBody: Swift.Equatable {
    let tags: [ChimeClientTypes.Tag]?
}

extension ListAttendeeTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListAttendeeTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAttendeesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAttendeesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

public struct ListAttendeesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        meetingId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.meetingId = meetingId
        self.nextToken = nextToken
    }
}

struct ListAttendeesInputBody: Swift.Equatable {
}

extension ListAttendeesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAttendeesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAttendeesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attendees = output.attendees
            self.nextToken = output.nextToken
        } else {
            self.attendees = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttendeesOutput: Swift.Equatable {
    /// The Amazon Chime SDK attendee information.
    public var attendees: [ChimeClientTypes.Attendee]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        attendees: [ChimeClientTypes.Attendee]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attendees = attendees
        self.nextToken = nextToken
    }
}

struct ListAttendeesOutputBody: Swift.Equatable {
    let attendees: [ChimeClientTypes.Attendee]?
    let nextToken: Swift.String?
}

extension ListAttendeesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Attendee?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeClientTypes.Attendee]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeClientTypes.Attendee]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAttendeesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBotsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots"
    }
}

public struct ListBotsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. The default is 10.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBotsInputBody: Swift.Equatable {
}

extension ListBotsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.bots = output.bots
            self.nextToken = output.nextToken
        } else {
            self.bots = nil
            self.nextToken = nil
        }
    }
}

public struct ListBotsOutput: Swift.Equatable {
    /// List of bots and bot details.
    public var bots: [ChimeClientTypes.Bot]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        bots: [ChimeClientTypes.Bot]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bots = bots
        self.nextToken = nextToken
    }
}

struct ListBotsOutputBody: Swift.Equatable {
    let bots: [ChimeClientTypes.Bot]?
    let nextToken: Swift.String?
}

extension ListBotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bots = "Bots"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Bot?].self, forKey: .bots)
        var botsDecoded0:[ChimeClientTypes.Bot]? = nil
        if let botsContainer = botsContainer {
            botsDecoded0 = [ChimeClientTypes.Bot]()
            for structure0 in botsContainer {
                if let structure0 = structure0 {
                    botsDecoded0?.append(structure0)
                }
            }
        }
        bots = botsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListChannelBansInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelBansInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelBansInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelBansInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelBansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans"
    }
}

public struct ListChannelBansInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of bans that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested bans are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelBansInputBody: Swift.Equatable {
}

extension ListChannelBansInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelBansOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelBansOutput(channelArn: \(Swift.String(describing: channelArn)), channelBans: \(Swift.String(describing: channelBans)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelBansOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChannelBansOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelBans = output.channelBans
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelBans = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelBansOutput: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information for each requested ban.
    public var channelBans: [ChimeClientTypes.ChannelBanSummary]?
    /// The token passed by previous API calls until all requested bans are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelBans: [ChimeClientTypes.ChannelBanSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelBans = channelBans
        self.nextToken = nextToken
    }
}

struct ListChannelBansOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let channelBans: [ChimeClientTypes.ChannelBanSummary]?
}

extension ListChannelBansOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelBans = "ChannelBans"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelBansContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelBanSummary?].self, forKey: .channelBans)
        var channelBansDecoded0:[ChimeClientTypes.ChannelBanSummary]? = nil
        if let channelBansContainer = channelBansContainer {
            channelBansDecoded0 = [ChimeClientTypes.ChannelBanSummary]()
            for structure0 in channelBansContainer {
                if let structure0 = structure0 {
                    channelBansDecoded0?.append(structure0)
                }
            }
        }
        channelBans = channelBansDecoded0
    }
}

enum ListChannelBansOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsForAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelMembershipsForAppInstanceUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-memberships"))
            if let appInstanceUserArn = appInstanceUserArn {
                let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
                items.append(appInstanceUserArnQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelMembershipsForAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUsers
    public var appInstanceUserArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of users that you want returned.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channel memberships is reached.
    public var nextToken: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsForAppInstanceUserInputBody: Swift.Equatable {
}

extension ListChannelMembershipsForAppInstanceUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelMembershipsForAppInstanceUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsForAppInstanceUserOutput(channelMemberships: \(Swift.String(describing: channelMemberships)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelMembershipsForAppInstanceUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChannelMembershipsForAppInstanceUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelMemberships = output.channelMemberships
            self.nextToken = output.nextToken
        } else {
            self.channelMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMembershipsForAppInstanceUserOutput: Swift.Equatable {
    /// The information for the requested channel memberships.
    public var channelMemberships: [ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init(
        channelMemberships: [ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsForAppInstanceUserOutputBody: Swift.Equatable {
    let channelMemberships: [ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary]?
    let nextToken: Swift.String?
}

extension ListChannelMembershipsForAppInstanceUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMemberships = "ChannelMemberships"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary?].self, forKey: .channelMemberships)
        var channelMembershipsDecoded0:[ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary]? = nil
        if let channelMembershipsContainer = channelMembershipsContainer {
            channelMembershipsDecoded0 = [ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary]()
            for structure0 in channelMembershipsContainer {
                if let structure0 = structure0 {
                    channelMembershipsDecoded0?.append(structure0)
                }
            }
        }
        channelMemberships = channelMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChannelMembershipsForAppInstanceUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListChannelMembershipsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), type: \(Swift.String(describing: type)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelMembershipsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMembershipsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelMembershipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

public struct ListChannelMembershipsInput: Swift.Equatable {
    /// The maximum number of channel memberships that you want returned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of channel memberships that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channel memberships are returned.
    public var nextToken: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned.
    public var type: ChimeClientTypes.ChannelMembershipType?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: ChimeClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListChannelMembershipsInputBody: Swift.Equatable {
}

extension ListChannelMembershipsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelMembershipsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsOutput(channelArn: \(Swift.String(describing: channelArn)), channelMemberships: \(Swift.String(describing: channelMemberships)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelMembershipsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChannelMembershipsOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelMemberships = output.channelMemberships
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMembershipsOutput: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information for the requested channel memberships.
    public var channelMemberships: [ChimeClientTypes.ChannelMembershipSummary]?
    /// The token passed by previous API calls until all requested channel memberships are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelMemberships: [ChimeClientTypes.ChannelMembershipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let channelMemberships: [ChimeClientTypes.ChannelMembershipSummary]?
    let nextToken: Swift.String?
}

extension ListChannelMembershipsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelMemberships = "ChannelMemberships"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let channelMembershipsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelMembershipSummary?].self, forKey: .channelMemberships)
        var channelMembershipsDecoded0:[ChimeClientTypes.ChannelMembershipSummary]? = nil
        if let channelMembershipsContainer = channelMembershipsContainer {
            channelMembershipsDecoded0 = [ChimeClientTypes.ChannelMembershipSummary]()
            for structure0 in channelMembershipsContainer {
                if let structure0 = structure0 {
                    channelMembershipsDecoded0?.append(structure0)
                }
            }
        }
        channelMemberships = channelMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChannelMembershipsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListChannelMessagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMessagesInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), notAfter: \(Swift.String(describing: notAfter)), notBefore: \(Swift.String(describing: notBefore)), sortOrder: \(Swift.String(describing: sortOrder)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelMessagesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMessagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sort-order".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let notBefore = notBefore {
                let notBeforeQueryItem = ClientRuntime.URLQueryItem(name: "not-before".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: notBefore)).urlPercentEncoding())
                items.append(notBeforeQueryItem)
            }
            if let notAfter = notAfter {
                let notAfterQueryItem = ClientRuntime.URLQueryItem(name: "not-after".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: notAfter)).urlPercentEncoding())
                items.append(notAfterQueryItem)
            }
            return items
        }
    }
}

extension ListChannelMessagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages"
    }
}

public struct ListChannelMessagesInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of messages that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested messages are returned.
    public var nextToken: Swift.String?
    /// The final or ending time stamp for your requested messages.
    public var notAfter: ClientRuntime.Date?
    /// The initial or starting time stamp for your requested messages.
    public var notBefore: ClientRuntime.Date?
    /// The order in which you want messages sorted. Default is Descending, based on time created.
    public var sortOrder: ChimeClientTypes.SortOrder?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notAfter: ClientRuntime.Date? = nil,
        notBefore: ClientRuntime.Date? = nil,
        sortOrder: ChimeClientTypes.SortOrder? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notAfter = notAfter
        self.notBefore = notBefore
        self.sortOrder = sortOrder
    }
}

struct ListChannelMessagesInputBody: Swift.Equatable {
}

extension ListChannelMessagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelMessagesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMessagesOutput(channelArn: \(Swift.String(describing: channelArn)), channelMessages: \(Swift.String(describing: channelMessages)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelMessagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChannelMessagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelMessages = output.channelMessages
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelMessages = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMessagesOutput: Swift.Equatable {
    /// The ARN of the channel containing the requested messages.
    public var channelArn: Swift.String?
    /// The information about, and content of, each requested message.
    public var channelMessages: [ChimeClientTypes.ChannelMessageSummary]?
    /// The token passed by previous API calls until all requested messages are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelMessages: [ChimeClientTypes.ChannelMessageSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMessages = channelMessages
        self.nextToken = nextToken
    }
}

struct ListChannelMessagesOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let channelMessages: [ChimeClientTypes.ChannelMessageSummary]?
}

extension ListChannelMessagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelMessages = "ChannelMessages"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelMessagesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelMessageSummary?].self, forKey: .channelMessages)
        var channelMessagesDecoded0:[ChimeClientTypes.ChannelMessageSummary]? = nil
        if let channelMessagesContainer = channelMessagesContainer {
            channelMessagesDecoded0 = [ChimeClientTypes.ChannelMessageSummary]()
            for structure0 in channelMessagesContainer {
                if let structure0 = structure0 {
                    channelMessagesDecoded0?.append(structure0)
                }
            }
        }
        channelMessages = channelMessagesDecoded0
    }
}

enum ListChannelMessagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListChannelModeratorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelModeratorsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelModeratorsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelModeratorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelModeratorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators"
    }
}

public struct ListChannelModeratorsInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of moderators that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested moderators are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelModeratorsInputBody: Swift.Equatable {
}

extension ListChannelModeratorsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelModeratorsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelModeratorsOutput(channelArn: \(Swift.String(describing: channelArn)), channelModerators: \(Swift.String(describing: channelModerators)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelModeratorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChannelModeratorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelModerators = output.channelModerators
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelModerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelModeratorsOutput: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information about and names of each moderator.
    public var channelModerators: [ChimeClientTypes.ChannelModeratorSummary]?
    /// The token passed by previous API calls until all requested moderators are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelModerators: [ChimeClientTypes.ChannelModeratorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerators = channelModerators
        self.nextToken = nextToken
    }
}

struct ListChannelModeratorsOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let channelModerators: [ChimeClientTypes.ChannelModeratorSummary]?
}

extension ListChannelModeratorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelModerators = "ChannelModerators"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelModeratorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelModeratorSummary?].self, forKey: .channelModerators)
        var channelModeratorsDecoded0:[ChimeClientTypes.ChannelModeratorSummary]? = nil
        if let channelModeratorsContainer = channelModeratorsContainer {
            channelModeratorsDecoded0 = [ChimeClientTypes.ChannelModeratorSummary]()
            for structure0 in channelModeratorsContainer {
                if let structure0 = structure0 {
                    channelModeratorsDecoded0?.append(structure0)
                }
            }
        }
        channelModerators = channelModeratorsDecoded0
    }
}

enum ListChannelModeratorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), privacy: \(Swift.String(describing: privacy)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let privacy = privacy {
                let privacyQueryItem = ClientRuntime.URLQueryItem(name: "privacy".urlPercentEncoding(), value: Swift.String(privacy.rawValue).urlPercentEncoding())
                items.append(privacyQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let appInstanceArn = appInstanceArn else {
                let message = "Creating a URL Query Item failed. appInstanceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            items.append(appInstanceArnQueryItem)
            return items
        }
    }
}

extension ListChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of channels that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channels are returned.
    public var nextToken: Swift.String?
    /// The privacy setting. PUBLIC retrieves all the public channels. PRIVATE retrieves private channels. Only an AppInstanceAdmin can retrieve private channels.
    public var privacy: ChimeClientTypes.ChannelPrivacy?

    public init(
        appInstanceArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        privacy: ChimeClientTypes.ChannelPrivacy? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.privacy = privacy
    }
}

struct ListChannelsInputBody: Swift.Equatable {
}

extension ListChannelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsModeratedByAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelsModeratedByAppInstanceUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-moderated-channels"))
            if let appInstanceUserArn = appInstanceUserArn {
                let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
                items.append(appInstanceUserArnQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelsModeratedByAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user in the moderated channel.
    public var appInstanceUserArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of channels in the request.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channels moderated by the user is reached.
    public var nextToken: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsModeratedByAppInstanceUserInputBody: Swift.Equatable {
}

extension ListChannelsModeratedByAppInstanceUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsModeratedByAppInstanceUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsModeratedByAppInstanceUserOutput(channels: \(Swift.String(describing: channels)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelsModeratedByAppInstanceUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChannelsModeratedByAppInstanceUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsModeratedByAppInstanceUserOutput: Swift.Equatable {
    /// The moderated channels in the request.
    public var channels: [ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary]?
    /// The token returned from previous API requests until the number of channels moderated by the user is reached.
    public var nextToken: Swift.String?

    public init(
        channels: [ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsModeratedByAppInstanceUserOutputBody: Swift.Equatable {
    let channels: [ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary]?
    let nextToken: Swift.String?
}

extension ListChannelsModeratedByAppInstanceUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChannelsModeratedByAppInstanceUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListChannelsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsOutput(channels: \(Swift.String(describing: channels)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChannelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutput: Swift.Equatable {
    /// The information about each channel.
    public var channels: [ChimeClientTypes.ChannelSummary]?
    /// The token returned from previous API requests until the number of channels is reached.
    public var nextToken: Swift.String?

    public init(
        channels: [ChimeClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputBody: Swift.Equatable {
    let channels: [ChimeClientTypes.ChannelSummary]?
    let nextToken: Swift.String?
}

extension ListChannelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ChannelSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeClientTypes.ChannelSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeClientTypes.ChannelSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChannelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMediaCapturePipelinesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMediaCapturePipelinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/media-capture-pipelines"
    }
}

public struct ListMediaCapturePipelinesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMediaCapturePipelinesInputBody: Swift.Equatable {
}

extension ListMediaCapturePipelinesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMediaCapturePipelinesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMediaCapturePipelinesOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipelines = output.mediaCapturePipelines
            self.nextToken = output.nextToken
        } else {
            self.mediaCapturePipelines = nil
            self.nextToken = nil
        }
    }
}

public struct ListMediaCapturePipelinesOutput: Swift.Equatable {
    /// The media capture pipeline objects in the list.
    public var mediaCapturePipelines: [ChimeClientTypes.MediaCapturePipeline]?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        mediaCapturePipelines: [ChimeClientTypes.MediaCapturePipeline]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mediaCapturePipelines = mediaCapturePipelines
        self.nextToken = nextToken
    }
}

struct ListMediaCapturePipelinesOutputBody: Swift.Equatable {
    let mediaCapturePipelines: [ChimeClientTypes.MediaCapturePipeline]?
    let nextToken: Swift.String?
}

extension ListMediaCapturePipelinesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipelines = "MediaCapturePipelines"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelinesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.MediaCapturePipeline?].self, forKey: .mediaCapturePipelines)
        var mediaCapturePipelinesDecoded0:[ChimeClientTypes.MediaCapturePipeline]? = nil
        if let mediaCapturePipelinesContainer = mediaCapturePipelinesContainer {
            mediaCapturePipelinesDecoded0 = [ChimeClientTypes.MediaCapturePipeline]()
            for structure0 in mediaCapturePipelinesContainer {
                if let structure0 = structure0 {
                    mediaCapturePipelinesDecoded0?.append(structure0)
                }
            }
        }
        mediaCapturePipelines = mediaCapturePipelinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMediaCapturePipelinesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMeetingTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/tags"
    }
}

public struct ListMeetingTagsInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct ListMeetingTagsInputBody: Swift.Equatable {
}

extension ListMeetingTagsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMeetingTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMeetingTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListMeetingTagsOutput: Swift.Equatable {
    /// A list of tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListMeetingTagsOutputBody: Swift.Equatable {
    let tags: [ChimeClientTypes.Tag]?
}

extension ListMeetingTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListMeetingTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMeetingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMeetingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/meetings"
    }
}

public struct ListMeetingsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMeetingsInputBody: Swift.Equatable {
}

extension ListMeetingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMeetingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMeetingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.meetings = output.meetings
            self.nextToken = output.nextToken
        } else {
            self.meetings = nil
            self.nextToken = nil
        }
    }
}

public struct ListMeetingsOutput: Swift.Equatable {
    /// The Amazon Chime SDK meeting information.
    public var meetings: [ChimeClientTypes.Meeting]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        meetings: [ChimeClientTypes.Meeting]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.meetings = meetings
        self.nextToken = nextToken
    }
}

struct ListMeetingsOutputBody: Swift.Equatable {
    let meetings: [ChimeClientTypes.Meeting]?
    let nextToken: Swift.String?
}

extension ListMeetingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meetings = "Meetings"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Meeting?].self, forKey: .meetings)
        var meetingsDecoded0:[ChimeClientTypes.Meeting]? = nil
        if let meetingsContainer = meetingsContainer {
            meetingsDecoded0 = [ChimeClientTypes.Meeting]()
            for structure0 in meetingsContainer {
                if let structure0 = structure0 {
                    meetingsDecoded0?.append(structure0)
                }
            }
        }
        meetings = meetingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMeetingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPhoneNumberOrdersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPhoneNumberOrdersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number-orders"
    }
}

public struct ListPhoneNumberOrdersInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPhoneNumberOrdersInputBody: Swift.Equatable {
}

extension ListPhoneNumberOrdersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPhoneNumberOrdersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPhoneNumberOrdersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumberOrders = output.phoneNumberOrders
        } else {
            self.nextToken = nil
            self.phoneNumberOrders = nil
        }
    }
}

public struct ListPhoneNumberOrdersOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number order details.
    public var phoneNumberOrders: [ChimeClientTypes.PhoneNumberOrder]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumberOrders: [ChimeClientTypes.PhoneNumberOrder]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumberOrders = phoneNumberOrders
    }
}

struct ListPhoneNumberOrdersOutputBody: Swift.Equatable {
    let phoneNumberOrders: [ChimeClientTypes.PhoneNumberOrder]?
    let nextToken: Swift.String?
}

extension ListPhoneNumberOrdersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumberOrders = "PhoneNumberOrders"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrdersContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberOrder?].self, forKey: .phoneNumberOrders)
        var phoneNumberOrdersDecoded0:[ChimeClientTypes.PhoneNumberOrder]? = nil
        if let phoneNumberOrdersContainer = phoneNumberOrdersContainer {
            phoneNumberOrdersDecoded0 = [ChimeClientTypes.PhoneNumberOrder]()
            for structure0 in phoneNumberOrdersContainer {
                if let structure0 = structure0 {
                    phoneNumberOrdersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberOrders = phoneNumberOrdersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPhoneNumberOrdersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPhoneNumbersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let productType = productType {
                let productTypeQueryItem = ClientRuntime.URLQueryItem(name: "product-type".urlPercentEncoding(), value: Swift.String(productType.rawValue).urlPercentEncoding())
                items.append(productTypeQueryItem)
            }
            if let filterName = filterName {
                let filterNameQueryItem = ClientRuntime.URLQueryItem(name: "filter-name".urlPercentEncoding(), value: Swift.String(filterName.rawValue).urlPercentEncoding())
                items.append(filterNameQueryItem)
            }
            if let filterValue = filterValue {
                let filterValueQueryItem = ClientRuntime.URLQueryItem(name: "filter-value".urlPercentEncoding(), value: Swift.String(filterValue).urlPercentEncoding())
                items.append(filterValueQueryItem)
            }
            return items
        }
    }
}

extension ListPhoneNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-numbers"
    }
}

public struct ListPhoneNumbersInput: Swift.Equatable {
    /// The filter to use to limit the number of results.
    public var filterName: ChimeClientTypes.PhoneNumberAssociationName?
    /// The value to use for the filter.
    public var filterValue: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number product type.
    public var productType: ChimeClientTypes.PhoneNumberProductType?
    /// The phone number status.
    public var status: ChimeClientTypes.PhoneNumberStatus?

    public init(
        filterName: ChimeClientTypes.PhoneNumberAssociationName? = nil,
        filterValue: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        productType: ChimeClientTypes.PhoneNumberProductType? = nil,
        status: ChimeClientTypes.PhoneNumberStatus? = nil
    )
    {
        self.filterName = filterName
        self.filterValue = filterValue
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.productType = productType
        self.status = status
    }
}

struct ListPhoneNumbersInputBody: Swift.Equatable {
}

extension ListPhoneNumbersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPhoneNumbersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPhoneNumbersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct ListPhoneNumbersOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number details.
    public var phoneNumbers: [ChimeClientTypes.PhoneNumber]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [ChimeClientTypes.PhoneNumber]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListPhoneNumbersOutputBody: Swift.Equatable {
    let phoneNumbers: [ChimeClientTypes.PhoneNumber]?
    let nextToken: Swift.String?
}

extension ListPhoneNumbersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumbersContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[ChimeClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [ChimeClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPhoneNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProxySessionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProxySessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions"
    }
}

public struct ListProxySessionsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The proxy session status.
    public var status: ChimeClientTypes.ProxySessionStatus?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: ChimeClientTypes.ProxySessionStatus? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.voiceConnectorId = voiceConnectorId
    }
}

struct ListProxySessionsInputBody: Swift.Equatable {
}

extension ListProxySessionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProxySessionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProxySessionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proxySessions = output.proxySessions
        } else {
            self.nextToken = nil
            self.proxySessions = nil
        }
    }
}

public struct ListProxySessionsOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The proxy session details.
    public var proxySessions: [ChimeClientTypes.ProxySession]?

    public init(
        nextToken: Swift.String? = nil,
        proxySessions: [ChimeClientTypes.ProxySession]? = nil
    )
    {
        self.nextToken = nextToken
        self.proxySessions = proxySessions
    }
}

struct ListProxySessionsOutputBody: Swift.Equatable {
    let proxySessions: [ChimeClientTypes.ProxySession]?
    let nextToken: Swift.String?
}

extension ListProxySessionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proxySessions = "ProxySessions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.ProxySession?].self, forKey: .proxySessions)
        var proxySessionsDecoded0:[ChimeClientTypes.ProxySession]? = nil
        if let proxySessionsContainer = proxySessionsContainer {
            proxySessionsDecoded0 = [ChimeClientTypes.ProxySession]()
            for structure0 in proxySessionsContainer {
                if let structure0 = structure0 {
                    proxySessionsDecoded0?.append(structure0)
                }
            }
        }
        proxySessions = proxySessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProxySessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRoomMembershipsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRoomMembershipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let roomId = roomId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships"
    }
}

public struct ListRoomMembershipsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.roomId = roomId
    }
}

struct ListRoomMembershipsInputBody: Swift.Equatable {
}

extension ListRoomMembershipsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRoomMembershipsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRoomMembershipsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.roomMemberships = output.roomMemberships
        } else {
            self.nextToken = nil
            self.roomMemberships = nil
        }
    }
}

public struct ListRoomMembershipsOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The room membership details.
    public var roomMemberships: [ChimeClientTypes.RoomMembership]?

    public init(
        nextToken: Swift.String? = nil,
        roomMemberships: [ChimeClientTypes.RoomMembership]? = nil
    )
    {
        self.nextToken = nextToken
        self.roomMemberships = roomMemberships
    }
}

struct ListRoomMembershipsOutputBody: Swift.Equatable {
    let roomMemberships: [ChimeClientTypes.RoomMembership]?
    let nextToken: Swift.String?
}

extension ListRoomMembershipsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case roomMemberships = "RoomMemberships"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomMembershipsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.RoomMembership?].self, forKey: .roomMemberships)
        var roomMembershipsDecoded0:[ChimeClientTypes.RoomMembership]? = nil
        if let roomMembershipsContainer = roomMembershipsContainer {
            roomMembershipsDecoded0 = [ChimeClientTypes.RoomMembership]()
            for structure0 in roomMembershipsContainer {
                if let structure0 = structure0 {
                    roomMembershipsDecoded0?.append(structure0)
                }
            }
        }
        roomMemberships = roomMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRoomMembershipsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRoomsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let memberId = memberId {
                let memberIdQueryItem = ClientRuntime.URLQueryItem(name: "member-id".urlPercentEncoding(), value: Swift.String(memberId).urlPercentEncoding())
                items.append(memberIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRoomsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms"
    }
}

public struct ListRoomsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The member ID (user ID or bot ID).
    public var memberId: Swift.String?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        memberId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.memberId = memberId
        self.nextToken = nextToken
    }
}

struct ListRoomsInputBody: Swift.Equatable {
}

extension ListRoomsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRoomsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRoomsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rooms = output.rooms
        } else {
            self.nextToken = nil
            self.rooms = nil
        }
    }
}

public struct ListRoomsOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The room details.
    public var rooms: [ChimeClientTypes.Room]?

    public init(
        nextToken: Swift.String? = nil,
        rooms: [ChimeClientTypes.Room]? = nil
    )
    {
        self.nextToken = nextToken
        self.rooms = rooms
    }
}

struct ListRoomsOutputBody: Swift.Equatable {
    let rooms: [ChimeClientTypes.Room]?
    let nextToken: Swift.String?
}

extension ListRoomsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rooms = "Rooms"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Room?].self, forKey: .rooms)
        var roomsDecoded0:[ChimeClientTypes.Room]? = nil
        if let roomsContainer = roomsContainer {
            roomsDecoded0 = [ChimeClientTypes.Room]()
            for structure0 in roomsContainer {
                if let structure0 = structure0 {
                    roomsDecoded0?.append(structure0)
                }
            }
        }
        rooms = roomsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRoomsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSipMediaApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSipMediaApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sip-media-applications"
    }
}

public struct ListSipMediaApplicationsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSipMediaApplicationsInputBody: Swift.Equatable {
}

extension ListSipMediaApplicationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSipMediaApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSipMediaApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sipMediaApplications = output.sipMediaApplications
        } else {
            self.nextToken = nil
            self.sipMediaApplications = nil
        }
    }
}

public struct ListSipMediaApplicationsOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// List of SIP media applications and application details.
    public var sipMediaApplications: [ChimeClientTypes.SipMediaApplication]?

    public init(
        nextToken: Swift.String? = nil,
        sipMediaApplications: [ChimeClientTypes.SipMediaApplication]? = nil
    )
    {
        self.nextToken = nextToken
        self.sipMediaApplications = sipMediaApplications
    }
}

struct ListSipMediaApplicationsOutputBody: Swift.Equatable {
    let sipMediaApplications: [ChimeClientTypes.SipMediaApplication]?
    let nextToken: Swift.String?
}

extension ListSipMediaApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sipMediaApplications = "SipMediaApplications"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipMediaApplication?].self, forKey: .sipMediaApplications)
        var sipMediaApplicationsDecoded0:[ChimeClientTypes.SipMediaApplication]? = nil
        if let sipMediaApplicationsContainer = sipMediaApplicationsContainer {
            sipMediaApplicationsDecoded0 = [ChimeClientTypes.SipMediaApplication]()
            for structure0 in sipMediaApplicationsContainer {
                if let structure0 = structure0 {
                    sipMediaApplicationsDecoded0?.append(structure0)
                }
            }
        }
        sipMediaApplications = sipMediaApplicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSipMediaApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSipRulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let sipMediaApplicationId = sipMediaApplicationId {
                let sipMediaApplicationIdQueryItem = ClientRuntime.URLQueryItem(name: "sip-media-application".urlPercentEncoding(), value: Swift.String(sipMediaApplicationId).urlPercentEncoding())
                items.append(sipMediaApplicationIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSipRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sip-rules"
    }
}

public struct ListSipRulesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The SIP media application ID.
    public var sipMediaApplicationId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct ListSipRulesInputBody: Swift.Equatable {
}

extension ListSipRulesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSipRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSipRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sipRules = output.sipRules
        } else {
            self.nextToken = nil
            self.sipRules = nil
        }
    }
}

public struct ListSipRulesOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// List of SIP rules and rule details.
    public var sipRules: [ChimeClientTypes.SipRule]?

    public init(
        nextToken: Swift.String? = nil,
        sipRules: [ChimeClientTypes.SipRule]? = nil
    )
    {
        self.nextToken = nextToken
        self.sipRules = sipRules
    }
}

struct ListSipRulesOutputBody: Swift.Equatable {
    let sipRules: [ChimeClientTypes.SipRule]?
    let nextToken: Swift.String?
}

extension ListSipRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sipRules = "SipRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRulesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipRule?].self, forKey: .sipRules)
        var sipRulesDecoded0:[ChimeClientTypes.SipRule]? = nil
        if let sipRulesContainer = sipRulesContainer {
            sipRulesDecoded0 = [ChimeClientTypes.SipRule]()
            for structure0 in sipRulesContainer {
                if let structure0 = structure0 {
                    sipRulesDecoded0?.append(structure0)
                }
            }
        }
        sipRules = sipRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSipRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSupportedPhoneNumberCountriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let productType = productType else {
                let message = "Creating a URL Query Item failed. productType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let productTypeQueryItem = ClientRuntime.URLQueryItem(name: "product-type".urlPercentEncoding(), value: Swift.String(productType.rawValue).urlPercentEncoding())
            items.append(productTypeQueryItem)
            return items
        }
    }
}

extension ListSupportedPhoneNumberCountriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number-countries"
    }
}

public struct ListSupportedPhoneNumberCountriesInput: Swift.Equatable {
    /// The phone number product type.
    /// This member is required.
    public var productType: ChimeClientTypes.PhoneNumberProductType?

    public init(
        productType: ChimeClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.productType = productType
    }
}

struct ListSupportedPhoneNumberCountriesInputBody: Swift.Equatable {
}

extension ListSupportedPhoneNumberCountriesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSupportedPhoneNumberCountriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSupportedPhoneNumberCountriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberCountries = output.phoneNumberCountries
        } else {
            self.phoneNumberCountries = nil
        }
    }
}

public struct ListSupportedPhoneNumberCountriesOutput: Swift.Equatable {
    /// The supported phone number countries.
    public var phoneNumberCountries: [ChimeClientTypes.PhoneNumberCountry]?

    public init(
        phoneNumberCountries: [ChimeClientTypes.PhoneNumberCountry]? = nil
    )
    {
        self.phoneNumberCountries = phoneNumberCountries
    }
}

struct ListSupportedPhoneNumberCountriesOutputBody: Swift.Equatable {
    let phoneNumberCountries: [ChimeClientTypes.PhoneNumberCountry]?
}

extension ListSupportedPhoneNumberCountriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberCountries = "PhoneNumberCountries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberCountriesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberCountry?].self, forKey: .phoneNumberCountries)
        var phoneNumberCountriesDecoded0:[ChimeClientTypes.PhoneNumberCountry]? = nil
        if let phoneNumberCountriesContainer = phoneNumberCountriesContainer {
            phoneNumberCountriesDecoded0 = [ChimeClientTypes.PhoneNumberCountry]()
            for structure0 in phoneNumberCountriesContainer {
                if let structure0 = structure0 {
                    phoneNumberCountriesDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberCountries = phoneNumberCountriesDecoded0
    }
}

enum ListSupportedPhoneNumberCountriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceARN = resourceARN else {
                let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tag-key value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [ChimeClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersInput(accountId: \(Swift.String(describing: accountId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), userType: \(Swift.String(describing: userType)), userEmail: \"CONTENT_REDACTED\")"}
}

extension ListUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let userEmail = userEmail {
                let userEmailQueryItem = ClientRuntime.URLQueryItem(name: "user-email".urlPercentEncoding(), value: Swift.String(userEmail).urlPercentEncoding())
                items.append(userEmailQueryItem)
            }
            if let userType = userType {
                let userTypeQueryItem = ClientRuntime.URLQueryItem(name: "user-type".urlPercentEncoding(), value: Swift.String(userType.rawValue).urlPercentEncoding())
                items.append(userTypeQueryItem)
            }
            return items
        }
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Optional. The user email address used to filter results. Maximum 1.
    public var userEmail: Swift.String?
    /// The user type.
    public var userType: ChimeClientTypes.UserType?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userEmail: Swift.String? = nil,
        userType: ChimeClientTypes.UserType? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userEmail = userEmail
        self.userType = userType
    }
}

struct ListUsersInputBody: Swift.Equatable {
}

extension ListUsersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// List of users and user details.
    public var users: [ChimeClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        users: [ChimeClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputBody: Swift.Equatable {
    let users: [ChimeClientTypes.User]?
    let nextToken: Swift.String?
}

extension ListUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([ChimeClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[ChimeClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [ChimeClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceConnectorGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListVoiceConnectorGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connector-groups"
    }
}

public struct ListVoiceConnectorGroupsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVoiceConnectorGroupsInputBody: Swift.Equatable {
}

extension ListVoiceConnectorGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceConnectorGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceConnectorGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceConnectorGroups = output.voiceConnectorGroups
        } else {
            self.nextToken = nil
            self.voiceConnectorGroups = nil
        }
    }
}

public struct ListVoiceConnectorGroupsOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The details of the Amazon Chime Voice Connector groups.
    public var voiceConnectorGroups: [ChimeClientTypes.VoiceConnectorGroup]?

    public init(
        nextToken: Swift.String? = nil,
        voiceConnectorGroups: [ChimeClientTypes.VoiceConnectorGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceConnectorGroups = voiceConnectorGroups
    }
}

struct ListVoiceConnectorGroupsOutputBody: Swift.Equatable {
    let voiceConnectorGroups: [ChimeClientTypes.VoiceConnectorGroup]?
    let nextToken: Swift.String?
}

extension ListVoiceConnectorGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceConnectorGroups = "VoiceConnectorGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.VoiceConnectorGroup?].self, forKey: .voiceConnectorGroups)
        var voiceConnectorGroupsDecoded0:[ChimeClientTypes.VoiceConnectorGroup]? = nil
        if let voiceConnectorGroupsContainer = voiceConnectorGroupsContainer {
            voiceConnectorGroupsDecoded0 = [ChimeClientTypes.VoiceConnectorGroup]()
            for structure0 in voiceConnectorGroupsContainer {
                if let structure0 = structure0 {
                    voiceConnectorGroupsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorGroups = voiceConnectorGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVoiceConnectorGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceConnectorTerminationCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

public struct ListVoiceConnectorTerminationCredentialsInput: Swift.Equatable {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct ListVoiceConnectorTerminationCredentialsInputBody: Swift.Equatable {
}

extension ListVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceConnectorTerminationCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceConnectorTerminationCredentialsOutputBody = try responseDecoder.decode(responseBody: data)
            self.usernames = output.usernames
        } else {
            self.usernames = nil
        }
    }
}

public struct ListVoiceConnectorTerminationCredentialsOutput: Swift.Equatable {
    /// A list of user names.
    public var usernames: [Swift.String]?

    public init(
        usernames: [Swift.String]? = nil
    )
    {
        self.usernames = usernames
    }
}

struct ListVoiceConnectorTerminationCredentialsOutputBody: Swift.Equatable {
    let usernames: [Swift.String]?
}

extension ListVoiceConnectorTerminationCredentialsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usernames)
        var usernamesDecoded0:[Swift.String]? = nil
        if let usernamesContainer = usernamesContainer {
            usernamesDecoded0 = [Swift.String]()
            for string0 in usernamesContainer {
                if let string0 = string0 {
                    usernamesDecoded0?.append(string0)
                }
            }
        }
        usernames = usernamesDecoded0
    }
}

enum ListVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceConnectorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListVoiceConnectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connectors"
    }
}

public struct ListVoiceConnectorsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVoiceConnectorsInputBody: Swift.Equatable {
}

extension ListVoiceConnectorsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceConnectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceConnectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceConnectors = output.voiceConnectors
        } else {
            self.nextToken = nil
            self.voiceConnectors = nil
        }
    }
}

public struct ListVoiceConnectorsOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The details of the Amazon Chime Voice Connectors.
    public var voiceConnectors: [ChimeClientTypes.VoiceConnector]?

    public init(
        nextToken: Swift.String? = nil,
        voiceConnectors: [ChimeClientTypes.VoiceConnector]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceConnectors = voiceConnectors
    }
}

struct ListVoiceConnectorsOutputBody: Swift.Equatable {
    let voiceConnectors: [ChimeClientTypes.VoiceConnector]?
    let nextToken: Swift.String?
}

extension ListVoiceConnectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceConnectors = "VoiceConnectors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.VoiceConnector?].self, forKey: .voiceConnectors)
        var voiceConnectorsDecoded0:[ChimeClientTypes.VoiceConnector]? = nil
        if let voiceConnectorsContainer = voiceConnectorsContainer {
            voiceConnectorsDecoded0 = [ChimeClientTypes.VoiceConnector]()
            for structure0 in voiceConnectorsContainer {
                if let structure0 = structure0 {
                    voiceConnectorsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectors = voiceConnectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVoiceConnectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.LoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableMediaMetricLogs = "EnableMediaMetricLogs"
        case enableSIPLogs = "EnableSIPLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableMediaMetricLogs = self.enableMediaMetricLogs {
            try encodeContainer.encode(enableMediaMetricLogs, forKey: .enableMediaMetricLogs)
        }
        if let enableSIPLogs = self.enableSIPLogs {
            try encodeContainer.encode(enableSIPLogs, forKey: .enableSIPLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableSIPLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSIPLogs)
        enableSIPLogs = enableSIPLogsDecoded
        let enableMediaMetricLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMediaMetricLogs)
        enableMediaMetricLogs = enableMediaMetricLogsDecoded
    }
}

extension ChimeClientTypes {
    /// The logging configuration associated with an Amazon Chime Voice Connector. Specifies whether SIP message logs are enabled for sending to Amazon CloudWatch Logs.
    public struct LoggingConfiguration: Swift.Equatable {
        /// Boolean that enables logging of detailed media metrics for Voice Connectors to Amazon CloudWatch logs.
        public var enableMediaMetricLogs: Swift.Bool?
        /// Boolean that enables SIP message logs to Amazon CloudWatch logs.
        public var enableSIPLogs: Swift.Bool?

        public init(
            enableMediaMetricLogs: Swift.Bool? = nil,
            enableSIPLogs: Swift.Bool? = nil
        )
        {
            self.enableMediaMetricLogs = enableMediaMetricLogs
            self.enableSIPLogs = enableSIPLogs
        }
    }

}

extension LogoutUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "logout"))
            return items
        }
    }
}

extension LogoutUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct LogoutUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

struct LogoutUserInputBody: Swift.Equatable {
}

extension LogoutUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension LogoutUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct LogoutUserOutput: Swift.Equatable {

    public init() { }
}

enum LogoutUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.MediaCapturePipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case createdTimestamp = "CreatedTimestamp"
        case mediaPipelineId = "MediaPipelineId"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chimeSdkMeetingConfiguration = self.chimeSdkMeetingConfiguration {
            try encodeContainer.encode(chimeSdkMeetingConfiguration, forKey: .chimeSdkMeetingConfiguration)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
        if let sinkArn = self.sinkArn {
            try encodeContainer.encode(sinkArn, forKey: .sinkArn)
        }
        if let sinkType = self.sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaPipelineSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaPipelineStatus.self, forKey: .status)
        status = statusDecoded
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaPipelineSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let chimeSdkMeetingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChimeSdkMeetingConfiguration.self, forKey: .chimeSdkMeetingConfiguration)
        chimeSdkMeetingConfiguration = chimeSdkMeetingConfigurationDecoded
    }
}

extension ChimeClientTypes.MediaCapturePipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaCapturePipeline(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), mediaPipelineId: \(Swift.String(describing: mediaPipelineId)), sinkType: \(Swift.String(describing: sinkType)), sourceType: \(Swift.String(describing: sourceType)), status: \(Swift.String(describing: status)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), sinkArn: \"CONTENT_REDACTED\", sourceArn: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// A media capture pipeline object consisting of an ID, source type, source ARN, a sink type, a sink ARN, and a configuration object.
    public struct MediaCapturePipeline: Swift.Equatable {
        /// The configuration for a specified media capture pipeline. SourceType must be ChimeSdkMeeting.
        public var chimeSdkMeetingConfiguration: ChimeClientTypes.ChimeSdkMeetingConfiguration?
        /// The time at which the capture pipeline was created, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ID of a media capture pipeline.
        public var mediaPipelineId: Swift.String?
        /// ARN of the destination to which the media artifacts are saved.
        public var sinkArn: Swift.String?
        /// Destination type to which the media artifacts are saved. You must use an S3 Bucket.
        public var sinkType: ChimeClientTypes.MediaPipelineSinkType?
        /// ARN of the source from which the media artifacts will be saved.
        public var sourceArn: Swift.String?
        /// Source type from which media artifacts are saved. You must use ChimeMeeting.
        public var sourceType: ChimeClientTypes.MediaPipelineSourceType?
        /// The status of the media capture pipeline.
        public var status: ChimeClientTypes.MediaPipelineStatus?
        /// The time at which the capture pipeline was updated, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            chimeSdkMeetingConfiguration: ChimeClientTypes.ChimeSdkMeetingConfiguration? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinkArn: Swift.String? = nil,
            sinkType: ChimeClientTypes.MediaPipelineSinkType? = nil,
            sourceArn: Swift.String? = nil,
            sourceType: ChimeClientTypes.MediaPipelineSourceType? = nil,
            status: ChimeClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineId = mediaPipelineId
            self.sinkArn = sinkArn
            self.sinkType = sinkType
            self.sourceArn = sourceArn
            self.sourceType = sourceType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes {
    public enum MediaPipelineSinkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3bucket
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSinkType] {
            return [
                .s3bucket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3bucket: return "S3Bucket"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineSinkType(rawValue: rawValue) ?? MediaPipelineSinkType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum MediaPipelineSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chimesdkmeeting
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSourceType] {
            return [
                .chimesdkmeeting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chimesdkmeeting: return "ChimeSdkMeeting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineSourceType(rawValue: rawValue) ?? MediaPipelineSourceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum MediaPipelineStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case initializing
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineStatus] {
            return [
                .failed,
                .inprogress,
                .initializing,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .initializing: return "Initializing"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineStatus(rawValue: rawValue) ?? MediaPipelineStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.MediaPlacement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioFallbackUrl = "AudioFallbackUrl"
        case audioHostUrl = "AudioHostUrl"
        case eventIngestionUrl = "EventIngestionUrl"
        case screenDataUrl = "ScreenDataUrl"
        case screenSharingUrl = "ScreenSharingUrl"
        case screenViewingUrl = "ScreenViewingUrl"
        case signalingUrl = "SignalingUrl"
        case turnControlUrl = "TurnControlUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioFallbackUrl = self.audioFallbackUrl {
            try encodeContainer.encode(audioFallbackUrl, forKey: .audioFallbackUrl)
        }
        if let audioHostUrl = self.audioHostUrl {
            try encodeContainer.encode(audioHostUrl, forKey: .audioHostUrl)
        }
        if let eventIngestionUrl = self.eventIngestionUrl {
            try encodeContainer.encode(eventIngestionUrl, forKey: .eventIngestionUrl)
        }
        if let screenDataUrl = self.screenDataUrl {
            try encodeContainer.encode(screenDataUrl, forKey: .screenDataUrl)
        }
        if let screenSharingUrl = self.screenSharingUrl {
            try encodeContainer.encode(screenSharingUrl, forKey: .screenSharingUrl)
        }
        if let screenViewingUrl = self.screenViewingUrl {
            try encodeContainer.encode(screenViewingUrl, forKey: .screenViewingUrl)
        }
        if let signalingUrl = self.signalingUrl {
            try encodeContainer.encode(signalingUrl, forKey: .signalingUrl)
        }
        if let turnControlUrl = self.turnControlUrl {
            try encodeContainer.encode(turnControlUrl, forKey: .turnControlUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioHostUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioHostUrl)
        audioHostUrl = audioHostUrlDecoded
        let audioFallbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioFallbackUrl)
        audioFallbackUrl = audioFallbackUrlDecoded
        let screenDataUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenDataUrl)
        screenDataUrl = screenDataUrlDecoded
        let screenSharingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenSharingUrl)
        screenSharingUrl = screenSharingUrlDecoded
        let screenViewingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenViewingUrl)
        screenViewingUrl = screenViewingUrlDecoded
        let signalingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalingUrl)
        signalingUrl = signalingUrlDecoded
        let turnControlUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .turnControlUrl)
        turnControlUrl = turnControlUrlDecoded
        let eventIngestionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventIngestionUrl)
        eventIngestionUrl = eventIngestionUrlDecoded
    }
}

extension ChimeClientTypes {
    /// A set of endpoints used by clients to connect to the media service group for an Amazon Chime SDK meeting.
    public struct MediaPlacement: Swift.Equatable {
        /// The audio fallback URL.
        public var audioFallbackUrl: Swift.String?
        /// The audio host URL.
        public var audioHostUrl: Swift.String?
        /// The event ingestion URL to which you send client meeting events.
        public var eventIngestionUrl: Swift.String?
        /// The screen data URL. This parameter is is no longer supported and no longer used by the Amazon Chime SDK.
        public var screenDataUrl: Swift.String?
        /// The screen sharing URL. This parameter is is no longer supported and no longer used by the Amazon Chime SDK..
        public var screenSharingUrl: Swift.String?
        /// The screen viewing URL. This parameter is is no longer supported and no longer used by the Amazon Chime SDK.
        public var screenViewingUrl: Swift.String?
        /// The signaling URL.
        public var signalingUrl: Swift.String?
        /// The turn control URL. This parameter is is no longer supported and no longer used by the Amazon Chime SDK.
        public var turnControlUrl: Swift.String?

        public init(
            audioFallbackUrl: Swift.String? = nil,
            audioHostUrl: Swift.String? = nil,
            eventIngestionUrl: Swift.String? = nil,
            screenDataUrl: Swift.String? = nil,
            screenSharingUrl: Swift.String? = nil,
            screenViewingUrl: Swift.String? = nil,
            signalingUrl: Swift.String? = nil,
            turnControlUrl: Swift.String? = nil
        )
        {
            self.audioFallbackUrl = audioFallbackUrl
            self.audioHostUrl = audioHostUrl
            self.eventIngestionUrl = eventIngestionUrl
            self.screenDataUrl = screenDataUrl
            self.screenSharingUrl = screenSharingUrl
            self.screenViewingUrl = screenViewingUrl
            self.signalingUrl = signalingUrl
            self.turnControlUrl = turnControlUrl
        }
    }

}

extension ChimeClientTypes.Meeting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalMeetingId = "ExternalMeetingId"
        case mediaPlacement = "MediaPlacement"
        case mediaRegion = "MediaRegion"
        case meetingId = "MeetingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalMeetingId = self.externalMeetingId {
            try encodeContainer.encode(externalMeetingId, forKey: .externalMeetingId)
        }
        if let mediaPlacement = self.mediaPlacement {
            try encodeContainer.encode(mediaPlacement, forKey: .mediaPlacement)
        }
        if let mediaRegion = self.mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingId = self.meetingId {
            try encodeContainer.encode(meetingId, forKey: .meetingId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingId)
        meetingId = meetingIdDecoded
        let externalMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalMeetingId)
        externalMeetingId = externalMeetingIdDecoded
        let mediaPlacementDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MediaPlacement.self, forKey: .mediaPlacement)
        mediaPlacement = mediaPlacementDecoded
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
    }
}

extension ChimeClientTypes.Meeting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Meeting(mediaPlacement: \(Swift.String(describing: mediaPlacement)), mediaRegion: \(Swift.String(describing: mediaRegion)), meetingId: \(Swift.String(describing: meetingId)), externalMeetingId: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// A meeting created using the Amazon Chime SDK.
    public struct Meeting: Swift.Equatable {
        /// The external meeting ID.
        public var externalMeetingId: Swift.String?
        /// The media placement for the meeting.
        public var mediaPlacement: ChimeClientTypes.MediaPlacement?
        /// The Region in which you create the meeting. Available values: af-south-1, ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, ca-central-1, eu-central-1, eu-north-1, eu-south-1, eu-west-1, eu-west-2, eu-west-3, sa-east-1, us-east-1, us-east-2, us-west-1, us-west-2.
        public var mediaRegion: Swift.String?
        /// The Amazon Chime SDK meeting ID.
        public var meetingId: Swift.String?

        public init(
            externalMeetingId: Swift.String? = nil,
            mediaPlacement: ChimeClientTypes.MediaPlacement? = nil,
            mediaRegion: Swift.String? = nil,
            meetingId: Swift.String? = nil
        )
        {
            self.externalMeetingId = externalMeetingId
            self.mediaPlacement = mediaPlacement
            self.mediaRegion = mediaRegion
            self.meetingId = meetingId
        }
    }

}

extension ChimeClientTypes.MeetingNotificationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snsTopicArn = "SnsTopicArn"
        case sqsQueueArn = "SqsQueueArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sqsQueueArn = self.sqsQueueArn {
            try encodeContainer.encode(sqsQueueArn, forKey: .sqsQueueArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sqsQueueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqsQueueArn)
        sqsQueueArn = sqsQueueArnDecoded
    }
}

extension ChimeClientTypes.MeetingNotificationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MeetingNotificationConfiguration(snsTopicArn: \"CONTENT_REDACTED\", sqsQueueArn: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The resource target configurations for receiving Amazon Chime SDK meeting and attendee event notifications. The Amazon Chime SDK supports resource targets located in the US East (N. Virginia) AWS Region (us-east-1).
    public struct MeetingNotificationConfiguration: Swift.Equatable {
        /// The SNS topic ARN.
        public var snsTopicArn: Swift.String?
        /// The SQS queue ARN.
        public var sqsQueueArn: Swift.String?

        public init(
            snsTopicArn: Swift.String? = nil,
            sqsQueueArn: Swift.String? = nil
        )
        {
            self.snsTopicArn = snsTopicArn
            self.sqsQueueArn = sqsQueueArn
        }
    }

}

extension ChimeClientTypes.Member: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case email = "Email"
        case fullName = "FullName"
        case memberId = "MemberId"
        case memberType = "MemberType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let fullName = self.fullName {
            try encodeContainer.encode(fullName, forKey: .fullName)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let memberType = self.memberType {
            try encodeContainer.encode(memberType.rawValue, forKey: .memberType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
        let memberTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.MemberType.self, forKey: .memberType)
        memberType = memberTypeDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let fullNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullName)
        fullName = fullNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ChimeClientTypes.Member: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Member(accountId: \(Swift.String(describing: accountId)), memberId: \(Swift.String(describing: memberId)), memberType: \(Swift.String(describing: memberType)), email: \"CONTENT_REDACTED\", fullName: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The member details, such as email address, name, member ID, and member type.
    public struct Member: Swift.Equatable {
        /// The Amazon Chime account ID.
        public var accountId: Swift.String?
        /// The member email address.
        public var email: Swift.String?
        /// The member name.
        public var fullName: Swift.String?
        /// The member ID (user ID or bot ID).
        public var memberId: Swift.String?
        /// The member type.
        public var memberType: ChimeClientTypes.MemberType?

        public init(
            accountId: Swift.String? = nil,
            email: Swift.String? = nil,
            fullName: Swift.String? = nil,
            memberId: Swift.String? = nil,
            memberType: ChimeClientTypes.MemberType? = nil
        )
        {
            self.accountId = accountId
            self.email = email
            self.fullName = fullName
            self.memberId = memberId
            self.memberType = memberType
        }
    }

}

extension ChimeClientTypes.MemberError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case memberId = "MemberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeClientTypes {
    /// The list of errors returned when a member action results in an error.
    public struct MemberError: Swift.Equatable {
        /// The error code.
        public var errorCode: ChimeClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The member ID.
        public var memberId: Swift.String?

        public init(
            errorCode: ChimeClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            memberId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memberId = memberId
        }
    }

}

extension ChimeClientTypes {
    public enum MemberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bot
        case user
        case webhook
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberType] {
            return [
                .bot,
                .user,
                .webhook,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bot: return "Bot"
            case .user: return "User"
            case .webhook: return "Webhook"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberType(rawValue: rawValue) ?? MemberType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.MembershipItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberId = "MemberId"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
        let roleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomMembershipRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension ChimeClientTypes {
    /// Membership details, such as member ID and member role.
    public struct MembershipItem: Swift.Equatable {
        /// The member ID.
        public var memberId: Swift.String?
        /// The member role.
        public var role: ChimeClientTypes.RoomMembershipRole?

        public init(
            memberId: Swift.String? = nil,
            role: ChimeClientTypes.RoomMembershipRole? = nil
        )
        {
            self.memberId = memberId
            self.role = role
        }
    }

}

extension ChimeClientTypes.MessagingSessionEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension ChimeClientTypes {
    /// The websocket endpoint used to connect to Amazon Chime SDK messaging.
    public struct MessagingSessionEndpoint: Swift.Equatable {
        /// The endpoint to which you establish a websocket connection.
        public var url: Swift.String?

        public init(
            url: Swift.String? = nil
        )
        {
            self.url = url
        }
    }

}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: ChimeClientTypes.ErrorCode?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes {
    public enum NotificationTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eventbridge
        case sns
        case sqs
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationTarget] {
            return [
                .eventbridge,
                .sns,
                .sqs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eventbridge: return "EventBridge"
            case .sns: return "SNS"
            case .sqs: return "SQS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationTarget(rawValue: rawValue) ?? NotificationTarget.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum NumberSelectionBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avoidsticky
        case prefersticky
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberSelectionBehavior] {
            return [
                .avoidsticky,
                .prefersticky,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avoidsticky: return "AvoidSticky"
            case .prefersticky: return "PreferSticky"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberSelectionBehavior(rawValue: rawValue) ?? NumberSelectionBehavior.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.OrderedPhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumber = "E164PhoneNumber"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumber = self.e164PhoneNumber {
            try encodeContainer.encode(e164PhoneNumber, forKey: .e164PhoneNumber)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .e164PhoneNumber)
        e164PhoneNumber = e164PhoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.OrderedPhoneNumberStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ChimeClientTypes.OrderedPhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrderedPhoneNumber(status: \(Swift.String(describing: status)), e164PhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// A phone number for which an order has been placed.
    public struct OrderedPhoneNumber: Swift.Equatable {
        /// The phone number, in E.164 format.
        public var e164PhoneNumber: Swift.String?
        /// The phone number status.
        public var status: ChimeClientTypes.OrderedPhoneNumberStatus?

        public init(
            e164PhoneNumber: Swift.String? = nil,
            status: ChimeClientTypes.OrderedPhoneNumberStatus? = nil
        )
        {
            self.e164PhoneNumber = e164PhoneNumber
            self.status = status
        }
    }

}

extension ChimeClientTypes {
    public enum OrderedPhoneNumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acquired
        case failed
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderedPhoneNumberStatus] {
            return [
                .acquired,
                .failed,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acquired: return "Acquired"
            case .failed: return "Failed"
            case .processing: return "Processing"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderedPhoneNumberStatus(rawValue: rawValue) ?? OrderedPhoneNumberStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.Origination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case routes = "Routes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let routes = routes {
            var routesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routes)
            for originationroute0 in routes {
                try routesContainer.encode(originationroute0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.OriginationRoute?].self, forKey: .routes)
        var routesDecoded0:[ChimeClientTypes.OriginationRoute]? = nil
        if let routesContainer = routesContainer {
            routesDecoded0 = [ChimeClientTypes.OriginationRoute]()
            for structure0 in routesContainer {
                if let structure0 = structure0 {
                    routesDecoded0?.append(structure0)
                }
            }
        }
        routes = routesDecoded0
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension ChimeClientTypes {
    /// Origination settings enable your SIP hosts to receive inbound calls using your Amazon Chime Voice Connector. The parameters listed below are not required, but you must use at least one.
    public struct Origination: Swift.Equatable {
        /// When origination settings are disabled, inbound calls are not enabled for your Amazon Chime Voice Connector. This parameter is not required, but you must specify this parameter or Routes.
        public var disabled: Swift.Bool?
        /// The call distribution properties defined for your SIP hosts. Valid range: Minimum value of 1. Maximum value of 20. This parameter is not required, but you must specify this parameter or Disabled.
        public var routes: [ChimeClientTypes.OriginationRoute]?

        public init(
            disabled: Swift.Bool? = nil,
            routes: [ChimeClientTypes.OriginationRoute]? = nil
        )
        {
            self.disabled = disabled
            self.routes = routes
        }
    }

}

extension ChimeClientTypes.OriginationRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case port = "Port"
        case priority = "Priority"
        case `protocol` = "Protocol"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.OriginationRouteProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension ChimeClientTypes {
    /// Origination routes define call distribution properties for your SIP hosts to receive inbound calls using your Amazon Chime Voice Connector. Limit: Ten origination routes for each Amazon Chime Voice Connector. The parameters listed below are not required, but you must use at least one.
    public struct OriginationRoute: Swift.Equatable {
        /// The FQDN or IP address to contact for origination traffic.
        public var host: Swift.String?
        /// The designated origination route port. Defaults to 5060.
        public var port: Swift.Int?
        /// The priority associated with the host, with 1 being the highest priority. Higher priority hosts are attempted first.
        public var priority: Swift.Int?
        /// The protocol to use for the origination route. Encryption-enabled Amazon Chime Voice Connectors use TCP protocol by default.
        public var `protocol`: ChimeClientTypes.OriginationRouteProtocol?
        /// The weight associated with the host. If hosts are equal in priority, calls are redistributed among them based on their relative weight.
        public var weight: Swift.Int?

        public init(
            host: Swift.String? = nil,
            port: Swift.Int? = nil,
            priority: Swift.Int? = nil,
            `protocol`: ChimeClientTypes.OriginationRouteProtocol? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.host = host
            self.port = port
            self.priority = priority
            self.`protocol` = `protocol`
            self.weight = weight
        }
    }

}

extension ChimeClientTypes {
    public enum OriginationRouteProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginationRouteProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginationRouteProtocol(rawValue: rawValue) ?? OriginationRouteProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.Participant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
        case proxyPhoneNumber = "ProxyPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let proxyPhoneNumber = self.proxyPhoneNumber {
            try encodeContainer.encode(proxyPhoneNumber, forKey: .proxyPhoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let proxyPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxyPhoneNumber)
        proxyPhoneNumber = proxyPhoneNumberDecoded
    }
}

extension ChimeClientTypes.Participant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Participant(phoneNumber: \"CONTENT_REDACTED\", proxyPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The phone number and proxy phone number for a participant in an Amazon Chime Voice Connector proxy session.
    public struct Participant: Swift.Equatable {
        /// The participant's phone number.
        public var phoneNumber: Swift.String?
        /// The participant's proxy phone number.
        public var proxyPhoneNumber: Swift.String?

        public init(
            phoneNumber: Swift.String? = nil,
            proxyPhoneNumber: Swift.String? = nil
        )
        {
            self.phoneNumber = phoneNumber
            self.proxyPhoneNumber = proxyPhoneNumber
        }
    }

}

extension ChimeClientTypes.PhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
        case callingName = "CallingName"
        case callingNameStatus = "CallingNameStatus"
        case capabilities = "Capabilities"
        case country = "Country"
        case createdTimestamp = "CreatedTimestamp"
        case deletionTimestamp = "DeletionTimestamp"
        case e164PhoneNumber = "E164PhoneNumber"
        case phoneNumberId = "PhoneNumberId"
        case productType = "ProductType"
        case status = "Status"
        case type = "Type"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associations = associations {
            var associationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associations)
            for phonenumberassociation0 in associations {
                try associationsContainer.encode(phonenumberassociation0)
            }
        }
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let callingNameStatus = self.callingNameStatus {
            try encodeContainer.encode(callingNameStatus.rawValue, forKey: .callingNameStatus)
        }
        if let capabilities = self.capabilities {
            try encodeContainer.encode(capabilities, forKey: .capabilities)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let deletionTimestamp = self.deletionTimestamp {
            try encodeContainer.encodeTimestamp(deletionTimestamp, format: .dateTime, forKey: .deletionTimestamp)
        }
        if let e164PhoneNumber = self.e164PhoneNumber {
            try encodeContainer.encode(e164PhoneNumber, forKey: .e164PhoneNumber)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let e164PhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .e164PhoneNumber)
        e164PhoneNumber = e164PhoneNumberDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberType.self, forKey: .type)
        type = typeDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberStatus.self, forKey: .status)
        status = statusDecoded
        let capabilitiesDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberCapabilities.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
        let associationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberAssociation?].self, forKey: .associations)
        var associationsDecoded0:[ChimeClientTypes.PhoneNumberAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [ChimeClientTypes.PhoneNumberAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
        let callingNameStatusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.CallingNameStatus.self, forKey: .callingNameStatus)
        callingNameStatus = callingNameStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let deletionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .deletionTimestamp)
        deletionTimestamp = deletionTimestampDecoded
    }
}

extension ChimeClientTypes.PhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumber(associations: \(Swift.String(describing: associations)), callingNameStatus: \(Swift.String(describing: callingNameStatus)), capabilities: \(Swift.String(describing: capabilities)), country: \(Swift.String(describing: country)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), deletionTimestamp: \(Swift.String(describing: deletionTimestamp)), phoneNumberId: \(Swift.String(describing: phoneNumberId)), productType: \(Swift.String(describing: productType)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), callingName: \"CONTENT_REDACTED\", e164PhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// A phone number used for Amazon Chime Business Calling or an Amazon Chime Voice Connector.
    public struct PhoneNumber: Swift.Equatable {
        /// The phone number associations.
        public var associations: [ChimeClientTypes.PhoneNumberAssociation]?
        /// The outbound calling name associated with the phone number.
        public var callingName: Swift.String?
        /// The outbound calling name status.
        public var callingNameStatus: ChimeClientTypes.CallingNameStatus?
        /// The phone number capabilities.
        public var capabilities: ChimeClientTypes.PhoneNumberCapabilities?
        /// The phone number country. Format: ISO 3166-1 alpha-2.
        public var country: Swift.String?
        /// The phone number creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The deleted phone number timestamp, in ISO 8601 format.
        public var deletionTimestamp: ClientRuntime.Date?
        /// The phone number, in E.164 format.
        public var e164PhoneNumber: Swift.String?
        /// The phone number ID.
        public var phoneNumberId: Swift.String?
        /// The phone number product type.
        public var productType: ChimeClientTypes.PhoneNumberProductType?
        /// The phone number status.
        public var status: ChimeClientTypes.PhoneNumberStatus?
        /// The phone number type.
        public var type: ChimeClientTypes.PhoneNumberType?
        /// The updated phone number timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            associations: [ChimeClientTypes.PhoneNumberAssociation]? = nil,
            callingName: Swift.String? = nil,
            callingNameStatus: ChimeClientTypes.CallingNameStatus? = nil,
            capabilities: ChimeClientTypes.PhoneNumberCapabilities? = nil,
            country: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            deletionTimestamp: ClientRuntime.Date? = nil,
            e164PhoneNumber: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            productType: ChimeClientTypes.PhoneNumberProductType? = nil,
            status: ChimeClientTypes.PhoneNumberStatus? = nil,
            type: ChimeClientTypes.PhoneNumberType? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.associations = associations
            self.callingName = callingName
            self.callingNameStatus = callingNameStatus
            self.capabilities = capabilities
            self.country = country
            self.createdTimestamp = createdTimestamp
            self.deletionTimestamp = deletionTimestamp
            self.e164PhoneNumber = e164PhoneNumber
            self.phoneNumberId = phoneNumberId
            self.productType = productType
            self.status = status
            self.type = type
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes.PhoneNumberAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedTimestamp = "AssociatedTimestamp"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedTimestamp = self.associatedTimestamp {
            try encodeContainer.encodeTimestamp(associatedTimestamp, format: .dateTime, forKey: .associatedTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberAssociationName.self, forKey: .name)
        name = nameDecoded
        let associatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .associatedTimestamp)
        associatedTimestamp = associatedTimestampDecoded
    }
}

extension ChimeClientTypes {
    /// The phone number associations, such as Amazon Chime account ID, Amazon Chime user ID, Amazon Chime Voice Connector ID, or Amazon Chime Voice Connector group ID.
    public struct PhoneNumberAssociation: Swift.Equatable {
        /// The timestamp of the phone number association, in ISO 8601 format.
        public var associatedTimestamp: ClientRuntime.Date?
        /// Defines the association with an Amazon Chime account ID, user ID, Amazon Chime Voice Connector ID, or Amazon Chime Voice Connector group ID.
        public var name: ChimeClientTypes.PhoneNumberAssociationName?
        /// Contains the ID for the entity specified in Name.
        public var value: Swift.String?

        public init(
            associatedTimestamp: ClientRuntime.Date? = nil,
            name: ChimeClientTypes.PhoneNumberAssociationName? = nil,
            value: Swift.String? = nil
        )
        {
            self.associatedTimestamp = associatedTimestamp
            self.name = name
            self.value = value
        }
    }

}

extension ChimeClientTypes {
    public enum PhoneNumberAssociationName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountid
        case sipruleid
        case userid
        case voiceconnectorgroupid
        case voiceconnectorid
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberAssociationName] {
            return [
                .accountid,
                .sipruleid,
                .userid,
                .voiceconnectorgroupid,
                .voiceconnectorid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountid: return "AccountId"
            case .sipruleid: return "SipRuleId"
            case .userid: return "UserId"
            case .voiceconnectorgroupid: return "VoiceConnectorGroupId"
            case .voiceconnectorid: return "VoiceConnectorId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberAssociationName(rawValue: rawValue) ?? PhoneNumberAssociationName.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.PhoneNumberCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inboundCall = "InboundCall"
        case inboundMMS = "InboundMMS"
        case inboundSMS = "InboundSMS"
        case outboundCall = "OutboundCall"
        case outboundMMS = "OutboundMMS"
        case outboundSMS = "OutboundSMS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboundCall = self.inboundCall {
            try encodeContainer.encode(inboundCall, forKey: .inboundCall)
        }
        if let inboundMMS = self.inboundMMS {
            try encodeContainer.encode(inboundMMS, forKey: .inboundMMS)
        }
        if let inboundSMS = self.inboundSMS {
            try encodeContainer.encode(inboundSMS, forKey: .inboundSMS)
        }
        if let outboundCall = self.outboundCall {
            try encodeContainer.encode(outboundCall, forKey: .outboundCall)
        }
        if let outboundMMS = self.outboundMMS {
            try encodeContainer.encode(outboundMMS, forKey: .outboundMMS)
        }
        if let outboundSMS = self.outboundSMS {
            try encodeContainer.encode(outboundSMS, forKey: .outboundSMS)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboundCallDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCall)
        inboundCall = inboundCallDecoded
        let outboundCallDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCall)
        outboundCall = outboundCallDecoded
        let inboundSMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundSMS)
        inboundSMS = inboundSMSDecoded
        let outboundSMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundSMS)
        outboundSMS = outboundSMSDecoded
        let inboundMMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundMMS)
        inboundMMS = inboundMMSDecoded
        let outboundMMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundMMS)
        outboundMMS = outboundMMSDecoded
    }
}

extension ChimeClientTypes {
    /// The phone number capabilities for Amazon Chime Business Calling phone numbers, such as enabled inbound and outbound calling and text messaging.
    public struct PhoneNumberCapabilities: Swift.Equatable {
        /// Allows or denies inbound calling for the specified phone number.
        public var inboundCall: Swift.Bool?
        /// Allows or denies inbound MMS messaging for the specified phone number.
        public var inboundMMS: Swift.Bool?
        /// Allows or denies inbound SMS messaging for the specified phone number.
        public var inboundSMS: Swift.Bool?
        /// Allows or denies outbound calling for the specified phone number.
        public var outboundCall: Swift.Bool?
        /// Allows or denies outbound MMS messaging for the specified phone number.
        public var outboundMMS: Swift.Bool?
        /// Allows or denies outbound SMS messaging for the specified phone number.
        public var outboundSMS: Swift.Bool?

        public init(
            inboundCall: Swift.Bool? = nil,
            inboundMMS: Swift.Bool? = nil,
            inboundSMS: Swift.Bool? = nil,
            outboundCall: Swift.Bool? = nil,
            outboundMMS: Swift.Bool? = nil,
            outboundSMS: Swift.Bool? = nil
        )
        {
            self.inboundCall = inboundCall
            self.inboundMMS = inboundMMS
            self.inboundSMS = inboundSMS
            self.outboundCall = outboundCall
            self.outboundMMS = outboundMMS
            self.outboundSMS = outboundSMS
        }
    }

}

extension ChimeClientTypes.PhoneNumberCountry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode = "CountryCode"
        case supportedPhoneNumberTypes = "SupportedPhoneNumberTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let supportedPhoneNumberTypes = supportedPhoneNumberTypes {
            var supportedPhoneNumberTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedPhoneNumberTypes)
            for phonenumbertype0 in supportedPhoneNumberTypes {
                try supportedPhoneNumberTypesContainer.encode(phonenumbertype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let supportedPhoneNumberTypesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.PhoneNumberType?].self, forKey: .supportedPhoneNumberTypes)
        var supportedPhoneNumberTypesDecoded0:[ChimeClientTypes.PhoneNumberType]? = nil
        if let supportedPhoneNumberTypesContainer = supportedPhoneNumberTypesContainer {
            supportedPhoneNumberTypesDecoded0 = [ChimeClientTypes.PhoneNumberType]()
            for enum0 in supportedPhoneNumberTypesContainer {
                if let enum0 = enum0 {
                    supportedPhoneNumberTypesDecoded0?.append(enum0)
                }
            }
        }
        supportedPhoneNumberTypes = supportedPhoneNumberTypesDecoded0
    }
}

extension ChimeClientTypes {
    /// The phone number country.
    public struct PhoneNumberCountry: Swift.Equatable {
        /// The phone number country code. Format: ISO 3166-1 alpha-2.
        public var countryCode: Swift.String?
        /// The supported phone number types.
        public var supportedPhoneNumberTypes: [ChimeClientTypes.PhoneNumberType]?

        public init(
            countryCode: Swift.String? = nil,
            supportedPhoneNumberTypes: [ChimeClientTypes.PhoneNumberType]? = nil
        )
        {
            self.countryCode = countryCode
            self.supportedPhoneNumberTypes = supportedPhoneNumberTypes
        }
    }

}

extension ChimeClientTypes.PhoneNumberError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case phoneNumberId = "PhoneNumberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeClientTypes {
    /// If the phone number action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public struct PhoneNumberError: Swift.Equatable {
        /// The error code.
        public var errorCode: ChimeClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The phone number ID for which the action failed.
        public var phoneNumberId: Swift.String?

        public init(
            errorCode: ChimeClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.phoneNumberId = phoneNumberId
        }
    }

}

extension ChimeClientTypes.PhoneNumberOrder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case orderedPhoneNumbers = "OrderedPhoneNumbers"
        case phoneNumberOrderId = "PhoneNumberOrderId"
        case productType = "ProductType"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let orderedPhoneNumbers = orderedPhoneNumbers {
            var orderedPhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedPhoneNumbers)
            for orderedphonenumber0 in orderedPhoneNumbers {
                try orderedPhoneNumbersContainer.encode(orderedphonenumber0)
            }
        }
        if let phoneNumberOrderId = self.phoneNumberOrderId {
            try encodeContainer.encode(phoneNumberOrderId, forKey: .phoneNumberOrderId)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberOrderId)
        phoneNumberOrderId = phoneNumberOrderIdDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberOrderStatus.self, forKey: .status)
        status = statusDecoded
        let orderedPhoneNumbersContainer = try containerValues.decodeIfPresent([ChimeClientTypes.OrderedPhoneNumber?].self, forKey: .orderedPhoneNumbers)
        var orderedPhoneNumbersDecoded0:[ChimeClientTypes.OrderedPhoneNumber]? = nil
        if let orderedPhoneNumbersContainer = orderedPhoneNumbersContainer {
            orderedPhoneNumbersDecoded0 = [ChimeClientTypes.OrderedPhoneNumber]()
            for structure0 in orderedPhoneNumbersContainer {
                if let structure0 = structure0 {
                    orderedPhoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        orderedPhoneNumbers = orderedPhoneNumbersDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes {
    /// The details of a phone number order created for Amazon Chime.
    public struct PhoneNumberOrder: Swift.Equatable {
        /// The phone number order creation time stamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ordered phone number details, such as the phone number in E.164 format and the phone number status.
        public var orderedPhoneNumbers: [ChimeClientTypes.OrderedPhoneNumber]?
        /// The phone number order ID.
        public var phoneNumberOrderId: Swift.String?
        /// The phone number order product type.
        public var productType: ChimeClientTypes.PhoneNumberProductType?
        /// The status of the phone number order.
        public var status: ChimeClientTypes.PhoneNumberOrderStatus?
        /// The updated phone number order time stamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            orderedPhoneNumbers: [ChimeClientTypes.OrderedPhoneNumber]? = nil,
            phoneNumberOrderId: Swift.String? = nil,
            productType: ChimeClientTypes.PhoneNumberProductType? = nil,
            status: ChimeClientTypes.PhoneNumberOrderStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.orderedPhoneNumbers = orderedPhoneNumbers
            self.phoneNumberOrderId = phoneNumberOrderId
            self.productType = productType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes {
    public enum PhoneNumberOrderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case partial
        case processing
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberOrderStatus] {
            return [
                .failed,
                .partial,
                .processing,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .partial: return "Partial"
            case .processing: return "Processing"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberOrderStatus(rawValue: rawValue) ?? PhoneNumberOrderStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum PhoneNumberProductType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case businesscalling
        case sipmediaapplicationdialin
        case voiceconnector
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberProductType] {
            return [
                .businesscalling,
                .sipmediaapplicationdialin,
                .voiceconnector,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .businesscalling: return "BusinessCalling"
            case .sipmediaapplicationdialin: return "SipMediaApplicationDialIn"
            case .voiceconnector: return "VoiceConnector"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberProductType(rawValue: rawValue) ?? PhoneNumberProductType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum PhoneNumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acquirefailed
        case acquireinprogress
        case assigned
        case deletefailed
        case deleteinprogress
        case releasefailed
        case releaseinprogress
        case unassigned
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberStatus] {
            return [
                .acquirefailed,
                .acquireinprogress,
                .assigned,
                .deletefailed,
                .deleteinprogress,
                .releasefailed,
                .releaseinprogress,
                .unassigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acquirefailed: return "AcquireFailed"
            case .acquireinprogress: return "AcquireInProgress"
            case .assigned: return "Assigned"
            case .deletefailed: return "DeleteFailed"
            case .deleteinprogress: return "DeleteInProgress"
            case .releasefailed: return "ReleaseFailed"
            case .releaseinprogress: return "ReleaseInProgress"
            case .unassigned: return "Unassigned"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberStatus(rawValue: rawValue) ?? PhoneNumberStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum PhoneNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case local
        case tollfree
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberType] {
            return [
                .local,
                .tollfree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .local: return "Local"
            case .tollfree: return "TollFree"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberType(rawValue: rawValue) ?? PhoneNumberType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.Proxy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberCountries = "PhoneNumberCountries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultSessionExpiryMinutes = self.defaultSessionExpiryMinutes {
            try encodeContainer.encode(defaultSessionExpiryMinutes, forKey: .defaultSessionExpiryMinutes)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let fallBackPhoneNumber = self.fallBackPhoneNumber {
            try encodeContainer.encode(fallBackPhoneNumber, forKey: .fallBackPhoneNumber)
        }
        if let phoneNumberCountries = phoneNumberCountries {
            var phoneNumberCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberCountries)
            for string0 in phoneNumberCountries {
                try phoneNumberCountriesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultSessionExpiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultSessionExpiryMinutes)
        defaultSessionExpiryMinutes = defaultSessionExpiryMinutesDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let fallBackPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallBackPhoneNumber)
        fallBackPhoneNumber = fallBackPhoneNumberDecoded
        let phoneNumberCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberCountries)
        var phoneNumberCountriesDecoded0:[Swift.String]? = nil
        if let phoneNumberCountriesContainer = phoneNumberCountriesContainer {
            phoneNumberCountriesDecoded0 = [Swift.String]()
            for string0 in phoneNumberCountriesContainer {
                if let string0 = string0 {
                    phoneNumberCountriesDecoded0?.append(string0)
                }
            }
        }
        phoneNumberCountries = phoneNumberCountriesDecoded0
    }
}

extension ChimeClientTypes.Proxy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Proxy(defaultSessionExpiryMinutes: \(Swift.String(describing: defaultSessionExpiryMinutes)), disabled: \(Swift.String(describing: disabled)), phoneNumberCountries: \(Swift.String(describing: phoneNumberCountries)), fallBackPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The proxy configuration for an Amazon Chime Voice Connector.
    public struct Proxy: Swift.Equatable {
        /// The default number of minutes allowed for proxy sessions.
        public var defaultSessionExpiryMinutes: Swift.Int?
        /// When true, stops proxy sessions from being created on the specified Amazon Chime Voice Connector.
        public var disabled: Swift.Bool?
        /// The phone number to route calls to after a proxy session expires.
        public var fallBackPhoneNumber: Swift.String?
        /// The countries for proxy phone numbers to be selected from.
        public var phoneNumberCountries: [Swift.String]?

        public init(
            defaultSessionExpiryMinutes: Swift.Int? = nil,
            disabled: Swift.Bool? = nil,
            fallBackPhoneNumber: Swift.String? = nil,
            phoneNumberCountries: [Swift.String]? = nil
        )
        {
            self.defaultSessionExpiryMinutes = defaultSessionExpiryMinutes
            self.disabled = disabled
            self.fallBackPhoneNumber = fallBackPhoneNumber
            self.phoneNumberCountries = phoneNumberCountries
        }
    }

}

extension ChimeClientTypes.ProxySession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case createdTimestamp = "CreatedTimestamp"
        case endedTimestamp = "EndedTimestamp"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participants = "Participants"
        case proxySessionId = "ProxySessionId"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capability0 in capabilities {
                try capabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let endedTimestamp = self.endedTimestamp {
            try encodeContainer.encodeTimestamp(endedTimestamp, format: .dateTime, forKey: .endedTimestamp)
        }
        if let expiryMinutes = self.expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
        if let geoMatchLevel = self.geoMatchLevel {
            try encodeContainer.encode(geoMatchLevel.rawValue, forKey: .geoMatchLevel)
        }
        if let geoMatchParams = self.geoMatchParams {
            try encodeContainer.encode(geoMatchParams, forKey: .geoMatchParams)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberSelectionBehavior = self.numberSelectionBehavior {
            try encodeContainer.encode(numberSelectionBehavior.rawValue, forKey: .numberSelectionBehavior)
        }
        if let participants = participants {
            var participantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participants)
            for participant0 in participants {
                try participantsContainer.encode(participant0)
            }
        }
        if let proxySessionId = self.proxySessionId {
            try encodeContainer.encode(proxySessionId, forKey: .proxySessionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let proxySessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxySessionId)
        proxySessionId = proxySessionIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ProxySessionStatus.self, forKey: .status)
        status = statusDecoded
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeClientTypes.Capability]()
            for enum0 in capabilitiesContainer {
                if let enum0 = enum0 {
                    capabilitiesDecoded0?.append(enum0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let endedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedTimestamp)
        endedTimestamp = endedTimestampDecoded
        let participantsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Participant?].self, forKey: .participants)
        var participantsDecoded0:[ChimeClientTypes.Participant]? = nil
        if let participantsContainer = participantsContainer {
            participantsDecoded0 = [ChimeClientTypes.Participant]()
            for structure0 in participantsContainer {
                if let structure0 = structure0 {
                    participantsDecoded0?.append(structure0)
                }
            }
        }
        participants = participantsDecoded0
        let numberSelectionBehaviorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.NumberSelectionBehavior.self, forKey: .numberSelectionBehavior)
        numberSelectionBehavior = numberSelectionBehaviorDecoded
        let geoMatchLevelDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.GeoMatchLevel.self, forKey: .geoMatchLevel)
        geoMatchLevel = geoMatchLevelDecoded
        let geoMatchParamsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.GeoMatchParams.self, forKey: .geoMatchParams)
        geoMatchParams = geoMatchParamsDecoded
    }
}

extension ChimeClientTypes {
    /// The proxy session for an Amazon Chime Voice Connector.
    public struct ProxySession: Swift.Equatable {
        /// The proxy session capabilities.
        public var capabilities: [ChimeClientTypes.Capability]?
        /// The created time stamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ended time stamp, in ISO 8601 format.
        public var endedTimestamp: ClientRuntime.Date?
        /// The number of minutes allowed for the proxy session.
        public var expiryMinutes: Swift.Int?
        /// The preference for matching the country or area code of the proxy phone number with that of the first participant.
        public var geoMatchLevel: ChimeClientTypes.GeoMatchLevel?
        /// The country and area code for the proxy phone number.
        public var geoMatchParams: ChimeClientTypes.GeoMatchParams?
        /// The name of the proxy session.
        public var name: Swift.String?
        /// The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.
        public var numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior?
        /// The proxy session participants.
        public var participants: [ChimeClientTypes.Participant]?
        /// The proxy session ID.
        public var proxySessionId: Swift.String?
        /// The status of the proxy session.
        public var status: ChimeClientTypes.ProxySessionStatus?
        /// The updated time stamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The Amazon Chime voice connector ID.
        public var voiceConnectorId: Swift.String?

        public init(
            capabilities: [ChimeClientTypes.Capability]? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endedTimestamp: ClientRuntime.Date? = nil,
            expiryMinutes: Swift.Int? = nil,
            geoMatchLevel: ChimeClientTypes.GeoMatchLevel? = nil,
            geoMatchParams: ChimeClientTypes.GeoMatchParams? = nil,
            name: Swift.String? = nil,
            numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior? = nil,
            participants: [ChimeClientTypes.Participant]? = nil,
            proxySessionId: Swift.String? = nil,
            status: ChimeClientTypes.ProxySessionStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.capabilities = capabilities
            self.createdTimestamp = createdTimestamp
            self.endedTimestamp = endedTimestamp
            self.expiryMinutes = expiryMinutes
            self.geoMatchLevel = geoMatchLevel
            self.geoMatchParams = geoMatchParams
            self.name = name
            self.numberSelectionBehavior = numberSelectionBehavior
            self.participants = participants
            self.proxySessionId = proxySessionId
            self.status = status
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeClientTypes {
    public enum ProxySessionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case inprogress
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [ProxySessionStatus] {
            return [
                .closed,
                .inprogress,
                .open,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "Closed"
            case .inprogress: return "InProgress"
            case .open: return "Open"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProxySessionStatus(rawValue: rawValue) ?? ProxySessionStatus.sdkUnknown(rawValue)
        }
    }
}

extension PutAppInstanceRetentionSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceRetentionSettings = self.appInstanceRetentionSettings {
            try encodeContainer.encode(appInstanceRetentionSettings, forKey: .appInstanceRetentionSettings)
        }
    }
}

extension PutAppInstanceRetentionSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/retention-settings"
    }
}

public struct PutAppInstanceRetentionSettingsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The time in days to retain data. Data type: number.
    /// This member is required.
    public var appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?

    public init(
        appInstanceArn: Swift.String? = nil,
        appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
    }
}

struct PutAppInstanceRetentionSettingsInputBody: Swift.Equatable {
    let appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?
}

extension PutAppInstanceRetentionSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
    }
}

extension PutAppInstanceRetentionSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutAppInstanceRetentionSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceRetentionSettings = output.appInstanceRetentionSettings
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
        } else {
            self.appInstanceRetentionSettings = nil
            self.initiateDeletionTimestamp = nil
        }
    }
}

public struct PutAppInstanceRetentionSettingsOutput: Swift.Equatable {
    /// The time in days to retain data. Data type: number.
    public var appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?
    /// The time at which the API deletes data.
    public var initiateDeletionTimestamp: ClientRuntime.Date?

    public init(
        appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings? = nil,
        initiateDeletionTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
    }
}

struct PutAppInstanceRetentionSettingsOutputBody: Swift.Equatable {
    let appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?
    let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension PutAppInstanceRetentionSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

enum PutAppInstanceRetentionSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutAppInstanceStreamingConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceStreamingConfigurations = "AppInstanceStreamingConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceStreamingConfigurations = appInstanceStreamingConfigurations {
            var appInstanceStreamingConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appInstanceStreamingConfigurations)
            for appinstancestreamingconfiguration0 in appInstanceStreamingConfigurations {
                try appInstanceStreamingConfigurationsContainer.encode(appinstancestreamingconfiguration0)
            }
        }
    }
}

extension PutAppInstanceStreamingConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/streaming-configurations"
    }
}

public struct PutAppInstanceStreamingConfigurationsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The streaming configurations set for an AppInstance.
    /// This member is required.
    public var appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?

    public init(
        appInstanceArn: Swift.String? = nil,
        appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceStreamingConfigurations = appInstanceStreamingConfigurations
    }
}

struct PutAppInstanceStreamingConfigurationsInputBody: Swift.Equatable {
    let appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?
}

extension PutAppInstanceStreamingConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceStreamingConfigurations = "AppInstanceStreamingConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceStreamingConfigurationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.AppInstanceStreamingConfiguration?].self, forKey: .appInstanceStreamingConfigurations)
        var appInstanceStreamingConfigurationsDecoded0:[ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
        if let appInstanceStreamingConfigurationsContainer = appInstanceStreamingConfigurationsContainer {
            appInstanceStreamingConfigurationsDecoded0 = [ChimeClientTypes.AppInstanceStreamingConfiguration]()
            for structure0 in appInstanceStreamingConfigurationsContainer {
                if let structure0 = structure0 {
                    appInstanceStreamingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceStreamingConfigurations = appInstanceStreamingConfigurationsDecoded0
    }
}

extension PutAppInstanceStreamingConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutAppInstanceStreamingConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceStreamingConfigurations = output.appInstanceStreamingConfigurations
        } else {
            self.appInstanceStreamingConfigurations = nil
        }
    }
}

public struct PutAppInstanceStreamingConfigurationsOutput: Swift.Equatable {
    /// The streaming configurations of an AppInstance.
    public var appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?

    public init(
        appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
    )
    {
        self.appInstanceStreamingConfigurations = appInstanceStreamingConfigurations
    }
}

struct PutAppInstanceStreamingConfigurationsOutputBody: Swift.Equatable {
    let appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?
}

extension PutAppInstanceStreamingConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceStreamingConfigurations = "AppInstanceStreamingConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceStreamingConfigurationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.AppInstanceStreamingConfiguration?].self, forKey: .appInstanceStreamingConfigurations)
        var appInstanceStreamingConfigurationsDecoded0:[ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
        if let appInstanceStreamingConfigurationsContainer = appInstanceStreamingConfigurationsContainer {
            appInstanceStreamingConfigurationsDecoded0 = [ChimeClientTypes.AppInstanceStreamingConfiguration]()
            for structure0 in appInstanceStreamingConfigurationsContainer {
                if let structure0 = structure0 {
                    appInstanceStreamingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceStreamingConfigurations = appInstanceStreamingConfigurationsDecoded0
    }
}

enum PutAppInstanceStreamingConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutEventsConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEventsConfigurationInput(accountId: \(Swift.String(describing: accountId)), botId: \(Swift.String(describing: botId)), lambdaFunctionArn: \"CONTENT_REDACTED\", outboundEventsHTTPSEndpoint: \"CONTENT_REDACTED\")"}
}

extension PutEventsConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaFunctionArn = "LambdaFunctionArn"
        case outboundEventsHTTPSEndpoint = "OutboundEventsHTTPSEndpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaFunctionArn = self.lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
        if let outboundEventsHTTPSEndpoint = self.outboundEventsHTTPSEndpoint {
            try encodeContainer.encode(outboundEventsHTTPSEndpoint, forKey: .outboundEventsHTTPSEndpoint)
        }
    }
}

extension PutEventsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let botId = botId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())/events-configuration"
    }
}

public struct PutEventsConfigurationInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?
    /// Lambda function ARN that allows the bot to receive outgoing events.
    public var lambdaFunctionArn: Swift.String?
    /// HTTPS endpoint that allows the bot to receive outgoing events.
    public var outboundEventsHTTPSEndpoint: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil,
        lambdaFunctionArn: Swift.String? = nil,
        outboundEventsHTTPSEndpoint: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
        self.lambdaFunctionArn = lambdaFunctionArn
        self.outboundEventsHTTPSEndpoint = outboundEventsHTTPSEndpoint
    }
}

struct PutEventsConfigurationInputBody: Swift.Equatable {
    let outboundEventsHTTPSEndpoint: Swift.String?
    let lambdaFunctionArn: Swift.String?
}

extension PutEventsConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaFunctionArn = "LambdaFunctionArn"
        case outboundEventsHTTPSEndpoint = "OutboundEventsHTTPSEndpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outboundEventsHTTPSEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundEventsHTTPSEndpoint)
        outboundEventsHTTPSEndpoint = outboundEventsHTTPSEndpointDecoded
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
    }
}

extension PutEventsConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutEventsConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventsConfiguration = output.eventsConfiguration
        } else {
            self.eventsConfiguration = nil
        }
    }
}

public struct PutEventsConfigurationOutput: Swift.Equatable {
    /// The configuration that allows a bot to receive outgoing events. Can be an HTTPS endpoint or an AWS Lambda function ARN.
    public var eventsConfiguration: ChimeClientTypes.EventsConfiguration?

    public init(
        eventsConfiguration: ChimeClientTypes.EventsConfiguration? = nil
    )
    {
        self.eventsConfiguration = eventsConfiguration
    }
}

struct PutEventsConfigurationOutputBody: Swift.Equatable {
    let eventsConfiguration: ChimeClientTypes.EventsConfiguration?
}

extension PutEventsConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventsConfiguration = "EventsConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EventsConfiguration.self, forKey: .eventsConfiguration)
        eventsConfiguration = eventsConfigurationDecoded
    }
}

enum PutEventsConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutRetentionSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionSettings = "RetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionSettings = self.retentionSettings {
            try encodeContainer.encode(retentionSettings, forKey: .retentionSettings)
        }
    }
}

extension PutRetentionSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/retention-settings"
    }
}

public struct PutRetentionSettingsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The retention settings.
    /// This member is required.
    public var retentionSettings: ChimeClientTypes.RetentionSettings?

    public init(
        accountId: Swift.String? = nil,
        retentionSettings: ChimeClientTypes.RetentionSettings? = nil
    )
    {
        self.accountId = accountId
        self.retentionSettings = retentionSettings
    }
}

struct PutRetentionSettingsInputBody: Swift.Equatable {
    let retentionSettings: ChimeClientTypes.RetentionSettings?
}

extension PutRetentionSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionSettings = "RetentionSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RetentionSettings.self, forKey: .retentionSettings)
        retentionSettings = retentionSettingsDecoded
    }
}

extension PutRetentionSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutRetentionSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
            self.retentionSettings = output.retentionSettings
        } else {
            self.initiateDeletionTimestamp = nil
            self.retentionSettings = nil
        }
    }
}

public struct PutRetentionSettingsOutput: Swift.Equatable {
    /// The timestamp representing the time at which the specified items are permanently deleted, in ISO 8601 format.
    public var initiateDeletionTimestamp: ClientRuntime.Date?
    /// The retention settings.
    public var retentionSettings: ChimeClientTypes.RetentionSettings?

    public init(
        initiateDeletionTimestamp: ClientRuntime.Date? = nil,
        retentionSettings: ChimeClientTypes.RetentionSettings? = nil
    )
    {
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
        self.retentionSettings = retentionSettings
    }
}

struct PutRetentionSettingsOutputBody: Swift.Equatable {
    let retentionSettings: ChimeClientTypes.RetentionSettings?
    let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension PutRetentionSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
        case retentionSettings = "RetentionSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RetentionSettings.self, forKey: .retentionSettings)
        retentionSettings = retentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

enum PutRetentionSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutSipMediaApplicationLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sipMediaApplicationLoggingConfiguration = self.sipMediaApplicationLoggingConfiguration {
            try encodeContainer.encode(sipMediaApplicationLoggingConfiguration, forKey: .sipMediaApplicationLoggingConfiguration)
        }
    }
}

extension PutSipMediaApplicationLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/logging-configuration"
    }
}

public struct PutSipMediaApplicationLoggingConfigurationInput: Swift.Equatable {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The actual logging configuration.
    public var sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?

    public init(
        sipMediaApplicationId: Swift.String? = nil,
        sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct PutSipMediaApplicationLoggingConfigurationInputBody: Swift.Equatable {
    let sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension PutSipMediaApplicationLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

extension PutSipMediaApplicationLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutSipMediaApplicationLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationLoggingConfiguration = output.sipMediaApplicationLoggingConfiguration
        } else {
            self.sipMediaApplicationLoggingConfiguration = nil
        }
    }
}

public struct PutSipMediaApplicationLoggingConfigurationOutput: Swift.Equatable {
    /// The logging configuration of the SIP media application.
    public var sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?

    public init(
        sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct PutSipMediaApplicationLoggingConfigurationOutputBody: Swift.Equatable {
    let sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension PutSipMediaApplicationLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

enum PutSipMediaApplicationLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emergencyCallingConfiguration = self.emergencyCallingConfiguration {
            try encodeContainer.encode(emergencyCallingConfiguration, forKey: .emergencyCallingConfiguration)
        }
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationInput: Swift.Equatable {
    /// The emergency calling configuration details.
    /// This member is required.
    public var emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Equatable {
    let emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?
}

extension PutVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorEmergencyCallingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.emergencyCallingConfiguration = output.emergencyCallingConfiguration
        } else {
            self.emergencyCallingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationOutput: Swift.Equatable {
    /// The emergency calling configuration details.
    public var emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?

    public init(
        emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
    }
}

struct PutVoiceConnectorEmergencyCallingConfigurationOutputBody: Swift.Equatable {
    let emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

enum PutVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingConfiguration = self.loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
    }
}

extension PutVoiceConnectorLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/logging-configuration"
    }
}

public struct PutVoiceConnectorLoggingConfigurationInput: Swift.Equatable {
    /// The logging configuration details to add.
    /// This member is required.
    public var loggingConfiguration: ChimeClientTypes.LoggingConfiguration?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        loggingConfiguration: ChimeClientTypes.LoggingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorLoggingConfigurationInputBody: Swift.Equatable {
    let loggingConfiguration: ChimeClientTypes.LoggingConfiguration?
}

extension PutVoiceConnectorLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

extension PutVoiceConnectorLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorLoggingConfigurationOutput: Swift.Equatable {
    /// The updated logging configuration details.
    public var loggingConfiguration: ChimeClientTypes.LoggingConfiguration?

    public init(
        loggingConfiguration: ChimeClientTypes.LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct PutVoiceConnectorLoggingConfigurationOutputBody: Swift.Equatable {
    let loggingConfiguration: ChimeClientTypes.LoggingConfiguration?
}

extension PutVoiceConnectorLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

enum PutVoiceConnectorLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorOriginationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let origination = self.origination {
            try encodeContainer.encode(origination, forKey: .origination)
        }
    }
}

extension PutVoiceConnectorOriginationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

public struct PutVoiceConnectorOriginationInput: Swift.Equatable {
    /// The origination setting details to add.
    /// This member is required.
    public var origination: ChimeClientTypes.Origination?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        origination: ChimeClientTypes.Origination? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.origination = origination
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorOriginationInputBody: Swift.Equatable {
    let origination: ChimeClientTypes.Origination?
}

extension PutVoiceConnectorOriginationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

extension PutVoiceConnectorOriginationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorOriginationOutputBody = try responseDecoder.decode(responseBody: data)
            self.origination = output.origination
        } else {
            self.origination = nil
        }
    }
}

public struct PutVoiceConnectorOriginationOutput: Swift.Equatable {
    /// The updated origination setting details.
    public var origination: ChimeClientTypes.Origination?

    public init(
        origination: ChimeClientTypes.Origination? = nil
    )
    {
        self.origination = origination
    }
}

struct PutVoiceConnectorOriginationOutputBody: Swift.Equatable {
    let origination: ChimeClientTypes.Origination?
}

extension PutVoiceConnectorOriginationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

enum PutVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorProxyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorProxyInput(defaultSessionExpiryMinutes: \(Swift.String(describing: defaultSessionExpiryMinutes)), disabled: \(Swift.String(describing: disabled)), phoneNumberPoolCountries: \(Swift.String(describing: phoneNumberPoolCountries)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), fallBackPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension PutVoiceConnectorProxyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberPoolCountries = "PhoneNumberPoolCountries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultSessionExpiryMinutes = self.defaultSessionExpiryMinutes {
            try encodeContainer.encode(defaultSessionExpiryMinutes, forKey: .defaultSessionExpiryMinutes)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let fallBackPhoneNumber = self.fallBackPhoneNumber {
            try encodeContainer.encode(fallBackPhoneNumber, forKey: .fallBackPhoneNumber)
        }
        if let phoneNumberPoolCountries = phoneNumberPoolCountries {
            var phoneNumberPoolCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberPoolCountries)
            for country0 in phoneNumberPoolCountries {
                try phoneNumberPoolCountriesContainer.encode(country0)
            }
        }
    }
}

extension PutVoiceConnectorProxyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

public struct PutVoiceConnectorProxyInput: Swift.Equatable {
    /// The default number of minutes allowed for proxy sessions.
    /// This member is required.
    public var defaultSessionExpiryMinutes: Swift.Int?
    /// When true, stops proxy sessions from being created on the specified Amazon Chime Voice Connector.
    public var disabled: Swift.Bool?
    /// The phone number to route calls to after a proxy session expires.
    public var fallBackPhoneNumber: Swift.String?
    /// The countries for proxy phone numbers to be selected from.
    /// This member is required.
    public var phoneNumberPoolCountries: [Swift.String]?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        defaultSessionExpiryMinutes: Swift.Int? = nil,
        disabled: Swift.Bool? = nil,
        fallBackPhoneNumber: Swift.String? = nil,
        phoneNumberPoolCountries: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.defaultSessionExpiryMinutes = defaultSessionExpiryMinutes
        self.disabled = disabled
        self.fallBackPhoneNumber = fallBackPhoneNumber
        self.phoneNumberPoolCountries = phoneNumberPoolCountries
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorProxyInputBody: Swift.Equatable {
    let defaultSessionExpiryMinutes: Swift.Int?
    let phoneNumberPoolCountries: [Swift.String]?
    let fallBackPhoneNumber: Swift.String?
    let disabled: Swift.Bool?
}

extension PutVoiceConnectorProxyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberPoolCountries = "PhoneNumberPoolCountries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultSessionExpiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultSessionExpiryMinutes)
        defaultSessionExpiryMinutes = defaultSessionExpiryMinutesDecoded
        let phoneNumberPoolCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberPoolCountries)
        var phoneNumberPoolCountriesDecoded0:[Swift.String]? = nil
        if let phoneNumberPoolCountriesContainer = phoneNumberPoolCountriesContainer {
            phoneNumberPoolCountriesDecoded0 = [Swift.String]()
            for string0 in phoneNumberPoolCountriesContainer {
                if let string0 = string0 {
                    phoneNumberPoolCountriesDecoded0?.append(string0)
                }
            }
        }
        phoneNumberPoolCountries = phoneNumberPoolCountriesDecoded0
        let fallBackPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallBackPhoneNumber)
        fallBackPhoneNumber = fallBackPhoneNumberDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension PutVoiceConnectorProxyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorProxyOutputBody = try responseDecoder.decode(responseBody: data)
            self.proxy = output.proxy
        } else {
            self.proxy = nil
        }
    }
}

public struct PutVoiceConnectorProxyOutput: Swift.Equatable {
    /// The proxy configuration details.
    public var proxy: ChimeClientTypes.Proxy?

    public init(
        proxy: ChimeClientTypes.Proxy? = nil
    )
    {
        self.proxy = proxy
    }
}

struct PutVoiceConnectorProxyOutputBody: Swift.Equatable {
    let proxy: ChimeClientTypes.Proxy?
}

extension PutVoiceConnectorProxyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxy = "Proxy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Proxy.self, forKey: .proxy)
        proxy = proxyDecoded
    }
}

enum PutVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorStreamingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamingConfiguration = self.streamingConfiguration {
            try encodeContainer.encode(streamingConfiguration, forKey: .streamingConfiguration)
        }
    }
}

extension PutVoiceConnectorStreamingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

public struct PutVoiceConnectorStreamingConfigurationInput: Swift.Equatable {
    /// The streaming configuration details to add.
    /// This member is required.
    public var streamingConfiguration: ChimeClientTypes.StreamingConfiguration?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        streamingConfiguration: ChimeClientTypes.StreamingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorStreamingConfigurationInputBody: Swift.Equatable {
    let streamingConfiguration: ChimeClientTypes.StreamingConfiguration?
}

extension PutVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

extension PutVoiceConnectorStreamingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorStreamingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamingConfiguration = output.streamingConfiguration
        } else {
            self.streamingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorStreamingConfigurationOutput: Swift.Equatable {
    /// The updated streaming configuration details.
    public var streamingConfiguration: ChimeClientTypes.StreamingConfiguration?

    public init(
        streamingConfiguration: ChimeClientTypes.StreamingConfiguration? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
    }
}

struct PutVoiceConnectorStreamingConfigurationOutputBody: Swift.Equatable {
    let streamingConfiguration: ChimeClientTypes.StreamingConfiguration?
}

extension PutVoiceConnectorStreamingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

enum PutVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorTerminationCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentials = credentials {
            var credentialsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentials)
            for credential0 in credentials {
                try credentialsContainer.encode(credential0)
            }
        }
    }
}

extension PutVoiceConnectorTerminationCredentialsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "put"))
            return items
        }
    }
}

extension PutVoiceConnectorTerminationCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

public struct PutVoiceConnectorTerminationCredentialsInput: Swift.Equatable {
    /// The termination SIP credentials.
    public var credentials: [ChimeClientTypes.Credential]?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        credentials: [ChimeClientTypes.Credential]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorTerminationCredentialsInputBody: Swift.Equatable {
    let credentials: [ChimeClientTypes.Credential]?
}

extension PutVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Credential?].self, forKey: .credentials)
        var credentialsDecoded0:[ChimeClientTypes.Credential]? = nil
        if let credentialsContainer = credentialsContainer {
            credentialsDecoded0 = [ChimeClientTypes.Credential]()
            for structure0 in credentialsContainer {
                if let structure0 = structure0 {
                    credentialsDecoded0?.append(structure0)
                }
            }
        }
        credentials = credentialsDecoded0
    }
}

extension PutVoiceConnectorTerminationCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutVoiceConnectorTerminationCredentialsOutput: Swift.Equatable {

    public init() { }
}

enum PutVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorTerminationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let termination = self.termination {
            try encodeContainer.encode(termination, forKey: .termination)
        }
    }
}

extension PutVoiceConnectorTerminationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

public struct PutVoiceConnectorTerminationInput: Swift.Equatable {
    /// The termination setting details to add.
    /// This member is required.
    public var termination: ChimeClientTypes.Termination?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        termination: ChimeClientTypes.Termination? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.termination = termination
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorTerminationInputBody: Swift.Equatable {
    let termination: ChimeClientTypes.Termination?
}

extension PutVoiceConnectorTerminationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

extension PutVoiceConnectorTerminationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorTerminationOutputBody = try responseDecoder.decode(responseBody: data)
            self.termination = output.termination
        } else {
            self.termination = nil
        }
    }
}

public struct PutVoiceConnectorTerminationOutput: Swift.Equatable {
    /// The updated termination setting details.
    public var termination: ChimeClientTypes.Termination?

    public init(
        termination: ChimeClientTypes.Termination? = nil
    )
    {
        self.termination = termination
    }
}

struct PutVoiceConnectorTerminationOutputBody: Swift.Equatable {
    let termination: ChimeClientTypes.Termination?
}

extension PutVoiceConnectorTerminationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

enum PutVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedactChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension RedactChannelMessageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "redact"))
            return items
        }
    }
}

extension RedactChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct RedactChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel containing the messages that you want to redact.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ID of the message being redacted.
    /// This member is required.
    public var messageId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

struct RedactChannelMessageInputBody: Swift.Equatable {
}

extension RedactChannelMessageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RedactChannelMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RedactChannelMessageOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
        } else {
            self.channelArn = nil
            self.messageId = nil
        }
    }
}

public struct RedactChannelMessageOutput: Swift.Equatable {
    /// The ARN of the channel containing the messages that you want to redact.
    public var channelArn: Swift.String?
    /// The ID of the message being redacted.
    public var messageId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

struct RedactChannelMessageOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let messageId: Swift.String?
}

extension RedactChannelMessageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

enum RedactChannelMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedactConversationMessageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "redact"))
            return items
        }
    }
}

extension RedactConversationMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let conversationId = conversationId else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/conversations/\(conversationId.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct RedactConversationMessageInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The conversation ID.
    /// This member is required.
    public var conversationId: Swift.String?
    /// The message ID.
    /// This member is required.
    public var messageId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        conversationId: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.conversationId = conversationId
        self.messageId = messageId
    }
}

struct RedactConversationMessageInputBody: Swift.Equatable {
}

extension RedactConversationMessageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RedactConversationMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RedactConversationMessageOutput: Swift.Equatable {

    public init() { }
}

enum RedactConversationMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RedactRoomMessageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "redact"))
            return items
        }
    }
}

extension RedactRoomMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let roomId = roomId else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct RedactRoomMessageInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The message ID.
    /// This member is required.
    public var messageId: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        messageId: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.messageId = messageId
        self.roomId = roomId
    }
}

struct RedactRoomMessageInputBody: Swift.Equatable {
}

extension RedactRoomMessageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RedactRoomMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RedactRoomMessageOutput: Swift.Equatable {

    public init() { }
}

enum RedactRoomMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegenerateSecurityTokenInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "regenerate-security-token"))
            return items
        }
    }
}

extension RegenerateSecurityTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let botId = botId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())"
    }
}

public struct RegenerateSecurityTokenInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
    }
}

struct RegenerateSecurityTokenInputBody: Swift.Equatable {
}

extension RegenerateSecurityTokenInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RegenerateSecurityTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegenerateSecurityTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.bot = output.bot
        } else {
            self.bot = nil
        }
    }
}

public struct RegenerateSecurityTokenOutput: Swift.Equatable {
    /// A resource that allows Enterprise account administrators to configure an interface that receives events from Amazon Chime.
    public var bot: ChimeClientTypes.Bot?

    public init(
        bot: ChimeClientTypes.Bot? = nil
    )
    {
        self.bot = bot
    }
}

struct RegenerateSecurityTokenOutputBody: Swift.Equatable {
    let bot: ChimeClientTypes.Bot?
}

extension RegenerateSecurityTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bot = "Bot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Bot.self, forKey: .bot)
        bot = botDecoded
    }
}

enum RegenerateSecurityTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes {
    public enum RegistrationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case registered
        case suspended
        case unregistered
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationStatus] {
            return [
                .registered,
                .suspended,
                .unregistered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .registered: return "Registered"
            case .suspended: return "Suspended"
            case .unregistered: return "Unregistered"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationStatus(rawValue: rawValue) ?? RegistrationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResetPersonalPINInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "reset-personal-pin"))
            return items
        }
    }
}

extension ResetPersonalPINInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct ResetPersonalPINInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

struct ResetPersonalPINInputBody: Swift.Equatable {
}

extension ResetPersonalPINInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ResetPersonalPINOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResetPersonalPINOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct ResetPersonalPINOutput: Swift.Equatable {
    /// The user details and new personal meeting PIN.
    public var user: ChimeClientTypes.User?

    public init(
        user: ChimeClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct ResetPersonalPINOutputBody: Swift.Equatable {
    let user: ChimeClientTypes.User?
}

extension ResetPersonalPINOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum ResetPersonalPINOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let code: ChimeClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestorePhoneNumberInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "restore"))
            return items
        }
    }
}

extension RestorePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct RestorePhoneNumberInput: Swift.Equatable {
    /// The phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct RestorePhoneNumberInputBody: Swift.Equatable {
}

extension RestorePhoneNumberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RestorePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestorePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct RestorePhoneNumberOutput: Swift.Equatable {
    /// The phone number details.
    public var phoneNumber: ChimeClientTypes.PhoneNumber?

    public init(
        phoneNumber: ChimeClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct RestorePhoneNumberOutputBody: Swift.Equatable {
    let phoneNumber: ChimeClientTypes.PhoneNumber?
}

extension RestorePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

enum RestorePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.RetentionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversationRetentionSettings = "ConversationRetentionSettings"
        case roomRetentionSettings = "RoomRetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversationRetentionSettings = self.conversationRetentionSettings {
            try encodeContainer.encode(conversationRetentionSettings, forKey: .conversationRetentionSettings)
        }
        if let roomRetentionSettings = self.roomRetentionSettings {
            try encodeContainer.encode(roomRetentionSettings, forKey: .roomRetentionSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomRetentionSettings.self, forKey: .roomRetentionSettings)
        roomRetentionSettings = roomRetentionSettingsDecoded
        let conversationRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ConversationRetentionSettings.self, forKey: .conversationRetentionSettings)
        conversationRetentionSettings = conversationRetentionSettingsDecoded
    }
}

extension ChimeClientTypes {
    /// The retention settings for an Amazon Chime Enterprise account that determine how long to retain items such as chat-room messages and chat-conversation messages.
    public struct RetentionSettings: Swift.Equatable {
        /// The chat conversation retention settings.
        public var conversationRetentionSettings: ChimeClientTypes.ConversationRetentionSettings?
        /// The chat room retention settings.
        public var roomRetentionSettings: ChimeClientTypes.RoomRetentionSettings?

        public init(
            conversationRetentionSettings: ChimeClientTypes.ConversationRetentionSettings? = nil,
            roomRetentionSettings: ChimeClientTypes.RoomRetentionSettings? = nil
        )
        {
            self.conversationRetentionSettings = conversationRetentionSettings
            self.roomRetentionSettings = roomRetentionSettings
        }
    }

}

extension ChimeClientTypes.Room: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
        case roomId = "RoomId"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roomId = self.roomId {
            try encodeContainer.encode(roomId, forKey: .roomId)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomId)
        roomId = roomIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes.Room: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Room(accountId: \(Swift.String(describing: accountId)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), roomId: \(Swift.String(describing: roomId)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The Amazon Chime chat room details.
    public struct Room: Swift.Equatable {
        /// The Amazon Chime account ID.
        public var accountId: Swift.String?
        /// The identifier of the room creator.
        public var createdBy: Swift.String?
        /// The room creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The room name.
        public var name: Swift.String?
        /// The room ID.
        public var roomId: Swift.String?
        /// The room update timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            accountId: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roomId: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.accountId = accountId
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.roomId = roomId
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes.RoomMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitedBy = "InvitedBy"
        case member = "Member"
        case role = "Role"
        case roomId = "RoomId"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitedBy = self.invitedBy {
            try encodeContainer.encode(invitedBy, forKey: .invitedBy)
        }
        if let member = self.member {
            try encodeContainer.encode(member, forKey: .member)
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let roomId = self.roomId {
            try encodeContainer.encode(roomId, forKey: .roomId)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomId)
        roomId = roomIdDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Member.self, forKey: .member)
        member = memberDecoded
        let roleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomMembershipRole.self, forKey: .role)
        role = roleDecoded
        let invitedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedBy)
        invitedBy = invitedByDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes {
    /// The room membership details.
    public struct RoomMembership: Swift.Equatable {
        /// The identifier of the user that invited the room member.
        public var invitedBy: Swift.String?
        /// The member details, such as email address, name, member ID, and member type.
        public var member: ChimeClientTypes.Member?
        /// The membership role.
        public var role: ChimeClientTypes.RoomMembershipRole?
        /// The room ID.
        public var roomId: Swift.String?
        /// The room membership update timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            invitedBy: Swift.String? = nil,
            member: ChimeClientTypes.Member? = nil,
            role: ChimeClientTypes.RoomMembershipRole? = nil,
            roomId: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.invitedBy = invitedBy
            self.member = member
            self.role = role
            self.roomId = roomId
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes {
    public enum RoomMembershipRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case administrator
        case member
        case sdkUnknown(Swift.String)

        public static var allCases: [RoomMembershipRole] {
            return [
                .administrator,
                .member,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .administrator: return "Administrator"
            case .member: return "Member"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoomMembershipRole(rawValue: rawValue) ?? RoomMembershipRole.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.RoomRetentionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionDays = self.retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension ChimeClientTypes {
    /// The retention settings that determine how long to retain chat-room messages for an Amazon Chime Enterprise account.
    public struct RoomRetentionSettings: Swift.Equatable {
        /// The number of days for which to retain chat-room messages.
        public var retentionDays: Swift.Int?

        public init(
            retentionDays: Swift.Int? = nil
        )
        {
            self.retentionDays = retentionDays
        }
    }

}

extension SearchAvailablePhoneNumbersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "type", value: "phone-numbers"))
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let state = state {
                let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state).urlPercentEncoding())
                items.append(stateQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let areaCode = areaCode {
                let areaCodeQueryItem = ClientRuntime.URLQueryItem(name: "area-code".urlPercentEncoding(), value: Swift.String(areaCode).urlPercentEncoding())
                items.append(areaCodeQueryItem)
            }
            if let country = country {
                let countryQueryItem = ClientRuntime.URLQueryItem(name: "country".urlPercentEncoding(), value: Swift.String(country).urlPercentEncoding())
                items.append(countryQueryItem)
            }
            if let city = city {
                let cityQueryItem = ClientRuntime.URLQueryItem(name: "city".urlPercentEncoding(), value: Swift.String(city).urlPercentEncoding())
                items.append(cityQueryItem)
            }
            if let phoneNumberType = phoneNumberType {
                let phoneNumberTypeQueryItem = ClientRuntime.URLQueryItem(name: "phone-number-type".urlPercentEncoding(), value: Swift.String(phoneNumberType.rawValue).urlPercentEncoding())
                items.append(phoneNumberTypeQueryItem)
            }
            if let tollFreePrefix = tollFreePrefix {
                let tollFreePrefixQueryItem = ClientRuntime.URLQueryItem(name: "toll-free-prefix".urlPercentEncoding(), value: Swift.String(tollFreePrefix).urlPercentEncoding())
                items.append(tollFreePrefixQueryItem)
            }
            return items
        }
    }
}

extension SearchAvailablePhoneNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search"
    }
}

public struct SearchAvailablePhoneNumbersInput: Swift.Equatable {
    /// The area code used to filter results. Only applies to the US.
    public var areaCode: Swift.String?
    /// The city used to filter results. Only applies to the US.
    public var city: Swift.String?
    /// The country used to filter results. Defaults to the US Format: ISO 3166-1 alpha-2.
    public var country: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number type used to filter results. Required for non-US numbers.
    public var phoneNumberType: ChimeClientTypes.PhoneNumberType?
    /// The state used to filter results. Required only if you provide City. Only applies to the US.
    public var state: Swift.String?
    /// The toll-free prefix that you use to filter results. Only applies to the US.
    public var tollFreePrefix: Swift.String?

    public init(
        areaCode: Swift.String? = nil,
        city: Swift.String? = nil,
        country: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberType: ChimeClientTypes.PhoneNumberType? = nil,
        state: Swift.String? = nil,
        tollFreePrefix: Swift.String? = nil
    )
    {
        self.areaCode = areaCode
        self.city = city
        self.country = country
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberType = phoneNumberType
        self.state = state
        self.tollFreePrefix = tollFreePrefix
    }
}

struct SearchAvailablePhoneNumbersInputBody: Swift.Equatable {
}

extension SearchAvailablePhoneNumbersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension SearchAvailablePhoneNumbersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchAvailablePhoneNumbersOutputBody = try responseDecoder.decode(responseBody: data)
            self.e164PhoneNumbers = output.e164PhoneNumbers
            self.nextToken = output.nextToken
        } else {
            self.e164PhoneNumbers = nil
            self.nextToken = nil
        }
    }
}

public struct SearchAvailablePhoneNumbersOutput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    public var e164PhoneNumbers: [Swift.String]?
    /// The token used to retrieve the next page of search results.
    public var nextToken: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.nextToken = nextToken
    }
}

struct SearchAvailablePhoneNumbersOutputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
    let nextToken: Swift.String?
}

extension SearchAvailablePhoneNumbersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchAvailablePhoneNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.SelectedVideoStreams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendeeIds = "AttendeeIds"
        case externalUserIds = "ExternalUserIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendeeIds = attendeeIds {
            var attendeeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attendeeIds)
            for guidstring0 in attendeeIds {
                try attendeeIdsContainer.encode(guidstring0)
            }
        }
        if let externalUserIds = externalUserIds {
            var externalUserIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalUserIds)
            for externaluseridtype0 in externalUserIds {
                try externalUserIdsContainer.encode(externaluseridtype0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attendeeIds)
        var attendeeIdsDecoded0:[Swift.String]? = nil
        if let attendeeIdsContainer = attendeeIdsContainer {
            attendeeIdsDecoded0 = [Swift.String]()
            for string0 in attendeeIdsContainer {
                if let string0 = string0 {
                    attendeeIdsDecoded0?.append(string0)
                }
            }
        }
        attendeeIds = attendeeIdsDecoded0
        let externalUserIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .externalUserIds)
        var externalUserIdsDecoded0:[Swift.String]? = nil
        if let externalUserIdsContainer = externalUserIdsContainer {
            externalUserIdsDecoded0 = [Swift.String]()
            for string0 in externalUserIdsContainer {
                if let string0 = string0 {
                    externalUserIdsDecoded0?.append(string0)
                }
            }
        }
        externalUserIds = externalUserIdsDecoded0
    }
}

extension ChimeClientTypes {
    /// The video streams to capture for a specified media capture pipeline. The total number of video streams can't exceed 25.
    public struct SelectedVideoStreams: Swift.Equatable {
        /// The attendee IDs of the streams selected for a media capture pipeline.
        public var attendeeIds: [Swift.String]?
        /// The external user IDs of the streams selected for a media capture pipeline.
        public var externalUserIds: [Swift.String]?

        public init(
            attendeeIds: [Swift.String]? = nil,
            externalUserIds: [Swift.String]? = nil
        )
        {
            self.attendeeIds = attendeeIds
            self.externalUserIds = externalUserIds
        }
    }

}

extension SendChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), persistence: \(Swift.String(describing: persistence)), type: \(Swift.String(describing: type)), clientRequestToken: \"CONTENT_REDACTED\", content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension SendChannelMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let persistence = self.persistence {
            try encodeContainer.encode(persistence.rawValue, forKey: .persistence)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension SendChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension SendChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages"
    }
}

public struct SendChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The Idempotency token for each client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The content of the message.
    /// This member is required.
    public var content: Swift.String?
    /// The optional metadata for each message.
    public var metadata: Swift.String?
    /// Boolean that controls whether the message is persisted on the back end. Required.
    /// This member is required.
    public var persistence: ChimeClientTypes.ChannelMessagePersistenceType?
    /// The type of message, STANDARD or CONTROL.
    /// This member is required.
    public var type: ChimeClientTypes.ChannelMessageType?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        metadata: Swift.String? = nil,
        persistence: ChimeClientTypes.ChannelMessagePersistenceType? = nil,
        type: ChimeClientTypes.ChannelMessageType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.metadata = metadata
        self.persistence = persistence
        self.type = type
    }
}

struct SendChannelMessageInputBody: Swift.Equatable {
    let content: Swift.String?
    let type: ChimeClientTypes.ChannelMessageType?
    let persistence: ChimeClientTypes.ChannelMessagePersistenceType?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
}

extension SendChannelMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let persistenceDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMessagePersistenceType.self, forKey: .persistence)
        persistence = persistenceDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension SendChannelMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendChannelMessageOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
        } else {
            self.channelArn = nil
            self.messageId = nil
        }
    }
}

public struct SendChannelMessageOutput: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID string assigned to each message.
    public var messageId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

struct SendChannelMessageOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let messageId: Swift.String?
}

extension SendChannelMessageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

enum SendChannelMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let code: ChimeClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: ChimeClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes.SigninDelegateGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension ChimeClientTypes {
    /// An Active Directory (AD) group whose members are granted permission to act as delegates.
    public struct SigninDelegateGroup: Swift.Equatable {
        /// The group name.
        public var groupName: Swift.String?

        public init(
            groupName: Swift.String? = nil
        )
        {
            self.groupName = groupName
        }
    }

}

extension ChimeClientTypes.SipMediaApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case createdTimestamp = "CreatedTimestamp"
        case endpoints = "Endpoints"
        case name = "Name"
        case sipMediaApplicationId = "SipMediaApplicationId"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpoint0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sipMediaApplicationId = self.sipMediaApplicationId {
            try encodeContainer.encode(sipMediaApplicationId, forKey: .sipMediaApplicationId)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipMediaApplicationId)
        sipMediaApplicationId = sipMediaApplicationIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes {
    /// The details of the SIP media application, including name and endpoints. An AWS account can have multiple SIP media applications.
    public struct SipMediaApplication: Swift.Equatable {
        /// The AWS Region in which the SIP media application is created.
        public var awsRegion: Swift.String?
        /// The SIP media application creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// List of endpoints for SIP media application. Currently, only one endpoint per SIP media application is permitted.
        public var endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
        /// The name of the SIP media application.
        public var name: Swift.String?
        /// The SIP media application ID.
        public var sipMediaApplicationId: Swift.String?
        /// The SIP media application updated timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            awsRegion: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]? = nil,
            name: Swift.String? = nil,
            sipMediaApplicationId: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.awsRegion = awsRegion
            self.createdTimestamp = createdTimestamp
            self.endpoints = endpoints
            self.name = name
            self.sipMediaApplicationId = sipMediaApplicationId
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes.SipMediaApplicationCall: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension ChimeClientTypes {
    /// A Call instance for a SIP media application.
    public struct SipMediaApplicationCall: Swift.Equatable {
        /// The transaction ID of a call.
        public var transactionId: Swift.String?

        public init(
            transactionId: Swift.String? = nil
        )
        {
            self.transactionId = transactionId
        }
    }

}

extension ChimeClientTypes.SipMediaApplicationEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaArn = "LambdaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = self.lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension ChimeClientTypes.SipMediaApplicationEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipMediaApplicationEndpoint(lambdaArn: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The endpoint assigned to the SIP media application.
    public struct SipMediaApplicationEndpoint: Swift.Equatable {
        /// Valid Amazon Resource Name (ARN) of the Lambda function, version, or alias. The function must be created in the same AWS Region as the SIP media application.
        public var lambdaArn: Swift.String?

        public init(
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }

}

extension ChimeClientTypes.SipMediaApplicationLoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableSipMediaApplicationMessageLogs = "EnableSipMediaApplicationMessageLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableSipMediaApplicationMessageLogs = self.enableSipMediaApplicationMessageLogs {
            try encodeContainer.encode(enableSipMediaApplicationMessageLogs, forKey: .enableSipMediaApplicationMessageLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableSipMediaApplicationMessageLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSipMediaApplicationMessageLogs)
        enableSipMediaApplicationMessageLogs = enableSipMediaApplicationMessageLogsDecoded
    }
}

extension ChimeClientTypes {
    /// Logging configuration of the SIP media application.
    public struct SipMediaApplicationLoggingConfiguration: Swift.Equatable {
        /// Enables application message logs for the SIP media application.
        public var enableSipMediaApplicationMessageLogs: Swift.Bool?

        public init(
            enableSipMediaApplicationMessageLogs: Swift.Bool? = nil
        )
        {
            self.enableSipMediaApplicationMessageLogs = enableSipMediaApplicationMessageLogs
        }
    }

}

extension ChimeClientTypes.SipRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case disabled = "Disabled"
        case name = "Name"
        case sipRuleId = "SipRuleId"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sipRuleId = self.sipRuleId {
            try encodeContainer.encode(sipRuleId, forKey: .sipRuleId)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplication0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplication0)
            }
        }
        if let triggerType = self.triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
        if let triggerValue = self.triggerValue {
            try encodeContainer.encode(triggerValue, forKey: .triggerValue)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipRuleId)
        sipRuleId = sipRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipRuleTriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerValue)
        triggerValue = triggerValueDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeClientTypes {
    /// The SIP rule details, including name, triggers, and target applications. An AWS account can have multiple SIP rules.
    public struct SipRule: Swift.Equatable {
        /// The time at which the SIP rule was created, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// Indicates whether the SIP rule is enabled or disabled. You must disable a rule before you can delete it.
        public var disabled: Swift.Bool?
        /// The name of the SIP rule.
        public var name: Swift.String?
        /// The SIP rule ID.
        public var sipRuleId: Swift.String?
        /// Target SIP media application and other details, such as priority and AWS Region, to be specified in the SIP rule. Only one SIP rule per AWS Region can be provided.
        public var targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?
        /// The type of trigger assigned to the SIP rule in TriggerValue, currently RequestUriHostname or ToPhoneNumber.
        public var triggerType: ChimeClientTypes.SipRuleTriggerType?
        /// If TriggerType is RequestUriHostname, then the value can be the outbound host name of the Amazon Chime Voice Connector. If TriggerType is ToPhoneNumber, then the value can be a customer-owned phone number in E164 format. SipRule is triggered when a SIP rule requests host name or ToPhoneNumber matches in the incoming SIP request.
        public var triggerValue: Swift.String?
        /// The time at which the SIP rule was last updated, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            disabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            sipRuleId: Swift.String? = nil,
            targetApplications: [ChimeClientTypes.SipRuleTargetApplication]? = nil,
            triggerType: ChimeClientTypes.SipRuleTriggerType? = nil,
            triggerValue: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.disabled = disabled
            self.name = name
            self.sipRuleId = sipRuleId
            self.targetApplications = targetApplications
            self.triggerType = triggerType
            self.triggerValue = triggerValue
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes.SipRuleTargetApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case priority = "Priority"
        case sipMediaApplicationId = "SipMediaApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let sipMediaApplicationId = self.sipMediaApplicationId {
            try encodeContainer.encode(sipMediaApplicationId, forKey: .sipMediaApplicationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipMediaApplicationId)
        sipMediaApplicationId = sipMediaApplicationIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ChimeClientTypes {
    /// Target SIP media application and other details, such as priority and AWS Region, to be specified in the SIP rule. Only one SIP rule per AWS Region can be provided.
    public struct SipRuleTargetApplication: Swift.Equatable {
        /// The AWS Region of the target application.
        public var awsRegion: Swift.String?
        /// Priority of the SIP media application in the target list.
        public var priority: Swift.Int?
        /// The SIP media application ID.
        public var sipMediaApplicationId: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sipMediaApplicationId: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.priority = priority
            self.sipMediaApplicationId = sipMediaApplicationId
        }
    }

}

extension ChimeClientTypes {
    public enum SipRuleTriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case requesturihostname
        case tophonenumber
        case sdkUnknown(Swift.String)

        public static var allCases: [SipRuleTriggerType] {
            return [
                .requesturihostname,
                .tophonenumber,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .requesturihostname: return "RequestUriHostname"
            case .tophonenumber: return "ToPhoneNumber"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SipRuleTriggerType(rawValue: rawValue) ?? SipRuleTriggerType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.SourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectedVideoStreams = "SelectedVideoStreams"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectedVideoStreams = self.selectedVideoStreams {
            try encodeContainer.encode(selectedVideoStreams, forKey: .selectedVideoStreams)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedVideoStreamsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SelectedVideoStreams.self, forKey: .selectedVideoStreams)
        selectedVideoStreams = selectedVideoStreamsDecoded
    }
}

extension ChimeClientTypes {
    /// Source configuration for a specified media capture pipeline.
    public struct SourceConfiguration: Swift.Equatable {
        /// The selected video streams to capture for a specified media capture pipeline. The number of video streams can't exceed 25.
        public var selectedVideoStreams: ChimeClientTypes.SelectedVideoStreams?

        public init(
            selectedVideoStreams: ChimeClientTypes.SelectedVideoStreams? = nil
        )
        {
            self.selectedVideoStreams = selectedVideoStreams
        }
    }

}

extension StartMeetingTranscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptionConfiguration = "TranscriptionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transcriptionConfiguration = self.transcriptionConfiguration {
            try encodeContainer.encode(transcriptionConfiguration, forKey: .transcriptionConfiguration)
        }
    }
}

extension StartMeetingTranscriptionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "start"))
            return items
        }
    }
}

extension StartMeetingTranscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/transcription"
    }
}

public struct StartMeetingTranscriptionInput: Swift.Equatable {
    /// The unique ID of the meeting being transcribed.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or EngineTranscribeMedicalSettings.
    /// This member is required.
    public var transcriptionConfiguration: ChimeClientTypes.TranscriptionConfiguration?

    public init(
        meetingId: Swift.String? = nil,
        transcriptionConfiguration: ChimeClientTypes.TranscriptionConfiguration? = nil
    )
    {
        self.meetingId = meetingId
        self.transcriptionConfiguration = transcriptionConfiguration
    }
}

struct StartMeetingTranscriptionInputBody: Swift.Equatable {
    let transcriptionConfiguration: ChimeClientTypes.TranscriptionConfiguration?
}

extension StartMeetingTranscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptionConfiguration = "TranscriptionConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptionConfigurationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TranscriptionConfiguration.self, forKey: .transcriptionConfiguration)
        transcriptionConfiguration = transcriptionConfigurationDecoded
    }
}

extension StartMeetingTranscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartMeetingTranscriptionOutput: Swift.Equatable {

    public init() { }
}

enum StartMeetingTranscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopMeetingTranscriptionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "stop"))
            return items
        }
    }
}

extension StopMeetingTranscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/transcription"
    }
}

public struct StopMeetingTranscriptionInput: Swift.Equatable {
    /// The unique ID of the meeting for which you stop transcription.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct StopMeetingTranscriptionInputBody: Swift.Equatable {
}

extension StopMeetingTranscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopMeetingTranscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopMeetingTranscriptionOutput: Swift.Equatable {

    public init() { }
}

enum StopMeetingTranscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.StreamingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case disabled = "Disabled"
        case streamingNotificationTargets = "StreamingNotificationTargets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRetentionInHours = self.dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let streamingNotificationTargets = streamingNotificationTargets {
            var streamingNotificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingNotificationTargets)
            for streamingnotificationtarget0 in streamingNotificationTargets {
                try streamingNotificationTargetsContainer.encode(streamingnotificationtarget0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let streamingNotificationTargetsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.StreamingNotificationTarget?].self, forKey: .streamingNotificationTargets)
        var streamingNotificationTargetsDecoded0:[ChimeClientTypes.StreamingNotificationTarget]? = nil
        if let streamingNotificationTargetsContainer = streamingNotificationTargetsContainer {
            streamingNotificationTargetsDecoded0 = [ChimeClientTypes.StreamingNotificationTarget]()
            for structure0 in streamingNotificationTargetsContainer {
                if let structure0 = structure0 {
                    streamingNotificationTargetsDecoded0?.append(structure0)
                }
            }
        }
        streamingNotificationTargets = streamingNotificationTargetsDecoded0
    }
}

extension ChimeClientTypes {
    /// The streaming configuration associated with an Amazon Chime Voice Connector. Specifies whether media streaming is enabled for sending to Amazon Kinesis, and shows the retention period for the Amazon Kinesis data, in hours.
    public struct StreamingConfiguration: Swift.Equatable {
        /// The retention period, in hours, for the Amazon Kinesis data.
        /// This member is required.
        public var dataRetentionInHours: Swift.Int?
        /// When true, media streaming to Amazon Kinesis is turned off.
        public var disabled: Swift.Bool?
        /// The streaming notification targets.
        public var streamingNotificationTargets: [ChimeClientTypes.StreamingNotificationTarget]?

        public init(
            dataRetentionInHours: Swift.Int? = nil,
            disabled: Swift.Bool? = nil,
            streamingNotificationTargets: [ChimeClientTypes.StreamingNotificationTarget]? = nil
        )
        {
            self.dataRetentionInHours = dataRetentionInHours
            self.disabled = disabled
            self.streamingNotificationTargets = streamingNotificationTargets
        }
    }

}

extension ChimeClientTypes.StreamingNotificationTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationTarget = "NotificationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationTarget = self.notificationTarget {
            try encodeContainer.encode(notificationTarget.rawValue, forKey: .notificationTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationTargetDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.NotificationTarget.self, forKey: .notificationTarget)
        notificationTarget = notificationTargetDecoded
    }
}

extension ChimeClientTypes {
    /// The targeted recipient for a streaming configuration notification.
    public struct StreamingNotificationTarget: Swift.Equatable {
        /// The streaming notification target.
        /// This member is required.
        public var notificationTarget: ChimeClientTypes.NotificationTarget?

        public init(
            notificationTarget: ChimeClientTypes.NotificationTarget? = nil
        )
        {
            self.notificationTarget = notificationTarget
        }
    }

}

extension ChimeClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Describes a tag applied to a resource.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagAttendeeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagAttendeeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "add"))
            return items
        }
    }
}

extension TagAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        guard let attendeeId = attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())/tags"
    }
}

public struct TagAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
        self.tags = tags
    }
}

struct TagAttendeeInputBody: Swift.Equatable {
    let tags: [ChimeClientTypes.Tag]?
}

extension TagAttendeeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagAttendeeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagAttendeeOutput: Swift.Equatable {

    public init() { }
}

enum TagAttendeeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagMeetingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagMeetingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "add"))
            return items
        }
    }
}

extension TagMeetingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/tags"
    }
}

public struct TagMeetingInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        meetingId: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.meetingId = meetingId
        self.tags = tags
    }
}

struct TagMeetingInputBody: Swift.Equatable {
    let tags: [ChimeClientTypes.Tag]?
}

extension TagMeetingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagMeetingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagMeetingOutput: Swift.Equatable {

    public init() { }
}

enum TagMeetingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(tags: \(Swift.String(describing: tags)), resourceARN: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "tag-resource"))
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ChimeClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.TelephonySettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inboundCalling = "InboundCalling"
        case outboundCalling = "OutboundCalling"
        case sms = "SMS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboundCalling = self.inboundCalling {
            try encodeContainer.encode(inboundCalling, forKey: .inboundCalling)
        }
        if let outboundCalling = self.outboundCalling {
            try encodeContainer.encode(outboundCalling, forKey: .outboundCalling)
        }
        if let sms = self.sms {
            try encodeContainer.encode(sms, forKey: .sms)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboundCallingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCalling)
        inboundCalling = inboundCallingDecoded
        let outboundCallingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCalling)
        outboundCalling = outboundCallingDecoded
        let smsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sms)
        sms = smsDecoded
    }
}

extension ChimeClientTypes {
    /// Settings that allow management of telephony permissions for an Amazon Chime user, such as inbound and outbound calling and text messaging.
    public struct TelephonySettings: Swift.Equatable {
        /// Allows or denies inbound calling.
        /// This member is required.
        public var inboundCalling: Swift.Bool?
        /// Allows or denies outbound calling.
        /// This member is required.
        public var outboundCalling: Swift.Bool?
        /// Allows or denies SMS messaging.
        /// This member is required.
        public var sms: Swift.Bool?

        public init(
            inboundCalling: Swift.Bool? = nil,
            outboundCalling: Swift.Bool? = nil,
            sms: Swift.Bool? = nil
        )
        {
            self.inboundCalling = inboundCalling
            self.outboundCalling = outboundCalling
            self.sms = sms
        }
    }

}

extension ChimeClientTypes.Termination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingRegions = "CallingRegions"
        case cidrAllowedList = "CidrAllowedList"
        case cpsLimit = "CpsLimit"
        case defaultPhoneNumber = "DefaultPhoneNumber"
        case disabled = "Disabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingRegions = callingRegions {
            var callingRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .callingRegions)
            for callingregion0 in callingRegions {
                try callingRegionsContainer.encode(callingregion0)
            }
        }
        if let cidrAllowedList = cidrAllowedList {
            var cidrAllowedListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowedList)
            for string0 in cidrAllowedList {
                try cidrAllowedListContainer.encode(string0)
            }
        }
        if let cpsLimit = self.cpsLimit {
            try encodeContainer.encode(cpsLimit, forKey: .cpsLimit)
        }
        if let defaultPhoneNumber = self.defaultPhoneNumber {
            try encodeContainer.encode(defaultPhoneNumber, forKey: .defaultPhoneNumber)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpsLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cpsLimit)
        cpsLimit = cpsLimitDecoded
        let defaultPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultPhoneNumber)
        defaultPhoneNumber = defaultPhoneNumberDecoded
        let callingRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .callingRegions)
        var callingRegionsDecoded0:[Swift.String]? = nil
        if let callingRegionsContainer = callingRegionsContainer {
            callingRegionsDecoded0 = [Swift.String]()
            for string0 in callingRegionsContainer {
                if let string0 = string0 {
                    callingRegionsDecoded0?.append(string0)
                }
            }
        }
        callingRegions = callingRegionsDecoded0
        let cidrAllowedListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrAllowedList)
        var cidrAllowedListDecoded0:[Swift.String]? = nil
        if let cidrAllowedListContainer = cidrAllowedListContainer {
            cidrAllowedListDecoded0 = [Swift.String]()
            for string0 in cidrAllowedListContainer {
                if let string0 = string0 {
                    cidrAllowedListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowedList = cidrAllowedListDecoded0
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension ChimeClientTypes.Termination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Termination(callingRegions: \(Swift.String(describing: callingRegions)), cidrAllowedList: \(Swift.String(describing: cidrAllowedList)), cpsLimit: \(Swift.String(describing: cpsLimit)), disabled: \(Swift.String(describing: disabled)), defaultPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Termination settings enable your SIP hosts to make outbound calls using your Amazon Chime Voice Connector.
    public struct Termination: Swift.Equatable {
        /// The countries to which calls are allowed, in ISO 3166-1 alpha-2 format. Required.
        public var callingRegions: [Swift.String]?
        /// The IP addresses allowed to make calls, in CIDR format. Required.
        public var cidrAllowedList: [Swift.String]?
        /// The limit on calls per second. Max value based on account service quota. Default value of 1.
        public var cpsLimit: Swift.Int?
        /// The default caller ID phone number.
        public var defaultPhoneNumber: Swift.String?
        /// When termination settings are disabled, outbound calls can not be made.
        public var disabled: Swift.Bool?

        public init(
            callingRegions: [Swift.String]? = nil,
            cidrAllowedList: [Swift.String]? = nil,
            cpsLimit: Swift.Int? = nil,
            defaultPhoneNumber: Swift.String? = nil,
            disabled: Swift.Bool? = nil
        )
        {
            self.callingRegions = callingRegions
            self.cidrAllowedList = cidrAllowedList
            self.cpsLimit = cpsLimit
            self.defaultPhoneNumber = defaultPhoneNumber
            self.disabled = disabled
        }
    }

}

extension ChimeClientTypes.TerminationHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source = "Source"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .dateTime, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .timestamp)
        timestamp = timestampDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension ChimeClientTypes {
    /// The termination health details, including the source IP address and timestamp of the last successful SIP OPTIONS message from your SIP infrastructure.
    public struct TerminationHealth: Swift.Equatable {
        /// The source IP address.
        public var source: Swift.String?
        /// The timestamp, in ISO 8601 format.
        public var timestamp: ClientRuntime.Date?

        public init(
            source: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.source = source
            self.timestamp = timestamp
        }
    }

}

extension ThrottledClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    let code: ChimeClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeClientTypes {
    public enum TranscribeContentIdentificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeContentIdentificationType] {
            return [
                .pii,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeContentIdentificationType(rawValue: rawValue) ?? TranscribeContentIdentificationType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeContentRedactionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeContentRedactionType] {
            return [
                .pii,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeContentRedactionType(rawValue: rawValue) ?? TranscribeContentRedactionType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enAu
        case enGb
        case enUs
        case esUs
        case frCa
        case frFr
        case hiIn
        case itIt
        case jaJp
        case koKr
        case ptBr
        case thTh
        case zhCn
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeLanguageCode] {
            return [
                .deDe,
                .enAu,
                .enGb,
                .enUs,
                .esUs,
                .frCa,
                .frFr,
                .hiIn,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .thTh,
                .zhCn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .esUs: return "es-US"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .hiIn: return "hi-IN"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .ptBr: return "pt-BR"
            case .thTh: return "th-TH"
            case .zhCn: return "zh-CN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeLanguageCode(rawValue: rawValue) ?? TranscribeLanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeMedicalContentIdentificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case phi
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalContentIdentificationType] {
            return [
                .phi,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .phi: return "PHI"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalContentIdentificationType(rawValue: rawValue) ?? TranscribeMedicalContentIdentificationType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeMedicalLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalLanguageCode] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalLanguageCode(rawValue: rawValue) ?? TranscribeMedicalLanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeMedicalRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apSoutheast2
        case auto
        case caCentral1
        case euWest1
        case usEast1
        case usEast2
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalRegion] {
            return [
                .apSoutheast2,
                .auto,
                .caCentral1,
                .euWest1,
                .usEast1,
                .usEast2,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apSoutheast2: return "ap-southeast-2"
            case .auto: return "auto"
            case .caCentral1: return "ca-central-1"
            case .euWest1: return "eu-west-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalRegion(rawValue: rawValue) ?? TranscribeMedicalRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeMedicalSpecialty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cardiology
        case neurology
        case oncology
        case primarycare
        case radiology
        case urology
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalSpecialty] {
            return [
                .cardiology,
                .neurology,
                .oncology,
                .primarycare,
                .radiology,
                .urology,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cardiology: return "CARDIOLOGY"
            case .neurology: return "NEUROLOGY"
            case .oncology: return "ONCOLOGY"
            case .primarycare: return "PRIMARYCARE"
            case .radiology: return "RADIOLOGY"
            case .urology: return "UROLOGY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalSpecialty(rawValue: rawValue) ?? TranscribeMedicalSpecialty.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeMedicalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conversation
        case dictation
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalType] {
            return [
                .conversation,
                .dictation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conversation: return "CONVERSATION"
            case .dictation: return "DICTATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalType(rawValue: rawValue) ?? TranscribeMedicalType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribePartialResultsStability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribePartialResultsStability] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .medium: return "medium"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribePartialResultsStability(rawValue: rawValue) ?? TranscribePartialResultsStability.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apNortheast1
        case apNortheast2
        case apSoutheast2
        case auto
        case caCentral1
        case euCentral1
        case euWest1
        case euWest2
        case saEast1
        case usEast1
        case usEast2
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeRegion] {
            return [
                .apNortheast1,
                .apNortheast2,
                .apSoutheast2,
                .auto,
                .caCentral1,
                .euCentral1,
                .euWest1,
                .euWest2,
                .saEast1,
                .usEast1,
                .usEast2,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apSoutheast2: return "ap-southeast-2"
            case .auto: return "auto"
            case .caCentral1: return "ca-central-1"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .saEast1: return "sa-east-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeRegion(rawValue: rawValue) ?? TranscribeRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes {
    public enum TranscribeVocabularyFilterMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mask
        case remove
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeVocabularyFilterMethod] {
            return [
                .mask,
                .remove,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mask: return "mask"
            case .remove: return "remove"
            case .tag: return "tag"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeVocabularyFilterMethod(rawValue: rawValue) ?? TranscribeVocabularyFilterMethod.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.TranscriptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineTranscribeMedicalSettings = "EngineTranscribeMedicalSettings"
        case engineTranscribeSettings = "EngineTranscribeSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineTranscribeMedicalSettings = self.engineTranscribeMedicalSettings {
            try encodeContainer.encode(engineTranscribeMedicalSettings, forKey: .engineTranscribeMedicalSettings)
        }
        if let engineTranscribeSettings = self.engineTranscribeSettings {
            try encodeContainer.encode(engineTranscribeSettings, forKey: .engineTranscribeSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineTranscribeSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EngineTranscribeSettings.self, forKey: .engineTranscribeSettings)
        engineTranscribeSettings = engineTranscribeSettingsDecoded
        let engineTranscribeMedicalSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.EngineTranscribeMedicalSettings.self, forKey: .engineTranscribeMedicalSettings)
        engineTranscribeMedicalSettings = engineTranscribeMedicalSettingsDecoded
    }
}

extension ChimeClientTypes {
    /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or EngineTranscribeMedicalSettings.
    public struct TranscriptionConfiguration: Swift.Equatable {
        /// The transcription configuration settings passed to Amazon Transcribe Medical.
        public var engineTranscribeMedicalSettings: ChimeClientTypes.EngineTranscribeMedicalSettings?
        /// The transcription configuration settings passed to Amazon Transcribe.
        public var engineTranscribeSettings: ChimeClientTypes.EngineTranscribeSettings?

        public init(
            engineTranscribeMedicalSettings: ChimeClientTypes.EngineTranscribeMedicalSettings? = nil,
            engineTranscribeSettings: ChimeClientTypes.EngineTranscribeSettings? = nil
        )
        {
            self.engineTranscribeMedicalSettings = engineTranscribeMedicalSettings
            self.engineTranscribeSettings = engineTranscribeSettings
        }
    }

}

extension UnauthorizedClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let code: ChimeClientTypes.ErrorCode?
    let message: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessableEntityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnprocessableEntityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was well-formed but was unable to be followed due to semantic errors.
public struct UnprocessableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnprocessableEntityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct UnprocessableEntityExceptionBody: Swift.Equatable {
    let code: ChimeClientTypes.ErrorCode?
    let message: Swift.String?
}

extension UnprocessableEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagAttendeeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagAttendeeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "delete"))
            return items
        }
    }
}

extension UntagAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        guard let attendeeId = attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())/tags"
    }
}

public struct UntagAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
        self.tagKeys = tagKeys
    }
}

struct UntagAttendeeInputBody: Swift.Equatable {
    let tagKeys: [Swift.String]?
}

extension UntagAttendeeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagAttendeeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagAttendeeOutput: Swift.Equatable {

    public init() { }
}

enum UntagAttendeeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagMeetingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagMeetingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "delete"))
            return items
        }
    }
}

extension UntagMeetingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/tags"
    }
}

public struct UntagMeetingInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        meetingId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.meetingId = meetingId
        self.tagKeys = tagKeys
    }
}

struct UntagMeetingInputBody: Swift.Equatable {
    let tagKeys: [Swift.String]?
}

extension UntagMeetingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagMeetingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagMeetingOutput: Swift.Equatable {

    public init() { }
}

enum UntagMeetingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(tagKeys: \(Swift.String(describing: tagKeys)), resourceARN: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "untag-resource"))
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLicense = "DefaultLicense"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultLicense = self.defaultLicense {
            try encodeContainer.encode(defaultLicense.rawValue, forKey: .defaultLicense)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())"
    }
}

public struct UpdateAccountInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The default license applied when you add users to an Amazon Chime account.
    public var defaultLicense: ChimeClientTypes.License?
    /// The new name for the specified Amazon Chime account.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        defaultLicense: ChimeClientTypes.License? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.defaultLicense = defaultLicense
        self.name = name
    }
}

struct UpdateAccountInputBody: Swift.Equatable {
    let name: Swift.String?
    let defaultLicense: ChimeClientTypes.License?
}

extension UpdateAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLicense = "DefaultLicense"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultLicenseDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.License.self, forKey: .defaultLicense)
        defaultLicense = defaultLicenseDecoded
    }
}

extension UpdateAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.account = output.account
        } else {
            self.account = nil
        }
    }
}

public struct UpdateAccountOutput: Swift.Equatable {
    /// The updated Amazon Chime account details.
    public var account: ChimeClientTypes.Account?

    public init(
        account: ChimeClientTypes.Account? = nil
    )
    {
        self.account = account
    }
}

struct UpdateAccountOutputBody: Swift.Equatable {
    let account: ChimeClientTypes.Account?
}

extension UpdateAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Account.self, forKey: .account)
        account = accountDecoded
    }
}

enum UpdateAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAccountSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings = "AccountSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountSettings = self.accountSettings {
            try encodeContainer.encode(accountSettings, forKey: .accountSettings)
        }
    }
}

extension UpdateAccountSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/settings"
    }
}

public struct UpdateAccountSettingsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Chime account settings to update.
    /// This member is required.
    public var accountSettings: ChimeClientTypes.AccountSettings?

    public init(
        accountId: Swift.String? = nil,
        accountSettings: ChimeClientTypes.AccountSettings? = nil
    )
    {
        self.accountId = accountId
        self.accountSettings = accountSettings
    }
}

struct UpdateAccountSettingsInputBody: Swift.Equatable {
    let accountSettings: ChimeClientTypes.AccountSettings?
}

extension UpdateAccountSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSettings = "AccountSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AccountSettings.self, forKey: .accountSettings)
        accountSettings = accountSettingsDecoded
    }
}

extension UpdateAccountSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAccountSettingsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAccountSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateAppInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAppInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())"
    }
}

public struct UpdateAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The metadata that you want to change.
    public var metadata: Swift.String?
    /// The name that you want to change.
    /// This member is required.
    public var name: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.metadata = metadata
        self.name = name
    }
}

struct UpdateAppInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let metadata: Swift.String?
}

extension UpdateAppInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateAppInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceArn = nil
        }
    }
}

public struct UpdateAppInstanceOutput: Swift.Equatable {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct UpdateAppInstanceOutputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
}

extension UpdateAppInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

enum UpdateAppInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateAppInstanceUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
    }
}

public struct UpdateAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The metadata of the AppInstanceUser.
    public var metadata: Swift.String?
    /// The name of the AppInstanceUser.
    /// This member is required.
    public var name: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.metadata = metadata
        self.name = name
    }
}

struct UpdateAppInstanceUserInputBody: Swift.Equatable {
    let name: Swift.String?
    let metadata: Swift.String?
}

extension UpdateAppInstanceUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateAppInstanceUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppInstanceUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
        } else {
            self.appInstanceUserArn = nil
        }
    }
}

public struct UpdateAppInstanceUserOutput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct UpdateAppInstanceUserOutputBody: Swift.Equatable {
    let appInstanceUserArn: Swift.String?
}

extension UpdateAppInstanceUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
    }
}

enum UpdateAppInstanceUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
    }
}

extension UpdateBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let botId = botId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())"
    }
}

public struct UpdateBotInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?
    /// When true, stops the specified bot from running in your account.
    public var disabled: Swift.Bool?

    public init(
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil,
        disabled: Swift.Bool? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
        self.disabled = disabled
    }
}

struct UpdateBotInputBody: Swift.Equatable {
    let disabled: Swift.Bool?
}

extension UpdateBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension UpdateBotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBotOutputBody = try responseDecoder.decode(responseBody: data)
            self.bot = output.bot
        } else {
            self.bot = nil
        }
    }
}

public struct UpdateBotOutput: Swift.Equatable {
    /// The updated bot details.
    public var bot: ChimeClientTypes.Bot?

    public init(
        bot: ChimeClientTypes.Bot? = nil
    )
    {
        self.bot = bot
    }
}

struct UpdateBotOutputBody: Swift.Equatable {
    let bot: ChimeClientTypes.Bot?
}

extension UpdateBotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bot = "Bot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Bot.self, forKey: .bot)
        bot = botDecoded
    }
}

enum UpdateBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), mode: \(Swift.String(describing: mode)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct UpdateChannelInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The metadata for the update request.
    public var metadata: Swift.String?
    /// The mode of the update request.
    /// This member is required.
    public var mode: ChimeClientTypes.ChannelMode?
    /// The name of the channel.
    /// This member is required.
    public var name: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeClientTypes.ChannelMode? = nil,
        name: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.metadata = metadata
        self.mode = mode
        self.name = name
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    let name: Swift.String?
    let mode: ChimeClientTypes.ChannelMode?
    let metadata: Swift.String?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), messageId: \(Swift.String(describing: messageId)), content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension UpdateChannelMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case metadata = "Metadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }
}

extension UpdateChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct UpdateChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The content of the message being updated.
    public var content: Swift.String?
    /// The ID string of the message being updated.
    /// This member is required.
    public var messageId: Swift.String?
    /// The metadata of the message being updated.
    public var metadata: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        content: Swift.String? = nil,
        messageId: Swift.String? = nil,
        metadata: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.content = content
        self.messageId = messageId
        self.metadata = metadata
    }
}

struct UpdateChannelMessageInputBody: Swift.Equatable {
    let content: Swift.String?
    let metadata: Swift.String?
}

extension UpdateChannelMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case metadata = "Metadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateChannelMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateChannelMessageOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
        } else {
            self.channelArn = nil
            self.messageId = nil
        }
    }
}

public struct UpdateChannelMessageOutput: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID string of the message being updated.
    public var messageId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

struct UpdateChannelMessageOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let messageId: Swift.String?
}

extension UpdateChannelMessageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

enum UpdateChannelMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct UpdateChannelOutput: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct UpdateChannelOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
}

extension UpdateChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

enum UpdateChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateChannelReadMarkerInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelReadMarkerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/readMarker"
    }
}

public struct UpdateChannelReadMarkerInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct UpdateChannelReadMarkerInputBody: Swift.Equatable {
}

extension UpdateChannelReadMarkerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UpdateChannelReadMarkerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateChannelReadMarkerOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct UpdateChannelReadMarkerOutput: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct UpdateChannelReadMarkerOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
}

extension UpdateChannelReadMarkerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

enum UpdateChannelReadMarkerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGlobalSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessCalling = "BusinessCalling"
        case voiceConnector = "VoiceConnector"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let businessCalling = self.businessCalling {
            try encodeContainer.encode(businessCalling, forKey: .businessCalling)
        }
        if let voiceConnector = self.voiceConnector {
            try encodeContainer.encode(voiceConnector, forKey: .voiceConnector)
        }
    }
}

extension UpdateGlobalSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings"
    }
}

public struct UpdateGlobalSettingsInput: Swift.Equatable {
    /// The Amazon Chime Business Calling settings.
    public var businessCalling: ChimeClientTypes.BusinessCallingSettings?
    /// The Amazon Chime Voice Connector settings.
    public var voiceConnector: ChimeClientTypes.VoiceConnectorSettings?

    public init(
        businessCalling: ChimeClientTypes.BusinessCallingSettings? = nil,
        voiceConnector: ChimeClientTypes.VoiceConnectorSettings? = nil
    )
    {
        self.businessCalling = businessCalling
        self.voiceConnector = voiceConnector
    }
}

struct UpdateGlobalSettingsInputBody: Swift.Equatable {
    let businessCalling: ChimeClientTypes.BusinessCallingSettings?
    let voiceConnector: ChimeClientTypes.VoiceConnectorSettings?
}

extension UpdateGlobalSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessCalling = "BusinessCalling"
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let businessCallingDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.BusinessCallingSettings.self, forKey: .businessCalling)
        businessCalling = businessCallingDecoded
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorSettings.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension UpdateGlobalSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateGlobalSettingsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateGlobalSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberInput(phoneNumberId: \(Swift.String(describing: phoneNumberId)), productType: \(Swift.String(describing: productType)), callingName: \"CONTENT_REDACTED\")"}
}

extension UpdatePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }
}

extension UpdatePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct UpdatePhoneNumberInput: Swift.Equatable {
    /// The outbound calling name associated with the phone number.
    public var callingName: Swift.String?
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?
    /// The product type.
    public var productType: ChimeClientTypes.PhoneNumberProductType?

    public init(
        callingName: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        productType: ChimeClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.callingName = callingName
        self.phoneNumberId = phoneNumberId
        self.productType = productType
    }
}

struct UpdatePhoneNumberInputBody: Swift.Equatable {
    let productType: ChimeClientTypes.PhoneNumberProductType?
    let callingName: Swift.String?
}

extension UpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case productType = "ProductType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

extension UpdatePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct UpdatePhoneNumberOutput: Swift.Equatable {
    /// The updated phone number details.
    public var phoneNumber: ChimeClientTypes.PhoneNumber?

    public init(
        phoneNumber: ChimeClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct UpdatePhoneNumberOutputBody: Swift.Equatable {
    let phoneNumber: ChimeClientTypes.PhoneNumber?
}

extension UpdatePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

enum UpdatePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.UpdatePhoneNumberRequestItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case phoneNumberId = "PhoneNumberId"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

extension ChimeClientTypes.UpdatePhoneNumberRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberRequestItem(phoneNumberId: \(Swift.String(describing: phoneNumberId)), productType: \(Swift.String(describing: productType)), callingName: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The phone number ID, product type, or calling name fields to update, used with the [BatchUpdatePhoneNumber] and [UpdatePhoneNumber] actions.
    public struct UpdatePhoneNumberRequestItem: Swift.Equatable {
        /// The outbound calling name to update.
        public var callingName: Swift.String?
        /// The phone number ID to update.
        /// This member is required.
        public var phoneNumberId: Swift.String?
        /// The product type to update.
        public var productType: ChimeClientTypes.PhoneNumberProductType?

        public init(
            callingName: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            productType: ChimeClientTypes.PhoneNumberProductType? = nil
        )
        {
            self.callingName = callingName
            self.phoneNumberId = phoneNumberId
            self.productType = productType
        }
    }

}

extension UpdatePhoneNumberSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberSettingsInput(callingName: \"CONTENT_REDACTED\")"}
}

extension UpdatePhoneNumberSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
    }
}

extension UpdatePhoneNumberSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings/phone-number"
    }
}

public struct UpdatePhoneNumberSettingsInput: Swift.Equatable {
    /// The default outbound calling name for the account.
    /// This member is required.
    public var callingName: Swift.String?

    public init(
        callingName: Swift.String? = nil
    )
    {
        self.callingName = callingName
    }
}

struct UpdatePhoneNumberSettingsInputBody: Swift.Equatable {
    let callingName: Swift.String?
}

extension UpdatePhoneNumberSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

extension UpdatePhoneNumberSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePhoneNumberSettingsOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePhoneNumberSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProxySessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capability0 in capabilities {
                try capabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let expiryMinutes = self.expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
    }
}

extension UpdateProxySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

public struct UpdateProxySessionInput: Swift.Equatable {
    /// The proxy session capabilities.
    /// This member is required.
    public var capabilities: [ChimeClientTypes.Capability]?
    /// The number of minutes allowed for the proxy session.
    public var expiryMinutes: Swift.Int?
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        capabilities: [ChimeClientTypes.Capability]? = nil,
        expiryMinutes: Swift.Int? = nil,
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.expiryMinutes = expiryMinutes
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct UpdateProxySessionInputBody: Swift.Equatable {
    let capabilities: [ChimeClientTypes.Capability]?
    let expiryMinutes: Swift.Int?
}

extension UpdateProxySessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeClientTypes.Capability]()
            for enum0 in capabilitiesContainer {
                if let enum0 = enum0 {
                    capabilitiesDecoded0?.append(enum0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
    }
}

extension UpdateProxySessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProxySessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct UpdateProxySessionOutput: Swift.Equatable {
    /// The proxy session details.
    public var proxySession: ChimeClientTypes.ProxySession?

    public init(
        proxySession: ChimeClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct UpdateProxySessionOutputBody: Swift.Equatable {
    let proxySession: ChimeClientTypes.ProxySession?
}

extension UpdateProxySessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

enum UpdateProxySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRoomInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRoomInput(accountId: \(Swift.String(describing: accountId)), roomId: \(Swift.String(describing: roomId)), name: \"CONTENT_REDACTED\")"}
}

extension UpdateRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let roomId = roomId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())"
    }
}

public struct UpdateRoomInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The room name.
    public var name: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.roomId = roomId
    }
}

struct UpdateRoomInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateRoomMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }
}

extension UpdateRoomMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let roomId = roomId else {
            return nil
        }
        guard let memberId = memberId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships/\(memberId.urlPercentEncoding())"
    }
}

public struct UpdateRoomMembershipInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The member ID.
    /// This member is required.
    public var memberId: Swift.String?
    /// The role of the member.
    public var role: ChimeClientTypes.RoomMembershipRole?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        role: ChimeClientTypes.RoomMembershipRole? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.memberId = memberId
        self.role = role
        self.roomId = roomId
    }
}

struct UpdateRoomMembershipInputBody: Swift.Equatable {
    let role: ChimeClientTypes.RoomMembershipRole?
}

extension UpdateRoomMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomMembershipRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension UpdateRoomMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRoomMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.roomMembership = output.roomMembership
        } else {
            self.roomMembership = nil
        }
    }
}

public struct UpdateRoomMembershipOutput: Swift.Equatable {
    /// The room membership details.
    public var roomMembership: ChimeClientTypes.RoomMembership?

    public init(
        roomMembership: ChimeClientTypes.RoomMembership? = nil
    )
    {
        self.roomMembership = roomMembership
    }
}

struct UpdateRoomMembershipOutputBody: Swift.Equatable {
    let roomMembership: ChimeClientTypes.RoomMembership?
}

extension UpdateRoomMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomMembership = "RoomMembership"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomMembershipDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RoomMembership.self, forKey: .roomMembership)
        roomMembership = roomMembershipDecoded
    }
}

enum UpdateRoomMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRoomOutputBody = try responseDecoder.decode(responseBody: data)
            self.room = output.room
        } else {
            self.room = nil
        }
    }
}

public struct UpdateRoomOutput: Swift.Equatable {
    /// The room details.
    public var room: ChimeClientTypes.Room?

    public init(
        room: ChimeClientTypes.Room? = nil
    )
    {
        self.room = room
    }
}

struct UpdateRoomOutputBody: Swift.Equatable {
    let room: ChimeClientTypes.Room?
}

extension UpdateRoomOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case room = "Room"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Room.self, forKey: .room)
        room = roomDecoded
    }
}

enum UpdateRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSipMediaApplicationCallInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arguments = "Arguments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arguments = arguments {
            var argumentsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .arguments)
            for (dictKey0, smaUpdateCallArgumentsMap0) in arguments {
                try argumentsContainer.encode(smaUpdateCallArgumentsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateSipMediaApplicationCallInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        guard let transactionId = transactionId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/calls/\(transactionId.urlPercentEncoding())"
    }
}

public struct UpdateSipMediaApplicationCallInput: Swift.Equatable {
    /// Arguments made available to the Lambda function as part of the CALL_UPDATE_REQUESTED event. Can contain 0-20 key-value pairs.
    /// This member is required.
    public var arguments: [Swift.String:Swift.String]?
    /// The ID of the SIP media application handling the call.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The ID of the call transaction.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        arguments: [Swift.String:Swift.String]? = nil,
        sipMediaApplicationId: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.arguments = arguments
        self.sipMediaApplicationId = sipMediaApplicationId
        self.transactionId = transactionId
    }
}

struct UpdateSipMediaApplicationCallInputBody: Swift.Equatable {
    let arguments: [Swift.String:Swift.String]?
}

extension UpdateSipMediaApplicationCallInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arguments = "Arguments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let argumentsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .arguments)
        var argumentsDecoded0: [Swift.String:Swift.String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in argumentsContainer {
                if let sensitivestring0 = sensitivestring0 {
                    argumentsDecoded0?[key0] = sensitivestring0
                }
            }
        }
        arguments = argumentsDecoded0
    }
}

extension UpdateSipMediaApplicationCallOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSipMediaApplicationCallOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationCall = output.sipMediaApplicationCall
        } else {
            self.sipMediaApplicationCall = nil
        }
    }
}

public struct UpdateSipMediaApplicationCallOutput: Swift.Equatable {
    /// A Call instance for a SIP media application.
    public var sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall?

    public init(
        sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall? = nil
    )
    {
        self.sipMediaApplicationCall = sipMediaApplicationCall
    }
}

struct UpdateSipMediaApplicationCallOutputBody: Swift.Equatable {
    let sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall?
}

extension UpdateSipMediaApplicationCallOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationCall = "SipMediaApplicationCall"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationCallDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplicationCall.self, forKey: .sipMediaApplicationCall)
        sipMediaApplicationCall = sipMediaApplicationCallDecoded
    }
}

enum UpdateSipMediaApplicationCallOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSipMediaApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpoint0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateSipMediaApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

public struct UpdateSipMediaApplicationInput: Swift.Equatable {
    /// The new set of endpoints for the specified SIP media application.
    public var endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
    /// The new name for the specified SIP media application.
    public var name: Swift.String?
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]? = nil,
        name: Swift.String? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.name = name
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct UpdateSipMediaApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
}

extension UpdateSipMediaApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension UpdateSipMediaApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSipMediaApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct UpdateSipMediaApplicationOutput: Swift.Equatable {
    /// The updated SIP media application details.
    public var sipMediaApplication: ChimeClientTypes.SipMediaApplication?

    public init(
        sipMediaApplication: ChimeClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct UpdateSipMediaApplicationOutputBody: Swift.Equatable {
    let sipMediaApplication: ChimeClientTypes.SipMediaApplication?
}

extension UpdateSipMediaApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

enum UpdateSipMediaApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSipRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplication0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplication0)
            }
        }
    }
}

extension UpdateSipRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipRuleId = sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

public struct UpdateSipRuleInput: Swift.Equatable {
    /// The new value specified to indicate whether the rule is disabled.
    public var disabled: Swift.Bool?
    /// The new name for the specified SIP rule.
    /// This member is required.
    public var name: Swift.String?
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?
    /// The new value of the list of target applications.
    public var targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?

    public init(
        disabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        sipRuleId: Swift.String? = nil,
        targetApplications: [ChimeClientTypes.SipRuleTargetApplication]? = nil
    )
    {
        self.disabled = disabled
        self.name = name
        self.sipRuleId = sipRuleId
        self.targetApplications = targetApplications
    }
}

struct UpdateSipRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let disabled: Swift.Bool?
    let targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?
}

extension UpdateSipRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
    }
}

extension UpdateSipRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSipRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct UpdateSipRuleOutput: Swift.Equatable {
    /// Updated SIP rule details.
    public var sipRule: ChimeClientTypes.SipRule?

    public init(
        sipRule: ChimeClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct UpdateSipRuleOutputBody: Swift.Equatable {
    let sipRule: ChimeClientTypes.SipRule?
}

extension UpdateSipRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

enum UpdateSipRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alexaForBusinessMetadata = "AlexaForBusinessMetadata"
        case licenseType = "LicenseType"
        case userType = "UserType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alexaForBusinessMetadata = self.alexaForBusinessMetadata {
            try encodeContainer.encode(alexaForBusinessMetadata, forKey: .alexaForBusinessMetadata)
        }
        if let licenseType = self.licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Alexa for Business metadata.
    public var alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata?
    /// The user license type to update. This must be a supported license type for the Amazon Chime account that the user belongs to.
    public var licenseType: ChimeClientTypes.License?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?
    /// The user type.
    public var userType: ChimeClientTypes.UserType?

    public init(
        accountId: Swift.String? = nil,
        alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata? = nil,
        licenseType: ChimeClientTypes.License? = nil,
        userId: Swift.String? = nil,
        userType: ChimeClientTypes.UserType? = nil
    )
    {
        self.accountId = accountId
        self.alexaForBusinessMetadata = alexaForBusinessMetadata
        self.licenseType = licenseType
        self.userId = userId
        self.userType = userType
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let licenseType: ChimeClientTypes.License?
    let userType: ChimeClientTypes.UserType?
    let alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alexaForBusinessMetadata = "AlexaForBusinessMetadata"
        case licenseType = "LicenseType"
        case userType = "UserType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.License.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
        let alexaForBusinessMetadataDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AlexaForBusinessMetadata.self, forKey: .alexaForBusinessMetadata)
        alexaForBusinessMetadata = alexaForBusinessMetadataDecoded
    }
}

extension UpdateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct UpdateUserOutput: Swift.Equatable {
    /// The updated user details.
    public var user: ChimeClientTypes.User?

    public init(
        user: ChimeClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct UpdateUserOutputBody: Swift.Equatable {
    let user: ChimeClientTypes.User?
}

extension UpdateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

enum UpdateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.UpdateUserRequestItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alexaForBusinessMetadata = "AlexaForBusinessMetadata"
        case licenseType = "LicenseType"
        case userId = "UserId"
        case userType = "UserType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alexaForBusinessMetadata = self.alexaForBusinessMetadata {
            try encodeContainer.encode(alexaForBusinessMetadata, forKey: .alexaForBusinessMetadata)
        }
        if let licenseType = self.licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.License.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
        let alexaForBusinessMetadataDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AlexaForBusinessMetadata.self, forKey: .alexaForBusinessMetadata)
        alexaForBusinessMetadata = alexaForBusinessMetadataDecoded
    }
}

extension ChimeClientTypes {
    /// The user ID and user fields to update, used with the [BatchUpdateUser] action.
    public struct UpdateUserRequestItem: Swift.Equatable {
        /// The Alexa for Business metadata.
        public var alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata?
        /// The user license type.
        public var licenseType: ChimeClientTypes.License?
        /// The user ID.
        /// This member is required.
        public var userId: Swift.String?
        /// The user type.
        public var userType: ChimeClientTypes.UserType?

        public init(
            alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata? = nil,
            licenseType: ChimeClientTypes.License? = nil,
            userId: Swift.String? = nil,
            userType: ChimeClientTypes.UserType? = nil
        )
        {
            self.alexaForBusinessMetadata = alexaForBusinessMetadata
            self.licenseType = licenseType
            self.userId = userId
            self.userType = userType
        }
    }

}

extension UpdateUserSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userSettings = self.userSettings {
            try encodeContainer.encode(userSettings, forKey: .userSettings)
        }
    }
}

extension UpdateUserSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accountId = accountId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())/settings"
    }
}

public struct UpdateUserSettingsInput: Swift.Equatable {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?
    /// The user settings to update.
    /// This member is required.
    public var userSettings: ChimeClientTypes.UserSettings?

    public init(
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil,
        userSettings: ChimeClientTypes.UserSettings? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
        self.userSettings = userSettings
    }
}

struct UpdateUserSettingsInputBody: Swift.Equatable {
    let userSettings: ChimeClientTypes.UserSettings?
}

extension UpdateUserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings = "UserSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserSettings.self, forKey: .userSettings)
        userSettings = userSettingsDecoded
    }
}

extension UpdateUserSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserSettingsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritem0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritem0)
            }
        }
    }
}

extension UpdateVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct UpdateVoiceConnectorGroupInput: Swift.Equatable {
    /// The name of the Amazon Chime Voice Connector group.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?
    /// The VoiceConnectorItems to associate with the group.
    /// This member is required.
    public var voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?

    public init(
        name: Swift.String? = nil,
        voiceConnectorGroupId: Swift.String? = nil,
        voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]? = nil
    )
    {
        self.name = name
        self.voiceConnectorGroupId = voiceConnectorGroupId
        self.voiceConnectorItems = voiceConnectorItems
    }
}

struct UpdateVoiceConnectorGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?
}

extension UpdateVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
    }
}

extension UpdateVoiceConnectorGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVoiceConnectorGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct UpdateVoiceConnectorGroupOutput: Swift.Equatable {
    /// The updated Amazon Chime Voice Connector group details.
    public var voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?

    public init(
        voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct UpdateVoiceConnectorGroupOutputBody: Swift.Equatable {
    let voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?
}

extension UpdateVoiceConnectorGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

enum UpdateVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requireEncryption = self.requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
    }
}

extension UpdateVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct UpdateVoiceConnectorInput: Swift.Equatable {
    /// The name of the Amazon Chime Voice Connector.
    /// This member is required.
    public var name: Swift.String?
    /// When enabled, requires encryption for the Amazon Chime Voice Connector.
    /// This member is required.
    public var requireEncryption: Swift.Bool?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        name: Swift.String? = nil,
        requireEncryption: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.name = name
        self.requireEncryption = requireEncryption
        self.voiceConnectorId = voiceConnectorId
    }
}

struct UpdateVoiceConnectorInputBody: Swift.Equatable {
    let name: Swift.String?
    let requireEncryption: Swift.Bool?
}

extension UpdateVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
    }
}

extension UpdateVoiceConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVoiceConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct UpdateVoiceConnectorOutput: Swift.Equatable {
    /// The updated Amazon Chime Voice Connector details.
    public var voiceConnector: ChimeClientTypes.VoiceConnector?

    public init(
        voiceConnector: ChimeClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct UpdateVoiceConnectorOutputBody: Swift.Equatable {
    let voiceConnector: ChimeClientTypes.VoiceConnector?
}

extension UpdateVoiceConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

enum UpdateVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alexaForBusinessMetadata = "AlexaForBusinessMetadata"
        case displayName = "DisplayName"
        case invitedOn = "InvitedOn"
        case licenseType = "LicenseType"
        case personalPIN = "PersonalPIN"
        case primaryEmail = "PrimaryEmail"
        case primaryProvisionedNumber = "PrimaryProvisionedNumber"
        case registeredOn = "RegisteredOn"
        case userId = "UserId"
        case userInvitationStatus = "UserInvitationStatus"
        case userRegistrationStatus = "UserRegistrationStatus"
        case userType = "UserType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let alexaForBusinessMetadata = self.alexaForBusinessMetadata {
            try encodeContainer.encode(alexaForBusinessMetadata, forKey: .alexaForBusinessMetadata)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let invitedOn = self.invitedOn {
            try encodeContainer.encodeTimestamp(invitedOn, format: .dateTime, forKey: .invitedOn)
        }
        if let licenseType = self.licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let personalPIN = self.personalPIN {
            try encodeContainer.encode(personalPIN, forKey: .personalPIN)
        }
        if let primaryEmail = self.primaryEmail {
            try encodeContainer.encode(primaryEmail, forKey: .primaryEmail)
        }
        if let primaryProvisionedNumber = self.primaryProvisionedNumber {
            try encodeContainer.encode(primaryProvisionedNumber, forKey: .primaryProvisionedNumber)
        }
        if let registeredOn = self.registeredOn {
            try encodeContainer.encodeTimestamp(registeredOn, format: .dateTime, forKey: .registeredOn)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let userInvitationStatus = self.userInvitationStatus {
            try encodeContainer.encode(userInvitationStatus.rawValue, forKey: .userInvitationStatus)
        }
        if let userRegistrationStatus = self.userRegistrationStatus {
            try encodeContainer.encode(userRegistrationStatus.rawValue, forKey: .userRegistrationStatus)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let primaryEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryEmail)
        primaryEmail = primaryEmailDecoded
        let primaryProvisionedNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryProvisionedNumber)
        primaryProvisionedNumber = primaryProvisionedNumberDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.License.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
        let userRegistrationStatusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.RegistrationStatus.self, forKey: .userRegistrationStatus)
        userRegistrationStatus = userRegistrationStatusDecoded
        let userInvitationStatusDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.InviteStatus.self, forKey: .userInvitationStatus)
        userInvitationStatus = userInvitationStatusDecoded
        let registeredOnDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .registeredOn)
        registeredOn = registeredOnDecoded
        let invitedOnDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .invitedOn)
        invitedOn = invitedOnDecoded
        let alexaForBusinessMetadataDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.AlexaForBusinessMetadata.self, forKey: .alexaForBusinessMetadata)
        alexaForBusinessMetadata = alexaForBusinessMetadataDecoded
        let personalPINDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .personalPIN)
        personalPIN = personalPINDecoded
    }
}

extension ChimeClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(accountId: \(Swift.String(describing: accountId)), alexaForBusinessMetadata: \(Swift.String(describing: alexaForBusinessMetadata)), invitedOn: \(Swift.String(describing: invitedOn)), licenseType: \(Swift.String(describing: licenseType)), personalPIN: \(Swift.String(describing: personalPIN)), registeredOn: \(Swift.String(describing: registeredOn)), userId: \(Swift.String(describing: userId)), userInvitationStatus: \(Swift.String(describing: userInvitationStatus)), userRegistrationStatus: \(Swift.String(describing: userRegistrationStatus)), userType: \(Swift.String(describing: userType)), displayName: \"CONTENT_REDACTED\", primaryEmail: \"CONTENT_REDACTED\", primaryProvisionedNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The user on the Amazon Chime account.
    public struct User: Swift.Equatable {
        /// The Amazon Chime account ID.
        public var accountId: Swift.String?
        /// The Alexa for Business metadata.
        public var alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata?
        /// The display name of the user.
        public var displayName: Swift.String?
        /// Date and time when the user is invited to the Amazon Chime account, in ISO 8601 format.
        public var invitedOn: ClientRuntime.Date?
        /// The license type for the user.
        public var licenseType: ChimeClientTypes.License?
        /// The user's personal meeting PIN.
        public var personalPIN: Swift.String?
        /// The primary email address of the user.
        public var primaryEmail: Swift.String?
        /// The primary phone number associated with the user.
        public var primaryProvisionedNumber: Swift.String?
        /// Date and time when the user is registered, in ISO 8601 format.
        public var registeredOn: ClientRuntime.Date?
        /// The user ID.
        /// This member is required.
        public var userId: Swift.String?
        /// The user invite status.
        public var userInvitationStatus: ChimeClientTypes.InviteStatus?
        /// The user registration status.
        public var userRegistrationStatus: ChimeClientTypes.RegistrationStatus?
        /// The user type.
        public var userType: ChimeClientTypes.UserType?

        public init(
            accountId: Swift.String? = nil,
            alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata? = nil,
            displayName: Swift.String? = nil,
            invitedOn: ClientRuntime.Date? = nil,
            licenseType: ChimeClientTypes.License? = nil,
            personalPIN: Swift.String? = nil,
            primaryEmail: Swift.String? = nil,
            primaryProvisionedNumber: Swift.String? = nil,
            registeredOn: ClientRuntime.Date? = nil,
            userId: Swift.String? = nil,
            userInvitationStatus: ChimeClientTypes.InviteStatus? = nil,
            userRegistrationStatus: ChimeClientTypes.RegistrationStatus? = nil,
            userType: ChimeClientTypes.UserType? = nil
        )
        {
            self.accountId = accountId
            self.alexaForBusinessMetadata = alexaForBusinessMetadata
            self.displayName = displayName
            self.invitedOn = invitedOn
            self.licenseType = licenseType
            self.personalPIN = personalPIN
            self.primaryEmail = primaryEmail
            self.primaryProvisionedNumber = primaryProvisionedNumber
            self.registeredOn = registeredOn
            self.userId = userId
            self.userInvitationStatus = userInvitationStatus
            self.userRegistrationStatus = userRegistrationStatus
            self.userType = userType
        }
    }

}

extension ChimeClientTypes.UserError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeClientTypes {
    /// The list of errors returned when errors are encountered during the [BatchSuspendUser], [BatchUnsuspendUser], or [BatchUpdateUser] actions. This includes user IDs, error codes, and error messages.
    public struct UserError: Swift.Equatable {
        /// The error code.
        public var errorCode: ChimeClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The user ID for which the action failed.
        public var userId: Swift.String?

        public init(
            errorCode: ChimeClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.userId = userId
        }
    }

}

extension ChimeClientTypes.UserSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case telephony = "Telephony"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let telephony = self.telephony {
            try encodeContainer.encode(telephony, forKey: .telephony)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telephonyDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.TelephonySettings.self, forKey: .telephony)
        telephony = telephonyDecoded
    }
}

extension ChimeClientTypes {
    /// Settings associated with an Amazon Chime user, including inbound and outbound calling and text messaging.
    public struct UserSettings: Swift.Equatable {
        /// The telephony settings associated with the user.
        /// This member is required.
        public var telephony: ChimeClientTypes.TelephonySettings?

        public init(
            telephony: ChimeClientTypes.TelephonySettings? = nil
        )
        {
            self.telephony = telephony
        }
    }

}

extension ChimeClientTypes {
    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case privateuser
        case shareddevice
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .privateuser,
                .shareddevice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .privateuser: return "PrivateUser"
            case .shareddevice: return "SharedDevice"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserType(rawValue: rawValue) ?? UserType.sdkUnknown(rawValue)
        }
    }
}

extension ValidateE911AddressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateE911AddressInput(awsAccountId: \(Swift.String(describing: awsAccountId)), city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetInfo: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\")"}
}

extension ValidateE911AddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case city = "City"
        case country = "Country"
        case postalCode = "PostalCode"
        case state = "State"
        case streetInfo = "StreetInfo"
        case streetNumber = "StreetNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let streetInfo = self.streetInfo {
            try encodeContainer.encode(streetInfo, forKey: .streetInfo)
        }
        if let streetNumber = self.streetNumber {
            try encodeContainer.encode(streetNumber, forKey: .streetNumber)
        }
    }
}

extension ValidateE911AddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/emergency-calling/address"
    }
}

public struct ValidateE911AddressInput: Swift.Equatable {
    /// The AWS account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The address city, such as Portland.
    /// This member is required.
    public var city: Swift.String?
    /// The address country, such as US.
    /// This member is required.
    public var country: Swift.String?
    /// The address postal code, such as 04352.
    /// This member is required.
    public var postalCode: Swift.String?
    /// The address state, such as ME.
    /// This member is required.
    public var state: Swift.String?
    /// The address street information, such as 8th Avenue.
    /// This member is required.
    public var streetInfo: Swift.String?
    /// The address street number, such as 200 or 2121.
    /// This member is required.
    public var streetNumber: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        city: Swift.String? = nil,
        country: Swift.String? = nil,
        postalCode: Swift.String? = nil,
        state: Swift.String? = nil,
        streetInfo: Swift.String? = nil,
        streetNumber: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.city = city
        self.country = country
        self.postalCode = postalCode
        self.state = state
        self.streetInfo = streetInfo
        self.streetNumber = streetNumber
    }
}

struct ValidateE911AddressInputBody: Swift.Equatable {
    let awsAccountId: Swift.String?
    let streetNumber: Swift.String?
    let streetInfo: Swift.String?
    let city: Swift.String?
    let state: Swift.String?
    let country: Swift.String?
    let postalCode: Swift.String?
}

extension ValidateE911AddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case city = "City"
        case country = "Country"
        case postalCode = "PostalCode"
        case state = "State"
        case streetInfo = "StreetInfo"
        case streetNumber = "StreetNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let streetNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetNumber)
        streetNumber = streetNumberDecoded
        let streetInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetInfo)
        streetInfo = streetInfoDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
    }
}

extension ValidateE911AddressOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidateE911AddressOutputBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
            self.addressExternalId = output.addressExternalId
            self.candidateAddressList = output.candidateAddressList
            self.validationResult = output.validationResult
        } else {
            self.address = nil
            self.addressExternalId = nil
            self.candidateAddressList = nil
            self.validationResult = 0
        }
    }
}

public struct ValidateE911AddressOutput: Swift.Equatable {
    /// The validated address.
    public var address: ChimeClientTypes.Address?
    /// The ID that represents the address.
    public var addressExternalId: Swift.String?
    /// The list of address suggestions.
    public var candidateAddressList: [ChimeClientTypes.CandidateAddress]?
    /// Number indicating the result of address validation. 0 means the address was perfect as is and successfully validated. 1 means the address was corrected. 2 means the address sent was not close enough and was not validated.
    public var validationResult: Swift.Int

    public init(
        address: ChimeClientTypes.Address? = nil,
        addressExternalId: Swift.String? = nil,
        candidateAddressList: [ChimeClientTypes.CandidateAddress]? = nil,
        validationResult: Swift.Int = 0
    )
    {
        self.address = address
        self.addressExternalId = addressExternalId
        self.candidateAddressList = candidateAddressList
        self.validationResult = validationResult
    }
}

struct ValidateE911AddressOutputBody: Swift.Equatable {
    let validationResult: Swift.Int
    let addressExternalId: Swift.String?
    let address: ChimeClientTypes.Address?
    let candidateAddressList: [ChimeClientTypes.CandidateAddress]?
}

extension ValidateE911AddressOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case addressExternalId = "AddressExternalId"
        case candidateAddressList = "CandidateAddressList"
        case validationResult = "ValidationResult"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationResultDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validationResult) ?? 0
        validationResult = validationResultDecoded
        let addressExternalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressExternalId)
        addressExternalId = addressExternalIdDecoded
        let addressDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.Address.self, forKey: .address)
        address = addressDecoded
        let candidateAddressListContainer = try containerValues.decodeIfPresent([ChimeClientTypes.CandidateAddress?].self, forKey: .candidateAddressList)
        var candidateAddressListDecoded0:[ChimeClientTypes.CandidateAddress]? = nil
        if let candidateAddressListContainer = candidateAddressListContainer {
            candidateAddressListDecoded0 = [ChimeClientTypes.CandidateAddress]()
            for structure0 in candidateAddressListContainer {
                if let structure0 = structure0 {
                    candidateAddressListDecoded0?.append(structure0)
                }
            }
        }
        candidateAddressList = candidateAddressListDecoded0
    }
}

enum ValidateE911AddressOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeClientTypes.VideoArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case muxType = "MuxType"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.ArtifactsState.self, forKey: .state)
        state = stateDecoded
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VideoMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
    }
}

extension ChimeClientTypes {
    /// The video artifact configuration object.
    public struct VideoArtifactsConfiguration: Swift.Equatable {
        /// The MUX type of the video artifact configuration object.
        public var muxType: ChimeClientTypes.VideoMuxType?
        /// Indicates whether the video artifact is enabled or disabled.
        /// This member is required.
        public var state: ChimeClientTypes.ArtifactsState?

        public init(
            muxType: ChimeClientTypes.VideoMuxType? = nil,
            state: ChimeClientTypes.ArtifactsState? = nil
        )
        {
            self.muxType = muxType
            self.state = state
        }
    }

}

extension ChimeClientTypes {
    public enum VideoMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case videoonly
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoMuxType] {
            return [
                .videoonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .videoonly: return "VideoOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VideoMuxType(rawValue: rawValue) ?? VideoMuxType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.VoiceConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
        case outboundHostName = "OutboundHostName"
        case requireEncryption = "RequireEncryption"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorArn = "VoiceConnectorArn"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion.rawValue, forKey: .awsRegion)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundHostName = self.outboundHostName {
            try encodeContainer.encode(outboundHostName, forKey: .outboundHostName)
        }
        if let requireEncryption = self.requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceConnectorArn = self.voiceConnectorArn {
            try encodeContainer.encode(voiceConnectorArn, forKey: .voiceConnectorArn)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(ChimeClientTypes.VoiceConnectorAwsRegion.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outboundHostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundHostName)
        outboundHostName = outboundHostNameDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let voiceConnectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorArn)
        voiceConnectorArn = voiceConnectorArnDecoded
    }
}

extension ChimeClientTypes {
    /// The Amazon Chime Voice Connector configuration, including outbound host name and encryption settings.
    public struct VoiceConnector: Swift.Equatable {
        /// The AWS Region in which the Amazon Chime Voice Connector is created. Default: us-east-1.
        public var awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion?
        /// The Amazon Chime Voice Connector creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The name of the Amazon Chime Voice Connector.
        public var name: Swift.String?
        /// The outbound host name for the Amazon Chime Voice Connector.
        public var outboundHostName: Swift.String?
        /// Designates whether encryption is required for the Amazon Chime Voice Connector.
        public var requireEncryption: Swift.Bool?
        /// The updated Amazon Chime Voice Connector timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ARN of the specified Amazon Chime Voice Connector.
        public var voiceConnectorArn: Swift.String?
        /// The Amazon Chime Voice Connector ID.
        public var voiceConnectorId: Swift.String?

        public init(
            awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            outboundHostName: Swift.String? = nil,
            requireEncryption: Swift.Bool? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorArn: Swift.String? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.outboundHostName = outboundHostName
            self.requireEncryption = requireEncryption
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorArn = voiceConnectorArn
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeClientTypes {
    public enum VoiceConnectorAwsRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case usEast1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceConnectorAwsRegion] {
            return [
                .usEast1,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .usEast1: return "us-east-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceConnectorAwsRegion(rawValue: rawValue) ?? VoiceConnectorAwsRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeClientTypes.VoiceConnectorGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorGroupArn = "VoiceConnectorGroupArn"
        case voiceConnectorGroupId = "VoiceConnectorGroupId"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceConnectorGroupArn = self.voiceConnectorGroupArn {
            try encodeContainer.encode(voiceConnectorGroupArn, forKey: .voiceConnectorGroupArn)
        }
        if let voiceConnectorGroupId = self.voiceConnectorGroupId {
            try encodeContainer.encode(voiceConnectorGroupId, forKey: .voiceConnectorGroupId)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritem0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritem0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorGroupId)
        voiceConnectorGroupId = voiceConnectorGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let voiceConnectorGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorGroupArn)
        voiceConnectorGroupArn = voiceConnectorGroupArnDecoded
    }
}

extension ChimeClientTypes {
    /// The Amazon Chime Voice Connector group configuration, including associated Amazon Chime Voice Connectors. You can include Amazon Chime Voice Connectors from different AWS Regions in your group. This creates a fault tolerant mechanism for fallback in case of availability events.
    public struct VoiceConnectorGroup: Swift.Equatable {
        /// The Amazon Chime Voice Connector group creation time stamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The name of the Amazon Chime Voice Connector group.
        public var name: Swift.String?
        /// The updated Amazon Chime Voice Connector group time stamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ARN of the specified Amazon Chime Voice Connector group.
        public var voiceConnectorGroupArn: Swift.String?
        /// The Amazon Chime Voice Connector group ID.
        public var voiceConnectorGroupId: Swift.String?
        /// The Amazon Chime Voice Connectors to which to route inbound calls.
        public var voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorGroupArn: Swift.String? = nil,
            voiceConnectorGroupId: Swift.String? = nil,
            voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorGroupArn = voiceConnectorGroupArn
            self.voiceConnectorGroupId = voiceConnectorGroupId
            self.voiceConnectorItems = voiceConnectorItems
        }
    }

}

extension ChimeClientTypes.VoiceConnectorItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority = "Priority"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension ChimeClientTypes {
    /// For Amazon Chime Voice Connector groups, the Amazon Chime Voice Connectors to which to route inbound calls. Includes priority configuration settings. Limit: 3 VoiceConnectorItems per Amazon Chime Voice Connector group.
    public struct VoiceConnectorItem: Swift.Equatable {
        /// The priority associated with the Amazon Chime Voice Connector, with 1 being the highest priority. Higher priority Amazon Chime Voice Connectors are attempted first.
        /// This member is required.
        public var priority: Swift.Int?
        /// The Amazon Chime Voice Connector ID.
        /// This member is required.
        public var voiceConnectorId: Swift.String?

        public init(
            priority: Swift.Int? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.priority = priority
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeClientTypes.VoiceConnectorSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdrBucket = "CdrBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdrBucket = self.cdrBucket {
            try encodeContainer.encode(cdrBucket, forKey: .cdrBucket)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cdrBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdrBucket)
        cdrBucket = cdrBucketDecoded
    }
}

extension ChimeClientTypes {
    /// The Amazon Chime Voice Connector settings. Includes any Amazon S3 buckets designated for storing call detail records.
    public struct VoiceConnectorSettings: Swift.Equatable {
        /// The Amazon S3 bucket designated for call detail record storage.
        public var cdrBucket: Swift.String?

        public init(
            cdrBucket: Swift.String? = nil
        )
        {
            self.cdrBucket = cdrBucket
        }
    }

}
