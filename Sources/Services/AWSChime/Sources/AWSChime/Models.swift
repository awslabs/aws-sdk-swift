//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct DeleteAppInstanceAdminOutput {

    public init() { }
}

public struct DeleteAppInstanceOutput {

    public init() { }
}

public struct DeleteAppInstanceStreamingConfigurationsOutput {

    public init() { }
}

public struct DeleteAppInstanceUserOutput {

    public init() { }
}

public struct DeleteAttendeeOutput {

    public init() { }
}

public struct DeleteChannelBanOutput {

    public init() { }
}

public struct DeleteChannelMembershipOutput {

    public init() { }
}

public struct DeleteChannelMessageOutput {

    public init() { }
}

public struct DeleteChannelModeratorOutput {

    public init() { }
}

public struct DeleteChannelOutput {

    public init() { }
}

public struct DeleteEventsConfigurationOutput {

    public init() { }
}

public struct DeleteMediaCapturePipelineOutput {

    public init() { }
}

public struct DeleteMeetingOutput {

    public init() { }
}

public struct DeletePhoneNumberOutput {

    public init() { }
}

public struct DeleteProxySessionOutput {

    public init() { }
}

public struct DeleteRoomMembershipOutput {

    public init() { }
}

public struct DeleteRoomOutput {

    public init() { }
}

public struct DeleteSipMediaApplicationOutput {

    public init() { }
}

public struct DeleteSipRuleOutput {

    public init() { }
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationOutput {

    public init() { }
}

public struct DeleteVoiceConnectorGroupOutput {

    public init() { }
}

public struct DeleteVoiceConnectorOriginationOutput {

    public init() { }
}

public struct DeleteVoiceConnectorOutput {

    public init() { }
}

public struct DeleteVoiceConnectorProxyOutput {

    public init() { }
}

public struct DeleteVoiceConnectorStreamingConfigurationOutput {

    public init() { }
}

public struct DeleteVoiceConnectorTerminationCredentialsOutput {

    public init() { }
}

public struct DeleteVoiceConnectorTerminationOutput {

    public init() { }
}

public struct GetGlobalSettingsInput {

    public init() { }
}

public struct GetPhoneNumberSettingsInput {

    public init() { }
}

public struct PutVoiceConnectorTerminationCredentialsOutput {

    public init() { }
}

public struct TagAttendeeOutput {

    public init() { }
}

public struct TagMeetingOutput {

    public init() { }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagAttendeeOutput {

    public init() { }
}

public struct UntagMeetingOutput {

    public init() { }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateGlobalSettingsOutput {

    public init() { }
}

public struct UpdatePhoneNumberSettingsOutput {

    public init() { }
}

public struct UpdateUserSettingsOutput {

    public init() { }
}

extension ChimeClientTypes {

    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// You don't have permissions to perform the requested operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension ChimeClientTypes {

    public enum AccountStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountStatus] {
            return [
                .active,
                .suspended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum AccountType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enterprisedirectory
        case enterpriselwa
        case enterpriseoidc
        case team
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountType] {
            return [
                .enterprisedirectory,
                .enterpriselwa,
                .enterpriseoidc,
                .team
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enterprisedirectory: return "EnterpriseDirectory"
            case .enterpriselwa: return "EnterpriseLWA"
            case .enterpriseoidc: return "EnterpriseOIDC"
            case .team: return "Team"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum License: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basic
        case plus
        case pro
        case protrial
        case sdkUnknown(Swift.String)

        public static var allCases: [License] {
            return [
                .basic,
                .plus,
                .pro,
                .protrial
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basic: return "Basic"
            case .plus: return "Plus"
            case .pro: return "Pro"
            case .protrial: return "ProTrial"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// An Active Directory (AD) group whose members are granted permission to act as delegates.
    public struct SigninDelegateGroup {
        /// The group name.
        public var groupName: Swift.String?

        public init(
            groupName: Swift.String? = nil
        )
        {
            self.groupName = groupName
        }
    }

}

extension ChimeClientTypes {
    /// The Amazon Chime account details. An AWS account can have multiple Amazon Chime accounts.
    public struct Account {
        /// The Amazon Chime account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The status of the account.
        public var accountStatus: ChimeClientTypes.AccountStatus?
        /// The Amazon Chime account type. For more information about different account types, see [Managing Your Amazon Chime Accounts](https://docs.aws.amazon.com/chime/latest/ag/manage-chime-account.html) in the Amazon Chime Administration Guide.
        public var accountType: ChimeClientTypes.AccountType?
        /// The AWS account ID.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// The Amazon Chime account creation timestamp, in ISO 8601 format.
        public var createdTimestamp: Foundation.Date?
        /// The default license for the Amazon Chime account.
        public var defaultLicense: ChimeClientTypes.License?
        /// The Amazon Chime account name.
        /// This member is required.
        public var name: Swift.String?
        /// The sign-in delegate groups associated with the account.
        public var signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]?
        /// Supported licenses for the Amazon Chime account.
        public var supportedLicenses: [ChimeClientTypes.License]?

        public init(
            accountId: Swift.String? = nil,
            accountStatus: ChimeClientTypes.AccountStatus? = nil,
            accountType: ChimeClientTypes.AccountType? = nil,
            awsAccountId: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            defaultLicense: ChimeClientTypes.License? = nil,
            name: Swift.String? = nil,
            signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]? = nil,
            supportedLicenses: [ChimeClientTypes.License]? = nil
        )
        {
            self.accountId = accountId
            self.accountStatus = accountStatus
            self.accountType = accountType
            self.awsAccountId = awsAccountId
            self.createdTimestamp = createdTimestamp
            self.defaultLicense = defaultLicense
            self.name = name
            self.signinDelegateGroups = signinDelegateGroups
            self.supportedLicenses = supportedLicenses
        }
    }

}

extension ChimeClientTypes {
    /// Settings related to the Amazon Chime account. This includes settings that start or stop remote control of shared screens, or start or stop the dial-out option in the Amazon Chime web application. For more information about these settings, see [Use the Policies Page](https://docs.aws.amazon.com/chime/latest/ag/policies.html) in the Amazon Chime Administration Guide.
    public struct AccountSettings {
        /// Setting that stops or starts remote control of shared screens during meetings.
        public var disableRemoteControl: Swift.Bool?
        /// Setting that allows meeting participants to choose the Call me at a phone number option. For more information, see [Join a Meeting without the Amazon Chime App](https://docs.aws.amazon.com/chime/latest/ug/chime-join-meeting.html).
        public var enableDialOut: Swift.Bool?

        public init(
            disableRemoteControl: Swift.Bool? = nil,
            enableDialOut: Swift.Bool? = nil
        )
        {
            self.disableRemoteControl = disableRemoteControl
            self.enableDialOut = enableDialOut
        }
    }

}

extension ChimeClientTypes {
    /// A validated address.
    public struct Address {
        /// The city of an address.
        public var city: Swift.String?
        /// The country of an address.
        public var country: Swift.String?
        /// An address suffix location, such as the S. Unit A in Central Park S. Unit A.
        public var postDirectional: Swift.String?
        /// The postal code of an address.
        public var postalCode: Swift.String?
        /// The Zip + 4 or postal code + 4 of an address.
        public var postalCodePlus4: Swift.String?
        /// An address prefix location, such as the N in N. Third St..
        public var preDirectional: Swift.String?
        /// The state of an address.
        public var state: Swift.String?
        /// The address street, such as 8th Avenue.
        public var streetName: Swift.String?
        /// The numeric portion of an address.
        public var streetNumber: Swift.String?
        /// The address suffix, such as the N in 8th Avenue N.
        public var streetSuffix: Swift.String?

        public init(
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            postDirectional: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            postalCodePlus4: Swift.String? = nil,
            preDirectional: Swift.String? = nil,
            state: Swift.String? = nil,
            streetName: Swift.String? = nil,
            streetNumber: Swift.String? = nil,
            streetSuffix: Swift.String? = nil
        )
        {
            self.city = city
            self.country = country
            self.postDirectional = postDirectional
            self.postalCode = postalCode
            self.postalCodePlus4 = postalCodePlus4
            self.preDirectional = preDirectional
            self.state = state
            self.streetName = streetName
            self.streetNumber = streetNumber
            self.streetSuffix = streetSuffix
        }
    }

}

extension ChimeClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postDirectional: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", postalCodePlus4: \"CONTENT_REDACTED\", preDirectional: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetName: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\", streetSuffix: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The Alexa for Business metadata associated with an Amazon Chime user, used to integrate Alexa for Business with a device.
    public struct AlexaForBusinessMetadata {
        /// The ARN of the room resource.
        public var alexaForBusinessRoomArn: Swift.String?
        /// Starts or stops Alexa for Business.
        public var isAlexaForBusinessEnabled: Swift.Bool?

        public init(
            alexaForBusinessRoomArn: Swift.String? = nil,
            isAlexaForBusinessEnabled: Swift.Bool? = nil
        )
        {
            self.alexaForBusinessRoomArn = alexaForBusinessRoomArn
            self.isAlexaForBusinessEnabled = isAlexaForBusinessEnabled
        }
    }

}

extension ChimeClientTypes.AlexaForBusinessMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlexaForBusinessMetadata(isAlexaForBusinessEnabled: \(Swift.String(describing: isAlexaForBusinessEnabled)), alexaForBusinessRoomArn: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The details of an AppInstance, an instance of an Amazon Chime SDK messaging application.
    public struct AppInstance {
        /// The ARN of the messaging instance.
        public var appInstanceArn: Swift.String?
        /// The time at which an AppInstance was created. In epoch milliseconds.
        public var createdTimestamp: Foundation.Date?
        /// The time an AppInstance was last updated. In epoch milliseconds.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The metadata of an AppInstance.
        public var metadata: Swift.String?
        /// The name of an AppInstance.
        public var name: Swift.String?

        public init(
            appInstanceArn: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceArn = appInstanceArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeClientTypes.AppInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstance(appInstanceArn: \(Swift.String(describing: appInstanceArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The details of a user.
    public struct Identity {
        /// The ARN in an Identity.
        public var arn: Swift.String?
        /// The name in an Identity.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ChimeClientTypes.Identity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Identity(arn: \(Swift.String(describing: arn)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The details of an AppInstanceAdmin.
    public struct AppInstanceAdmin {
        /// The AppInstanceAdmin data.
        public var admin: ChimeClientTypes.Identity?
        /// The ARN of the AppInstance for which the user is an administrator.
        public var appInstanceArn: Swift.String?
        /// The time at which an administrator was created.
        public var createdTimestamp: Foundation.Date?

        public init(
            admin: ChimeClientTypes.Identity? = nil,
            appInstanceArn: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil
        )
        {
            self.admin = admin
            self.appInstanceArn = appInstanceArn
            self.createdTimestamp = createdTimestamp
        }
    }

}

extension ChimeClientTypes {
    /// Summary of the details of an AppInstanceAdmin.
    public struct AppInstanceAdminSummary {
        /// The details of the AppInstanceAdmin.
        public var admin: ChimeClientTypes.Identity?

        public init(
            admin: ChimeClientTypes.Identity? = nil
        )
        {
            self.admin = admin
        }
    }

}

extension ChimeClientTypes {

    public enum AppInstanceDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case channel
        case channelmessage
        case sdkUnknown(Swift.String)

        public static var allCases: [AppInstanceDataType] {
            return [
                .channel,
                .channelmessage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .channel: return "Channel"
            case .channelmessage: return "ChannelMessage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// Summary of the data for an AppInstance.
    public struct AppInstanceSummary {
        /// The AppInstance ARN.
        public var appInstanceArn: Swift.String?
        /// The metadata of the AppInstance.
        public var metadata: Swift.String?
        /// The name of the AppInstance.
        public var name: Swift.String?

        public init(
            appInstanceArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceArn = appInstanceArn
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeClientTypes.AppInstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceSummary(appInstanceArn: \(Swift.String(describing: appInstanceArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The details of the retention settings for a channel.
    public struct ChannelRetentionSettings {
        /// The time in days to retain the messages in a channel.
        public var retentionDays: Swift.Int?

        public init(
            retentionDays: Swift.Int? = nil
        )
        {
            self.retentionDays = retentionDays
        }
    }

}

extension ChimeClientTypes {
    /// The details of the data-retention settings for an AppInstance.
    public struct AppInstanceRetentionSettings {
        /// The length of time in days to retain the messages in a channel.
        public var channelRetentionSettings: ChimeClientTypes.ChannelRetentionSettings?

        public init(
            channelRetentionSettings: ChimeClientTypes.ChannelRetentionSettings? = nil
        )
        {
            self.channelRetentionSettings = channelRetentionSettings
        }
    }

}

extension ChimeClientTypes {
    /// The details of the streaming configuration of an AppInstance.
    public struct AppInstanceStreamingConfiguration {
        /// The type of data to be streamed.
        /// This member is required.
        public var appInstanceDataType: ChimeClientTypes.AppInstanceDataType?
        /// The resource ARN.
        /// This member is required.
        public var resourceArn: Swift.String?

        public init(
            appInstanceDataType: ChimeClientTypes.AppInstanceDataType? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.appInstanceDataType = appInstanceDataType
            self.resourceArn = resourceArn
        }
    }

}

extension ChimeClientTypes.AppInstanceStreamingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceStreamingConfiguration(appInstanceDataType: \(Swift.String(describing: appInstanceDataType)), resourceArn: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The details of an AppInstanceUser.
    public struct AppInstanceUser {
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The time at which the AppInstanceUser was created.
        public var createdTimestamp: Foundation.Date?
        /// The time at which the AppInstanceUser was last updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The metadata of the AppInstanceUser.
        public var metadata: Swift.String?
        /// The name of the AppInstanceUser.
        public var name: Swift.String?

        public init(
            appInstanceUserArn: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceUserArn = appInstanceUserArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeClientTypes.AppInstanceUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUser(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Summary of the details of an AppInstanceUser.
    public struct AppInstanceUserSummary {
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The metadata of the AppInstanceUser.
        public var metadata: Swift.String?
        /// The name of an AppInstanceUser.
        public var name: Swift.String?

        public init(
            appInstanceUserArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceUserArn = appInstanceUserArn
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeClientTypes.AppInstanceUserSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUserSummary(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {

    public enum ChannelMembershipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case hidden
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMembershipType] {
            return [
                .default,
                .hidden
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .hidden: return "HIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// Summary of the membership details of an AppInstanceUser.
    public struct AppInstanceUserMembershipSummary {
        /// The time at which a message was last read.
        public var readMarkerTimestamp: Foundation.Date?
        /// The type of ChannelMembership.
        public var type: ChimeClientTypes.ChannelMembershipType?

        public init(
            readMarkerTimestamp: Foundation.Date? = nil,
            type: ChimeClientTypes.ChannelMembershipType? = nil
        )
        {
            self.readMarkerTimestamp = readMarkerTimestamp
            self.type = type
        }
    }

}

extension ChimeClientTypes {

    public enum AudioMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case audioonly
        case audiowithactivespeakervideo
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioMuxType] {
            return [
                .audioonly,
                .audiowithactivespeakervideo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .audioonly: return "AudioOnly"
            case .audiowithactivespeakervideo: return "AudioWithActiveSpeakerVideo"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The audio artifact configuration object.
    public struct AudioArtifactsConfiguration {
        /// The MUX type of the audio artifact configuration object.
        /// This member is required.
        public var muxType: ChimeClientTypes.AudioMuxType?

        public init(
            muxType: ChimeClientTypes.AudioMuxType? = nil
        )
        {
            self.muxType = muxType
        }
    }

}

extension ChimeClientTypes {

    public enum ContentMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contentonly
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentMuxType] {
            return [
                .contentonly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contentonly: return "ContentOnly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum ArtifactsState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactsState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The content artifact object.
    public struct ContentArtifactsConfiguration {
        /// The MUX type of the artifact configuration.
        public var muxType: ChimeClientTypes.ContentMuxType?
        /// Indicates whether the content artifact is enabled or disabled.
        /// This member is required.
        public var state: ChimeClientTypes.ArtifactsState?

        public init(
            muxType: ChimeClientTypes.ContentMuxType? = nil,
            state: ChimeClientTypes.ArtifactsState? = nil
        )
        {
            self.muxType = muxType
            self.state = state
        }
    }

}

extension ChimeClientTypes {

    public enum VideoMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case videoonly
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoMuxType] {
            return [
                .videoonly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .videoonly: return "VideoOnly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The video artifact configuration object.
    public struct VideoArtifactsConfiguration {
        /// The MUX type of the video artifact configuration object.
        public var muxType: ChimeClientTypes.VideoMuxType?
        /// Indicates whether the video artifact is enabled or disabled.
        /// This member is required.
        public var state: ChimeClientTypes.ArtifactsState?

        public init(
            muxType: ChimeClientTypes.VideoMuxType? = nil,
            state: ChimeClientTypes.ArtifactsState? = nil
        )
        {
            self.muxType = muxType
            self.state = state
        }
    }

}

extension ChimeClientTypes {
    /// The configuration for the artifacts.
    public struct ArtifactsConfiguration {
        /// The configuration for the audio artifacts.
        /// This member is required.
        public var audio: ChimeClientTypes.AudioArtifactsConfiguration?
        /// The configuration for the content artifacts.
        /// This member is required.
        public var content: ChimeClientTypes.ContentArtifactsConfiguration?
        /// The configuration for the video artifacts.
        /// This member is required.
        public var video: ChimeClientTypes.VideoArtifactsConfiguration?

        public init(
            audio: ChimeClientTypes.AudioArtifactsConfiguration? = nil,
            content: ChimeClientTypes.ContentArtifactsConfiguration? = nil,
            video: ChimeClientTypes.VideoArtifactsConfiguration? = nil
        )
        {
            self.audio = audio
            self.content = content
            self.video = video
        }
    }

}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledClientException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedClientException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorInput {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.
    public var forceAssociate: Swift.Bool?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        forceAssociate: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.forceAssociate = forceAssociate
        self.voiceConnectorId = voiceConnectorId
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatePhoneNumbersWithVoiceConnectorInput(forceAssociate: \(Swift.String(describing: forceAssociate)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), e164PhoneNumbers: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// If the phone number action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public struct PhoneNumberError {
        /// The error code.
        public var errorCode: ChimeClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The phone number ID for which the action failed.
        public var phoneNumberId: Swift.String?

        public init(
            errorCode: ChimeClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.phoneNumberId = phoneNumberId
        }
    }

}

public struct AssociatePhoneNumbersWithVoiceConnectorOutput {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupInput {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector Group and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.
    public var forceAssociate: Swift.Bool?
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        forceAssociate: Swift.Bool? = nil,
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.forceAssociate = forceAssociate
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatePhoneNumbersWithVoiceConnectorGroupInput(forceAssociate: \(Swift.String(describing: forceAssociate)), voiceConnectorGroupId: \(Swift.String(describing: voiceConnectorGroupId)), e164PhoneNumbers: \"CONTENT_REDACTED\")"}
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupOutput {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

public struct AssociatePhoneNumberWithUserInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The phone number, in E.164 format.
    /// This member is required.
    public var e164PhoneNumber: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        e164PhoneNumber: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.e164PhoneNumber = e164PhoneNumber
        self.userId = userId
    }
}

extension AssociatePhoneNumberWithUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatePhoneNumberWithUserInput(accountId: \(Swift.String(describing: accountId)), userId: \(Swift.String(describing: userId)), e164PhoneNumber: \"CONTENT_REDACTED\")"}
}

public struct AssociatePhoneNumberWithUserOutput {

    public init() { }
}

public struct AssociateSigninDelegateGroupsWithAccountInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The sign-in delegate groups.
    /// This member is required.
    public var signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]?

    public init(
        accountId: Swift.String? = nil,
        signinDelegateGroups: [ChimeClientTypes.SigninDelegateGroup]? = nil
    )
    {
        self.accountId = accountId
        self.signinDelegateGroups = signinDelegateGroups
    }
}

public struct AssociateSigninDelegateGroupsWithAccountOutput {

    public init() { }
}

extension ChimeClientTypes {
    /// An Amazon Chime SDK meeting attendee. Includes a unique AttendeeId and JoinToken . The JoinToken allows a client to authenticate and join as the specified attendee. The JoinToken expires when the meeting ends or when [DeleteAttendee] is called. After that, the attendee is unable to join the meeting. We recommend securely transferring each JoinToken from your server application to the client so that no other client has access to the token except for the one authorized to represent the attendee.
    public struct Attendee {
        /// The Amazon Chime SDK attendee ID.
        public var attendeeId: Swift.String?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
        public var externalUserId: Swift.String?
        /// The join token used by the Amazon Chime SDK attendee.
        public var joinToken: Swift.String?

        public init(
            attendeeId: Swift.String? = nil,
            externalUserId: Swift.String? = nil,
            joinToken: Swift.String? = nil
        )
        {
            self.attendeeId = attendeeId
            self.externalUserId = externalUserId
            self.joinToken = joinToken
        }
    }

}

extension ChimeClientTypes.Attendee: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attendee(attendeeId: \(Swift.String(describing: attendeeId)), externalUserId: \"CONTENT_REDACTED\", joinToken: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Describes a tag applied to a resource.
    public struct Tag {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ChimeClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The membership information, including member ARNs, the channel ARN, and membership types.
    public struct BatchChannelMemberships {
        /// The ARN of the channel to which you're adding users.
        public var channelArn: Swift.String?
        /// The identifier of the member who invited another member.
        public var invitedBy: ChimeClientTypes.Identity?
        /// The users successfully added to the request.
        public var members: [ChimeClientTypes.Identity]?
        /// The membership types set for the channel users.
        public var type: ChimeClientTypes.ChannelMembershipType?

        public init(
            channelArn: Swift.String? = nil,
            invitedBy: ChimeClientTypes.Identity? = nil,
            members: [ChimeClientTypes.Identity]? = nil,
            type: ChimeClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.invitedBy = invitedBy
            self.members = members
            self.type = type
        }
    }

}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension ChimeClientTypes {
    /// The Amazon Chime SDK attendee fields to create, used with the BatchCreateAttendee action.
    public struct CreateAttendeeRequestItem {
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
        /// This member is required.
        public var externalUserId: Swift.String?
        /// The tag key-value pairs.
        public var tags: [ChimeClientTypes.Tag]?

        public init(
            externalUserId: Swift.String? = nil,
            tags: [ChimeClientTypes.Tag]? = nil
        )
        {
            self.externalUserId = externalUserId
            self.tags = tags
        }
    }

}

extension ChimeClientTypes.CreateAttendeeRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeRequestItem(tags: \(Swift.String(describing: tags)), externalUserId: \"CONTENT_REDACTED\")"}
}

public struct BatchCreateAttendeeInput {
    /// The request containing the attendees to create.
    /// This member is required.
    public var attendees: [ChimeClientTypes.CreateAttendeeRequestItem]?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendees: [ChimeClientTypes.CreateAttendeeRequestItem]? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendees = attendees
        self.meetingId = meetingId
    }
}

extension ChimeClientTypes {
    /// The list of errors returned when errors are encountered during the BatchCreateAttendee and CreateAttendee actions. This includes external user IDs, error codes, and error messages.
    public struct CreateAttendeeError {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
        public var externalUserId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            externalUserId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.externalUserId = externalUserId
        }
    }

}

extension ChimeClientTypes.CreateAttendeeError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), externalUserId: \"CONTENT_REDACTED\")"}
}

public struct BatchCreateAttendeeOutput {
    /// The attendee information, including attendees IDs and join tokens.
    public var attendees: [ChimeClientTypes.Attendee]?
    /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
    public var errors: [ChimeClientTypes.CreateAttendeeError]?

    public init(
        attendees: [ChimeClientTypes.Attendee]? = nil,
        errors: [ChimeClientTypes.CreateAttendeeError]? = nil
    )
    {
        self.attendees = attendees
        self.errors = errors
    }
}

public struct BatchCreateChannelMembershipInput {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARNs of the members you want to add to the channel.
    /// This member is required.
    public var memberArns: [Swift.String]?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
    public var type: ChimeClientTypes.ChannelMembershipType?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArns: [Swift.String]? = nil,
        type: ChimeClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArns = memberArns
        self.type = type
    }
}

extension ChimeClientTypes {
    /// A list of failed member ARNs, error codes, and error messages.
    public struct BatchCreateChannelMembershipError {
        /// The error code.
        public var errorCode: ChimeClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The ARN of the member that the service couldn't add.
        public var memberArn: Swift.String?

        public init(
            errorCode: ChimeClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            memberArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memberArn = memberArn
        }
    }

}

public struct BatchCreateChannelMembershipOutput {
    /// The list of channel memberships in the response.
    public var batchChannelMemberships: ChimeClientTypes.BatchChannelMemberships?
    /// If the action fails for one or more of the memberships in the request, a list of the memberships is returned, along with error codes and error messages.
    public var errors: [ChimeClientTypes.BatchCreateChannelMembershipError]?

    public init(
        batchChannelMemberships: ChimeClientTypes.BatchChannelMemberships? = nil,
        errors: [ChimeClientTypes.BatchCreateChannelMembershipError]? = nil
    )
    {
        self.batchChannelMemberships = batchChannelMemberships
        self.errors = errors
    }
}

extension ChimeClientTypes {

    public enum RoomMembershipRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case administrator
        case member
        case sdkUnknown(Swift.String)

        public static var allCases: [RoomMembershipRole] {
            return [
                .administrator,
                .member
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .administrator: return "Administrator"
            case .member: return "Member"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// Membership details, such as member ID and member role.
    public struct MembershipItem {
        /// The member ID.
        public var memberId: Swift.String?
        /// The member role.
        public var role: ChimeClientTypes.RoomMembershipRole?

        public init(
            memberId: Swift.String? = nil,
            role: ChimeClientTypes.RoomMembershipRole? = nil
        )
        {
            self.memberId = memberId
            self.role = role
        }
    }

}

public struct BatchCreateRoomMembershipInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The list of membership items.
    /// This member is required.
    public var membershipItemList: [ChimeClientTypes.MembershipItem]?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        membershipItemList: [ChimeClientTypes.MembershipItem]? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.membershipItemList = membershipItemList
        self.roomId = roomId
    }
}

extension ChimeClientTypes {
    /// The list of errors returned when a member action results in an error.
    public struct MemberError {
        /// The error code.
        public var errorCode: ChimeClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The member ID.
        public var memberId: Swift.String?

        public init(
            errorCode: ChimeClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            memberId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memberId = memberId
        }
    }

}

public struct BatchCreateRoomMembershipOutput {
    /// If the action fails for one or more of the member IDs in the request, a list of the member IDs is returned, along with error codes and error messages.
    public var errors: [ChimeClientTypes.MemberError]?

    public init(
        errors: [ChimeClientTypes.MemberError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct BatchDeletePhoneNumberInput {
    /// List of phone number IDs.
    /// This member is required.
    public var phoneNumberIds: [Swift.String]?

    public init(
        phoneNumberIds: [Swift.String]? = nil
    )
    {
        self.phoneNumberIds = phoneNumberIds
    }
}

public struct BatchDeletePhoneNumberOutput {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

public struct BatchSuspendUserInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The request containing the user IDs to suspend.
    /// This member is required.
    public var userIdList: [Swift.String]?

    public init(
        accountId: Swift.String? = nil,
        userIdList: [Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.userIdList = userIdList
    }
}

extension ChimeClientTypes {
    /// The list of errors returned when errors are encountered during the [BatchSuspendUser], [BatchUnsuspendUser], or [BatchUpdateUser] actions. This includes user IDs, error codes, and error messages.
    public struct UserError {
        /// The error code.
        public var errorCode: ChimeClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The user ID for which the action failed.
        public var userId: Swift.String?

        public init(
            errorCode: ChimeClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.userId = userId
        }
    }

}

public struct BatchSuspendUserOutput {
    /// If the [BatchSuspendUser] action fails for one or more of the user IDs in the request, a list of the user IDs is returned, along with error codes and error messages.
    public var userErrors: [ChimeClientTypes.UserError]?

    public init(
        userErrors: [ChimeClientTypes.UserError]? = nil
    )
    {
        self.userErrors = userErrors
    }
}

public struct BatchUnsuspendUserInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The request containing the user IDs to unsuspend.
    /// This member is required.
    public var userIdList: [Swift.String]?

    public init(
        accountId: Swift.String? = nil,
        userIdList: [Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.userIdList = userIdList
    }
}

public struct BatchUnsuspendUserOutput {
    /// If the [BatchUnsuspendUser] action fails for one or more of the user IDs in the request, a list of the user IDs is returned, along with error codes and error messages.
    public var userErrors: [ChimeClientTypes.UserError]?

    public init(
        userErrors: [ChimeClientTypes.UserError]? = nil
    )
    {
        self.userErrors = userErrors
    }
}

extension ChimeClientTypes {

    public enum PhoneNumberProductType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businesscalling
        case sipmediaapplicationdialin
        case voiceconnector
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberProductType] {
            return [
                .businesscalling,
                .sipmediaapplicationdialin,
                .voiceconnector
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businesscalling: return "BusinessCalling"
            case .sipmediaapplicationdialin: return "SipMediaApplicationDialIn"
            case .voiceconnector: return "VoiceConnector"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The phone number ID, product type, or calling name fields to update, used with the [BatchUpdatePhoneNumber] and [UpdatePhoneNumber] actions.
    public struct UpdatePhoneNumberRequestItem {
        /// The outbound calling name to update.
        public var callingName: Swift.String?
        /// The phone number ID to update.
        /// This member is required.
        public var phoneNumberId: Swift.String?
        /// The product type to update.
        public var productType: ChimeClientTypes.PhoneNumberProductType?

        public init(
            callingName: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            productType: ChimeClientTypes.PhoneNumberProductType? = nil
        )
        {
            self.callingName = callingName
            self.phoneNumberId = phoneNumberId
            self.productType = productType
        }
    }

}

extension ChimeClientTypes.UpdatePhoneNumberRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberRequestItem(phoneNumberId: \(Swift.String(describing: phoneNumberId)), productType: \(Swift.String(describing: productType)), callingName: \"CONTENT_REDACTED\")"}
}

public struct BatchUpdatePhoneNumberInput {
    /// The request containing the phone number IDs and product types or calling names to update.
    /// This member is required.
    public var updatePhoneNumberRequestItems: [ChimeClientTypes.UpdatePhoneNumberRequestItem]?

    public init(
        updatePhoneNumberRequestItems: [ChimeClientTypes.UpdatePhoneNumberRequestItem]? = nil
    )
    {
        self.updatePhoneNumberRequestItems = updatePhoneNumberRequestItems
    }
}

public struct BatchUpdatePhoneNumberOutput {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

extension ChimeClientTypes {

    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case privateuser
        case shareddevice
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .privateuser,
                .shareddevice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .privateuser: return "PrivateUser"
            case .shareddevice: return "SharedDevice"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The user ID and user fields to update, used with the [BatchUpdateUser] action.
    public struct UpdateUserRequestItem {
        /// The Alexa for Business metadata.
        public var alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata?
        /// The user license type.
        public var licenseType: ChimeClientTypes.License?
        /// The user ID.
        /// This member is required.
        public var userId: Swift.String?
        /// The user type.
        public var userType: ChimeClientTypes.UserType?

        public init(
            alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata? = nil,
            licenseType: ChimeClientTypes.License? = nil,
            userId: Swift.String? = nil,
            userType: ChimeClientTypes.UserType? = nil
        )
        {
            self.alexaForBusinessMetadata = alexaForBusinessMetadata
            self.licenseType = licenseType
            self.userId = userId
            self.userType = userType
        }
    }

}

public struct BatchUpdateUserInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The request containing the user IDs and details to update.
    /// This member is required.
    public var updateUserRequestItems: [ChimeClientTypes.UpdateUserRequestItem]?

    public init(
        accountId: Swift.String? = nil,
        updateUserRequestItems: [ChimeClientTypes.UpdateUserRequestItem]? = nil
    )
    {
        self.accountId = accountId
        self.updateUserRequestItems = updateUserRequestItems
    }
}

public struct BatchUpdateUserOutput {
    /// If the [BatchUpdateUser] action fails for one or more of the user IDs in the request, a list of the user IDs is returned, along with error codes and error messages.
    public var userErrors: [ChimeClientTypes.UserError]?

    public init(
        userErrors: [ChimeClientTypes.UserError]? = nil
    )
    {
        self.userErrors = userErrors
    }
}

extension ChimeClientTypes {

    public enum BotType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case chatbot
        case sdkUnknown(Swift.String)

        public static var allCases: [BotType] {
            return [
                .chatbot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .chatbot: return "ChatBot"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// A resource that allows Enterprise account administrators to configure an interface to receive events from Amazon Chime.
    public struct Bot {
        /// The bot email address.
        public var botEmail: Swift.String?
        /// The bot ID.
        public var botId: Swift.String?
        /// The bot type.
        public var botType: ChimeClientTypes.BotType?
        /// The bot creation timestamp, in ISO 8601 format.
        public var createdTimestamp: Foundation.Date?
        /// When true, the bot is stopped from running in your account.
        public var disabled: Swift.Bool?
        /// The bot display name.
        public var displayName: Swift.String?
        /// The security token used to authenticate Amazon Chime with the outgoing event endpoint.
        public var securityToken: Swift.String?
        /// The updated bot timestamp, in ISO 8601 format.
        public var updatedTimestamp: Foundation.Date?
        /// The unique ID for the bot user.
        public var userId: Swift.String?

        public init(
            botEmail: Swift.String? = nil,
            botId: Swift.String? = nil,
            botType: ChimeClientTypes.BotType? = nil,
            createdTimestamp: Foundation.Date? = nil,
            disabled: Swift.Bool? = nil,
            displayName: Swift.String? = nil,
            securityToken: Swift.String? = nil,
            updatedTimestamp: Foundation.Date? = nil,
            userId: Swift.String? = nil
        )
        {
            self.botEmail = botEmail
            self.botId = botId
            self.botType = botType
            self.createdTimestamp = createdTimestamp
            self.disabled = disabled
            self.displayName = displayName
            self.securityToken = securityToken
            self.updatedTimestamp = updatedTimestamp
            self.userId = userId
        }
    }

}

extension ChimeClientTypes.Bot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Bot(botId: \(Swift.String(describing: botId)), botType: \(Swift.String(describing: botType)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), disabled: \(Swift.String(describing: disabled)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), userId: \(Swift.String(describing: userId)), botEmail: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", securityToken: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The Amazon Chime Business Calling settings for the administrator's AWS account. Includes any Amazon S3 buckets designated for storing call detail records.
    public struct BusinessCallingSettings {
        /// The Amazon S3 bucket designated for call detail record storage.
        public var cdrBucket: Swift.String?

        public init(
            cdrBucket: Swift.String? = nil
        )
        {
            self.cdrBucket = cdrBucket
        }
    }

}

extension ChimeClientTypes {

    public enum CallingNameStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case unassigned
        case updatefailed
        case updateinprogress
        case updatesucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CallingNameStatus] {
            return [
                .unassigned,
                .updatefailed,
                .updateinprogress,
                .updatesucceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .unassigned: return "Unassigned"
            case .updatefailed: return "UpdateFailed"
            case .updateinprogress: return "UpdateInProgress"
            case .updatesucceeded: return "UpdateSucceeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// A suggested address.
    public struct CandidateAddress {
        /// The city of a candidate address.
        public var city: Swift.String?
        /// The country of a candidate address.
        public var country: Swift.String?
        /// The postal code of a candidate address.
        public var postalCode: Swift.String?
        /// The Zip + 4 or postal code + 4 of a candidate address.
        public var postalCodePlus4: Swift.String?
        /// The state of a candidate address.
        public var state: Swift.String?
        /// The street information of a candidate address
        public var streetInfo: Swift.String?
        /// The numeric portion of a candidate address.
        public var streetNumber: Swift.String?

        public init(
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            postalCodePlus4: Swift.String? = nil,
            state: Swift.String? = nil,
            streetInfo: Swift.String? = nil,
            streetNumber: Swift.String? = nil
        )
        {
            self.city = city
            self.country = country
            self.postalCode = postalCode
            self.postalCodePlus4 = postalCodePlus4
            self.state = state
            self.streetInfo = streetInfo
            self.streetNumber = streetNumber
        }
    }

}

extension ChimeClientTypes.CandidateAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CandidateAddress(city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", postalCodePlus4: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetInfo: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {

    public enum Capability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [Capability] {
            return [
                .sms,
                .voice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sms: return "SMS"
            case .voice: return "Voice"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum ChannelMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case restricted
        case unrestricted
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMode] {
            return [
                .restricted,
                .unrestricted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .restricted: return "RESTRICTED"
            case .unrestricted: return "UNRESTRICTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum ChannelPrivacy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelPrivacy] {
            return [
                .private,
                .public
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The details of a channel.
    public struct Channel {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the channel.
        public var createdBy: ChimeClientTypes.Identity?
        /// The time at which the AppInstanceUser created the channel.
        public var createdTimestamp: Foundation.Date?
        /// The time at which a member sent the last message in the channel.
        public var lastMessageTimestamp: Foundation.Date?
        /// The time at which a channel was last updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The channel's metadata.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeClientTypes.ChannelMode?
        /// The name of the channel.
        public var name: Swift.String?
        /// The channel's privacy setting.
        public var privacy: ChimeClientTypes.ChannelPrivacy?

        public init(
            channelArn: Swift.String? = nil,
            createdBy: ChimeClientTypes.Identity? = nil,
            createdTimestamp: Foundation.Date? = nil,
            lastMessageTimestamp: Foundation.Date? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.lastMessageTimestamp = lastMessageTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ChimeClientTypes.Channel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Channel(channelArn: \(Swift.String(describing: channelArn)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastMessageTimestamp: \(Swift.String(describing: lastMessageTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), mode: \(Swift.String(describing: mode)), privacy: \(Swift.String(describing: privacy)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The details of a channel ban.
    public struct ChannelBan {
        /// The ARN of the channel from which a member is being banned.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the ban.
        public var createdBy: ChimeClientTypes.Identity?
        /// The time at which the ban was created.
        public var createdTimestamp: Foundation.Date?
        /// The member being banned from the channel.
        public var member: ChimeClientTypes.Identity?

        public init(
            channelArn: Swift.String? = nil,
            createdBy: ChimeClientTypes.Identity? = nil,
            createdTimestamp: Foundation.Date? = nil,
            member: ChimeClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.member = member
        }
    }

}

extension ChimeClientTypes {
    /// Summary of the details of a ChannelBan.
    public struct ChannelBanSummary {
        /// The member being banned from a channel.
        public var member: ChimeClientTypes.Identity?

        public init(
            member: ChimeClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }

}

extension ChimeClientTypes {
    /// The details of a channel member.
    public struct ChannelMembership {
        /// The ARN of the member's channel.
        public var channelArn: Swift.String?
        /// The time at which the channel membership was created.
        public var createdTimestamp: Foundation.Date?
        /// The identifier of the member who invited another member.
        public var invitedBy: ChimeClientTypes.Identity?
        /// The time at which a channel membership was last updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The data of the channel member.
        public var member: ChimeClientTypes.Identity?
        /// The membership type set for the channel member.
        public var type: ChimeClientTypes.ChannelMembershipType?

        public init(
            channelArn: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            invitedBy: ChimeClientTypes.Identity? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            member: ChimeClientTypes.Identity? = nil,
            type: ChimeClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.createdTimestamp = createdTimestamp
            self.invitedBy = invitedBy
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.member = member
            self.type = type
        }
    }

}

extension ChimeClientTypes {
    /// Summary of the details of a Channel.
    public struct ChannelSummary {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The time at which the last message in a channel was sent.
        public var lastMessageTimestamp: Foundation.Date?
        /// The metadata of the channel.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeClientTypes.ChannelMode?
        /// The name of the channel.
        public var name: Swift.String?
        /// The privacy setting of the channel.
        public var privacy: ChimeClientTypes.ChannelPrivacy?

        public init(
            channelArn: Swift.String? = nil,
            lastMessageTimestamp: Foundation.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.lastMessageTimestamp = lastMessageTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ChimeClientTypes.ChannelSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelSummary(channelArn: \(Swift.String(describing: channelArn)), lastMessageTimestamp: \(Swift.String(describing: lastMessageTimestamp)), mode: \(Swift.String(describing: mode)), privacy: \(Swift.String(describing: privacy)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Summary of the channel membership details of an AppInstanceUser.
    public struct ChannelMembershipForAppInstanceUserSummary {
        /// Summary of the membership details of an AppInstanceUser.
        public var appInstanceUserMembershipSummary: ChimeClientTypes.AppInstanceUserMembershipSummary?
        /// Summary of the details of a Channel.
        public var channelSummary: ChimeClientTypes.ChannelSummary?

        public init(
            appInstanceUserMembershipSummary: ChimeClientTypes.AppInstanceUserMembershipSummary? = nil,
            channelSummary: ChimeClientTypes.ChannelSummary? = nil
        )
        {
            self.appInstanceUserMembershipSummary = appInstanceUserMembershipSummary
            self.channelSummary = channelSummary
        }
    }

}

extension ChimeClientTypes {
    /// Summary of the details of a ChannelMembership.
    public struct ChannelMembershipSummary {
        /// A member's summary data.
        public var member: ChimeClientTypes.Identity?

        public init(
            member: ChimeClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }

}

extension ChimeClientTypes {

    public enum ChannelMessagePersistenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nonPersistent
        case persistent
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessagePersistenceType] {
            return [
                .nonPersistent,
                .persistent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nonPersistent: return "NON_PERSISTENT"
            case .persistent: return "PERSISTENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum ChannelMessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case control
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessageType] {
            return [
                .control,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .control: return "CONTROL"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The details of a message in a channel.
    public struct ChannelMessage {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The message content.
        public var content: Swift.String?
        /// The time at which the message was created.
        public var createdTimestamp: Foundation.Date?
        /// The time at which a message was edited.
        public var lastEditedTimestamp: Foundation.Date?
        /// The time at which a message was updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The ID of a message.
        public var messageId: Swift.String?
        /// The message metadata.
        public var metadata: Swift.String?
        /// The persistence setting for a channel message.
        public var persistence: ChimeClientTypes.ChannelMessagePersistenceType?
        /// Hides the content of a message.
        public var redacted: Swift.Bool
        /// The message sender.
        public var sender: ChimeClientTypes.Identity?
        /// The message type.
        public var type: ChimeClientTypes.ChannelMessageType?

        public init(
            channelArn: Swift.String? = nil,
            content: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            lastEditedTimestamp: Foundation.Date? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            persistence: ChimeClientTypes.ChannelMessagePersistenceType? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeClientTypes.Identity? = nil,
            type: ChimeClientTypes.ChannelMessageType? = nil
        )
        {
            self.channelArn = channelArn
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageId = messageId
            self.metadata = metadata
            self.persistence = persistence
            self.redacted = redacted
            self.sender = sender
            self.type = type
        }
    }

}

extension ChimeClientTypes.ChannelMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessage(channelArn: \(Swift.String(describing: channelArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastEditedTimestamp: \(Swift.String(describing: lastEditedTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), messageId: \(Swift.String(describing: messageId)), persistence: \(Swift.String(describing: persistence)), redacted: \(Swift.String(describing: redacted)), sender: \(Swift.String(describing: sender)), type: \(Swift.String(describing: type)), content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Summary of the messages in a Channel.
    public struct ChannelMessageSummary {
        /// The content of the message.
        public var content: Swift.String?
        /// The time at which the message summary was created.
        public var createdTimestamp: Foundation.Date?
        /// The time at which a message was last edited.
        public var lastEditedTimestamp: Foundation.Date?
        /// The time at which a message was last updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The ID of the message.
        public var messageId: Swift.String?
        /// The metadata of the message.
        public var metadata: Swift.String?
        /// Indicates whether a message was redacted.
        public var redacted: Swift.Bool
        /// The message sender.
        public var sender: ChimeClientTypes.Identity?
        /// The type of message.
        public var type: ChimeClientTypes.ChannelMessageType?

        public init(
            content: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            lastEditedTimestamp: Foundation.Date? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeClientTypes.Identity? = nil,
            type: ChimeClientTypes.ChannelMessageType? = nil
        )
        {
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageId = messageId
            self.metadata = metadata
            self.redacted = redacted
            self.sender = sender
            self.type = type
        }
    }

}

extension ChimeClientTypes.ChannelMessageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessageSummary(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastEditedTimestamp: \(Swift.String(describing: lastEditedTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), messageId: \(Swift.String(describing: messageId)), redacted: \(Swift.String(describing: redacted)), sender: \(Swift.String(describing: sender)), type: \(Swift.String(describing: type)), content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Summary of the details of a moderated channel.
    public struct ChannelModeratedByAppInstanceUserSummary {
        /// Summary of the details of a Channel.
        public var channelSummary: ChimeClientTypes.ChannelSummary?

        public init(
            channelSummary: ChimeClientTypes.ChannelSummary? = nil
        )
        {
            self.channelSummary = channelSummary
        }
    }

}

extension ChimeClientTypes {
    /// The details of a channel moderator.
    public struct ChannelModerator {
        /// The ARN of the moderator's channel.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the moderator.
        public var createdBy: ChimeClientTypes.Identity?
        /// The time at which the moderator was created.
        public var createdTimestamp: Foundation.Date?
        /// The moderator's data.
        public var moderator: ChimeClientTypes.Identity?

        public init(
            channelArn: Swift.String? = nil,
            createdBy: ChimeClientTypes.Identity? = nil,
            createdTimestamp: Foundation.Date? = nil,
            moderator: ChimeClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.moderator = moderator
        }
    }

}

extension ChimeClientTypes {
    /// Summary of the details of a ChannelModerator.
    public struct ChannelModeratorSummary {
        /// The data for a moderator.
        public var moderator: ChimeClientTypes.Identity?

        public init(
            moderator: ChimeClientTypes.Identity? = nil
        )
        {
            self.moderator = moderator
        }
    }

}

extension ChimeClientTypes {
    /// The video streams to capture for a specified media capture pipeline. The total number of video streams can't exceed 25.
    public struct SelectedVideoStreams {
        /// The attendee IDs of the streams selected for a media capture pipeline.
        public var attendeeIds: [Swift.String]?
        /// The external user IDs of the streams selected for a media capture pipeline.
        public var externalUserIds: [Swift.String]?

        public init(
            attendeeIds: [Swift.String]? = nil,
            externalUserIds: [Swift.String]? = nil
        )
        {
            self.attendeeIds = attendeeIds
            self.externalUserIds = externalUserIds
        }
    }

}

extension ChimeClientTypes.SelectedVideoStreams: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SelectedVideoStreams(attendeeIds: \(Swift.String(describing: attendeeIds)), externalUserIds: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// Source configuration for a specified media capture pipeline.
    public struct SourceConfiguration {
        /// The selected video streams to capture for a specified media capture pipeline. The number of video streams can't exceed 25.
        public var selectedVideoStreams: ChimeClientTypes.SelectedVideoStreams?

        public init(
            selectedVideoStreams: ChimeClientTypes.SelectedVideoStreams? = nil
        )
        {
            self.selectedVideoStreams = selectedVideoStreams
        }
    }

}

extension ChimeClientTypes {
    /// The configuration object of the Amazon Chime SDK meeting for a specified media capture pipeline. SourceType must be ChimeSdkMeeting.
    public struct ChimeSdkMeetingConfiguration {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting.
        public var artifactsConfiguration: ChimeClientTypes.ArtifactsConfiguration?
        /// The source configuration for a specified media capture pipeline.
        public var sourceConfiguration: ChimeClientTypes.SourceConfiguration?

        public init(
            artifactsConfiguration: ChimeClientTypes.ArtifactsConfiguration? = nil,
            sourceConfiguration: ChimeClientTypes.SourceConfiguration? = nil
        )
        {
            self.artifactsConfiguration = artifactsConfiguration
            self.sourceConfiguration = sourceConfiguration
        }
    }

}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension ChimeClientTypes {
    /// The retention settings that determine how long to retain conversation messages for an Amazon Chime Enterprise account.
    public struct ConversationRetentionSettings {
        /// The number of days for which to retain conversation messages.
        public var retentionDays: Swift.Int?

        public init(
            retentionDays: Swift.Int? = nil
        )
        {
            self.retentionDays = retentionDays
        }
    }

}

public struct CreateAccountInput {
    /// The name of the Amazon Chime account.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct CreateAccountOutput {
    /// The Amazon Chime account details.
    public var account: ChimeClientTypes.Account?

    public init(
        account: ChimeClientTypes.Account? = nil
    )
    {
        self.account = account
    }
}

public struct CreateAppInstanceInput {
    /// The ClientRequestToken of the AppInstance.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The metadata of the AppInstance. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The name of the AppInstance.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to the AppInstance.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

extension CreateAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceInput(tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateAppInstanceOutput {
    /// The Amazon Resource Number (ARN) of the AppInstance.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

public struct CreateAppInstanceAdminInput {
    /// The ARN of the administrator of the current AppInstance.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

public struct CreateAppInstanceAdminOutput {
    /// The name and ARN of the admin for the AppInstance.
    public var appInstanceAdmin: ChimeClientTypes.Identity?
    /// The ARN of the of the admin for the AppInstance.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceAdmin: ChimeClientTypes.Identity? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdmin = appInstanceAdmin
        self.appInstanceArn = appInstanceArn
    }
}

public struct CreateAppInstanceUserInput {
    /// The ARN of the AppInstance request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The user ID of the AppInstance.
    /// This member is required.
    public var appInstanceUserId: Swift.String?
    /// The token assigned to the user requesting an AppInstance.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The request's metadata. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The user's name.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to the AppInstanceUser.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        appInstanceArn: Swift.String? = nil,
        appInstanceUserId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceUserId = appInstanceUserId
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

extension CreateAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceUserInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), tags: \(Swift.String(describing: tags)), appInstanceUserId: \"CONTENT_REDACTED\", clientRequestToken: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateAppInstanceUserOutput {
    /// The user's ARN.
    public var appInstanceUserArn: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

public struct CreateAttendeeInput {
    /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.
    /// This member is required.
    public var externalUserId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        externalUserId: Swift.String? = nil,
        meetingId: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.externalUserId = externalUserId
        self.meetingId = meetingId
        self.tags = tags
    }
}

extension CreateAttendeeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeInput(meetingId: \(Swift.String(describing: meetingId)), tags: \(Swift.String(describing: tags)), externalUserId: \"CONTENT_REDACTED\")"}
}

public struct CreateAttendeeOutput {
    /// The attendee information, including attendee ID and join token.
    public var attendee: ChimeClientTypes.Attendee?

    public init(
        attendee: ChimeClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

public struct CreateBotInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot display name.
    /// This member is required.
    public var displayName: Swift.String?
    /// The domain of the Amazon Chime Enterprise account.
    public var domain: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domain: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.displayName = displayName
        self.domain = domain
    }
}

extension CreateBotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBotInput(accountId: \(Swift.String(describing: accountId)), domain: \(Swift.String(describing: domain)), displayName: \"CONTENT_REDACTED\")"}
}

public struct CreateBotOutput {
    /// The bot details.
    public var bot: ChimeClientTypes.Bot?

    public init(
        bot: ChimeClientTypes.Bot? = nil
    )
    {
        self.bot = bot
    }
}

public struct CreateChannelInput {
    /// The ARN of the channel request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The client token for the request. An Idempotency token.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The metadata of the creation request. Limited to 1KB and UTF-8.
    public var metadata: Swift.String?
    /// The channel mode: UNRESTRICTED or RESTRICTED. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.
    public var mode: ChimeClientTypes.ChannelMode?
    /// The name of the channel.
    /// This member is required.
    public var name: Swift.String?
    /// The channel's privacy level: PUBLIC or PRIVATE. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the AppInstance.
    public var privacy: ChimeClientTypes.ChannelPrivacy?
    /// The tags for the creation request.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        appInstanceArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeClientTypes.ChannelMode? = nil,
        name: Swift.String? = nil,
        privacy: ChimeClientTypes.ChannelPrivacy? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.mode = mode
        self.name = name
        self.privacy = privacy
        self.tags = tags
    }
}

extension CreateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), mode: \(Swift.String(describing: mode)), privacy: \(Swift.String(describing: privacy)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateChannelOutput {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

public struct CreateChannelBanInput {
    /// The ARN of the ban request.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member being banned.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

public struct CreateChannelBanOutput {
    /// The ARN of the response to the ban request.
    public var channelArn: Swift.String?
    /// The ChannelArn and BannedIdentity of the member in the ban response.
    public var member: ChimeClientTypes.Identity?

    public init(
        channelArn: Swift.String? = nil,
        member: ChimeClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
    }
}

public struct CreateChannelMembershipInput {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member you want to add to the channel.
    /// This member is required.
    public var memberArn: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
    /// This member is required.
    public var type: ChimeClientTypes.ChannelMembershipType?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        type: ChimeClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.type = type
    }
}

public struct CreateChannelMembershipOutput {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ARN and metadata of the member being added.
    public var member: ChimeClientTypes.Identity?

    public init(
        channelArn: Swift.String? = nil,
        member: ChimeClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
    }
}

public struct CreateChannelModeratorInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the moderator.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

public struct CreateChannelModeratorOutput {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ARNs of the channel and the moderator.
    public var channelModerator: ChimeClientTypes.Identity?

    public init(
        channelArn: Swift.String? = nil,
        channelModerator: ChimeClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerator = channelModerator
    }
}

extension ChimeClientTypes {

    public enum MediaPipelineSinkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case s3bucket
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSinkType] {
            return [
                .s3bucket
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .s3bucket: return "S3Bucket"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum MediaPipelineSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case chimesdkmeeting
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSourceType] {
            return [
                .chimesdkmeeting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .chimesdkmeeting: return "ChimeSdkMeeting"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateMediaCapturePipelineInput {
    /// The configuration for a specified media capture pipeline. SourceType must be ChimeSdkMeeting.
    public var chimeSdkMeetingConfiguration: ChimeClientTypes.ChimeSdkMeetingConfiguration?
    /// The unique identifier for the client request. The token makes the API request idempotent. Use a different token for different media pipeline requests.
    public var clientRequestToken: Swift.String?
    /// The ARN of the sink type.
    /// This member is required.
    public var sinkArn: Swift.String?
    /// Destination type to which the media artifacts are saved. You must use an S3 bucket.
    /// This member is required.
    public var sinkType: ChimeClientTypes.MediaPipelineSinkType?
    /// ARN of the source from which the media artifacts are captured.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Source type from which the media artifacts will be captured. A Chime SDK Meeting is the only supported source.
    /// This member is required.
    public var sourceType: ChimeClientTypes.MediaPipelineSourceType?

    public init(
        chimeSdkMeetingConfiguration: ChimeClientTypes.ChimeSdkMeetingConfiguration? = nil,
        clientRequestToken: Swift.String? = nil,
        sinkArn: Swift.String? = nil,
        sinkType: ChimeClientTypes.MediaPipelineSinkType? = nil,
        sourceArn: Swift.String? = nil,
        sourceType: ChimeClientTypes.MediaPipelineSourceType? = nil
    )
    {
        self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
        self.clientRequestToken = clientRequestToken
        self.sinkArn = sinkArn
        self.sinkType = sinkType
        self.sourceArn = sourceArn
        self.sourceType = sourceType
    }
}

extension CreateMediaCapturePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaCapturePipelineInput(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), sinkType: \(Swift.String(describing: sinkType)), sourceType: \(Swift.String(describing: sourceType)), clientRequestToken: \"CONTENT_REDACTED\", sinkArn: \"CONTENT_REDACTED\", sourceArn: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {

    public enum MediaPipelineStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inprogress
        case initializing
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineStatus] {
            return [
                .failed,
                .inprogress,
                .initializing,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .initializing: return "Initializing"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// A media capture pipeline object consisting of an ID, source type, source ARN, a sink type, a sink ARN, and a configuration object.
    public struct MediaCapturePipeline {
        /// The configuration for a specified media capture pipeline. SourceType must be ChimeSdkMeeting.
        public var chimeSdkMeetingConfiguration: ChimeClientTypes.ChimeSdkMeetingConfiguration?
        /// The time at which the capture pipeline was created, in ISO 8601 format.
        public var createdTimestamp: Foundation.Date?
        /// The ID of a media capture pipeline.
        public var mediaPipelineId: Swift.String?
        /// ARN of the destination to which the media artifacts are saved.
        public var sinkArn: Swift.String?
        /// Destination type to which the media artifacts are saved. You must use an S3 Bucket.
        public var sinkType: ChimeClientTypes.MediaPipelineSinkType?
        /// ARN of the source from which the media artifacts will be saved.
        public var sourceArn: Swift.String?
        /// Source type from which media artifacts are saved. You must use ChimeMeeting.
        public var sourceType: ChimeClientTypes.MediaPipelineSourceType?
        /// The status of the media capture pipeline.
        public var status: ChimeClientTypes.MediaPipelineStatus?
        /// The time at which the capture pipeline was updated, in ISO 8601 format.
        public var updatedTimestamp: Foundation.Date?

        public init(
            chimeSdkMeetingConfiguration: ChimeClientTypes.ChimeSdkMeetingConfiguration? = nil,
            createdTimestamp: Foundation.Date? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinkArn: Swift.String? = nil,
            sinkType: ChimeClientTypes.MediaPipelineSinkType? = nil,
            sourceArn: Swift.String? = nil,
            sourceType: ChimeClientTypes.MediaPipelineSourceType? = nil,
            status: ChimeClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineId = mediaPipelineId
            self.sinkArn = sinkArn
            self.sinkType = sinkType
            self.sourceArn = sourceArn
            self.sourceType = sourceType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes.MediaCapturePipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaCapturePipeline(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), mediaPipelineId: \(Swift.String(describing: mediaPipelineId)), sinkType: \(Swift.String(describing: sinkType)), sourceType: \(Swift.String(describing: sourceType)), status: \(Swift.String(describing: status)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), sinkArn: \"CONTENT_REDACTED\", sourceArn: \"CONTENT_REDACTED\")"}
}

public struct CreateMediaCapturePipelineOutput {
    /// A media capture pipeline object, the ID, source type, source ARN, sink type, and sink ARN of a media capture pipeline object.
    public var mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline?

    public init(
        mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

extension ChimeClientTypes {
    /// The resource target configurations for receiving Amazon Chime SDK meeting and attendee event notifications. The Amazon Chime SDK supports resource targets located in the US East (N. Virginia) AWS Region (us-east-1).
    public struct MeetingNotificationConfiguration {
        /// The SNS topic ARN.
        public var snsTopicArn: Swift.String?
        /// The SQS queue ARN.
        public var sqsQueueArn: Swift.String?

        public init(
            snsTopicArn: Swift.String? = nil,
            sqsQueueArn: Swift.String? = nil
        )
        {
            self.snsTopicArn = snsTopicArn
            self.sqsQueueArn = sqsQueueArn
        }
    }

}

extension ChimeClientTypes.MeetingNotificationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MeetingNotificationConfiguration(snsTopicArn: \"CONTENT_REDACTED\", sqsQueueArn: \"CONTENT_REDACTED\")"}
}

public struct CreateMeetingInput {
    /// The unique identifier for the client request. Use a different token for different meetings.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The external meeting ID.
    public var externalMeetingId: Swift.String?
    /// The Region in which to create the meeting. Default: us-east-1. Available values: af-south-1 , ap-northeast-1 , ap-northeast-2 , ap-south-1 , ap-southeast-1 , ap-southeast-2 , ca-central-1 , eu-central-1 , eu-north-1 , eu-south-1 , eu-west-1 , eu-west-2 , eu-west-3 , sa-east-1 , us-east-1 , us-east-2 , us-west-1 , us-west-2 .
    public var mediaRegion: Swift.String?
    /// Reserved.
    public var meetingHostId: Swift.String?
    /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
    public var notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration?
    /// The tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        externalMeetingId: Swift.String? = nil,
        mediaRegion: Swift.String? = nil,
        meetingHostId: Swift.String? = nil,
        notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.externalMeetingId = externalMeetingId
        self.mediaRegion = mediaRegion
        self.meetingHostId = meetingHostId
        self.notificationsConfiguration = notificationsConfiguration
        self.tags = tags
    }
}

extension CreateMeetingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingInput(mediaRegion: \(Swift.String(describing: mediaRegion)), notificationsConfiguration: \(Swift.String(describing: notificationsConfiguration)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", externalMeetingId: \"CONTENT_REDACTED\", meetingHostId: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// A set of endpoints used by clients to connect to the media service group for an Amazon Chime SDK meeting.
    public struct MediaPlacement {
        /// The audio fallback URL.
        public var audioFallbackUrl: Swift.String?
        /// The audio host URL.
        public var audioHostUrl: Swift.String?
        /// The event ingestion URL to which you send client meeting events.
        public var eventIngestionUrl: Swift.String?
        /// The screen data URL. This parameter is is no longer supported and no longer used by the Amazon Chime SDK.
        public var screenDataUrl: Swift.String?
        /// The screen sharing URL. This parameter is is no longer supported and no longer used by the Amazon Chime SDK..
        public var screenSharingUrl: Swift.String?
        /// The screen viewing URL. This parameter is is no longer supported and no longer used by the Amazon Chime SDK.
        public var screenViewingUrl: Swift.String?
        /// The signaling URL.
        public var signalingUrl: Swift.String?
        /// The turn control URL. This parameter is is no longer supported and no longer used by the Amazon Chime SDK.
        public var turnControlUrl: Swift.String?

        public init(
            audioFallbackUrl: Swift.String? = nil,
            audioHostUrl: Swift.String? = nil,
            eventIngestionUrl: Swift.String? = nil,
            screenDataUrl: Swift.String? = nil,
            screenSharingUrl: Swift.String? = nil,
            screenViewingUrl: Swift.String? = nil,
            signalingUrl: Swift.String? = nil,
            turnControlUrl: Swift.String? = nil
        )
        {
            self.audioFallbackUrl = audioFallbackUrl
            self.audioHostUrl = audioHostUrl
            self.eventIngestionUrl = eventIngestionUrl
            self.screenDataUrl = screenDataUrl
            self.screenSharingUrl = screenSharingUrl
            self.screenViewingUrl = screenViewingUrl
            self.signalingUrl = signalingUrl
            self.turnControlUrl = turnControlUrl
        }
    }

}

extension ChimeClientTypes {
    /// A meeting created using the Amazon Chime SDK.
    public struct Meeting {
        /// The external meeting ID.
        public var externalMeetingId: Swift.String?
        /// The media placement for the meeting.
        public var mediaPlacement: ChimeClientTypes.MediaPlacement?
        /// The Region in which you create the meeting. Available values: af-south-1, ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, ca-central-1, eu-central-1, eu-north-1, eu-south-1, eu-west-1, eu-west-2, eu-west-3, sa-east-1, us-east-1, us-east-2, us-west-1, us-west-2.
        public var mediaRegion: Swift.String?
        /// The Amazon Chime SDK meeting ID.
        public var meetingId: Swift.String?

        public init(
            externalMeetingId: Swift.String? = nil,
            mediaPlacement: ChimeClientTypes.MediaPlacement? = nil,
            mediaRegion: Swift.String? = nil,
            meetingId: Swift.String? = nil
        )
        {
            self.externalMeetingId = externalMeetingId
            self.mediaPlacement = mediaPlacement
            self.mediaRegion = mediaRegion
            self.meetingId = meetingId
        }
    }

}

extension ChimeClientTypes.Meeting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Meeting(mediaPlacement: \(Swift.String(describing: mediaPlacement)), mediaRegion: \(Swift.String(describing: mediaRegion)), meetingId: \(Swift.String(describing: meetingId)), externalMeetingId: \"CONTENT_REDACTED\")"}
}

public struct CreateMeetingOutput {
    /// The meeting information, including the meeting ID and MediaPlacement .
    public var meeting: ChimeClientTypes.Meeting?

    public init(
        meeting: ChimeClientTypes.Meeting? = nil
    )
    {
        self.meeting = meeting
    }
}

public struct CreateMeetingDialOutInput {
    /// Phone number used as the caller ID when the remote party receives a call.
    /// This member is required.
    public var fromPhoneNumber: Swift.String?
    /// Token used by the Amazon Chime SDK attendee. Call the [CreateAttendee](https://docs.aws.amazon.com/chime/latest/APIReference/API_CreateAttendee.html) action to get a join token.
    /// This member is required.
    public var joinToken: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// Phone number called when inviting someone to a meeting.
    /// This member is required.
    public var toPhoneNumber: Swift.String?

    public init(
        fromPhoneNumber: Swift.String? = nil,
        joinToken: Swift.String? = nil,
        meetingId: Swift.String? = nil,
        toPhoneNumber: Swift.String? = nil
    )
    {
        self.fromPhoneNumber = fromPhoneNumber
        self.joinToken = joinToken
        self.meetingId = meetingId
        self.toPhoneNumber = toPhoneNumber
    }
}

extension CreateMeetingDialOutInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingDialOutInput(meetingId: \(Swift.String(describing: meetingId)), fromPhoneNumber: \"CONTENT_REDACTED\", joinToken: \"CONTENT_REDACTED\", toPhoneNumber: \"CONTENT_REDACTED\")"}
}

public struct CreateMeetingDialOutOutput {
    /// Unique ID that tracks API calls.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

public struct CreateMeetingWithAttendeesInput {
    /// The request containing the attendees to create.
    public var attendees: [ChimeClientTypes.CreateAttendeeRequestItem]?
    /// The unique identifier for the client request. Use a different token for different meetings.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The external meeting ID.
    public var externalMeetingId: Swift.String?
    /// The Region in which to create the meeting. Default: us-east-1 . Available values: af-south-1 , ap-northeast-1 , ap-northeast-2 , ap-south-1 , ap-southeast-1 , ap-southeast-2 , ca-central-1 , eu-central-1 , eu-north-1 , eu-south-1 , eu-west-1 , eu-west-2 , eu-west-3 , sa-east-1 , us-east-1 , us-east-2 , us-west-1 , us-west-2 .
    public var mediaRegion: Swift.String?
    /// Reserved.
    public var meetingHostId: Swift.String?
    /// The resource target configurations for receiving Amazon Chime SDK meeting and attendee event notifications. The Amazon Chime SDK supports resource targets located in the US East (N. Virginia) AWS Region (us-east-1).
    public var notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration?
    /// The tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        attendees: [ChimeClientTypes.CreateAttendeeRequestItem]? = nil,
        clientRequestToken: Swift.String? = nil,
        externalMeetingId: Swift.String? = nil,
        mediaRegion: Swift.String? = nil,
        meetingHostId: Swift.String? = nil,
        notificationsConfiguration: ChimeClientTypes.MeetingNotificationConfiguration? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.attendees = attendees
        self.clientRequestToken = clientRequestToken
        self.externalMeetingId = externalMeetingId
        self.mediaRegion = mediaRegion
        self.meetingHostId = meetingHostId
        self.notificationsConfiguration = notificationsConfiguration
        self.tags = tags
    }
}

extension CreateMeetingWithAttendeesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingWithAttendeesInput(attendees: \(Swift.String(describing: attendees)), mediaRegion: \(Swift.String(describing: mediaRegion)), notificationsConfiguration: \(Swift.String(describing: notificationsConfiguration)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", externalMeetingId: \"CONTENT_REDACTED\", meetingHostId: \"CONTENT_REDACTED\")"}
}

public struct CreateMeetingWithAttendeesOutput {
    /// The attendee information, including attendees IDs and join tokens.
    public var attendees: [ChimeClientTypes.Attendee]?
    /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
    public var errors: [ChimeClientTypes.CreateAttendeeError]?
    /// A meeting created using the Amazon Chime SDK.
    public var meeting: ChimeClientTypes.Meeting?

    public init(
        attendees: [ChimeClientTypes.Attendee]? = nil,
        errors: [ChimeClientTypes.CreateAttendeeError]? = nil,
        meeting: ChimeClientTypes.Meeting? = nil
    )
    {
        self.attendees = attendees
        self.errors = errors
        self.meeting = meeting
    }
}

public struct CreatePhoneNumberOrderInput {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The phone number product type.
    /// This member is required.
    public var productType: ChimeClientTypes.PhoneNumberProductType?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        productType: ChimeClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.productType = productType
    }
}

extension CreatePhoneNumberOrderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePhoneNumberOrderInput(productType: \(Swift.String(describing: productType)), e164PhoneNumbers: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {

    public enum OrderedPhoneNumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acquired
        case failed
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderedPhoneNumberStatus] {
            return [
                .acquired,
                .failed,
                .processing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acquired: return "Acquired"
            case .failed: return "Failed"
            case .processing: return "Processing"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// A phone number for which an order has been placed.
    public struct OrderedPhoneNumber {
        /// The phone number, in E.164 format.
        public var e164PhoneNumber: Swift.String?
        /// The phone number status.
        public var status: ChimeClientTypes.OrderedPhoneNumberStatus?

        public init(
            e164PhoneNumber: Swift.String? = nil,
            status: ChimeClientTypes.OrderedPhoneNumberStatus? = nil
        )
        {
            self.e164PhoneNumber = e164PhoneNumber
            self.status = status
        }
    }

}

extension ChimeClientTypes.OrderedPhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrderedPhoneNumber(status: \(Swift.String(describing: status)), e164PhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {

    public enum PhoneNumberOrderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case partial
        case processing
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberOrderStatus] {
            return [
                .failed,
                .partial,
                .processing,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .partial: return "Partial"
            case .processing: return "Processing"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The details of a phone number order created for Amazon Chime.
    public struct PhoneNumberOrder {
        /// The phone number order creation time stamp, in ISO 8601 format.
        public var createdTimestamp: Foundation.Date?
        /// The ordered phone number details, such as the phone number in E.164 format and the phone number status.
        public var orderedPhoneNumbers: [ChimeClientTypes.OrderedPhoneNumber]?
        /// The phone number order ID.
        public var phoneNumberOrderId: Swift.String?
        /// The phone number order product type.
        public var productType: ChimeClientTypes.PhoneNumberProductType?
        /// The status of the phone number order.
        public var status: ChimeClientTypes.PhoneNumberOrderStatus?
        /// The updated phone number order time stamp, in ISO 8601 format.
        public var updatedTimestamp: Foundation.Date?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            orderedPhoneNumbers: [ChimeClientTypes.OrderedPhoneNumber]? = nil,
            phoneNumberOrderId: Swift.String? = nil,
            productType: ChimeClientTypes.PhoneNumberProductType? = nil,
            status: ChimeClientTypes.PhoneNumberOrderStatus? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.orderedPhoneNumbers = orderedPhoneNumbers
            self.phoneNumberOrderId = phoneNumberOrderId
            self.productType = productType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

public struct CreatePhoneNumberOrderOutput {
    /// The phone number order details.
    public var phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder?

    public init(
        phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder? = nil
    )
    {
        self.phoneNumberOrder = phoneNumberOrder
    }
}

extension ChimeClientTypes {

    public enum GeoMatchLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case areacode
        case country
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoMatchLevel] {
            return [
                .areacode,
                .country
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .areacode: return "AreaCode"
            case .country: return "Country"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The country and area code for a proxy phone number in a proxy phone session.
    public struct GeoMatchParams {
        /// The area code.
        /// This member is required.
        public var areaCode: Swift.String?
        /// The country.
        /// This member is required.
        public var country: Swift.String?

        public init(
            areaCode: Swift.String? = nil,
            country: Swift.String? = nil
        )
        {
            self.areaCode = areaCode
            self.country = country
        }
    }

}

extension ChimeClientTypes {

    public enum NumberSelectionBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case avoidsticky
        case prefersticky
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberSelectionBehavior] {
            return [
                .avoidsticky,
                .prefersticky
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .avoidsticky: return "AvoidSticky"
            case .prefersticky: return "PreferSticky"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProxySessionInput {
    /// The proxy session capabilities.
    /// This member is required.
    public var capabilities: [ChimeClientTypes.Capability]?
    /// The number of minutes allowed for the proxy session.
    public var expiryMinutes: Swift.Int?
    /// The preference for matching the country or area code of the proxy phone number with that of the first participant.
    public var geoMatchLevel: ChimeClientTypes.GeoMatchLevel?
    /// The country and area code for the proxy phone number.
    public var geoMatchParams: ChimeClientTypes.GeoMatchParams?
    /// The name of the proxy session.
    public var name: Swift.String?
    /// The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.
    public var numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior?
    /// The participant phone numbers.
    /// This member is required.
    public var participantPhoneNumbers: [Swift.String]?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        capabilities: [ChimeClientTypes.Capability]? = nil,
        expiryMinutes: Swift.Int? = nil,
        geoMatchLevel: ChimeClientTypes.GeoMatchLevel? = nil,
        geoMatchParams: ChimeClientTypes.GeoMatchParams? = nil,
        name: Swift.String? = nil,
        numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior? = nil,
        participantPhoneNumbers: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.expiryMinutes = expiryMinutes
        self.geoMatchLevel = geoMatchLevel
        self.geoMatchParams = geoMatchParams
        self.name = name
        self.numberSelectionBehavior = numberSelectionBehavior
        self.participantPhoneNumbers = participantPhoneNumbers
        self.voiceConnectorId = voiceConnectorId
    }
}

extension CreateProxySessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProxySessionInput(capabilities: \(Swift.String(describing: capabilities)), expiryMinutes: \(Swift.String(describing: expiryMinutes)), geoMatchLevel: \(Swift.String(describing: geoMatchLevel)), geoMatchParams: \(Swift.String(describing: geoMatchParams)), numberSelectionBehavior: \(Swift.String(describing: numberSelectionBehavior)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), name: \"CONTENT_REDACTED\", participantPhoneNumbers: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The phone number and proxy phone number for a participant in an Amazon Chime Voice Connector proxy session.
    public struct Participant {
        /// The participant's phone number.
        public var phoneNumber: Swift.String?
        /// The participant's proxy phone number.
        public var proxyPhoneNumber: Swift.String?

        public init(
            phoneNumber: Swift.String? = nil,
            proxyPhoneNumber: Swift.String? = nil
        )
        {
            self.phoneNumber = phoneNumber
            self.proxyPhoneNumber = proxyPhoneNumber
        }
    }

}

extension ChimeClientTypes.Participant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Participant(phoneNumber: \"CONTENT_REDACTED\", proxyPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {

    public enum ProxySessionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case closed
        case inprogress
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [ProxySessionStatus] {
            return [
                .closed,
                .inprogress,
                .open
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .closed: return "Closed"
            case .inprogress: return "InProgress"
            case .open: return "Open"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The proxy session for an Amazon Chime Voice Connector.
    public struct ProxySession {
        /// The proxy session capabilities.
        public var capabilities: [ChimeClientTypes.Capability]?
        /// The created time stamp, in ISO 8601 format.
        public var createdTimestamp: Foundation.Date?
        /// The ended time stamp, in ISO 8601 format.
        public var endedTimestamp: Foundation.Date?
        /// The number of minutes allowed for the proxy session.
        public var expiryMinutes: Swift.Int?
        /// The preference for matching the country or area code of the proxy phone number with that of the first participant.
        public var geoMatchLevel: ChimeClientTypes.GeoMatchLevel?
        /// The country and area code for the proxy phone number.
        public var geoMatchParams: ChimeClientTypes.GeoMatchParams?
        /// The name of the proxy session.
        public var name: Swift.String?
        /// The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.
        public var numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior?
        /// The proxy session participants.
        public var participants: [ChimeClientTypes.Participant]?
        /// The proxy session ID.
        public var proxySessionId: Swift.String?
        /// The status of the proxy session.
        public var status: ChimeClientTypes.ProxySessionStatus?
        /// The updated time stamp, in ISO 8601 format.
        public var updatedTimestamp: Foundation.Date?
        /// The Amazon Chime voice connector ID.
        public var voiceConnectorId: Swift.String?

        public init(
            capabilities: [ChimeClientTypes.Capability]? = nil,
            createdTimestamp: Foundation.Date? = nil,
            endedTimestamp: Foundation.Date? = nil,
            expiryMinutes: Swift.Int? = nil,
            geoMatchLevel: ChimeClientTypes.GeoMatchLevel? = nil,
            geoMatchParams: ChimeClientTypes.GeoMatchParams? = nil,
            name: Swift.String? = nil,
            numberSelectionBehavior: ChimeClientTypes.NumberSelectionBehavior? = nil,
            participants: [ChimeClientTypes.Participant]? = nil,
            proxySessionId: Swift.String? = nil,
            status: ChimeClientTypes.ProxySessionStatus? = nil,
            updatedTimestamp: Foundation.Date? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.capabilities = capabilities
            self.createdTimestamp = createdTimestamp
            self.endedTimestamp = endedTimestamp
            self.expiryMinutes = expiryMinutes
            self.geoMatchLevel = geoMatchLevel
            self.geoMatchParams = geoMatchParams
            self.name = name
            self.numberSelectionBehavior = numberSelectionBehavior
            self.participants = participants
            self.proxySessionId = proxySessionId
            self.status = status
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

public struct CreateProxySessionOutput {
    /// The proxy session details.
    public var proxySession: ChimeClientTypes.ProxySession?

    public init(
        proxySession: ChimeClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

public struct CreateRoomInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The idempotency token for the request.
    public var clientRequestToken: Swift.String?
    /// The room name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.clientRequestToken = clientRequestToken
        self.name = name
    }
}

extension CreateRoomInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRoomInput(accountId: \(Swift.String(describing: accountId)), clientRequestToken: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The Amazon Chime chat room details.
    public struct Room {
        /// The Amazon Chime account ID.
        public var accountId: Swift.String?
        /// The identifier of the room creator.
        public var createdBy: Swift.String?
        /// The room creation timestamp, in ISO 8601 format.
        public var createdTimestamp: Foundation.Date?
        /// The room name.
        public var name: Swift.String?
        /// The room ID.
        public var roomId: Swift.String?
        /// The room update timestamp, in ISO 8601 format.
        public var updatedTimestamp: Foundation.Date?

        public init(
            accountId: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            name: Swift.String? = nil,
            roomId: Swift.String? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.accountId = accountId
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.roomId = roomId
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes.Room: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Room(accountId: \(Swift.String(describing: accountId)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), roomId: \(Swift.String(describing: roomId)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), name: \"CONTENT_REDACTED\")"}
}

public struct CreateRoomOutput {
    /// The room details.
    public var room: ChimeClientTypes.Room?

    public init(
        room: ChimeClientTypes.Room? = nil
    )
    {
        self.room = room
    }
}

public struct CreateRoomMembershipInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Chime member ID (user ID or bot ID).
    /// This member is required.
    public var memberId: Swift.String?
    /// The role of the member.
    public var role: ChimeClientTypes.RoomMembershipRole?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        role: ChimeClientTypes.RoomMembershipRole? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.memberId = memberId
        self.role = role
        self.roomId = roomId
    }
}

extension ChimeClientTypes {

    public enum MemberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bot
        case user
        case webhook
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberType] {
            return [
                .bot,
                .user,
                .webhook
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bot: return "Bot"
            case .user: return "User"
            case .webhook: return "Webhook"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The member details, such as email address, name, member ID, and member type.
    public struct Member {
        /// The Amazon Chime account ID.
        public var accountId: Swift.String?
        /// The member email address.
        public var email: Swift.String?
        /// The member name.
        public var fullName: Swift.String?
        /// The member ID (user ID or bot ID).
        public var memberId: Swift.String?
        /// The member type.
        public var memberType: ChimeClientTypes.MemberType?

        public init(
            accountId: Swift.String? = nil,
            email: Swift.String? = nil,
            fullName: Swift.String? = nil,
            memberId: Swift.String? = nil,
            memberType: ChimeClientTypes.MemberType? = nil
        )
        {
            self.accountId = accountId
            self.email = email
            self.fullName = fullName
            self.memberId = memberId
            self.memberType = memberType
        }
    }

}

extension ChimeClientTypes.Member: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Member(accountId: \(Swift.String(describing: accountId)), memberId: \(Swift.String(describing: memberId)), memberType: \(Swift.String(describing: memberType)), email: \"CONTENT_REDACTED\", fullName: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// The room membership details.
    public struct RoomMembership {
        /// The identifier of the user that invited the room member.
        public var invitedBy: Swift.String?
        /// The member details, such as email address, name, member ID, and member type.
        public var member: ChimeClientTypes.Member?
        /// The membership role.
        public var role: ChimeClientTypes.RoomMembershipRole?
        /// The room ID.
        public var roomId: Swift.String?
        /// The room membership update timestamp, in ISO 8601 format.
        public var updatedTimestamp: Foundation.Date?

        public init(
            invitedBy: Swift.String? = nil,
            member: ChimeClientTypes.Member? = nil,
            role: ChimeClientTypes.RoomMembershipRole? = nil,
            roomId: Swift.String? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.invitedBy = invitedBy
            self.member = member
            self.role = role
            self.roomId = roomId
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

public struct CreateRoomMembershipOutput {
    /// The room membership details.
    public var roomMembership: ChimeClientTypes.RoomMembership?

    public init(
        roomMembership: ChimeClientTypes.RoomMembership? = nil
    )
    {
        self.roomMembership = roomMembership
    }
}

extension ChimeClientTypes {
    /// The endpoint assigned to the SIP media application.
    public struct SipMediaApplicationEndpoint {
        /// Valid Amazon Resource Name (ARN) of the Lambda function, version, or alias. The function must be created in the same AWS Region as the SIP media application.
        public var lambdaArn: Swift.String?

        public init(
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }

}

extension ChimeClientTypes.SipMediaApplicationEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipMediaApplicationEndpoint(lambdaArn: \"CONTENT_REDACTED\")"}
}

public struct CreateSipMediaApplicationInput {
    /// The AWS Region assigned to the SIP media application.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// List of endpoints (Lambda Amazon Resource Names) specified for the SIP media application. Currently, only one endpoint is supported.
    /// This member is required.
    public var endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
    /// The SIP media application name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        awsRegion: Swift.String? = nil,
        endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]? = nil,
        name: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.endpoints = endpoints
        self.name = name
    }
}

extension ChimeClientTypes {
    /// The details of the SIP media application, including name and endpoints. An AWS account can have multiple SIP media applications.
    public struct SipMediaApplication {
        /// The AWS Region in which the SIP media application is created.
        public var awsRegion: Swift.String?
        /// The SIP media application creation timestamp, in ISO 8601 format.
        public var createdTimestamp: Foundation.Date?
        /// List of endpoints for SIP media application. Currently, only one endpoint per SIP media application is permitted.
        public var endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
        /// The name of the SIP media application.
        public var name: Swift.String?
        /// The SIP media application ID.
        public var sipMediaApplicationId: Swift.String?
        /// The SIP media application updated timestamp, in ISO 8601 format.
        public var updatedTimestamp: Foundation.Date?

        public init(
            awsRegion: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]? = nil,
            name: Swift.String? = nil,
            sipMediaApplicationId: Swift.String? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.awsRegion = awsRegion
            self.createdTimestamp = createdTimestamp
            self.endpoints = endpoints
            self.name = name
            self.sipMediaApplicationId = sipMediaApplicationId
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

public struct CreateSipMediaApplicationOutput {
    /// The SIP media application details.
    public var sipMediaApplication: ChimeClientTypes.SipMediaApplication?

    public init(
        sipMediaApplication: ChimeClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

public struct CreateSipMediaApplicationCallInput {
    /// The phone number that a user calls from. This is a phone number in your Amazon Chime phone number inventory.
    /// This member is required.
    public var fromPhoneNumber: Swift.String?
    /// The SIP headers added to an outbound call leg.
    public var sipHeaders: [Swift.String: Swift.String]?
    /// The ID of the SIP media application.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The phone number that the service should call.
    /// This member is required.
    public var toPhoneNumber: Swift.String?

    public init(
        fromPhoneNumber: Swift.String? = nil,
        sipHeaders: [Swift.String: Swift.String]? = nil,
        sipMediaApplicationId: Swift.String? = nil,
        toPhoneNumber: Swift.String? = nil
    )
    {
        self.fromPhoneNumber = fromPhoneNumber
        self.sipHeaders = sipHeaders
        self.sipMediaApplicationId = sipMediaApplicationId
        self.toPhoneNumber = toPhoneNumber
    }
}

extension CreateSipMediaApplicationCallInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSipMediaApplicationCallInput(sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)), fromPhoneNumber: \"CONTENT_REDACTED\", sipHeaders: \"CONTENT_REDACTED\", toPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {
    /// A Call instance for a SIP media application.
    public struct SipMediaApplicationCall {
        /// The transaction ID of a call.
        public var transactionId: Swift.String?

        public init(
            transactionId: Swift.String? = nil
        )
        {
            self.transactionId = transactionId
        }
    }

}

public struct CreateSipMediaApplicationCallOutput {
    /// The actual call.
    public var sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall?

    public init(
        sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall? = nil
    )
    {
        self.sipMediaApplicationCall = sipMediaApplicationCall
    }
}

extension ChimeClientTypes {
    /// Target SIP media application and other details, such as priority and AWS Region, to be specified in the SIP rule. Only one SIP rule per AWS Region can be provided.
    public struct SipRuleTargetApplication {
        /// The AWS Region of the target application.
        public var awsRegion: Swift.String?
        /// Priority of the SIP media application in the target list.
        public var priority: Swift.Int?
        /// The SIP media application ID.
        public var sipMediaApplicationId: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sipMediaApplicationId: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.priority = priority
            self.sipMediaApplicationId = sipMediaApplicationId
        }
    }

}

extension ChimeClientTypes {

    public enum SipRuleTriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case requesturihostname
        case tophonenumber
        case sdkUnknown(Swift.String)

        public static var allCases: [SipRuleTriggerType] {
            return [
                .requesturihostname,
                .tophonenumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .requesturihostname: return "RequestUriHostname"
            case .tophonenumber: return "ToPhoneNumber"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSipRuleInput {
    /// Enables or disables a rule. You must disable rules before you can delete them.
    public var disabled: Swift.Bool?
    /// The name of the SIP rule.
    /// This member is required.
    public var name: Swift.String?
    /// List of SIP media applications with priority and AWS Region. Only one SIP application per AWS Region can be used.
    /// This member is required.
    public var targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?
    /// The type of trigger assigned to the SIP rule in TriggerValue, currently RequestUriHostname or ToPhoneNumber.
    /// This member is required.
    public var triggerType: ChimeClientTypes.SipRuleTriggerType?
    /// If TriggerType is RequestUriHostname, the value can be the outbound host name of an Amazon Chime Voice Connector. If TriggerType is ToPhoneNumber, the value can be a customer-owned phone number in the E164 format. The SipMediaApplication specified in the SipRule is triggered if the request URI in an incoming SIP request matches the RequestUriHostname, or if the To header in the incoming SIP request matches the ToPhoneNumber value.
    /// This member is required.
    public var triggerValue: Swift.String?

    public init(
        disabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        targetApplications: [ChimeClientTypes.SipRuleTargetApplication]? = nil,
        triggerType: ChimeClientTypes.SipRuleTriggerType? = nil,
        triggerValue: Swift.String? = nil
    )
    {
        self.disabled = disabled
        self.name = name
        self.targetApplications = targetApplications
        self.triggerType = triggerType
        self.triggerValue = triggerValue
    }
}

extension ChimeClientTypes {
    /// The SIP rule details, including name, triggers, and target applications. An AWS account can have multiple SIP rules.
    public struct SipRule {
        /// The time at which the SIP rule was created, in ISO 8601 format.
        public var createdTimestamp: Foundation.Date?
        /// Indicates whether the SIP rule is enabled or disabled. You must disable a rule before you can delete it.
        public var disabled: Swift.Bool?
        /// The name of the SIP rule.
        public var name: Swift.String?
        /// The SIP rule ID.
        public var sipRuleId: Swift.String?
        /// Target SIP media application and other details, such as priority and AWS Region, to be specified in the SIP rule. Only one SIP rule per AWS Region can be provided.
        public var targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?
        /// The type of trigger assigned to the SIP rule in TriggerValue, currently RequestUriHostname or ToPhoneNumber.
        public var triggerType: ChimeClientTypes.SipRuleTriggerType?
        /// If TriggerType is RequestUriHostname, then the value can be the outbound host name of the Amazon Chime Voice Connector. If TriggerType is ToPhoneNumber, then the value can be a customer-owned phone number in E164 format. SipRule is triggered when a SIP rule requests host name or ToPhoneNumber matches in the incoming SIP request.
        public var triggerValue: Swift.String?
        /// The time at which the SIP rule was last updated, in ISO 8601 format.
        public var updatedTimestamp: Foundation.Date?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            disabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            sipRuleId: Swift.String? = nil,
            targetApplications: [ChimeClientTypes.SipRuleTargetApplication]? = nil,
            triggerType: ChimeClientTypes.SipRuleTriggerType? = nil,
            triggerValue: Swift.String? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.disabled = disabled
            self.name = name
            self.sipRuleId = sipRuleId
            self.targetApplications = targetApplications
            self.triggerType = triggerType
            self.triggerValue = triggerValue
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

public struct CreateSipRuleOutput {
    /// Returns the SIP rule information, including the rule ID, triggers, and target applications.
    public var sipRule: ChimeClientTypes.SipRule?

    public init(
        sipRule: ChimeClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

public struct CreateUserInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user's email address.
    public var email: Swift.String?
    /// The user type.
    public var userType: ChimeClientTypes.UserType?
    /// The user name.
    public var username: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        email: Swift.String? = nil,
        userType: ChimeClientTypes.UserType? = nil,
        username: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.email = email
        self.userType = userType
        self.username = username
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(accountId: \(Swift.String(describing: accountId)), userType: \(Swift.String(describing: userType)), username: \(Swift.String(describing: username)), email: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {

    public enum InviteStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accepted
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [InviteStatus] {
            return [
                .accepted,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "Accepted"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum RegistrationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case registered
        case suspended
        case unregistered
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationStatus] {
            return [
                .registered,
                .suspended,
                .unregistered
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .registered: return "Registered"
            case .suspended: return "Suspended"
            case .unregistered: return "Unregistered"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The user on the Amazon Chime account.
    public struct User {
        /// The Amazon Chime account ID.
        public var accountId: Swift.String?
        /// The Alexa for Business metadata.
        public var alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata?
        /// The display name of the user.
        public var displayName: Swift.String?
        /// Date and time when the user is invited to the Amazon Chime account, in ISO 8601 format.
        public var invitedOn: Foundation.Date?
        /// The license type for the user.
        public var licenseType: ChimeClientTypes.License?
        /// The user's personal meeting PIN.
        public var personalPIN: Swift.String?
        /// The primary email address of the user.
        public var primaryEmail: Swift.String?
        /// The primary phone number associated with the user.
        public var primaryProvisionedNumber: Swift.String?
        /// Date and time when the user is registered, in ISO 8601 format.
        public var registeredOn: Foundation.Date?
        /// The user ID.
        /// This member is required.
        public var userId: Swift.String?
        /// The user invite status.
        public var userInvitationStatus: ChimeClientTypes.InviteStatus?
        /// The user registration status.
        public var userRegistrationStatus: ChimeClientTypes.RegistrationStatus?
        /// The user type.
        public var userType: ChimeClientTypes.UserType?

        public init(
            accountId: Swift.String? = nil,
            alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata? = nil,
            displayName: Swift.String? = nil,
            invitedOn: Foundation.Date? = nil,
            licenseType: ChimeClientTypes.License? = nil,
            personalPIN: Swift.String? = nil,
            primaryEmail: Swift.String? = nil,
            primaryProvisionedNumber: Swift.String? = nil,
            registeredOn: Foundation.Date? = nil,
            userId: Swift.String? = nil,
            userInvitationStatus: ChimeClientTypes.InviteStatus? = nil,
            userRegistrationStatus: ChimeClientTypes.RegistrationStatus? = nil,
            userType: ChimeClientTypes.UserType? = nil
        )
        {
            self.accountId = accountId
            self.alexaForBusinessMetadata = alexaForBusinessMetadata
            self.displayName = displayName
            self.invitedOn = invitedOn
            self.licenseType = licenseType
            self.personalPIN = personalPIN
            self.primaryEmail = primaryEmail
            self.primaryProvisionedNumber = primaryProvisionedNumber
            self.registeredOn = registeredOn
            self.userId = userId
            self.userInvitationStatus = userInvitationStatus
            self.userRegistrationStatus = userRegistrationStatus
            self.userType = userType
        }
    }

}

extension ChimeClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(accountId: \(Swift.String(describing: accountId)), alexaForBusinessMetadata: \(Swift.String(describing: alexaForBusinessMetadata)), invitedOn: \(Swift.String(describing: invitedOn)), licenseType: \(Swift.String(describing: licenseType)), personalPIN: \(Swift.String(describing: personalPIN)), registeredOn: \(Swift.String(describing: registeredOn)), userId: \(Swift.String(describing: userId)), userInvitationStatus: \(Swift.String(describing: userInvitationStatus)), userRegistrationStatus: \(Swift.String(describing: userRegistrationStatus)), userType: \(Swift.String(describing: userType)), displayName: \"CONTENT_REDACTED\", primaryEmail: \"CONTENT_REDACTED\", primaryProvisionedNumber: \"CONTENT_REDACTED\")"}
}

public struct CreateUserOutput {
    /// The user on the Amazon Chime account.
    public var user: ChimeClientTypes.User?

    public init(
        user: ChimeClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

extension ChimeClientTypes {

    public enum VoiceConnectorAwsRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case usEast1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceConnectorAwsRegion] {
            return [
                .usEast1,
                .usWest2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .usEast1: return "us-east-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateVoiceConnectorInput {
    /// The AWS Region in which the Amazon Chime Voice Connector is created. Default value: us-east-1 .
    public var awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion?
    /// The name of the Amazon Chime Voice Connector.
    /// This member is required.
    public var name: Swift.String?
    /// When enabled, requires encryption for the Amazon Chime Voice Connector.
    /// This member is required.
    public var requireEncryption: Swift.Bool?

    public init(
        awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion? = nil,
        name: Swift.String? = nil,
        requireEncryption: Swift.Bool? = nil
    )
    {
        self.awsRegion = awsRegion
        self.name = name
        self.requireEncryption = requireEncryption
    }
}

extension ChimeClientTypes {
    /// The Amazon Chime Voice Connector configuration, including outbound host name and encryption settings.
    public struct VoiceConnector {
        /// The AWS Region in which the Amazon Chime Voice Connector is created. Default: us-east-1.
        public var awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion?
        /// The Amazon Chime Voice Connector creation timestamp, in ISO 8601 format.
        public var createdTimestamp: Foundation.Date?
        /// The name of the Amazon Chime Voice Connector.
        public var name: Swift.String?
        /// The outbound host name for the Amazon Chime Voice Connector.
        public var outboundHostName: Swift.String?
        /// Designates whether encryption is required for the Amazon Chime Voice Connector.
        public var requireEncryption: Swift.Bool?
        /// The updated Amazon Chime Voice Connector timestamp, in ISO 8601 format.
        public var updatedTimestamp: Foundation.Date?
        /// The ARN of the specified Amazon Chime Voice Connector.
        public var voiceConnectorArn: Swift.String?
        /// The Amazon Chime Voice Connector ID.
        public var voiceConnectorId: Swift.String?

        public init(
            awsRegion: ChimeClientTypes.VoiceConnectorAwsRegion? = nil,
            createdTimestamp: Foundation.Date? = nil,
            name: Swift.String? = nil,
            outboundHostName: Swift.String? = nil,
            requireEncryption: Swift.Bool? = nil,
            updatedTimestamp: Foundation.Date? = nil,
            voiceConnectorArn: Swift.String? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.outboundHostName = outboundHostName
            self.requireEncryption = requireEncryption
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorArn = voiceConnectorArn
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

public struct CreateVoiceConnectorOutput {
    /// The Amazon Chime Voice Connector details.
    public var voiceConnector: ChimeClientTypes.VoiceConnector?

    public init(
        voiceConnector: ChimeClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

extension ChimeClientTypes {
    /// For Amazon Chime Voice Connector groups, the Amazon Chime Voice Connectors to which to route inbound calls. Includes priority configuration settings. Limit: 3 VoiceConnectorItems per Amazon Chime Voice Connector group.
    public struct VoiceConnectorItem {
        /// The priority associated with the Amazon Chime Voice Connector, with 1 being the highest priority. Higher priority Amazon Chime Voice Connectors are attempted first.
        /// This member is required.
        public var priority: Swift.Int?
        /// The Amazon Chime Voice Connector ID.
        /// This member is required.
        public var voiceConnectorId: Swift.String?

        public init(
            priority: Swift.Int? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.priority = priority
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

public struct CreateVoiceConnectorGroupInput {
    /// The name of the Amazon Chime Voice Connector group.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Chime Voice Connectors to route inbound calls to.
    public var voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?

    public init(
        name: Swift.String? = nil,
        voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]? = nil
    )
    {
        self.name = name
        self.voiceConnectorItems = voiceConnectorItems
    }
}

extension ChimeClientTypes {
    /// The Amazon Chime Voice Connector group configuration, including associated Amazon Chime Voice Connectors. You can include Amazon Chime Voice Connectors from different AWS Regions in your group. This creates a fault tolerant mechanism for fallback in case of availability events.
    public struct VoiceConnectorGroup {
        /// The Amazon Chime Voice Connector group creation time stamp, in ISO 8601 format.
        public var createdTimestamp: Foundation.Date?
        /// The name of the Amazon Chime Voice Connector group.
        public var name: Swift.String?
        /// The updated Amazon Chime Voice Connector group time stamp, in ISO 8601 format.
        public var updatedTimestamp: Foundation.Date?
        /// The ARN of the specified Amazon Chime Voice Connector group.
        public var voiceConnectorGroupArn: Swift.String?
        /// The Amazon Chime Voice Connector group ID.
        public var voiceConnectorGroupId: Swift.String?
        /// The Amazon Chime Voice Connectors to which to route inbound calls.
        public var voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            name: Swift.String? = nil,
            updatedTimestamp: Foundation.Date? = nil,
            voiceConnectorGroupArn: Swift.String? = nil,
            voiceConnectorGroupId: Swift.String? = nil,
            voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorGroupArn = voiceConnectorGroupArn
            self.voiceConnectorGroupId = voiceConnectorGroupId
            self.voiceConnectorItems = voiceConnectorItems
        }
    }

}

public struct CreateVoiceConnectorGroupOutput {
    /// The Amazon Chime Voice Connector group details.
    public var voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?

    public init(
        voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

extension ChimeClientTypes {
    /// The SIP credentials used to authenticate requests to your Amazon Chime Voice Connector.
    public struct Credential {
        /// The RFC2617 compliant password associated with the SIP credentials, in US-ASCII format.
        public var password: Swift.String?
        /// The RFC2617 compliant user name associated with the SIP credentials, in US-ASCII format.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension ChimeClientTypes.Credential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Credential(password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

/// The request was well-formed but was unable to be followed due to semantic errors.
public struct UnprocessableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnprocessableEntityException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct DeleteAccountInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

public struct DeleteAccountOutput {

    public init() { }
}

public struct DeleteAppInstanceInput {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

public struct DeleteAppInstanceAdminInput {
    /// The ARN of the AppInstance's administrator.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

public struct DeleteAppInstanceStreamingConfigurationsInput {
    /// The ARN of the streaming configurations being deleted.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

public struct DeleteAppInstanceUserInput {
    /// The ARN of the user request being deleted.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

public struct DeleteAttendeeInput {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

public struct DeleteChannelInput {
    /// The ARN of the channel being deleted.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

public struct DeleteChannelBanInput {
    /// The ARN of the channel from which the AppInstanceUser was banned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the AppInstanceUser that you want to reinstate.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

public struct DeleteChannelMembershipInput {
    /// The ARN of the channel from which you want to remove the user.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member that you're removing from the channel.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

public struct DeleteChannelMessageInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ID of the message being deleted.
    /// This member is required.
    public var messageId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

public struct DeleteChannelModeratorInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the moderator being deleted.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

public struct DeleteEventsConfigurationInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
    }
}

public struct DeleteMediaCapturePipelineInput {
    /// The ID of the media capture pipeline being deleted.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init(
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

public struct DeleteMeetingInput {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

public struct DeletePhoneNumberInput {
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

public struct DeleteProxySessionInput {
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct DeleteRoomInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The chat room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.roomId = roomId
    }
}

public struct DeleteRoomMembershipInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The member ID (user ID or bot ID).
    /// This member is required.
    public var memberId: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.memberId = memberId
        self.roomId = roomId
    }
}

public struct DeleteSipMediaApplicationInput {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

public struct DeleteSipRuleInput {
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?

    public init(
        sipRuleId: Swift.String? = nil
    )
    {
        self.sipRuleId = sipRuleId
    }
}

public struct DeleteVoiceConnectorInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct DeleteVoiceConnectorGroupInput {
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

public struct DeleteVoiceConnectorOriginationInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct DeleteVoiceConnectorProxyInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct DeleteVoiceConnectorStreamingConfigurationInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct DeleteVoiceConnectorTerminationInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct DeleteVoiceConnectorTerminationCredentialsInput {
    /// The RFC2617 compliant username associated with the SIP credentials, in US-ASCII format.
    /// This member is required.
    public var usernames: [Swift.String]?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        usernames: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.usernames = usernames
        self.voiceConnectorId = voiceConnectorId
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteVoiceConnectorTerminationCredentialsInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), usernames: \"CONTENT_REDACTED\")"}
}

public struct DescribeAppInstanceInput {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

public struct DescribeAppInstanceOutput {
    /// The ARN, metadata, created and last-updated timestamps, and the name of the AppInstance. All timestamps use epoch milliseconds.
    public var appInstance: ChimeClientTypes.AppInstance?

    public init(
        appInstance: ChimeClientTypes.AppInstance? = nil
    )
    {
        self.appInstance = appInstance
    }
}

public struct DescribeAppInstanceAdminInput {
    /// The ARN of the AppInstanceAdmin.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

public struct DescribeAppInstanceAdminOutput {
    /// The ARN and name of the AppInstanceUser, the ARN of the AppInstance, and the created and last-updated timestamps. All timestamps use epoch milliseconds.
    public var appInstanceAdmin: ChimeClientTypes.AppInstanceAdmin?

    public init(
        appInstanceAdmin: ChimeClientTypes.AppInstanceAdmin? = nil
    )
    {
        self.appInstanceAdmin = appInstanceAdmin
    }
}

public struct DescribeAppInstanceUserInput {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

public struct DescribeAppInstanceUserOutput {
    /// The name of the AppInstanceUser.
    public var appInstanceUser: ChimeClientTypes.AppInstanceUser?

    public init(
        appInstanceUser: ChimeClientTypes.AppInstanceUser? = nil
    )
    {
        self.appInstanceUser = appInstanceUser
    }
}

public struct DescribeChannelInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

public struct DescribeChannelOutput {
    /// The channel details.
    public var channel: ChimeClientTypes.Channel?

    public init(
        channel: ChimeClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

public struct DescribeChannelBanInput {
    /// The ARN of the channel from which the user is banned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member being banned.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

public struct DescribeChannelBanOutput {
    /// The details of the ban.
    public var channelBan: ChimeClientTypes.ChannelBan?

    public init(
        channelBan: ChimeClientTypes.ChannelBan? = nil
    )
    {
        self.channelBan = channelBan
    }
}

public struct DescribeChannelMembershipInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ARN of the member.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

public struct DescribeChannelMembershipOutput {
    /// The details of the membership.
    public var channelMembership: ChimeClientTypes.ChannelMembership?

    public init(
        channelMembership: ChimeClientTypes.ChannelMembership? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

public struct DescribeChannelMembershipForAppInstanceUserInput {
    /// The ARN of the user in a channel.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the channel to which the user belongs.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

public struct DescribeChannelMembershipForAppInstanceUserOutput {
    /// The channel to which a user belongs.
    public var channelMembership: ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary?

    public init(
        channelMembership: ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

public struct DescribeChannelModeratedByAppInstanceUserInput {
    /// The ARN of the AppInstanceUser in the moderated channel.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the moderated channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

public struct DescribeChannelModeratedByAppInstanceUserOutput {
    /// The moderated channel.
    public var channel: ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary?

    public init(
        channel: ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary? = nil
    )
    {
        self.channel = channel
    }
}

public struct DescribeChannelModeratorInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the channel moderator.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

public struct DescribeChannelModeratorOutput {
    /// The details of the channel moderator.
    public var channelModerator: ChimeClientTypes.ChannelModerator?

    public init(
        channelModerator: ChimeClientTypes.ChannelModerator? = nil
    )
    {
        self.channelModerator = channelModerator
    }
}

public struct DisassociatePhoneNumberFromUserInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

public struct DisassociatePhoneNumberFromUserOutput {

    public init() { }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorInput {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.voiceConnectorId = voiceConnectorId
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociatePhoneNumbersFromVoiceConnectorInput(voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), e164PhoneNumbers: \"CONTENT_REDACTED\")"}
}

public struct DisassociatePhoneNumbersFromVoiceConnectorOutput {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupInput {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociatePhoneNumbersFromVoiceConnectorGroupInput(voiceConnectorGroupId: \(Swift.String(describing: voiceConnectorGroupId)), e164PhoneNumbers: \"CONTENT_REDACTED\")"}
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupOutput {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

public struct DisassociateSigninDelegateGroupsFromAccountInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The sign-in delegate group names.
    /// This member is required.
    public var groupNames: [Swift.String]?

    public init(
        accountId: Swift.String? = nil,
        groupNames: [Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.groupNames = groupNames
    }
}

public struct DisassociateSigninDelegateGroupsFromAccountOutput {

    public init() { }
}

extension ChimeClientTypes {
    /// The Dialed Number Identification Service (DNIS) emergency calling configuration details associated with an Amazon Chime Voice Connector's emergency calling configuration.
    public struct DNISEmergencyCallingConfiguration {
        /// The country from which emergency calls are allowed, in ISO 3166-1 alpha-2 format.
        /// This member is required.
        public var callingCountry: Swift.String?
        /// The DNIS phone number to route emergency calls to, in E.164 format.
        /// This member is required.
        public var emergencyPhoneNumber: Swift.String?
        /// The DNIS phone number to route test emergency calls to, in E.164 format.
        public var testPhoneNumber: Swift.String?

        public init(
            callingCountry: Swift.String? = nil,
            emergencyPhoneNumber: Swift.String? = nil,
            testPhoneNumber: Swift.String? = nil
        )
        {
            self.callingCountry = callingCountry
            self.emergencyPhoneNumber = emergencyPhoneNumber
            self.testPhoneNumber = testPhoneNumber
        }
    }

}

extension ChimeClientTypes.DNISEmergencyCallingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DNISEmergencyCallingConfiguration(callingCountry: \(Swift.String(describing: callingCountry)), emergencyPhoneNumber: \"CONTENT_REDACTED\", testPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {

    public enum EmailStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case notsent
        case sent
        case sdkUnknown(Swift.String)

        public static var allCases: [EmailStatus] {
            return [
                .failed,
                .notsent,
                .sent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .notsent: return "NotSent"
            case .sent: return "Sent"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The emergency calling configuration details associated with an Amazon Chime Voice Connector.
    public struct EmergencyCallingConfiguration {
        /// The Dialed Number Identification Service (DNIS) emergency calling configuration details.
        public var dnis: [ChimeClientTypes.DNISEmergencyCallingConfiguration]?

        public init(
            dnis: [ChimeClientTypes.DNISEmergencyCallingConfiguration]? = nil
        )
        {
            self.dnis = dnis
        }
    }

}

extension ChimeClientTypes {

    public enum TranscribeMedicalContentIdentificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case phi
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalContentIdentificationType] {
            return [
                .phi
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .phi: return "PHI"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum TranscribeMedicalLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalLanguageCode] {
            return [
                .enUs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum TranscribeMedicalRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apSoutheast2
        case auto
        case caCentral1
        case euWest1
        case usEast1
        case usEast2
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalRegion] {
            return [
                .apSoutheast2,
                .auto,
                .caCentral1,
                .euWest1,
                .usEast1,
                .usEast2,
                .usWest2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apSoutheast2: return "ap-southeast-2"
            case .auto: return "auto"
            case .caCentral1: return "ca-central-1"
            case .euWest1: return "eu-west-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum TranscribeMedicalSpecialty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cardiology
        case neurology
        case oncology
        case primarycare
        case radiology
        case urology
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalSpecialty] {
            return [
                .cardiology,
                .neurology,
                .oncology,
                .primarycare,
                .radiology,
                .urology
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cardiology: return "CARDIOLOGY"
            case .neurology: return "NEUROLOGY"
            case .oncology: return "ONCOLOGY"
            case .primarycare: return "PRIMARYCARE"
            case .radiology: return "RADIOLOGY"
            case .urology: return "UROLOGY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum TranscribeMedicalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case conversation
        case dictation
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalType] {
            return [
                .conversation,
                .dictation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .conversation: return "CONVERSATION"
            case .dictation: return "DICTATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// Settings specific to the Amazon Transcribe Medical engine.
    public struct EngineTranscribeMedicalSettings {
        /// Labels all personally identifiable information (PII) identified in your transcript. If you don't include PiiEntityTypes, all PII is identified. You can’t set ContentIdentificationType and ContentRedactionType.
        public var contentIdentificationType: ChimeClientTypes.TranscribeMedicalContentIdentificationType?
        /// The language code specified for the Amazon Transcribe Medical engine.
        /// This member is required.
        public var languageCode: ChimeClientTypes.TranscribeMedicalLanguageCode?
        /// The AWS Region passed to Amazon Transcribe Medical. If you don't specify a Region, Amazon Chime uses the meeting's Region.
        public var region: ChimeClientTypes.TranscribeMedicalRegion?
        /// The specialty specified for the Amazon Transcribe Medical engine.
        /// This member is required.
        public var specialty: ChimeClientTypes.TranscribeMedicalSpecialty?
        /// The type of transcription.
        /// This member is required.
        public var type: ChimeClientTypes.TranscribeMedicalType?
        /// The name of the vocabulary passed to Amazon Transcribe Medical.
        public var vocabularyName: Swift.String?

        public init(
            contentIdentificationType: ChimeClientTypes.TranscribeMedicalContentIdentificationType? = nil,
            languageCode: ChimeClientTypes.TranscribeMedicalLanguageCode? = nil,
            region: ChimeClientTypes.TranscribeMedicalRegion? = nil,
            specialty: ChimeClientTypes.TranscribeMedicalSpecialty? = nil,
            type: ChimeClientTypes.TranscribeMedicalType? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.contentIdentificationType = contentIdentificationType
            self.languageCode = languageCode
            self.region = region
            self.specialty = specialty
            self.type = type
            self.vocabularyName = vocabularyName
        }
    }

}

extension ChimeClientTypes {

    public enum TranscribeContentIdentificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeContentIdentificationType] {
            return [
                .pii
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum TranscribeContentRedactionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeContentRedactionType] {
            return [
                .pii
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum TranscribeLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deDe
        case enAu
        case enGb
        case enUs
        case esUs
        case frCa
        case frFr
        case hiIn
        case itIt
        case jaJp
        case koKr
        case ptBr
        case thTh
        case zhCn
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeLanguageCode] {
            return [
                .deDe,
                .enAu,
                .enGb,
                .enUs,
                .esUs,
                .frCa,
                .frFr,
                .hiIn,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .thTh,
                .zhCn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .esUs: return "es-US"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .hiIn: return "hi-IN"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .ptBr: return "pt-BR"
            case .thTh: return "th-TH"
            case .zhCn: return "zh-CN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum TranscribePartialResultsStability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribePartialResultsStability] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .medium: return "medium"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum TranscribeRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apNortheast1
        case apNortheast2
        case apSoutheast2
        case auto
        case caCentral1
        case euCentral1
        case euWest1
        case euWest2
        case saEast1
        case usEast1
        case usEast2
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeRegion] {
            return [
                .apNortheast1,
                .apNortheast2,
                .apSoutheast2,
                .auto,
                .caCentral1,
                .euCentral1,
                .euWest1,
                .euWest2,
                .saEast1,
                .usEast1,
                .usEast2,
                .usWest2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apSoutheast2: return "ap-southeast-2"
            case .auto: return "auto"
            case .caCentral1: return "ca-central-1"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .saEast1: return "sa-east-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum TranscribeVocabularyFilterMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mask
        case remove
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeVocabularyFilterMethod] {
            return [
                .mask,
                .remove,
                .tag
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mask: return "mask"
            case .remove: return "remove"
            case .tag: return "tag"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// Settings specific for Amazon Transcribe as the live transcription engine. If you specify an invalid combination of parameters, a TranscriptFailed event will be sent with the contents of the BadRequestException generated by Amazon Transcribe. For more information on each parameter and which combinations are valid, refer to the [StartStreamTranscription](https://docs.aws.amazon.com/transcribe/latest/APIReference/API_streaming_StartStreamTranscription.html) API in the Amazon Transcribe Developer Guide.
    public struct EngineTranscribeSettings {
        /// Labels all personally identifiable information (PII) identified in your transcript. If you don't include PiiEntityTypes, all PII is identified. You can’t set ContentIdentificationType and ContentRedactionType.
        public var contentIdentificationType: ChimeClientTypes.TranscribeContentIdentificationType?
        /// Content redaction is performed at the segment level. If you don't include PiiEntityTypes, all PII is redacted. You can’t set ContentIdentificationType and ContentRedactionType.
        public var contentRedactionType: ChimeClientTypes.TranscribeContentRedactionType?
        /// Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy.
        public var enablePartialResultsStabilization: Swift.Bool?
        /// Enables automatic language identification for your transcription. If you include IdentifyLanguage, you can optionally use LanguageOptions to include a list of language codes that you think may be present in your audio stream. Including language options can improve transcription accuracy. You can also use PreferredLanguage to include a preferred language. Doing so can help Amazon Transcribe identify the language faster. You must include either LanguageCode or IdentifyLanguage. Language identification can't be combined with custom language models or redaction.
        public var identifyLanguage: Swift.Bool?
        /// Specify the language code that represents the language spoken. If you're unsure of the language spoken in your audio, consider using IdentifyLanguage to enable automatic language identification.
        public var languageCode: ChimeClientTypes.TranscribeLanguageCode?
        /// Specify the name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive. The language of the specified language model must match the language code. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch. If you use Amazon Transcribe in multiple Regions, the custom language model must be available in Amazon Transcribe in each Region.
        public var languageModelName: Swift.String?
        /// Specify two or more language codes that represent the languages you think may be present in your media; including more than five is not recommended. If you're unsure what languages are present, do not include this parameter. Including language options can improve the accuracy of language identification. If you include LanguageOptions, you must also include IdentifyLanguage. You can only include one language dialect per language. For example, you cannot include en-US and en-AU.
        public var languageOptions: Swift.String?
        /// Specify the level of stability to use when you enable partial results stabilization (EnablePartialResultsStabilization). Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy.
        public var partialResultsStability: ChimeClientTypes.TranscribePartialResultsStability?
        /// Specify which types of personally identifiable information (PII) you want to redact in your transcript. You can include as many types as you'd like, or you can select ALL. Values must be comma-separated and can include: ADDRESS, BANK_ACCOUNT_NUMBER, BANK_ROUTING, CREDIT_DEBIT_CVV, CREDIT_DEBIT_EXPIRYCREDIT_DEBIT_NUMBER, EMAIL,NAME, PHONE, PIN, SSN, or ALL. Note that if you include PiiEntityTypes, you must also include ContentIdentificationType or ContentRedactionType. If you include ContentRedactionType or ContentIdentificationType, but do not include PiiEntityTypes, all PII is redacted or identified.
        public var piiEntityTypes: Swift.String?
        /// Specify a preferred language from the subset of languages codes you specified in LanguageOptions. You can only use this parameter if you include IdentifyLanguage and LanguageOptions.
        public var preferredLanguage: ChimeClientTypes.TranscribeLanguageCode?
        /// The AWS Region in which to use Amazon Transcribe. If you don't specify a Region, then the MediaRegion parameter of the [CreateMeeting.html](https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_meeting-chime_CreateMeeting.html) API will be used. However, if Amazon Transcribe is not available in the MediaRegion, then a TranscriptFailed event is sent. Use auto to use Amazon Transcribe in a Region near the meeting’s MediaRegion. For more information, refer to [Choosing a transcription Region](https://docs.aws.amazon.com/chime-sdk/latest/dg/transcription-options.html#choose-region) in the Amazon Chime SDK Developer Guide.
        public var region: ChimeClientTypes.TranscribeRegion?
        /// Specify how you want your vocabulary filter applied to your transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public var vocabularyFilterMethod: ChimeClientTypes.TranscribeVocabularyFilterMethod?
        /// Specify the name of the custom vocabulary filter that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region. If you include IdentifyLanguage and want to use one or more vocabulary filters with your transcription, use the VocabularyFilterNames parameter instead.
        public var vocabularyFilterName: Swift.String?
        /// Specify the names of the custom vocabulary filters that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region. If you're not including IdentifyLanguage and want to use a custom vocabulary filter with your transcription, use the VocabularyFilterName parameter instead.
        public var vocabularyFilterNames: Swift.String?
        /// Specify the name of the custom vocabulary that you want to use when processing your transcription. Note that vocabulary names are case sensitive. If you use Amazon Transcribe multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region. If you include IdentifyLanguage and want to use one or more custom vocabularies with your transcription, use the VocabularyNames parameter instead.
        public var vocabularyName: Swift.String?
        /// Specify the names of the custom vocabularies that you want to use when processing your transcription. Note that vocabulary names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region. If you don't include IdentifyLanguage and want to use a custom vocabulary with your transcription, use the VocabularyName parameter instead.
        public var vocabularyNames: Swift.String?

        public init(
            contentIdentificationType: ChimeClientTypes.TranscribeContentIdentificationType? = nil,
            contentRedactionType: ChimeClientTypes.TranscribeContentRedactionType? = nil,
            enablePartialResultsStabilization: Swift.Bool? = nil,
            identifyLanguage: Swift.Bool? = nil,
            languageCode: ChimeClientTypes.TranscribeLanguageCode? = nil,
            languageModelName: Swift.String? = nil,
            languageOptions: Swift.String? = nil,
            partialResultsStability: ChimeClientTypes.TranscribePartialResultsStability? = nil,
            piiEntityTypes: Swift.String? = nil,
            preferredLanguage: ChimeClientTypes.TranscribeLanguageCode? = nil,
            region: ChimeClientTypes.TranscribeRegion? = nil,
            vocabularyFilterMethod: ChimeClientTypes.TranscribeVocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyFilterNames: Swift.String? = nil,
            vocabularyName: Swift.String? = nil,
            vocabularyNames: Swift.String? = nil
        )
        {
            self.contentIdentificationType = contentIdentificationType
            self.contentRedactionType = contentRedactionType
            self.enablePartialResultsStabilization = enablePartialResultsStabilization
            self.identifyLanguage = identifyLanguage
            self.languageCode = languageCode
            self.languageModelName = languageModelName
            self.languageOptions = languageOptions
            self.partialResultsStability = partialResultsStability
            self.piiEntityTypes = piiEntityTypes
            self.preferredLanguage = preferredLanguage
            self.region = region
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyFilterNames = vocabularyFilterNames
            self.vocabularyName = vocabularyName
            self.vocabularyNames = vocabularyNames
        }
    }

}

extension ChimeClientTypes {
    /// The configuration that allows a bot to receive outgoing events. Can be either an HTTPS endpoint or a Lambda function ARN.
    public struct EventsConfiguration {
        /// The bot ID.
        public var botId: Swift.String?
        /// Lambda function ARN that allows a bot to receive outgoing events.
        public var lambdaFunctionArn: Swift.String?
        /// HTTPS endpoint that allows a bot to receive outgoing events.
        public var outboundEventsHTTPSEndpoint: Swift.String?

        public init(
            botId: Swift.String? = nil,
            lambdaFunctionArn: Swift.String? = nil,
            outboundEventsHTTPSEndpoint: Swift.String? = nil
        )
        {
            self.botId = botId
            self.lambdaFunctionArn = lambdaFunctionArn
            self.outboundEventsHTTPSEndpoint = outboundEventsHTTPSEndpoint
        }
    }

}

extension ChimeClientTypes.EventsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventsConfiguration(botId: \(Swift.String(describing: botId)), lambdaFunctionArn: \"CONTENT_REDACTED\", outboundEventsHTTPSEndpoint: \"CONTENT_REDACTED\")"}
}

public struct GetAccountInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

public struct GetAccountOutput {
    /// The Amazon Chime account details.
    public var account: ChimeClientTypes.Account?

    public init(
        account: ChimeClientTypes.Account? = nil
    )
    {
        self.account = account
    }
}

public struct GetAccountSettingsInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

public struct GetAccountSettingsOutput {
    /// The Amazon Chime account settings.
    public var accountSettings: ChimeClientTypes.AccountSettings?

    public init(
        accountSettings: ChimeClientTypes.AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

public struct GetAppInstanceRetentionSettingsInput {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

public struct GetAppInstanceRetentionSettingsOutput {
    /// The retention settings for the AppInstance.
    public var appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?
    /// The timestamp representing the time at which the specified items are retained, in Epoch Seconds.
    public var initiateDeletionTimestamp: Foundation.Date?

    public init(
        appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings? = nil,
        initiateDeletionTimestamp: Foundation.Date? = nil
    )
    {
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
    }
}

public struct GetAppInstanceStreamingConfigurationsInput {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

public struct GetAppInstanceStreamingConfigurationsOutput {
    /// The streaming settings.
    public var appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?

    public init(
        appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
    )
    {
        self.appInstanceStreamingConfigurations = appInstanceStreamingConfigurations
    }
}

public struct GetAttendeeInput {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

public struct GetAttendeeOutput {
    /// The Amazon Chime SDK attendee information.
    public var attendee: ChimeClientTypes.Attendee?

    public init(
        attendee: ChimeClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

public struct GetBotInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
    }
}

public struct GetBotOutput {
    /// The chat bot details.
    public var bot: ChimeClientTypes.Bot?

    public init(
        bot: ChimeClientTypes.Bot? = nil
    )
    {
        self.bot = bot
    }
}

public struct GetChannelMessageInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ID of the message.
    /// This member is required.
    public var messageId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

public struct GetChannelMessageOutput {
    /// The details of and content in the message.
    public var channelMessage: ChimeClientTypes.ChannelMessage?

    public init(
        channelMessage: ChimeClientTypes.ChannelMessage? = nil
    )
    {
        self.channelMessage = channelMessage
    }
}

public struct GetEventsConfigurationInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
    }
}

public struct GetEventsConfigurationOutput {
    /// The events configuration details.
    public var eventsConfiguration: ChimeClientTypes.EventsConfiguration?

    public init(
        eventsConfiguration: ChimeClientTypes.EventsConfiguration? = nil
    )
    {
        self.eventsConfiguration = eventsConfiguration
    }
}

extension ChimeClientTypes {
    /// The Amazon Chime Voice Connector settings. Includes any Amazon S3 buckets designated for storing call detail records.
    public struct VoiceConnectorSettings {
        /// The Amazon S3 bucket designated for call detail record storage.
        public var cdrBucket: Swift.String?

        public init(
            cdrBucket: Swift.String? = nil
        )
        {
            self.cdrBucket = cdrBucket
        }
    }

}

public struct GetGlobalSettingsOutput {
    /// The Amazon Chime Business Calling settings.
    public var businessCalling: ChimeClientTypes.BusinessCallingSettings?
    /// The Amazon Chime Voice Connector settings.
    public var voiceConnector: ChimeClientTypes.VoiceConnectorSettings?

    public init(
        businessCalling: ChimeClientTypes.BusinessCallingSettings? = nil,
        voiceConnector: ChimeClientTypes.VoiceConnectorSettings? = nil
    )
    {
        self.businessCalling = businessCalling
        self.voiceConnector = voiceConnector
    }
}

public struct GetMediaCapturePipelineInput {
    /// The ID of the pipeline that you want to get.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init(
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

public struct GetMediaCapturePipelineOutput {
    /// The media capture pipeline object.
    public var mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline?

    public init(
        mediaCapturePipeline: ChimeClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

public struct GetMeetingInput {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

public struct GetMeetingOutput {
    /// The Amazon Chime SDK meeting information.
    public var meeting: ChimeClientTypes.Meeting?

    public init(
        meeting: ChimeClientTypes.Meeting? = nil
    )
    {
        self.meeting = meeting
    }
}

public struct GetMessagingSessionEndpointInput {

    public init() { }
}

extension ChimeClientTypes {
    /// The websocket endpoint used to connect to Amazon Chime SDK messaging.
    public struct MessagingSessionEndpoint {
        /// The endpoint to which you establish a websocket connection.
        public var url: Swift.String?

        public init(
            url: Swift.String? = nil
        )
        {
            self.url = url
        }
    }

}

public struct GetMessagingSessionEndpointOutput {
    /// The endpoint returned in the response.
    public var endpoint: ChimeClientTypes.MessagingSessionEndpoint?

    public init(
        endpoint: ChimeClientTypes.MessagingSessionEndpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

public struct GetPhoneNumberInput {
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

extension ChimeClientTypes {

    public enum PhoneNumberAssociationName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountid
        case sipruleid
        case userid
        case voiceconnectorgroupid
        case voiceconnectorid
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberAssociationName] {
            return [
                .accountid,
                .sipruleid,
                .userid,
                .voiceconnectorgroupid,
                .voiceconnectorid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountid: return "AccountId"
            case .sipruleid: return "SipRuleId"
            case .userid: return "UserId"
            case .voiceconnectorgroupid: return "VoiceConnectorGroupId"
            case .voiceconnectorid: return "VoiceConnectorId"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The phone number associations, such as Amazon Chime account ID, Amazon Chime user ID, Amazon Chime Voice Connector ID, or Amazon Chime Voice Connector group ID.
    public struct PhoneNumberAssociation {
        /// The timestamp of the phone number association, in ISO 8601 format.
        public var associatedTimestamp: Foundation.Date?
        /// Defines the association with an Amazon Chime account ID, user ID, Amazon Chime Voice Connector ID, or Amazon Chime Voice Connector group ID.
        public var name: ChimeClientTypes.PhoneNumberAssociationName?
        /// Contains the ID for the entity specified in Name.
        public var value: Swift.String?

        public init(
            associatedTimestamp: Foundation.Date? = nil,
            name: ChimeClientTypes.PhoneNumberAssociationName? = nil,
            value: Swift.String? = nil
        )
        {
            self.associatedTimestamp = associatedTimestamp
            self.name = name
            self.value = value
        }
    }

}

extension ChimeClientTypes {
    /// The phone number capabilities for Amazon Chime Business Calling phone numbers, such as enabled inbound and outbound calling and text messaging.
    public struct PhoneNumberCapabilities {
        /// Allows or denies inbound calling for the specified phone number.
        public var inboundCall: Swift.Bool?
        /// Allows or denies inbound MMS messaging for the specified phone number.
        public var inboundMMS: Swift.Bool?
        /// Allows or denies inbound SMS messaging for the specified phone number.
        public var inboundSMS: Swift.Bool?
        /// Allows or denies outbound calling for the specified phone number.
        public var outboundCall: Swift.Bool?
        /// Allows or denies outbound MMS messaging for the specified phone number.
        public var outboundMMS: Swift.Bool?
        /// Allows or denies outbound SMS messaging for the specified phone number.
        public var outboundSMS: Swift.Bool?

        public init(
            inboundCall: Swift.Bool? = nil,
            inboundMMS: Swift.Bool? = nil,
            inboundSMS: Swift.Bool? = nil,
            outboundCall: Swift.Bool? = nil,
            outboundMMS: Swift.Bool? = nil,
            outboundSMS: Swift.Bool? = nil
        )
        {
            self.inboundCall = inboundCall
            self.inboundMMS = inboundMMS
            self.inboundSMS = inboundSMS
            self.outboundCall = outboundCall
            self.outboundMMS = outboundMMS
            self.outboundSMS = outboundSMS
        }
    }

}

extension ChimeClientTypes {

    public enum PhoneNumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acquirefailed
        case acquireinprogress
        case assigned
        case deletefailed
        case deleteinprogress
        case releasefailed
        case releaseinprogress
        case unassigned
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberStatus] {
            return [
                .acquirefailed,
                .acquireinprogress,
                .assigned,
                .deletefailed,
                .deleteinprogress,
                .releasefailed,
                .releaseinprogress,
                .unassigned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acquirefailed: return "AcquireFailed"
            case .acquireinprogress: return "AcquireInProgress"
            case .assigned: return "Assigned"
            case .deletefailed: return "DeleteFailed"
            case .deleteinprogress: return "DeleteInProgress"
            case .releasefailed: return "ReleaseFailed"
            case .releaseinprogress: return "ReleaseInProgress"
            case .unassigned: return "Unassigned"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {

    public enum PhoneNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case local
        case tollfree
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberType] {
            return [
                .local,
                .tollfree
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .local: return "Local"
            case .tollfree: return "TollFree"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// A phone number used for Amazon Chime Business Calling or an Amazon Chime Voice Connector.
    public struct PhoneNumber {
        /// The phone number associations.
        public var associations: [ChimeClientTypes.PhoneNumberAssociation]?
        /// The outbound calling name associated with the phone number.
        public var callingName: Swift.String?
        /// The outbound calling name status.
        public var callingNameStatus: ChimeClientTypes.CallingNameStatus?
        /// The phone number capabilities.
        public var capabilities: ChimeClientTypes.PhoneNumberCapabilities?
        /// The phone number country. Format: ISO 3166-1 alpha-2.
        public var country: Swift.String?
        /// The phone number creation timestamp, in ISO 8601 format.
        public var createdTimestamp: Foundation.Date?
        /// The deleted phone number timestamp, in ISO 8601 format.
        public var deletionTimestamp: Foundation.Date?
        /// The phone number, in E.164 format.
        public var e164PhoneNumber: Swift.String?
        /// The phone number ID.
        public var phoneNumberId: Swift.String?
        /// The phone number product type.
        public var productType: ChimeClientTypes.PhoneNumberProductType?
        /// The phone number status.
        public var status: ChimeClientTypes.PhoneNumberStatus?
        /// The phone number type.
        public var type: ChimeClientTypes.PhoneNumberType?
        /// The updated phone number timestamp, in ISO 8601 format.
        public var updatedTimestamp: Foundation.Date?

        public init(
            associations: [ChimeClientTypes.PhoneNumberAssociation]? = nil,
            callingName: Swift.String? = nil,
            callingNameStatus: ChimeClientTypes.CallingNameStatus? = nil,
            capabilities: ChimeClientTypes.PhoneNumberCapabilities? = nil,
            country: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            deletionTimestamp: Foundation.Date? = nil,
            e164PhoneNumber: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            productType: ChimeClientTypes.PhoneNumberProductType? = nil,
            status: ChimeClientTypes.PhoneNumberStatus? = nil,
            type: ChimeClientTypes.PhoneNumberType? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.associations = associations
            self.callingName = callingName
            self.callingNameStatus = callingNameStatus
            self.capabilities = capabilities
            self.country = country
            self.createdTimestamp = createdTimestamp
            self.deletionTimestamp = deletionTimestamp
            self.e164PhoneNumber = e164PhoneNumber
            self.phoneNumberId = phoneNumberId
            self.productType = productType
            self.status = status
            self.type = type
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeClientTypes.PhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumber(associations: \(Swift.String(describing: associations)), callingNameStatus: \(Swift.String(describing: callingNameStatus)), capabilities: \(Swift.String(describing: capabilities)), country: \(Swift.String(describing: country)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), deletionTimestamp: \(Swift.String(describing: deletionTimestamp)), phoneNumberId: \(Swift.String(describing: phoneNumberId)), productType: \(Swift.String(describing: productType)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), callingName: \"CONTENT_REDACTED\", e164PhoneNumber: \"CONTENT_REDACTED\")"}
}

public struct GetPhoneNumberOutput {
    /// The phone number details.
    public var phoneNumber: ChimeClientTypes.PhoneNumber?

    public init(
        phoneNumber: ChimeClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

public struct GetPhoneNumberOrderInput {
    /// The ID for the phone number order.
    /// This member is required.
    public var phoneNumberOrderId: Swift.String?

    public init(
        phoneNumberOrderId: Swift.String? = nil
    )
    {
        self.phoneNumberOrderId = phoneNumberOrderId
    }
}

public struct GetPhoneNumberOrderOutput {
    /// The phone number order details.
    public var phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder?

    public init(
        phoneNumberOrder: ChimeClientTypes.PhoneNumberOrder? = nil
    )
    {
        self.phoneNumberOrder = phoneNumberOrder
    }
}

public struct GetPhoneNumberSettingsOutput {
    /// The default outbound calling name for the account.
    public var callingName: Swift.String?
    /// The updated outbound calling name timestamp, in ISO 8601 format.
    public var callingNameUpdatedTimestamp: Foundation.Date?

    public init(
        callingName: Swift.String? = nil,
        callingNameUpdatedTimestamp: Foundation.Date? = nil
    )
    {
        self.callingName = callingName
        self.callingNameUpdatedTimestamp = callingNameUpdatedTimestamp
    }
}

extension GetPhoneNumberSettingsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberSettingsOutput(callingNameUpdatedTimestamp: \(Swift.String(describing: callingNameUpdatedTimestamp)), callingName: \"CONTENT_REDACTED\")"}
}

public struct GetProxySessionInput {
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct GetProxySessionOutput {
    /// The proxy session details.
    public var proxySession: ChimeClientTypes.ProxySession?

    public init(
        proxySession: ChimeClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

public struct GetRetentionSettingsInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

extension ChimeClientTypes {
    /// The retention settings that determine how long to retain chat-room messages for an Amazon Chime Enterprise account.
    public struct RoomRetentionSettings {
        /// The number of days for which to retain chat-room messages.
        public var retentionDays: Swift.Int?

        public init(
            retentionDays: Swift.Int? = nil
        )
        {
            self.retentionDays = retentionDays
        }
    }

}

extension ChimeClientTypes {
    /// The retention settings for an Amazon Chime Enterprise account that determine how long to retain items such as chat-room messages and chat-conversation messages.
    public struct RetentionSettings {
        /// The chat conversation retention settings.
        public var conversationRetentionSettings: ChimeClientTypes.ConversationRetentionSettings?
        /// The chat room retention settings.
        public var roomRetentionSettings: ChimeClientTypes.RoomRetentionSettings?

        public init(
            conversationRetentionSettings: ChimeClientTypes.ConversationRetentionSettings? = nil,
            roomRetentionSettings: ChimeClientTypes.RoomRetentionSettings? = nil
        )
        {
            self.conversationRetentionSettings = conversationRetentionSettings
            self.roomRetentionSettings = roomRetentionSettings
        }
    }

}

public struct GetRetentionSettingsOutput {
    /// The timestamp representing the time at which the specified items are permanently deleted, in ISO 8601 format.
    public var initiateDeletionTimestamp: Foundation.Date?
    /// The retention settings.
    public var retentionSettings: ChimeClientTypes.RetentionSettings?

    public init(
        initiateDeletionTimestamp: Foundation.Date? = nil,
        retentionSettings: ChimeClientTypes.RetentionSettings? = nil
    )
    {
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
        self.retentionSettings = retentionSettings
    }
}

public struct GetRoomInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.roomId = roomId
    }
}

public struct GetRoomOutput {
    /// The room details.
    public var room: ChimeClientTypes.Room?

    public init(
        room: ChimeClientTypes.Room? = nil
    )
    {
        self.room = room
    }
}

public struct GetSipMediaApplicationInput {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

public struct GetSipMediaApplicationOutput {
    /// The SIP media application details.
    public var sipMediaApplication: ChimeClientTypes.SipMediaApplication?

    public init(
        sipMediaApplication: ChimeClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

public struct GetSipMediaApplicationLoggingConfigurationInput {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

extension ChimeClientTypes {
    /// Logging configuration of the SIP media application.
    public struct SipMediaApplicationLoggingConfiguration {
        /// Enables application message logs for the SIP media application.
        public var enableSipMediaApplicationMessageLogs: Swift.Bool?

        public init(
            enableSipMediaApplicationMessageLogs: Swift.Bool? = nil
        )
        {
            self.enableSipMediaApplicationMessageLogs = enableSipMediaApplicationMessageLogs
        }
    }

}

public struct GetSipMediaApplicationLoggingConfigurationOutput {
    /// The actual logging configuration.
    public var sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?

    public init(
        sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

public struct GetSipRuleInput {
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?

    public init(
        sipRuleId: Swift.String? = nil
    )
    {
        self.sipRuleId = sipRuleId
    }
}

public struct GetSipRuleOutput {
    /// The SIP rule details.
    public var sipRule: ChimeClientTypes.SipRule?

    public init(
        sipRule: ChimeClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

public struct GetUserInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

public struct GetUserOutput {
    /// The user details.
    public var user: ChimeClientTypes.User?

    public init(
        user: ChimeClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

public struct GetUserSettingsInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

extension ChimeClientTypes {
    /// Settings that allow management of telephony permissions for an Amazon Chime user, such as inbound and outbound calling and text messaging.
    public struct TelephonySettings {
        /// Allows or denies inbound calling.
        /// This member is required.
        public var inboundCalling: Swift.Bool?
        /// Allows or denies outbound calling.
        /// This member is required.
        public var outboundCalling: Swift.Bool?
        /// Allows or denies SMS messaging.
        /// This member is required.
        public var sms: Swift.Bool?

        public init(
            inboundCalling: Swift.Bool? = nil,
            outboundCalling: Swift.Bool? = nil,
            sms: Swift.Bool? = nil
        )
        {
            self.inboundCalling = inboundCalling
            self.outboundCalling = outboundCalling
            self.sms = sms
        }
    }

}

extension ChimeClientTypes {
    /// Settings associated with an Amazon Chime user, including inbound and outbound calling and text messaging.
    public struct UserSettings {
        /// The telephony settings associated with the user.
        /// This member is required.
        public var telephony: ChimeClientTypes.TelephonySettings?

        public init(
            telephony: ChimeClientTypes.TelephonySettings? = nil
        )
        {
            self.telephony = telephony
        }
    }

}

public struct GetUserSettingsOutput {
    /// The user settings.
    public var userSettings: ChimeClientTypes.UserSettings?

    public init(
        userSettings: ChimeClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

public struct GetVoiceConnectorInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct GetVoiceConnectorOutput {
    /// The Amazon Chime Voice Connector details.
    public var voiceConnector: ChimeClientTypes.VoiceConnector?

    public init(
        voiceConnector: ChimeClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

public struct GetVoiceConnectorEmergencyCallingConfigurationInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct GetVoiceConnectorEmergencyCallingConfigurationOutput {
    /// The emergency calling configuration details.
    public var emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?

    public init(
        emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
    }
}

public struct GetVoiceConnectorGroupInput {
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

public struct GetVoiceConnectorGroupOutput {
    /// The Amazon Chime Voice Connector group details.
    public var voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?

    public init(
        voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

public struct GetVoiceConnectorLoggingConfigurationInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

extension ChimeClientTypes {
    /// The logging configuration associated with an Amazon Chime Voice Connector. Specifies whether SIP message logs are enabled for sending to Amazon CloudWatch Logs.
    public struct LoggingConfiguration {
        /// Boolean that enables logging of detailed media metrics for Voice Connectors to Amazon CloudWatch logs.
        public var enableMediaMetricLogs: Swift.Bool?
        /// Boolean that enables SIP message logs to Amazon CloudWatch logs.
        public var enableSIPLogs: Swift.Bool?

        public init(
            enableMediaMetricLogs: Swift.Bool? = nil,
            enableSIPLogs: Swift.Bool? = nil
        )
        {
            self.enableMediaMetricLogs = enableMediaMetricLogs
            self.enableSIPLogs = enableSIPLogs
        }
    }

}

public struct GetVoiceConnectorLoggingConfigurationOutput {
    /// The logging configuration details.
    public var loggingConfiguration: ChimeClientTypes.LoggingConfiguration?

    public init(
        loggingConfiguration: ChimeClientTypes.LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

public struct GetVoiceConnectorOriginationInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

extension ChimeClientTypes {

    public enum OriginationRouteProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginationRouteProtocol] {
            return [
                .tcp,
                .udp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// Origination routes define call distribution properties for your SIP hosts to receive inbound calls using your Amazon Chime Voice Connector. Limit: Ten origination routes for each Amazon Chime Voice Connector. The parameters listed below are not required, but you must use at least one.
    public struct OriginationRoute {
        /// The FQDN or IP address to contact for origination traffic.
        public var host: Swift.String?
        /// The designated origination route port. Defaults to 5060.
        public var port: Swift.Int?
        /// The priority associated with the host, with 1 being the highest priority. Higher priority hosts are attempted first.
        public var priority: Swift.Int?
        /// The protocol to use for the origination route. Encryption-enabled Amazon Chime Voice Connectors use TCP protocol by default.
        public var `protocol`: ChimeClientTypes.OriginationRouteProtocol?
        /// The weight associated with the host. If hosts are equal in priority, calls are redistributed among them based on their relative weight.
        public var weight: Swift.Int?

        public init(
            host: Swift.String? = nil,
            port: Swift.Int? = nil,
            priority: Swift.Int? = nil,
            `protocol`: ChimeClientTypes.OriginationRouteProtocol? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.host = host
            self.port = port
            self.priority = priority
            self.`protocol` = `protocol`
            self.weight = weight
        }
    }

}

extension ChimeClientTypes {
    /// Origination settings enable your SIP hosts to receive inbound calls using your Amazon Chime Voice Connector. The parameters listed below are not required, but you must use at least one.
    public struct Origination {
        /// When origination settings are disabled, inbound calls are not enabled for your Amazon Chime Voice Connector. This parameter is not required, but you must specify this parameter or Routes.
        public var disabled: Swift.Bool?
        /// The call distribution properties defined for your SIP hosts. Valid range: Minimum value of 1. Maximum value of 20. This parameter is not required, but you must specify this parameter or Disabled.
        public var routes: [ChimeClientTypes.OriginationRoute]?

        public init(
            disabled: Swift.Bool? = nil,
            routes: [ChimeClientTypes.OriginationRoute]? = nil
        )
        {
            self.disabled = disabled
            self.routes = routes
        }
    }

}

public struct GetVoiceConnectorOriginationOutput {
    /// The origination setting details.
    public var origination: ChimeClientTypes.Origination?

    public init(
        origination: ChimeClientTypes.Origination? = nil
    )
    {
        self.origination = origination
    }
}

public struct GetVoiceConnectorProxyInput {
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

extension ChimeClientTypes {
    /// The proxy configuration for an Amazon Chime Voice Connector.
    public struct Proxy {
        /// The default number of minutes allowed for proxy sessions.
        public var defaultSessionExpiryMinutes: Swift.Int?
        /// When true, stops proxy sessions from being created on the specified Amazon Chime Voice Connector.
        public var disabled: Swift.Bool?
        /// The phone number to route calls to after a proxy session expires.
        public var fallBackPhoneNumber: Swift.String?
        /// The countries for proxy phone numbers to be selected from.
        public var phoneNumberCountries: [Swift.String]?

        public init(
            defaultSessionExpiryMinutes: Swift.Int? = nil,
            disabled: Swift.Bool? = nil,
            fallBackPhoneNumber: Swift.String? = nil,
            phoneNumberCountries: [Swift.String]? = nil
        )
        {
            self.defaultSessionExpiryMinutes = defaultSessionExpiryMinutes
            self.disabled = disabled
            self.fallBackPhoneNumber = fallBackPhoneNumber
            self.phoneNumberCountries = phoneNumberCountries
        }
    }

}

extension ChimeClientTypes.Proxy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Proxy(defaultSessionExpiryMinutes: \(Swift.String(describing: defaultSessionExpiryMinutes)), disabled: \(Swift.String(describing: disabled)), phoneNumberCountries: \(Swift.String(describing: phoneNumberCountries)), fallBackPhoneNumber: \"CONTENT_REDACTED\")"}
}

public struct GetVoiceConnectorProxyOutput {
    /// The proxy configuration details.
    public var proxy: ChimeClientTypes.Proxy?

    public init(
        proxy: ChimeClientTypes.Proxy? = nil
    )
    {
        self.proxy = proxy
    }
}

public struct GetVoiceConnectorStreamingConfigurationInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

extension ChimeClientTypes {

    public enum NotificationTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eventbridge
        case sns
        case sqs
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationTarget] {
            return [
                .eventbridge,
                .sns,
                .sqs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eventbridge: return "EventBridge"
            case .sns: return "SNS"
            case .sqs: return "SQS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeClientTypes {
    /// The targeted recipient for a streaming configuration notification.
    public struct StreamingNotificationTarget {
        /// The streaming notification target.
        /// This member is required.
        public var notificationTarget: ChimeClientTypes.NotificationTarget?

        public init(
            notificationTarget: ChimeClientTypes.NotificationTarget? = nil
        )
        {
            self.notificationTarget = notificationTarget
        }
    }

}

extension ChimeClientTypes {
    /// The streaming configuration associated with an Amazon Chime Voice Connector. Specifies whether media streaming is enabled for sending to Amazon Kinesis, and shows the retention period for the Amazon Kinesis data, in hours.
    public struct StreamingConfiguration {
        /// The retention period, in hours, for the Amazon Kinesis data.
        /// This member is required.
        public var dataRetentionInHours: Swift.Int?
        /// When true, media streaming to Amazon Kinesis is turned off.
        public var disabled: Swift.Bool?
        /// The streaming notification targets.
        public var streamingNotificationTargets: [ChimeClientTypes.StreamingNotificationTarget]?

        public init(
            dataRetentionInHours: Swift.Int? = nil,
            disabled: Swift.Bool? = nil,
            streamingNotificationTargets: [ChimeClientTypes.StreamingNotificationTarget]? = nil
        )
        {
            self.dataRetentionInHours = dataRetentionInHours
            self.disabled = disabled
            self.streamingNotificationTargets = streamingNotificationTargets
        }
    }

}

public struct GetVoiceConnectorStreamingConfigurationOutput {
    /// The streaming configuration details.
    public var streamingConfiguration: ChimeClientTypes.StreamingConfiguration?

    public init(
        streamingConfiguration: ChimeClientTypes.StreamingConfiguration? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
    }
}

public struct GetVoiceConnectorTerminationInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

extension ChimeClientTypes {
    /// Termination settings enable your SIP hosts to make outbound calls using your Amazon Chime Voice Connector.
    public struct Termination {
        /// The countries to which calls are allowed, in ISO 3166-1 alpha-2 format. Required.
        public var callingRegions: [Swift.String]?
        /// The IP addresses allowed to make calls, in CIDR format. Required.
        public var cidrAllowedList: [Swift.String]?
        /// The limit on calls per second. Max value based on account service quota. Default value of 1.
        public var cpsLimit: Swift.Int?
        /// The default caller ID phone number.
        public var defaultPhoneNumber: Swift.String?
        /// When termination settings are disabled, outbound calls can not be made.
        public var disabled: Swift.Bool?

        public init(
            callingRegions: [Swift.String]? = nil,
            cidrAllowedList: [Swift.String]? = nil,
            cpsLimit: Swift.Int? = nil,
            defaultPhoneNumber: Swift.String? = nil,
            disabled: Swift.Bool? = nil
        )
        {
            self.callingRegions = callingRegions
            self.cidrAllowedList = cidrAllowedList
            self.cpsLimit = cpsLimit
            self.defaultPhoneNumber = defaultPhoneNumber
            self.disabled = disabled
        }
    }

}

extension ChimeClientTypes.Termination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Termination(callingRegions: \(Swift.String(describing: callingRegions)), cidrAllowedList: \(Swift.String(describing: cidrAllowedList)), cpsLimit: \(Swift.String(describing: cpsLimit)), disabled: \(Swift.String(describing: disabled)), defaultPhoneNumber: \"CONTENT_REDACTED\")"}
}

public struct GetVoiceConnectorTerminationOutput {
    /// The termination setting details.
    public var termination: ChimeClientTypes.Termination?

    public init(
        termination: ChimeClientTypes.Termination? = nil
    )
    {
        self.termination = termination
    }
}

public struct GetVoiceConnectorTerminationHealthInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

extension ChimeClientTypes {
    /// The termination health details, including the source IP address and timestamp of the last successful SIP OPTIONS message from your SIP infrastructure.
    public struct TerminationHealth {
        /// The source IP address.
        public var source: Swift.String?
        /// The timestamp, in ISO 8601 format.
        public var timestamp: Foundation.Date?

        public init(
            source: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        )
        {
            self.source = source
            self.timestamp = timestamp
        }
    }

}

public struct GetVoiceConnectorTerminationHealthOutput {
    /// The termination health details.
    public var terminationHealth: ChimeClientTypes.TerminationHealth?

    public init(
        terminationHealth: ChimeClientTypes.TerminationHealth? = nil
    )
    {
        self.terminationHealth = terminationHealth
    }
}

extension ChimeClientTypes {
    /// Invitation object returned after emailing users to invite them to join the Amazon Chime Team account.
    public struct Invite {
        /// The email address to which the invite is sent.
        public var emailAddress: Swift.String?
        /// The status of the invite email.
        public var emailStatus: ChimeClientTypes.EmailStatus?
        /// The invite ID.
        public var inviteId: Swift.String?
        /// The status of the invite.
        public var status: ChimeClientTypes.InviteStatus?

        public init(
            emailAddress: Swift.String? = nil,
            emailStatus: ChimeClientTypes.EmailStatus? = nil,
            inviteId: Swift.String? = nil,
            status: ChimeClientTypes.InviteStatus? = nil
        )
        {
            self.emailAddress = emailAddress
            self.emailStatus = emailStatus
            self.inviteId = inviteId
            self.status = status
        }
    }

}

extension ChimeClientTypes.Invite: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Invite(emailStatus: \(Swift.String(describing: emailStatus)), inviteId: \(Swift.String(describing: inviteId)), status: \(Swift.String(describing: status)), emailAddress: \"CONTENT_REDACTED\")"}
}

public struct InviteUsersInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user email addresses to which to send the email invitation.
    /// This member is required.
    public var userEmailList: [Swift.String]?
    /// The user type.
    public var userType: ChimeClientTypes.UserType?

    public init(
        accountId: Swift.String? = nil,
        userEmailList: [Swift.String]? = nil,
        userType: ChimeClientTypes.UserType? = nil
    )
    {
        self.accountId = accountId
        self.userEmailList = userEmailList
        self.userType = userType
    }
}

extension InviteUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InviteUsersInput(accountId: \(Swift.String(describing: accountId)), userType: \(Swift.String(describing: userType)), userEmailList: \"CONTENT_REDACTED\")"}
}

public struct InviteUsersOutput {
    /// The email invitation details.
    public var invites: [ChimeClientTypes.Invite]?

    public init(
        invites: [ChimeClientTypes.Invite]? = nil
    )
    {
        self.invites = invites
    }
}

public struct ListAccountsInput {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// Amazon Chime account name prefix with which to filter results.
    public var name: Swift.String?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// User email address with which to filter results.
    public var userEmail: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        userEmail: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.userEmail = userEmail
    }
}

extension ListAccountsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccountsInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), userEmail: \"CONTENT_REDACTED\")"}
}

public struct ListAccountsOutput {
    /// List of Amazon Chime accounts and account details.
    public var accounts: [ChimeClientTypes.Account]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accounts: [ChimeClientTypes.Account]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accounts = accounts
        self.nextToken = nextToken
    }
}

public struct ListAppInstanceAdminsInput {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of administrators that you want to return.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of administrators is reached.
    public var nextToken: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAppInstanceAdminsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceAdminsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListAppInstanceAdminsOutput {
    /// The information for each administrator.
    public var appInstanceAdmins: [ChimeClientTypes.AppInstanceAdminSummary]?
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The token returned from previous API requests until the number of administrators is reached.
    public var nextToken: Swift.String?

    public init(
        appInstanceAdmins: [ChimeClientTypes.AppInstanceAdminSummary]? = nil,
        appInstanceArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceAdmins = appInstanceAdmins
        self.appInstanceArn = appInstanceArn
        self.nextToken = nextToken
    }
}

extension ListAppInstanceAdminsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceAdminsOutput(appInstanceAdmins: \(Swift.String(describing: appInstanceAdmins)), appInstanceArn: \(Swift.String(describing: appInstanceArn)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListAppInstancesInput {
    /// The maximum number of AppInstances that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API requests until you reach the maximum number of AppInstances.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAppInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstancesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListAppInstancesOutput {
    /// The information for each AppInstance.
    public var appInstances: [ChimeClientTypes.AppInstanceSummary]?
    /// The token passed by previous API requests until the maximum number of AppInstances is reached.
    public var nextToken: Swift.String?

    public init(
        appInstances: [ChimeClientTypes.AppInstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstances = appInstances
        self.nextToken = nextToken
    }
}

extension ListAppInstancesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstancesOutput(appInstances: \(Swift.String(describing: appInstances)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListAppInstanceUsersInput {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of requests that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAppInstanceUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUsersInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListAppInstanceUsersOutput {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The information for each requested AppInstanceUser.
    public var appInstanceUsers: [ChimeClientTypes.AppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        appInstanceUsers: [ChimeClientTypes.AppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceUsers = appInstanceUsers
        self.nextToken = nextToken
    }
}

extension ListAppInstanceUsersOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUsersOutput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), appInstanceUsers: \(Swift.String(describing: appInstanceUsers)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListAttendeesInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        meetingId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.meetingId = meetingId
        self.nextToken = nextToken
    }
}

public struct ListAttendeesOutput {
    /// The Amazon Chime SDK attendee information.
    public var attendees: [ChimeClientTypes.Attendee]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        attendees: [ChimeClientTypes.Attendee]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attendees = attendees
        self.nextToken = nextToken
    }
}

public struct ListAttendeeTagsInput {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

public struct ListAttendeeTagsOutput {
    /// A list of tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListBotsInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. The default is 10.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBotsOutput {
    /// List of bots and bot details.
    public var bots: [ChimeClientTypes.Bot]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        bots: [ChimeClientTypes.Bot]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bots = bots
        self.nextToken = nextToken
    }
}

public struct ListChannelBansInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of bans that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested bans are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelBansInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelBansInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelBansOutput {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information for each requested ban.
    public var channelBans: [ChimeClientTypes.ChannelBanSummary]?
    /// The token passed by previous API calls until all requested bans are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelBans: [ChimeClientTypes.ChannelBanSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelBans = channelBans
        self.nextToken = nextToken
    }
}

extension ListChannelBansOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelBansOutput(channelArn: \(Swift.String(describing: channelArn)), channelBans: \(Swift.String(describing: channelBans)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelMembershipsInput {
    /// The maximum number of channel memberships that you want returned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of channel memberships that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channel memberships are returned.
    public var nextToken: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned.
    public var type: ChimeClientTypes.ChannelMembershipType?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: ChimeClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

extension ListChannelMembershipsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), type: \(Swift.String(describing: type)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelMembershipsOutput {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information for the requested channel memberships.
    public var channelMemberships: [ChimeClientTypes.ChannelMembershipSummary]?
    /// The token passed by previous API calls until all requested channel memberships are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelMemberships: [ChimeClientTypes.ChannelMembershipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

extension ListChannelMembershipsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsOutput(channelArn: \(Swift.String(describing: channelArn)), channelMemberships: \(Swift.String(describing: channelMemberships)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelMembershipsForAppInstanceUserInput {
    /// The ARN of the AppInstanceUsers
    public var appInstanceUserArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of users that you want returned.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channel memberships is reached.
    public var nextToken: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsForAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelMembershipsForAppInstanceUserOutput {
    /// The information for the requested channel memberships.
    public var channelMemberships: [ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init(
        channelMemberships: [ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

extension ListChannelMembershipsForAppInstanceUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsForAppInstanceUserOutput(channelMemberships: \(Swift.String(describing: channelMemberships)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ChimeClientTypes {

    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListChannelMessagesInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of messages that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested messages are returned.
    public var nextToken: Swift.String?
    /// The final or ending time stamp for your requested messages.
    public var notAfter: Foundation.Date?
    /// The initial or starting time stamp for your requested messages.
    public var notBefore: Foundation.Date?
    /// The order in which you want messages sorted. Default is Descending, based on time created.
    public var sortOrder: ChimeClientTypes.SortOrder?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notAfter: Foundation.Date? = nil,
        notBefore: Foundation.Date? = nil,
        sortOrder: ChimeClientTypes.SortOrder? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notAfter = notAfter
        self.notBefore = notBefore
        self.sortOrder = sortOrder
    }
}

extension ListChannelMessagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMessagesInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), notAfter: \(Swift.String(describing: notAfter)), notBefore: \(Swift.String(describing: notBefore)), sortOrder: \(Swift.String(describing: sortOrder)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelMessagesOutput {
    /// The ARN of the channel containing the requested messages.
    public var channelArn: Swift.String?
    /// The information about, and content of, each requested message.
    public var channelMessages: [ChimeClientTypes.ChannelMessageSummary]?
    /// The token passed by previous API calls until all requested messages are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelMessages: [ChimeClientTypes.ChannelMessageSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMessages = channelMessages
        self.nextToken = nextToken
    }
}

extension ListChannelMessagesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMessagesOutput(channelArn: \(Swift.String(describing: channelArn)), channelMessages: \(Swift.String(describing: channelMessages)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelModeratorsInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of moderators that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested moderators are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelModeratorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelModeratorsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelModeratorsOutput {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information about and names of each moderator.
    public var channelModerators: [ChimeClientTypes.ChannelModeratorSummary]?
    /// The token passed by previous API calls until all requested moderators are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelModerators: [ChimeClientTypes.ChannelModeratorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerators = channelModerators
        self.nextToken = nextToken
    }
}

extension ListChannelModeratorsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelModeratorsOutput(channelArn: \(Swift.String(describing: channelArn)), channelModerators: \(Swift.String(describing: channelModerators)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelsInput {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of channels that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channels are returned.
    public var nextToken: Swift.String?
    /// The privacy setting. PUBLIC retrieves all the public channels. PRIVATE retrieves private channels. Only an AppInstanceAdmin can retrieve private channels.
    public var privacy: ChimeClientTypes.ChannelPrivacy?

    public init(
        appInstanceArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        privacy: ChimeClientTypes.ChannelPrivacy? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.privacy = privacy
    }
}

extension ListChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), privacy: \(Swift.String(describing: privacy)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelsOutput {
    /// The information about each channel.
    public var channels: [ChimeClientTypes.ChannelSummary]?
    /// The token returned from previous API requests until the number of channels is reached.
    public var nextToken: Swift.String?

    public init(
        channels: [ChimeClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

extension ListChannelsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsOutput(channels: \(Swift.String(describing: channels)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelsModeratedByAppInstanceUserInput {
    /// The ARN of the user in the moderated channel.
    public var appInstanceUserArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The maximum number of channels in the request.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channels moderated by the user is reached.
    public var nextToken: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsModeratedByAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelsModeratedByAppInstanceUserOutput {
    /// The moderated channels in the request.
    public var channels: [ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary]?
    /// The token returned from previous API requests until the number of channels moderated by the user is reached.
    public var nextToken: Swift.String?

    public init(
        channels: [ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

extension ListChannelsModeratedByAppInstanceUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsModeratedByAppInstanceUserOutput(channels: \(Swift.String(describing: channels)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListMediaCapturePipelinesInput {
    /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListMediaCapturePipelinesOutput {
    /// The media capture pipeline objects in the list.
    public var mediaCapturePipelines: [ChimeClientTypes.MediaCapturePipeline]?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        mediaCapturePipelines: [ChimeClientTypes.MediaCapturePipeline]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mediaCapturePipelines = mediaCapturePipelines
        self.nextToken = nextToken
    }
}

public struct ListMeetingsInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListMeetingsOutput {
    /// The Amazon Chime SDK meeting information.
    public var meetings: [ChimeClientTypes.Meeting]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        meetings: [ChimeClientTypes.Meeting]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.meetings = meetings
        self.nextToken = nextToken
    }
}

public struct ListMeetingTagsInput {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

public struct ListMeetingTagsOutput {
    /// A list of tag key-value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListPhoneNumberOrdersInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListPhoneNumberOrdersOutput {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number order details.
    public var phoneNumberOrders: [ChimeClientTypes.PhoneNumberOrder]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumberOrders: [ChimeClientTypes.PhoneNumberOrder]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumberOrders = phoneNumberOrders
    }
}

public struct ListPhoneNumbersInput {
    /// The filter to use to limit the number of results.
    public var filterName: ChimeClientTypes.PhoneNumberAssociationName?
    /// The value to use for the filter.
    public var filterValue: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number product type.
    public var productType: ChimeClientTypes.PhoneNumberProductType?
    /// The phone number status.
    public var status: ChimeClientTypes.PhoneNumberStatus?

    public init(
        filterName: ChimeClientTypes.PhoneNumberAssociationName? = nil,
        filterValue: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        productType: ChimeClientTypes.PhoneNumberProductType? = nil,
        status: ChimeClientTypes.PhoneNumberStatus? = nil
    )
    {
        self.filterName = filterName
        self.filterValue = filterValue
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.productType = productType
        self.status = status
    }
}

public struct ListPhoneNumbersOutput {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number details.
    public var phoneNumbers: [ChimeClientTypes.PhoneNumber]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [ChimeClientTypes.PhoneNumber]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

public struct ListProxySessionsInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The proxy session status.
    public var status: ChimeClientTypes.ProxySessionStatus?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: ChimeClientTypes.ProxySessionStatus? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct ListProxySessionsOutput {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The proxy session details.
    public var proxySessions: [ChimeClientTypes.ProxySession]?

    public init(
        nextToken: Swift.String? = nil,
        proxySessions: [ChimeClientTypes.ProxySession]? = nil
    )
    {
        self.nextToken = nextToken
        self.proxySessions = proxySessions
    }
}

public struct ListRoomMembershipsInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.roomId = roomId
    }
}

public struct ListRoomMembershipsOutput {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The room membership details.
    public var roomMemberships: [ChimeClientTypes.RoomMembership]?

    public init(
        nextToken: Swift.String? = nil,
        roomMemberships: [ChimeClientTypes.RoomMembership]? = nil
    )
    {
        self.nextToken = nextToken
        self.roomMemberships = roomMemberships
    }
}

public struct ListRoomsInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The member ID (user ID or bot ID).
    public var memberId: Swift.String?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        memberId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.memberId = memberId
        self.nextToken = nextToken
    }
}

public struct ListRoomsOutput {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The room details.
    public var rooms: [ChimeClientTypes.Room]?

    public init(
        nextToken: Swift.String? = nil,
        rooms: [ChimeClientTypes.Room]? = nil
    )
    {
        self.nextToken = nextToken
        self.rooms = rooms
    }
}

public struct ListSipMediaApplicationsInput {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListSipMediaApplicationsOutput {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// List of SIP media applications and application details.
    public var sipMediaApplications: [ChimeClientTypes.SipMediaApplication]?

    public init(
        nextToken: Swift.String? = nil,
        sipMediaApplications: [ChimeClientTypes.SipMediaApplication]? = nil
    )
    {
        self.nextToken = nextToken
        self.sipMediaApplications = sipMediaApplications
    }
}

public struct ListSipRulesInput {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The SIP media application ID.
    public var sipMediaApplicationId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

public struct ListSipRulesOutput {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// List of SIP rules and rule details.
    public var sipRules: [ChimeClientTypes.SipRule]?

    public init(
        nextToken: Swift.String? = nil,
        sipRules: [ChimeClientTypes.SipRule]? = nil
    )
    {
        self.nextToken = nextToken
        self.sipRules = sipRules
    }
}

public struct ListSupportedPhoneNumberCountriesInput {
    /// The phone number product type.
    /// This member is required.
    public var productType: ChimeClientTypes.PhoneNumberProductType?

    public init(
        productType: ChimeClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.productType = productType
    }
}

extension ChimeClientTypes {
    /// The phone number country.
    public struct PhoneNumberCountry {
        /// The phone number country code. Format: ISO 3166-1 alpha-2.
        public var countryCode: Swift.String?
        /// The supported phone number types.
        public var supportedPhoneNumberTypes: [ChimeClientTypes.PhoneNumberType]?

        public init(
            countryCode: Swift.String? = nil,
            supportedPhoneNumberTypes: [ChimeClientTypes.PhoneNumberType]? = nil
        )
        {
            self.countryCode = countryCode
            self.supportedPhoneNumberTypes = supportedPhoneNumberTypes
        }
    }

}

public struct ListSupportedPhoneNumberCountriesOutput {
    /// The supported phone number countries.
    public var phoneNumberCountries: [ChimeClientTypes.PhoneNumberCountry]?

    public init(
        phoneNumberCountries: [ChimeClientTypes.PhoneNumberCountry]? = nil
    )
    {
        self.phoneNumberCountries = phoneNumberCountries
    }
}

public struct ListTagsForResourceInput {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \"CONTENT_REDACTED\")"}
}

public struct ListTagsForResourceOutput {
    /// A list of tag-key value pairs.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListUsersInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Optional. The user email address used to filter results. Maximum 1.
    public var userEmail: Swift.String?
    /// The user type.
    public var userType: ChimeClientTypes.UserType?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userEmail: Swift.String? = nil,
        userType: ChimeClientTypes.UserType? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userEmail = userEmail
        self.userType = userType
    }
}

extension ListUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersInput(accountId: \(Swift.String(describing: accountId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), userType: \(Swift.String(describing: userType)), userEmail: \"CONTENT_REDACTED\")"}
}

public struct ListUsersOutput {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// List of users and user details.
    public var users: [ChimeClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        users: [ChimeClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

public struct ListVoiceConnectorGroupsInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListVoiceConnectorGroupsOutput {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The details of the Amazon Chime Voice Connector groups.
    public var voiceConnectorGroups: [ChimeClientTypes.VoiceConnectorGroup]?

    public init(
        nextToken: Swift.String? = nil,
        voiceConnectorGroups: [ChimeClientTypes.VoiceConnectorGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceConnectorGroups = voiceConnectorGroups
    }
}

public struct ListVoiceConnectorsInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListVoiceConnectorsOutput {
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The details of the Amazon Chime Voice Connectors.
    public var voiceConnectors: [ChimeClientTypes.VoiceConnector]?

    public init(
        nextToken: Swift.String? = nil,
        voiceConnectors: [ChimeClientTypes.VoiceConnector]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceConnectors = voiceConnectors
    }
}

public struct ListVoiceConnectorTerminationCredentialsInput {
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct ListVoiceConnectorTerminationCredentialsOutput {
    /// A list of user names.
    public var usernames: [Swift.String]?

    public init(
        usernames: [Swift.String]? = nil
    )
    {
        self.usernames = usernames
    }
}

extension ListVoiceConnectorTerminationCredentialsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListVoiceConnectorTerminationCredentialsOutput(usernames: \"CONTENT_REDACTED\")"}
}

public struct LogoutUserInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

public struct LogoutUserOutput {

    public init() { }
}

public struct PutAppInstanceRetentionSettingsInput {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The time in days to retain data. Data type: number.
    /// This member is required.
    public var appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?

    public init(
        appInstanceArn: Swift.String? = nil,
        appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
    }
}

public struct PutAppInstanceRetentionSettingsOutput {
    /// The time in days to retain data. Data type: number.
    public var appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings?
    /// The time at which the API deletes data.
    public var initiateDeletionTimestamp: Foundation.Date?

    public init(
        appInstanceRetentionSettings: ChimeClientTypes.AppInstanceRetentionSettings? = nil,
        initiateDeletionTimestamp: Foundation.Date? = nil
    )
    {
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
    }
}

public struct PutAppInstanceStreamingConfigurationsInput {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The streaming configurations set for an AppInstance.
    /// This member is required.
    public var appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?

    public init(
        appInstanceArn: Swift.String? = nil,
        appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceStreamingConfigurations = appInstanceStreamingConfigurations
    }
}

public struct PutAppInstanceStreamingConfigurationsOutput {
    /// The streaming configurations of an AppInstance.
    public var appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]?

    public init(
        appInstanceStreamingConfigurations: [ChimeClientTypes.AppInstanceStreamingConfiguration]? = nil
    )
    {
        self.appInstanceStreamingConfigurations = appInstanceStreamingConfigurations
    }
}

public struct PutEventsConfigurationInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?
    /// Lambda function ARN that allows the bot to receive outgoing events.
    public var lambdaFunctionArn: Swift.String?
    /// HTTPS endpoint that allows the bot to receive outgoing events.
    public var outboundEventsHTTPSEndpoint: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil,
        lambdaFunctionArn: Swift.String? = nil,
        outboundEventsHTTPSEndpoint: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
        self.lambdaFunctionArn = lambdaFunctionArn
        self.outboundEventsHTTPSEndpoint = outboundEventsHTTPSEndpoint
    }
}

extension PutEventsConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutEventsConfigurationInput(accountId: \(Swift.String(describing: accountId)), botId: \(Swift.String(describing: botId)), lambdaFunctionArn: \"CONTENT_REDACTED\", outboundEventsHTTPSEndpoint: \"CONTENT_REDACTED\")"}
}

public struct PutEventsConfigurationOutput {
    /// The configuration that allows a bot to receive outgoing events. Can be an HTTPS endpoint or an AWS Lambda function ARN.
    public var eventsConfiguration: ChimeClientTypes.EventsConfiguration?

    public init(
        eventsConfiguration: ChimeClientTypes.EventsConfiguration? = nil
    )
    {
        self.eventsConfiguration = eventsConfiguration
    }
}

public struct PutRetentionSettingsInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The retention settings.
    /// This member is required.
    public var retentionSettings: ChimeClientTypes.RetentionSettings?

    public init(
        accountId: Swift.String? = nil,
        retentionSettings: ChimeClientTypes.RetentionSettings? = nil
    )
    {
        self.accountId = accountId
        self.retentionSettings = retentionSettings
    }
}

public struct PutRetentionSettingsOutput {
    /// The timestamp representing the time at which the specified items are permanently deleted, in ISO 8601 format.
    public var initiateDeletionTimestamp: Foundation.Date?
    /// The retention settings.
    public var retentionSettings: ChimeClientTypes.RetentionSettings?

    public init(
        initiateDeletionTimestamp: Foundation.Date? = nil,
        retentionSettings: ChimeClientTypes.RetentionSettings? = nil
    )
    {
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
        self.retentionSettings = retentionSettings
    }
}

public struct PutSipMediaApplicationLoggingConfigurationInput {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The actual logging configuration.
    public var sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?

    public init(
        sipMediaApplicationId: Swift.String? = nil,
        sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

public struct PutSipMediaApplicationLoggingConfigurationOutput {
    /// The logging configuration of the SIP media application.
    public var sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?

    public init(
        sipMediaApplicationLoggingConfiguration: ChimeClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationInput {
    /// The emergency calling configuration details.
    /// This member is required.
    public var emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationOutput {
    /// The emergency calling configuration details.
    public var emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration?

    public init(
        emergencyCallingConfiguration: ChimeClientTypes.EmergencyCallingConfiguration? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
    }
}

public struct PutVoiceConnectorLoggingConfigurationInput {
    /// The logging configuration details to add.
    /// This member is required.
    public var loggingConfiguration: ChimeClientTypes.LoggingConfiguration?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        loggingConfiguration: ChimeClientTypes.LoggingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct PutVoiceConnectorLoggingConfigurationOutput {
    /// The updated logging configuration details.
    public var loggingConfiguration: ChimeClientTypes.LoggingConfiguration?

    public init(
        loggingConfiguration: ChimeClientTypes.LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

public struct PutVoiceConnectorOriginationInput {
    /// The origination setting details to add.
    /// This member is required.
    public var origination: ChimeClientTypes.Origination?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        origination: ChimeClientTypes.Origination? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.origination = origination
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct PutVoiceConnectorOriginationOutput {
    /// The updated origination setting details.
    public var origination: ChimeClientTypes.Origination?

    public init(
        origination: ChimeClientTypes.Origination? = nil
    )
    {
        self.origination = origination
    }
}

public struct PutVoiceConnectorProxyInput {
    /// The default number of minutes allowed for proxy sessions.
    /// This member is required.
    public var defaultSessionExpiryMinutes: Swift.Int?
    /// When true, stops proxy sessions from being created on the specified Amazon Chime Voice Connector.
    public var disabled: Swift.Bool?
    /// The phone number to route calls to after a proxy session expires.
    public var fallBackPhoneNumber: Swift.String?
    /// The countries for proxy phone numbers to be selected from.
    /// This member is required.
    public var phoneNumberPoolCountries: [Swift.String]?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        defaultSessionExpiryMinutes: Swift.Int? = nil,
        disabled: Swift.Bool? = nil,
        fallBackPhoneNumber: Swift.String? = nil,
        phoneNumberPoolCountries: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.defaultSessionExpiryMinutes = defaultSessionExpiryMinutes
        self.disabled = disabled
        self.fallBackPhoneNumber = fallBackPhoneNumber
        self.phoneNumberPoolCountries = phoneNumberPoolCountries
        self.voiceConnectorId = voiceConnectorId
    }
}

extension PutVoiceConnectorProxyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorProxyInput(defaultSessionExpiryMinutes: \(Swift.String(describing: defaultSessionExpiryMinutes)), disabled: \(Swift.String(describing: disabled)), phoneNumberPoolCountries: \(Swift.String(describing: phoneNumberPoolCountries)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), fallBackPhoneNumber: \"CONTENT_REDACTED\")"}
}

public struct PutVoiceConnectorProxyOutput {
    /// The proxy configuration details.
    public var proxy: ChimeClientTypes.Proxy?

    public init(
        proxy: ChimeClientTypes.Proxy? = nil
    )
    {
        self.proxy = proxy
    }
}

public struct PutVoiceConnectorStreamingConfigurationInput {
    /// The streaming configuration details to add.
    /// This member is required.
    public var streamingConfiguration: ChimeClientTypes.StreamingConfiguration?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        streamingConfiguration: ChimeClientTypes.StreamingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct PutVoiceConnectorStreamingConfigurationOutput {
    /// The updated streaming configuration details.
    public var streamingConfiguration: ChimeClientTypes.StreamingConfiguration?

    public init(
        streamingConfiguration: ChimeClientTypes.StreamingConfiguration? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
    }
}

public struct PutVoiceConnectorTerminationInput {
    /// The termination setting details to add.
    /// This member is required.
    public var termination: ChimeClientTypes.Termination?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        termination: ChimeClientTypes.Termination? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.termination = termination
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct PutVoiceConnectorTerminationOutput {
    /// The updated termination setting details.
    public var termination: ChimeClientTypes.Termination?

    public init(
        termination: ChimeClientTypes.Termination? = nil
    )
    {
        self.termination = termination
    }
}

public struct PutVoiceConnectorTerminationCredentialsInput {
    /// The termination SIP credentials.
    public var credentials: [ChimeClientTypes.Credential]?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        credentials: [ChimeClientTypes.Credential]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct RedactChannelMessageInput {
    /// The ARN of the channel containing the messages that you want to redact.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The ID of the message being redacted.
    /// This member is required.
    public var messageId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
    }
}

public struct RedactChannelMessageOutput {
    /// The ARN of the channel containing the messages that you want to redact.
    public var channelArn: Swift.String?
    /// The ID of the message being redacted.
    public var messageId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

public struct RedactConversationMessageInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The conversation ID.
    /// This member is required.
    public var conversationId: Swift.String?
    /// The message ID.
    /// This member is required.
    public var messageId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        conversationId: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.conversationId = conversationId
        self.messageId = messageId
    }
}

public struct RedactConversationMessageOutput {

    public init() { }
}

public struct RedactRoomMessageInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The message ID.
    /// This member is required.
    public var messageId: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        messageId: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.messageId = messageId
        self.roomId = roomId
    }
}

public struct RedactRoomMessageOutput {

    public init() { }
}

public struct RegenerateSecurityTokenInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
    }
}

public struct RegenerateSecurityTokenOutput {
    /// A resource that allows Enterprise account administrators to configure an interface that receives events from Amazon Chime.
    public var bot: ChimeClientTypes.Bot?

    public init(
        bot: ChimeClientTypes.Bot? = nil
    )
    {
        self.bot = bot
    }
}

public struct ResetPersonalPINInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
    }
}

public struct ResetPersonalPINOutput {
    /// The user details and new personal meeting PIN.
    public var user: ChimeClientTypes.User?

    public init(
        user: ChimeClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

public struct RestorePhoneNumberInput {
    /// The phone number.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

public struct RestorePhoneNumberOutput {
    /// The phone number details.
    public var phoneNumber: ChimeClientTypes.PhoneNumber?

    public init(
        phoneNumber: ChimeClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

public struct SearchAvailablePhoneNumbersInput {
    /// The area code used to filter results. Only applies to the US.
    public var areaCode: Swift.String?
    /// The city used to filter results. Only applies to the US.
    public var city: Swift.String?
    /// The country used to filter results. Defaults to the US Format: ISO 3166-1 alpha-2.
    public var country: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number type used to filter results. Required for non-US numbers.
    public var phoneNumberType: ChimeClientTypes.PhoneNumberType?
    /// The state used to filter results. Required only if you provide City. Only applies to the US.
    public var state: Swift.String?
    /// The toll-free prefix that you use to filter results. Only applies to the US.
    public var tollFreePrefix: Swift.String?

    public init(
        areaCode: Swift.String? = nil,
        city: Swift.String? = nil,
        country: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberType: ChimeClientTypes.PhoneNumberType? = nil,
        state: Swift.String? = nil,
        tollFreePrefix: Swift.String? = nil
    )
    {
        self.areaCode = areaCode
        self.city = city
        self.country = country
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberType = phoneNumberType
        self.state = state
        self.tollFreePrefix = tollFreePrefix
    }
}

public struct SearchAvailablePhoneNumbersOutput {
    /// List of phone numbers, in E.164 format.
    public var e164PhoneNumbers: [Swift.String]?
    /// The token used to retrieve the next page of search results.
    public var nextToken: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.nextToken = nextToken
    }
}

extension SearchAvailablePhoneNumbersOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchAvailablePhoneNumbersOutput(nextToken: \(Swift.String(describing: nextToken)), e164PhoneNumbers: \"CONTENT_REDACTED\")"}
}

public struct SendChannelMessageInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The Idempotency token for each client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The content of the message.
    /// This member is required.
    public var content: Swift.String?
    /// The optional metadata for each message.
    public var metadata: Swift.String?
    /// Boolean that controls whether the message is persisted on the back end. Required.
    /// This member is required.
    public var persistence: ChimeClientTypes.ChannelMessagePersistenceType?
    /// The type of message, STANDARD or CONTROL.
    /// This member is required.
    public var type: ChimeClientTypes.ChannelMessageType?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        metadata: Swift.String? = nil,
        persistence: ChimeClientTypes.ChannelMessagePersistenceType? = nil,
        type: ChimeClientTypes.ChannelMessageType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.metadata = metadata
        self.persistence = persistence
        self.type = type
    }
}

extension SendChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), persistence: \(Swift.String(describing: persistence)), type: \(Swift.String(describing: type)), clientRequestToken: \"CONTENT_REDACTED\", content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

public struct SendChannelMessageOutput {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID string assigned to each message.
    public var messageId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

extension ChimeClientTypes {
    /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or EngineTranscribeMedicalSettings.
    public struct TranscriptionConfiguration {
        /// The transcription configuration settings passed to Amazon Transcribe Medical.
        public var engineTranscribeMedicalSettings: ChimeClientTypes.EngineTranscribeMedicalSettings?
        /// The transcription configuration settings passed to Amazon Transcribe.
        public var engineTranscribeSettings: ChimeClientTypes.EngineTranscribeSettings?

        public init(
            engineTranscribeMedicalSettings: ChimeClientTypes.EngineTranscribeMedicalSettings? = nil,
            engineTranscribeSettings: ChimeClientTypes.EngineTranscribeSettings? = nil
        )
        {
            self.engineTranscribeMedicalSettings = engineTranscribeMedicalSettings
            self.engineTranscribeSettings = engineTranscribeSettings
        }
    }

}

public struct StartMeetingTranscriptionInput {
    /// The unique ID of the meeting being transcribed.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or EngineTranscribeMedicalSettings.
    /// This member is required.
    public var transcriptionConfiguration: ChimeClientTypes.TranscriptionConfiguration?

    public init(
        meetingId: Swift.String? = nil,
        transcriptionConfiguration: ChimeClientTypes.TranscriptionConfiguration? = nil
    )
    {
        self.meetingId = meetingId
        self.transcriptionConfiguration = transcriptionConfiguration
    }
}

public struct StartMeetingTranscriptionOutput {

    public init() { }
}

public struct StopMeetingTranscriptionInput {
    /// The unique ID of the meeting for which you stop transcription.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

public struct StopMeetingTranscriptionOutput {

    public init() { }
}

public struct TagAttendeeInput {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
        self.tags = tags
    }
}

public struct TagMeetingInput {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        meetingId: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.meetingId = meetingId
        self.tags = tags
    }
}

public struct TagResourceInput {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ChimeClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(tags: \(Swift.String(describing: tags)), resourceARN: \"CONTENT_REDACTED\")"}
}

public struct UntagAttendeeInput {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
        self.tagKeys = tagKeys
    }
}

extension UntagAttendeeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagAttendeeInput(attendeeId: \(Swift.String(describing: attendeeId)), meetingId: \(Swift.String(describing: meetingId)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagMeetingInput {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        meetingId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.meetingId = meetingId
        self.tagKeys = tagKeys
    }
}

extension UntagMeetingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagMeetingInput(meetingId: \(Swift.String(describing: meetingId)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceInput {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \"CONTENT_REDACTED\", tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UpdateAccountInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The default license applied when you add users to an Amazon Chime account.
    public var defaultLicense: ChimeClientTypes.License?
    /// The new name for the specified Amazon Chime account.
    public var name: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        defaultLicense: ChimeClientTypes.License? = nil,
        name: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.defaultLicense = defaultLicense
        self.name = name
    }
}

public struct UpdateAccountOutput {
    /// The updated Amazon Chime account details.
    public var account: ChimeClientTypes.Account?

    public init(
        account: ChimeClientTypes.Account? = nil
    )
    {
        self.account = account
    }
}

public struct UpdateAccountSettingsInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Amazon Chime account settings to update.
    /// This member is required.
    public var accountSettings: ChimeClientTypes.AccountSettings?

    public init(
        accountId: Swift.String? = nil,
        accountSettings: ChimeClientTypes.AccountSettings? = nil
    )
    {
        self.accountId = accountId
        self.accountSettings = accountSettings
    }
}

public struct UpdateAccountSettingsOutput {

    public init() { }
}

public struct UpdateAppInstanceInput {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The metadata that you want to change.
    public var metadata: Swift.String?
    /// The name that you want to change.
    /// This member is required.
    public var name: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.metadata = metadata
        self.name = name
    }
}

extension UpdateAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateAppInstanceOutput {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

public struct UpdateAppInstanceUserInput {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The metadata of the AppInstanceUser.
    public var metadata: Swift.String?
    /// The name of the AppInstanceUser.
    /// This member is required.
    public var name: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.metadata = metadata
        self.name = name
    }
}

extension UpdateAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateAppInstanceUserOutput {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

public struct UpdateBotInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The bot ID.
    /// This member is required.
    public var botId: Swift.String?
    /// When true, stops the specified bot from running in your account.
    public var disabled: Swift.Bool?

    public init(
        accountId: Swift.String? = nil,
        botId: Swift.String? = nil,
        disabled: Swift.Bool? = nil
    )
    {
        self.accountId = accountId
        self.botId = botId
        self.disabled = disabled
    }
}

public struct UpdateBotOutput {
    /// The updated bot details.
    public var bot: ChimeClientTypes.Bot?

    public init(
        bot: ChimeClientTypes.Bot? = nil
    )
    {
        self.bot = bot
    }
}

public struct UpdateChannelInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The metadata for the update request.
    public var metadata: Swift.String?
    /// The mode of the update request.
    /// This member is required.
    public var mode: ChimeClientTypes.ChannelMode?
    /// The name of the channel.
    /// This member is required.
    public var name: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeClientTypes.ChannelMode? = nil,
        name: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.metadata = metadata
        self.mode = mode
        self.name = name
    }
}

extension UpdateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), mode: \(Swift.String(describing: mode)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateChannelOutput {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

public struct UpdateChannelMessageInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?
    /// The content of the message being updated.
    public var content: Swift.String?
    /// The ID string of the message being updated.
    /// This member is required.
    public var messageId: Swift.String?
    /// The metadata of the message being updated.
    public var metadata: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        content: Swift.String? = nil,
        messageId: Swift.String? = nil,
        metadata: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.content = content
        self.messageId = messageId
        self.metadata = metadata
    }
}

extension UpdateChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), messageId: \(Swift.String(describing: messageId)), content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

public struct UpdateChannelMessageOutput {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID string of the message being updated.
    public var messageId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
    }
}

public struct UpdateChannelReadMarkerInput {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

public struct UpdateChannelReadMarkerOutput {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

public struct UpdateGlobalSettingsInput {
    /// The Amazon Chime Business Calling settings.
    public var businessCalling: ChimeClientTypes.BusinessCallingSettings?
    /// The Amazon Chime Voice Connector settings.
    public var voiceConnector: ChimeClientTypes.VoiceConnectorSettings?

    public init(
        businessCalling: ChimeClientTypes.BusinessCallingSettings? = nil,
        voiceConnector: ChimeClientTypes.VoiceConnectorSettings? = nil
    )
    {
        self.businessCalling = businessCalling
        self.voiceConnector = voiceConnector
    }
}

public struct UpdatePhoneNumberInput {
    /// The outbound calling name associated with the phone number.
    public var callingName: Swift.String?
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?
    /// The product type.
    public var productType: ChimeClientTypes.PhoneNumberProductType?

    public init(
        callingName: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        productType: ChimeClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.callingName = callingName
        self.phoneNumberId = phoneNumberId
        self.productType = productType
    }
}

extension UpdatePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberInput(phoneNumberId: \(Swift.String(describing: phoneNumberId)), productType: \(Swift.String(describing: productType)), callingName: \"CONTENT_REDACTED\")"}
}

public struct UpdatePhoneNumberOutput {
    /// The updated phone number details.
    public var phoneNumber: ChimeClientTypes.PhoneNumber?

    public init(
        phoneNumber: ChimeClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

public struct UpdatePhoneNumberSettingsInput {
    /// The default outbound calling name for the account.
    /// This member is required.
    public var callingName: Swift.String?

    public init(
        callingName: Swift.String? = nil
    )
    {
        self.callingName = callingName
    }
}

extension UpdatePhoneNumberSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberSettingsInput(callingName: \"CONTENT_REDACTED\")"}
}

public struct UpdateProxySessionInput {
    /// The proxy session capabilities.
    /// This member is required.
    public var capabilities: [ChimeClientTypes.Capability]?
    /// The number of minutes allowed for the proxy session.
    public var expiryMinutes: Swift.Int?
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Amazon Chime voice connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        capabilities: [ChimeClientTypes.Capability]? = nil,
        expiryMinutes: Swift.Int? = nil,
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.expiryMinutes = expiryMinutes
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct UpdateProxySessionOutput {
    /// The proxy session details.
    public var proxySession: ChimeClientTypes.ProxySession?

    public init(
        proxySession: ChimeClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

public struct UpdateRoomInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The room name.
    public var name: Swift.String?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        name: Swift.String? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.roomId = roomId
    }
}

extension UpdateRoomInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRoomInput(accountId: \(Swift.String(describing: accountId)), roomId: \(Swift.String(describing: roomId)), name: \"CONTENT_REDACTED\")"}
}

public struct UpdateRoomOutput {
    /// The room details.
    public var room: ChimeClientTypes.Room?

    public init(
        room: ChimeClientTypes.Room? = nil
    )
    {
        self.room = room
    }
}

public struct UpdateRoomMembershipInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The member ID.
    /// This member is required.
    public var memberId: Swift.String?
    /// The role of the member.
    public var role: ChimeClientTypes.RoomMembershipRole?
    /// The room ID.
    /// This member is required.
    public var roomId: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        role: ChimeClientTypes.RoomMembershipRole? = nil,
        roomId: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.memberId = memberId
        self.role = role
        self.roomId = roomId
    }
}

public struct UpdateRoomMembershipOutput {
    /// The room membership details.
    public var roomMembership: ChimeClientTypes.RoomMembership?

    public init(
        roomMembership: ChimeClientTypes.RoomMembership? = nil
    )
    {
        self.roomMembership = roomMembership
    }
}

public struct UpdateSipMediaApplicationInput {
    /// The new set of endpoints for the specified SIP media application.
    public var endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]?
    /// The new name for the specified SIP media application.
    public var name: Swift.String?
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        endpoints: [ChimeClientTypes.SipMediaApplicationEndpoint]? = nil,
        name: Swift.String? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.name = name
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

public struct UpdateSipMediaApplicationOutput {
    /// The updated SIP media application details.
    public var sipMediaApplication: ChimeClientTypes.SipMediaApplication?

    public init(
        sipMediaApplication: ChimeClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

public struct UpdateSipMediaApplicationCallInput {
    /// Arguments made available to the Lambda function as part of the CALL_UPDATE_REQUESTED event. Can contain 0-20 key-value pairs.
    /// This member is required.
    public var arguments: [Swift.String: Swift.String]?
    /// The ID of the SIP media application handling the call.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The ID of the call transaction.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        arguments: [Swift.String: Swift.String]? = nil,
        sipMediaApplicationId: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.arguments = arguments
        self.sipMediaApplicationId = sipMediaApplicationId
        self.transactionId = transactionId
    }
}

extension UpdateSipMediaApplicationCallInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSipMediaApplicationCallInput(sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)), transactionId: \(Swift.String(describing: transactionId)), arguments: \"CONTENT_REDACTED\")"}
}

public struct UpdateSipMediaApplicationCallOutput {
    /// A Call instance for a SIP media application.
    public var sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall?

    public init(
        sipMediaApplicationCall: ChimeClientTypes.SipMediaApplicationCall? = nil
    )
    {
        self.sipMediaApplicationCall = sipMediaApplicationCall
    }
}

public struct UpdateSipRuleInput {
    /// The new value specified to indicate whether the rule is disabled.
    public var disabled: Swift.Bool?
    /// The new name for the specified SIP rule.
    /// This member is required.
    public var name: Swift.String?
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?
    /// The new value of the list of target applications.
    public var targetApplications: [ChimeClientTypes.SipRuleTargetApplication]?

    public init(
        disabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        sipRuleId: Swift.String? = nil,
        targetApplications: [ChimeClientTypes.SipRuleTargetApplication]? = nil
    )
    {
        self.disabled = disabled
        self.name = name
        self.sipRuleId = sipRuleId
        self.targetApplications = targetApplications
    }
}

public struct UpdateSipRuleOutput {
    /// Updated SIP rule details.
    public var sipRule: ChimeClientTypes.SipRule?

    public init(
        sipRule: ChimeClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

public struct UpdateUserInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The Alexa for Business metadata.
    public var alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata?
    /// The user license type to update. This must be a supported license type for the Amazon Chime account that the user belongs to.
    public var licenseType: ChimeClientTypes.License?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?
    /// The user type.
    public var userType: ChimeClientTypes.UserType?

    public init(
        accountId: Swift.String? = nil,
        alexaForBusinessMetadata: ChimeClientTypes.AlexaForBusinessMetadata? = nil,
        licenseType: ChimeClientTypes.License? = nil,
        userId: Swift.String? = nil,
        userType: ChimeClientTypes.UserType? = nil
    )
    {
        self.accountId = accountId
        self.alexaForBusinessMetadata = alexaForBusinessMetadata
        self.licenseType = licenseType
        self.userId = userId
        self.userType = userType
    }
}

public struct UpdateUserOutput {
    /// The updated user details.
    public var user: ChimeClientTypes.User?

    public init(
        user: ChimeClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

public struct UpdateUserSettingsInput {
    /// The Amazon Chime account ID.
    /// This member is required.
    public var accountId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?
    /// The user settings to update.
    /// This member is required.
    public var userSettings: ChimeClientTypes.UserSettings?

    public init(
        accountId: Swift.String? = nil,
        userId: Swift.String? = nil,
        userSettings: ChimeClientTypes.UserSettings? = nil
    )
    {
        self.accountId = accountId
        self.userId = userId
        self.userSettings = userSettings
    }
}

public struct UpdateVoiceConnectorInput {
    /// The name of the Amazon Chime Voice Connector.
    /// This member is required.
    public var name: Swift.String?
    /// When enabled, requires encryption for the Amazon Chime Voice Connector.
    /// This member is required.
    public var requireEncryption: Swift.Bool?
    /// The Amazon Chime Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        name: Swift.String? = nil,
        requireEncryption: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.name = name
        self.requireEncryption = requireEncryption
        self.voiceConnectorId = voiceConnectorId
    }
}

public struct UpdateVoiceConnectorOutput {
    /// The updated Amazon Chime Voice Connector details.
    public var voiceConnector: ChimeClientTypes.VoiceConnector?

    public init(
        voiceConnector: ChimeClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

public struct UpdateVoiceConnectorGroupInput {
    /// The name of the Amazon Chime Voice Connector group.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Chime Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?
    /// The VoiceConnectorItems to associate with the group.
    /// This member is required.
    public var voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]?

    public init(
        name: Swift.String? = nil,
        voiceConnectorGroupId: Swift.String? = nil,
        voiceConnectorItems: [ChimeClientTypes.VoiceConnectorItem]? = nil
    )
    {
        self.name = name
        self.voiceConnectorGroupId = voiceConnectorGroupId
        self.voiceConnectorItems = voiceConnectorItems
    }
}

public struct UpdateVoiceConnectorGroupOutput {
    /// The updated Amazon Chime Voice Connector group details.
    public var voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup?

    public init(
        voiceConnectorGroup: ChimeClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

public struct ValidateE911AddressInput {
    /// The AWS account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The address city, such as Portland.
    /// This member is required.
    public var city: Swift.String?
    /// The address country, such as US.
    /// This member is required.
    public var country: Swift.String?
    /// The address postal code, such as 04352.
    /// This member is required.
    public var postalCode: Swift.String?
    /// The address state, such as ME.
    /// This member is required.
    public var state: Swift.String?
    /// The address street information, such as 8th Avenue.
    /// This member is required.
    public var streetInfo: Swift.String?
    /// The address street number, such as 200 or 2121.
    /// This member is required.
    public var streetNumber: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        city: Swift.String? = nil,
        country: Swift.String? = nil,
        postalCode: Swift.String? = nil,
        state: Swift.String? = nil,
        streetInfo: Swift.String? = nil,
        streetNumber: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.city = city
        self.country = country
        self.postalCode = postalCode
        self.state = state
        self.streetInfo = streetInfo
        self.streetNumber = streetNumber
    }
}

extension ValidateE911AddressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateE911AddressInput(awsAccountId: \(Swift.String(describing: awsAccountId)), city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetInfo: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\")"}
}

public struct ValidateE911AddressOutput {
    /// The validated address.
    public var address: ChimeClientTypes.Address?
    /// The ID that represents the address.
    public var addressExternalId: Swift.String?
    /// The list of address suggestions.
    public var candidateAddressList: [ChimeClientTypes.CandidateAddress]?
    /// Number indicating the result of address validation. 0 means the address was perfect as is and successfully validated. 1 means the address was corrected. 2 means the address sent was not close enough and was not validated.
    public var validationResult: Swift.Int

    public init(
        address: ChimeClientTypes.Address? = nil,
        addressExternalId: Swift.String? = nil,
        candidateAddressList: [ChimeClientTypes.CandidateAddress]? = nil,
        validationResult: Swift.Int = 0
    )
    {
        self.address = address
        self.addressExternalId = addressExternalId
        self.candidateAddressList = candidateAddressList
        self.validationResult = validationResult
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput {

    static func urlPathProvider(_ value: AssociatePhoneNumbersWithVoiceConnectorInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput {

    static func queryItemProvider(_ value: AssociatePhoneNumbersWithVoiceConnectorInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "associate-phone-numbers"))
        return items
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput {

    static func urlPathProvider(_ value: AssociatePhoneNumbersWithVoiceConnectorGroupInput) -> Swift.String? {
        guard let voiceConnectorGroupId = value.voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput {

    static func queryItemProvider(_ value: AssociatePhoneNumbersWithVoiceConnectorGroupInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "associate-phone-numbers"))
        return items
    }
}

extension AssociatePhoneNumberWithUserInput {

    static func urlPathProvider(_ value: AssociatePhoneNumberWithUserInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

extension AssociatePhoneNumberWithUserInput {

    static func queryItemProvider(_ value: AssociatePhoneNumberWithUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "associate-phone-number"))
        return items
    }
}

extension AssociateSigninDelegateGroupsWithAccountInput {

    static func urlPathProvider(_ value: AssociateSigninDelegateGroupsWithAccountInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())"
    }
}

extension AssociateSigninDelegateGroupsWithAccountInput {

    static func queryItemProvider(_ value: AssociateSigninDelegateGroupsWithAccountInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "associate-signin-delegate-groups"))
        return items
    }
}

extension BatchCreateAttendeeInput {

    static func urlPathProvider(_ value: BatchCreateAttendeeInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

extension BatchCreateAttendeeInput {

    static func queryItemProvider(_ value: BatchCreateAttendeeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "batch-create"))
        return items
    }
}

extension BatchCreateChannelMembershipInput {

    static func urlPathProvider(_ value: BatchCreateChannelMembershipInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

extension BatchCreateChannelMembershipInput {

    static func headerProvider(_ value: BatchCreateChannelMembershipInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension BatchCreateChannelMembershipInput {

    static func queryItemProvider(_ value: BatchCreateChannelMembershipInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "batch-create"))
        return items
    }
}

extension BatchCreateRoomMembershipInput {

    static func urlPathProvider(_ value: BatchCreateRoomMembershipInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let roomId = value.roomId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships"
    }
}

extension BatchCreateRoomMembershipInput {

    static func queryItemProvider(_ value: BatchCreateRoomMembershipInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "batch-create"))
        return items
    }
}

extension BatchDeletePhoneNumberInput {

    static func urlPathProvider(_ value: BatchDeletePhoneNumberInput) -> Swift.String? {
        return "/phone-numbers"
    }
}

extension BatchDeletePhoneNumberInput {

    static func queryItemProvider(_ value: BatchDeletePhoneNumberInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "batch-delete"))
        return items
    }
}

extension BatchSuspendUserInput {

    static func urlPathProvider(_ value: BatchSuspendUserInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users"
    }
}

extension BatchSuspendUserInput {

    static func queryItemProvider(_ value: BatchSuspendUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "suspend"))
        return items
    }
}

extension BatchUnsuspendUserInput {

    static func urlPathProvider(_ value: BatchUnsuspendUserInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users"
    }
}

extension BatchUnsuspendUserInput {

    static func queryItemProvider(_ value: BatchUnsuspendUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "unsuspend"))
        return items
    }
}

extension BatchUpdatePhoneNumberInput {

    static func urlPathProvider(_ value: BatchUpdatePhoneNumberInput) -> Swift.String? {
        return "/phone-numbers"
    }
}

extension BatchUpdatePhoneNumberInput {

    static func queryItemProvider(_ value: BatchUpdatePhoneNumberInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "batch-update"))
        return items
    }
}

extension BatchUpdateUserInput {

    static func urlPathProvider(_ value: BatchUpdateUserInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users"
    }
}

extension CreateAccountInput {

    static func urlPathProvider(_ value: CreateAccountInput) -> Swift.String? {
        return "/accounts"
    }
}

extension CreateAppInstanceInput {

    static func urlPathProvider(_ value: CreateAppInstanceInput) -> Swift.String? {
        return "/app-instances"
    }
}

extension CreateAppInstanceAdminInput {

    static func urlPathProvider(_ value: CreateAppInstanceAdminInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins"
    }
}

extension CreateAppInstanceUserInput {

    static func urlPathProvider(_ value: CreateAppInstanceUserInput) -> Swift.String? {
        return "/app-instance-users"
    }
}

extension CreateAttendeeInput {

    static func urlPathProvider(_ value: CreateAttendeeInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

extension CreateBotInput {

    static func urlPathProvider(_ value: CreateBotInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots"
    }
}

extension CreateChannelInput {

    static func urlPathProvider(_ value: CreateChannelInput) -> Swift.String? {
        return "/channels"
    }
}

extension CreateChannelInput {

    static func headerProvider(_ value: CreateChannelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelBanInput {

    static func urlPathProvider(_ value: CreateChannelBanInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans"
    }
}

extension CreateChannelBanInput {

    static func headerProvider(_ value: CreateChannelBanInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelMembershipInput {

    static func urlPathProvider(_ value: CreateChannelMembershipInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

extension CreateChannelMembershipInput {

    static func headerProvider(_ value: CreateChannelMembershipInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelModeratorInput {

    static func urlPathProvider(_ value: CreateChannelModeratorInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators"
    }
}

extension CreateChannelModeratorInput {

    static func headerProvider(_ value: CreateChannelModeratorInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateMediaCapturePipelineInput {

    static func urlPathProvider(_ value: CreateMediaCapturePipelineInput) -> Swift.String? {
        return "/media-capture-pipelines"
    }
}

extension CreateMeetingInput {

    static func urlPathProvider(_ value: CreateMeetingInput) -> Swift.String? {
        return "/meetings"
    }
}

extension CreateMeetingDialOutInput {

    static func urlPathProvider(_ value: CreateMeetingDialOutInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/dial-outs"
    }
}

extension CreateMeetingWithAttendeesInput {

    static func urlPathProvider(_ value: CreateMeetingWithAttendeesInput) -> Swift.String? {
        return "/meetings"
    }
}

extension CreateMeetingWithAttendeesInput {

    static func queryItemProvider(_ value: CreateMeetingWithAttendeesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "create-attendees"))
        return items
    }
}

extension CreatePhoneNumberOrderInput {

    static func urlPathProvider(_ value: CreatePhoneNumberOrderInput) -> Swift.String? {
        return "/phone-number-orders"
    }
}

extension CreateProxySessionInput {

    static func urlPathProvider(_ value: CreateProxySessionInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions"
    }
}

extension CreateRoomInput {

    static func urlPathProvider(_ value: CreateRoomInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms"
    }
}

extension CreateRoomMembershipInput {

    static func urlPathProvider(_ value: CreateRoomMembershipInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let roomId = value.roomId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships"
    }
}

extension CreateSipMediaApplicationInput {

    static func urlPathProvider(_ value: CreateSipMediaApplicationInput) -> Swift.String? {
        return "/sip-media-applications"
    }
}

extension CreateSipMediaApplicationCallInput {

    static func urlPathProvider(_ value: CreateSipMediaApplicationCallInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/calls"
    }
}

extension CreateSipRuleInput {

    static func urlPathProvider(_ value: CreateSipRuleInput) -> Swift.String? {
        return "/sip-rules"
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users"
    }
}

extension CreateUserInput {

    static func queryItemProvider(_ value: CreateUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "create"))
        return items
    }
}

extension CreateVoiceConnectorInput {

    static func urlPathProvider(_ value: CreateVoiceConnectorInput) -> Swift.String? {
        return "/voice-connectors"
    }
}

extension CreateVoiceConnectorGroupInput {

    static func urlPathProvider(_ value: CreateVoiceConnectorGroupInput) -> Swift.String? {
        return "/voice-connector-groups"
    }
}

extension DeleteAccountInput {

    static func urlPathProvider(_ value: DeleteAccountInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())"
    }
}

extension DeleteAppInstanceInput {

    static func urlPathProvider(_ value: DeleteAppInstanceInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())"
    }
}

extension DeleteAppInstanceAdminInput {

    static func urlPathProvider(_ value: DeleteAppInstanceAdminInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        guard let appInstanceAdminArn = value.appInstanceAdminArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins/\(appInstanceAdminArn.urlPercentEncoding())"
    }
}

extension DeleteAppInstanceStreamingConfigurationsInput {

    static func urlPathProvider(_ value: DeleteAppInstanceStreamingConfigurationsInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/streaming-configurations"
    }
}

extension DeleteAppInstanceUserInput {

    static func urlPathProvider(_ value: DeleteAppInstanceUserInput) -> Swift.String? {
        guard let appInstanceUserArn = value.appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
    }
}

extension DeleteAttendeeInput {

    static func urlPathProvider(_ value: DeleteAttendeeInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        guard let attendeeId = value.attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())"
    }
}

extension DeleteChannelInput {

    static func urlPathProvider(_ value: DeleteChannelInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

extension DeleteChannelInput {

    static func headerProvider(_ value: DeleteChannelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelBanInput {

    static func urlPathProvider(_ value: DeleteChannelBanInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let memberArn = value.memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
    }
}

extension DeleteChannelBanInput {

    static func headerProvider(_ value: DeleteChannelBanInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelMembershipInput {

    static func urlPathProvider(_ value: DeleteChannelMembershipInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let memberArn = value.memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
    }
}

extension DeleteChannelMembershipInput {

    static func headerProvider(_ value: DeleteChannelMembershipInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelMessageInput {

    static func urlPathProvider(_ value: DeleteChannelMessageInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let messageId = value.messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

extension DeleteChannelMessageInput {

    static func headerProvider(_ value: DeleteChannelMessageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelModeratorInput {

    static func urlPathProvider(_ value: DeleteChannelModeratorInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let channelModeratorArn = value.channelModeratorArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
    }
}

extension DeleteChannelModeratorInput {

    static func headerProvider(_ value: DeleteChannelModeratorInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteEventsConfigurationInput {

    static func urlPathProvider(_ value: DeleteEventsConfigurationInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let botId = value.botId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())/events-configuration"
    }
}

extension DeleteMediaCapturePipelineInput {

    static func urlPathProvider(_ value: DeleteMediaCapturePipelineInput) -> Swift.String? {
        guard let mediaPipelineId = value.mediaPipelineId else {
            return nil
        }
        return "/media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

extension DeleteMeetingInput {

    static func urlPathProvider(_ value: DeleteMeetingInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())"
    }
}

extension DeletePhoneNumberInput {

    static func urlPathProvider(_ value: DeletePhoneNumberInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

extension DeleteProxySessionInput {

    static func urlPathProvider(_ value: DeleteProxySessionInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = value.proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

extension DeleteRoomInput {

    static func urlPathProvider(_ value: DeleteRoomInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let roomId = value.roomId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())"
    }
}

extension DeleteRoomMembershipInput {

    static func urlPathProvider(_ value: DeleteRoomMembershipInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let roomId = value.roomId else {
            return nil
        }
        guard let memberId = value.memberId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships/\(memberId.urlPercentEncoding())"
    }
}

extension DeleteSipMediaApplicationInput {

    static func urlPathProvider(_ value: DeleteSipMediaApplicationInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

extension DeleteSipRuleInput {

    static func urlPathProvider(_ value: DeleteSipRuleInput) -> Swift.String? {
        guard let sipRuleId = value.sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

extension DeleteVoiceConnectorInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorEmergencyCallingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

extension DeleteVoiceConnectorGroupInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorGroupInput) -> Swift.String? {
        guard let voiceConnectorGroupId = value.voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

extension DeleteVoiceConnectorOriginationInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorOriginationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

extension DeleteVoiceConnectorProxyInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorProxyInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

extension DeleteVoiceConnectorStreamingConfigurationInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorStreamingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

extension DeleteVoiceConnectorTerminationInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorTerminationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorTerminationCredentialsInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput {

    static func queryItemProvider(_ value: DeleteVoiceConnectorTerminationCredentialsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "delete"))
        return items
    }
}

extension DescribeAppInstanceInput {

    static func urlPathProvider(_ value: DescribeAppInstanceInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())"
    }
}

extension DescribeAppInstanceAdminInput {

    static func urlPathProvider(_ value: DescribeAppInstanceAdminInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        guard let appInstanceAdminArn = value.appInstanceAdminArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins/\(appInstanceAdminArn.urlPercentEncoding())"
    }
}

extension DescribeAppInstanceUserInput {

    static func urlPathProvider(_ value: DescribeAppInstanceUserInput) -> Swift.String? {
        guard let appInstanceUserArn = value.appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
    }
}

extension DescribeChannelInput {

    static func urlPathProvider(_ value: DescribeChannelInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

extension DescribeChannelInput {

    static func headerProvider(_ value: DescribeChannelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelBanInput {

    static func urlPathProvider(_ value: DescribeChannelBanInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let memberArn = value.memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
    }
}

extension DescribeChannelBanInput {

    static func headerProvider(_ value: DescribeChannelBanInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelMembershipInput {

    static func urlPathProvider(_ value: DescribeChannelMembershipInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let memberArn = value.memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
    }
}

extension DescribeChannelMembershipInput {

    static func headerProvider(_ value: DescribeChannelMembershipInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput {

    static func urlPathProvider(_ value: DescribeChannelMembershipForAppInstanceUserInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput {

    static func headerProvider(_ value: DescribeChannelMembershipForAppInstanceUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput {

    static func queryItemProvider(_ value: DescribeChannelMembershipForAppInstanceUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "scope", value: "app-instance-user-membership"))
        guard let appInstanceUserArn = value.appInstanceUserArn else {
            let message = "Creating a URL Query Item failed. appInstanceUserArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appInstanceUserArnQueryItem = Smithy.URIQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
        items.append(appInstanceUserArnQueryItem)
        return items
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput {

    static func urlPathProvider(_ value: DescribeChannelModeratedByAppInstanceUserInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput {

    static func headerProvider(_ value: DescribeChannelModeratedByAppInstanceUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput {

    static func queryItemProvider(_ value: DescribeChannelModeratedByAppInstanceUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "scope", value: "app-instance-user-moderated-channel"))
        guard let appInstanceUserArn = value.appInstanceUserArn else {
            let message = "Creating a URL Query Item failed. appInstanceUserArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appInstanceUserArnQueryItem = Smithy.URIQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
        items.append(appInstanceUserArnQueryItem)
        return items
    }
}

extension DescribeChannelModeratorInput {

    static func urlPathProvider(_ value: DescribeChannelModeratorInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let channelModeratorArn = value.channelModeratorArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
    }
}

extension DescribeChannelModeratorInput {

    static func headerProvider(_ value: DescribeChannelModeratorInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DisassociatePhoneNumberFromUserInput {

    static func urlPathProvider(_ value: DisassociatePhoneNumberFromUserInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

extension DisassociatePhoneNumberFromUserInput {

    static func queryItemProvider(_ value: DisassociatePhoneNumberFromUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "disassociate-phone-number"))
        return items
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput {

    static func urlPathProvider(_ value: DisassociatePhoneNumbersFromVoiceConnectorInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput {

    static func queryItemProvider(_ value: DisassociatePhoneNumbersFromVoiceConnectorInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "disassociate-phone-numbers"))
        return items
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput {

    static func urlPathProvider(_ value: DisassociatePhoneNumbersFromVoiceConnectorGroupInput) -> Swift.String? {
        guard let voiceConnectorGroupId = value.voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput {

    static func queryItemProvider(_ value: DisassociatePhoneNumbersFromVoiceConnectorGroupInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "disassociate-phone-numbers"))
        return items
    }
}

extension DisassociateSigninDelegateGroupsFromAccountInput {

    static func urlPathProvider(_ value: DisassociateSigninDelegateGroupsFromAccountInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())"
    }
}

extension DisassociateSigninDelegateGroupsFromAccountInput {

    static func queryItemProvider(_ value: DisassociateSigninDelegateGroupsFromAccountInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "disassociate-signin-delegate-groups"))
        return items
    }
}

extension GetAccountInput {

    static func urlPathProvider(_ value: GetAccountInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())"
    }
}

extension GetAccountSettingsInput {

    static func urlPathProvider(_ value: GetAccountSettingsInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/settings"
    }
}

extension GetAppInstanceRetentionSettingsInput {

    static func urlPathProvider(_ value: GetAppInstanceRetentionSettingsInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/retention-settings"
    }
}

extension GetAppInstanceStreamingConfigurationsInput {

    static func urlPathProvider(_ value: GetAppInstanceStreamingConfigurationsInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/streaming-configurations"
    }
}

extension GetAttendeeInput {

    static func urlPathProvider(_ value: GetAttendeeInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        guard let attendeeId = value.attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())"
    }
}

extension GetBotInput {

    static func urlPathProvider(_ value: GetBotInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let botId = value.botId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())"
    }
}

extension GetChannelMessageInput {

    static func urlPathProvider(_ value: GetChannelMessageInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let messageId = value.messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

extension GetChannelMessageInput {

    static func headerProvider(_ value: GetChannelMessageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension GetEventsConfigurationInput {

    static func urlPathProvider(_ value: GetEventsConfigurationInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let botId = value.botId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())/events-configuration"
    }
}

extension GetGlobalSettingsInput {

    static func urlPathProvider(_ value: GetGlobalSettingsInput) -> Swift.String? {
        return "/settings"
    }
}

extension GetMediaCapturePipelineInput {

    static func urlPathProvider(_ value: GetMediaCapturePipelineInput) -> Swift.String? {
        guard let mediaPipelineId = value.mediaPipelineId else {
            return nil
        }
        return "/media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

extension GetMeetingInput {

    static func urlPathProvider(_ value: GetMeetingInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())"
    }
}

extension GetMessagingSessionEndpointInput {

    static func urlPathProvider(_ value: GetMessagingSessionEndpointInput) -> Swift.String? {
        return "/endpoints/messaging-session"
    }
}

extension GetPhoneNumberInput {

    static func urlPathProvider(_ value: GetPhoneNumberInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

extension GetPhoneNumberOrderInput {

    static func urlPathProvider(_ value: GetPhoneNumberOrderInput) -> Swift.String? {
        guard let phoneNumberOrderId = value.phoneNumberOrderId else {
            return nil
        }
        return "/phone-number-orders/\(phoneNumberOrderId.urlPercentEncoding())"
    }
}

extension GetPhoneNumberSettingsInput {

    static func urlPathProvider(_ value: GetPhoneNumberSettingsInput) -> Swift.String? {
        return "/settings/phone-number"
    }
}

extension GetProxySessionInput {

    static func urlPathProvider(_ value: GetProxySessionInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = value.proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

extension GetRetentionSettingsInput {

    static func urlPathProvider(_ value: GetRetentionSettingsInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/retention-settings"
    }
}

extension GetRoomInput {

    static func urlPathProvider(_ value: GetRoomInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let roomId = value.roomId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())"
    }
}

extension GetSipMediaApplicationInput {

    static func urlPathProvider(_ value: GetSipMediaApplicationInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

extension GetSipMediaApplicationLoggingConfigurationInput {

    static func urlPathProvider(_ value: GetSipMediaApplicationLoggingConfigurationInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/logging-configuration"
    }
}

extension GetSipRuleInput {

    static func urlPathProvider(_ value: GetSipRuleInput) -> Swift.String? {
        guard let sipRuleId = value.sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

extension GetUserInput {

    static func urlPathProvider(_ value: GetUserInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

extension GetUserSettingsInput {

    static func urlPathProvider(_ value: GetUserSettingsInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())/settings"
    }
}

extension GetVoiceConnectorInput {

    static func urlPathProvider(_ value: GetVoiceConnectorInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationInput {

    static func urlPathProvider(_ value: GetVoiceConnectorEmergencyCallingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

extension GetVoiceConnectorGroupInput {

    static func urlPathProvider(_ value: GetVoiceConnectorGroupInput) -> Swift.String? {
        guard let voiceConnectorGroupId = value.voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

extension GetVoiceConnectorLoggingConfigurationInput {

    static func urlPathProvider(_ value: GetVoiceConnectorLoggingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/logging-configuration"
    }
}

extension GetVoiceConnectorOriginationInput {

    static func urlPathProvider(_ value: GetVoiceConnectorOriginationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

extension GetVoiceConnectorProxyInput {

    static func urlPathProvider(_ value: GetVoiceConnectorProxyInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

extension GetVoiceConnectorStreamingConfigurationInput {

    static func urlPathProvider(_ value: GetVoiceConnectorStreamingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

extension GetVoiceConnectorTerminationInput {

    static func urlPathProvider(_ value: GetVoiceConnectorTerminationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

extension GetVoiceConnectorTerminationHealthInput {

    static func urlPathProvider(_ value: GetVoiceConnectorTerminationHealthInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/health"
    }
}

extension InviteUsersInput {

    static func urlPathProvider(_ value: InviteUsersInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users"
    }
}

extension InviteUsersInput {

    static func queryItemProvider(_ value: InviteUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "add"))
        return items
    }
}

extension ListAccountsInput {

    static func urlPathProvider(_ value: ListAccountsInput) -> Swift.String? {
        return "/accounts"
    }
}

extension ListAccountsInput {

    static func queryItemProvider(_ value: ListAccountsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let userEmail = value.userEmail {
            let userEmailQueryItem = Smithy.URIQueryItem(name: "user-email".urlPercentEncoding(), value: Swift.String(userEmail).urlPercentEncoding())
            items.append(userEmailQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        return items
    }
}

extension ListAppInstanceAdminsInput {

    static func urlPathProvider(_ value: ListAppInstanceAdminsInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins"
    }
}

extension ListAppInstanceAdminsInput {

    static func queryItemProvider(_ value: ListAppInstanceAdminsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAppInstancesInput {

    static func urlPathProvider(_ value: ListAppInstancesInput) -> Swift.String? {
        return "/app-instances"
    }
}

extension ListAppInstancesInput {

    static func queryItemProvider(_ value: ListAppInstancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAppInstanceUsersInput {

    static func urlPathProvider(_ value: ListAppInstanceUsersInput) -> Swift.String? {
        return "/app-instance-users"
    }
}

extension ListAppInstanceUsersInput {

    static func queryItemProvider(_ value: ListAppInstanceUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let appInstanceArn = value.appInstanceArn else {
            let message = "Creating a URL Query Item failed. appInstanceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appInstanceArnQueryItem = Smithy.URIQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
        items.append(appInstanceArnQueryItem)
        return items
    }
}

extension ListAttendeesInput {

    static func urlPathProvider(_ value: ListAttendeesInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

extension ListAttendeesInput {

    static func queryItemProvider(_ value: ListAttendeesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAttendeeTagsInput {

    static func urlPathProvider(_ value: ListAttendeeTagsInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        guard let attendeeId = value.attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())/tags"
    }
}

extension ListBotsInput {

    static func urlPathProvider(_ value: ListBotsInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots"
    }
}

extension ListBotsInput {

    static func queryItemProvider(_ value: ListBotsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelBansInput {

    static func urlPathProvider(_ value: ListChannelBansInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans"
    }
}

extension ListChannelBansInput {

    static func headerProvider(_ value: ListChannelBansInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelBansInput {

    static func queryItemProvider(_ value: ListChannelBansInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelMembershipsInput {

    static func urlPathProvider(_ value: ListChannelMembershipsInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

extension ListChannelMembershipsInput {

    static func headerProvider(_ value: ListChannelMembershipsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMembershipsInput {

    static func queryItemProvider(_ value: ListChannelMembershipsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelMembershipsForAppInstanceUserInput {

    static func urlPathProvider(_ value: ListChannelMembershipsForAppInstanceUserInput) -> Swift.String? {
        return "/channels"
    }
}

extension ListChannelMembershipsForAppInstanceUserInput {

    static func headerProvider(_ value: ListChannelMembershipsForAppInstanceUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMembershipsForAppInstanceUserInput {

    static func queryItemProvider(_ value: ListChannelMembershipsForAppInstanceUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "scope", value: "app-instance-user-memberships"))
        if let appInstanceUserArn = value.appInstanceUserArn {
            let appInstanceUserArnQueryItem = Smithy.URIQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            items.append(appInstanceUserArnQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelMessagesInput {

    static func urlPathProvider(_ value: ListChannelMessagesInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages"
    }
}

extension ListChannelMessagesInput {

    static func headerProvider(_ value: ListChannelMessagesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMessagesInput {

    static func queryItemProvider(_ value: ListChannelMessagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sort-order".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let notBefore = value.notBefore {
            let notBeforeQueryItem = Smithy.URIQueryItem(name: "not-before".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: notBefore)).urlPercentEncoding())
            items.append(notBeforeQueryItem)
        }
        if let notAfter = value.notAfter {
            let notAfterQueryItem = Smithy.URIQueryItem(name: "not-after".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: notAfter)).urlPercentEncoding())
            items.append(notAfterQueryItem)
        }
        return items
    }
}

extension ListChannelModeratorsInput {

    static func urlPathProvider(_ value: ListChannelModeratorsInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators"
    }
}

extension ListChannelModeratorsInput {

    static func headerProvider(_ value: ListChannelModeratorsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelModeratorsInput {

    static func queryItemProvider(_ value: ListChannelModeratorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelsInput {

    static func urlPathProvider(_ value: ListChannelsInput) -> Swift.String? {
        return "/channels"
    }
}

extension ListChannelsInput {

    static func headerProvider(_ value: ListChannelsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelsInput {

    static func queryItemProvider(_ value: ListChannelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let privacy = value.privacy {
            let privacyQueryItem = Smithy.URIQueryItem(name: "privacy".urlPercentEncoding(), value: Swift.String(privacy.rawValue).urlPercentEncoding())
            items.append(privacyQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let appInstanceArn = value.appInstanceArn else {
            let message = "Creating a URL Query Item failed. appInstanceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appInstanceArnQueryItem = Smithy.URIQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
        items.append(appInstanceArnQueryItem)
        return items
    }
}

extension ListChannelsModeratedByAppInstanceUserInput {

    static func urlPathProvider(_ value: ListChannelsModeratedByAppInstanceUserInput) -> Swift.String? {
        return "/channels"
    }
}

extension ListChannelsModeratedByAppInstanceUserInput {

    static func headerProvider(_ value: ListChannelsModeratedByAppInstanceUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelsModeratedByAppInstanceUserInput {

    static func queryItemProvider(_ value: ListChannelsModeratedByAppInstanceUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "scope", value: "app-instance-user-moderated-channels"))
        if let appInstanceUserArn = value.appInstanceUserArn {
            let appInstanceUserArnQueryItem = Smithy.URIQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            items.append(appInstanceUserArnQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMediaCapturePipelinesInput {

    static func urlPathProvider(_ value: ListMediaCapturePipelinesInput) -> Swift.String? {
        return "/media-capture-pipelines"
    }
}

extension ListMediaCapturePipelinesInput {

    static func queryItemProvider(_ value: ListMediaCapturePipelinesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMeetingsInput {

    static func urlPathProvider(_ value: ListMeetingsInput) -> Swift.String? {
        return "/meetings"
    }
}

extension ListMeetingsInput {

    static func queryItemProvider(_ value: ListMeetingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMeetingTagsInput {

    static func urlPathProvider(_ value: ListMeetingTagsInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/tags"
    }
}

extension ListPhoneNumberOrdersInput {

    static func urlPathProvider(_ value: ListPhoneNumberOrdersInput) -> Swift.String? {
        return "/phone-number-orders"
    }
}

extension ListPhoneNumberOrdersInput {

    static func queryItemProvider(_ value: ListPhoneNumberOrdersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPhoneNumbersInput {

    static func urlPathProvider(_ value: ListPhoneNumbersInput) -> Swift.String? {
        return "/phone-numbers"
    }
}

extension ListPhoneNumbersInput {

    static func queryItemProvider(_ value: ListPhoneNumbersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let productType = value.productType {
            let productTypeQueryItem = Smithy.URIQueryItem(name: "product-type".urlPercentEncoding(), value: Swift.String(productType.rawValue).urlPercentEncoding())
            items.append(productTypeQueryItem)
        }
        if let filterName = value.filterName {
            let filterNameQueryItem = Smithy.URIQueryItem(name: "filter-name".urlPercentEncoding(), value: Swift.String(filterName.rawValue).urlPercentEncoding())
            items.append(filterNameQueryItem)
        }
        if let filterValue = value.filterValue {
            let filterValueQueryItem = Smithy.URIQueryItem(name: "filter-value".urlPercentEncoding(), value: Swift.String(filterValue).urlPercentEncoding())
            items.append(filterValueQueryItem)
        }
        return items
    }
}

extension ListProxySessionsInput {

    static func urlPathProvider(_ value: ListProxySessionsInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions"
    }
}

extension ListProxySessionsInput {

    static func queryItemProvider(_ value: ListProxySessionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRoomMembershipsInput {

    static func urlPathProvider(_ value: ListRoomMembershipsInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let roomId = value.roomId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships"
    }
}

extension ListRoomMembershipsInput {

    static func queryItemProvider(_ value: ListRoomMembershipsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRoomsInput {

    static func urlPathProvider(_ value: ListRoomsInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms"
    }
}

extension ListRoomsInput {

    static func queryItemProvider(_ value: ListRoomsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let memberId = value.memberId {
            let memberIdQueryItem = Smithy.URIQueryItem(name: "member-id".urlPercentEncoding(), value: Swift.String(memberId).urlPercentEncoding())
            items.append(memberIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSipMediaApplicationsInput {

    static func urlPathProvider(_ value: ListSipMediaApplicationsInput) -> Swift.String? {
        return "/sip-media-applications"
    }
}

extension ListSipMediaApplicationsInput {

    static func queryItemProvider(_ value: ListSipMediaApplicationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSipRulesInput {

    static func urlPathProvider(_ value: ListSipRulesInput) -> Swift.String? {
        return "/sip-rules"
    }
}

extension ListSipRulesInput {

    static func queryItemProvider(_ value: ListSipRulesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sipMediaApplicationId = value.sipMediaApplicationId {
            let sipMediaApplicationIdQueryItem = Smithy.URIQueryItem(name: "sip-media-application".urlPercentEncoding(), value: Swift.String(sipMediaApplicationId).urlPercentEncoding())
            items.append(sipMediaApplicationIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSupportedPhoneNumberCountriesInput {

    static func urlPathProvider(_ value: ListSupportedPhoneNumberCountriesInput) -> Swift.String? {
        return "/phone-number-countries"
    }
}

extension ListSupportedPhoneNumberCountriesInput {

    static func queryItemProvider(_ value: ListSupportedPhoneNumberCountriesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let productType = value.productType else {
            let message = "Creating a URL Query Item failed. productType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let productTypeQueryItem = Smithy.URIQueryItem(name: "product-type".urlPercentEncoding(), value: Swift.String(productType.rawValue).urlPercentEncoding())
        items.append(productTypeQueryItem)
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceARN = value.resourceARN else {
            let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceARNQueryItem = Smithy.URIQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
        items.append(resourceARNQueryItem)
        return items
    }
}

extension ListUsersInput {

    static func urlPathProvider(_ value: ListUsersInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users"
    }
}

extension ListUsersInput {

    static func queryItemProvider(_ value: ListUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let userEmail = value.userEmail {
            let userEmailQueryItem = Smithy.URIQueryItem(name: "user-email".urlPercentEncoding(), value: Swift.String(userEmail).urlPercentEncoding())
            items.append(userEmailQueryItem)
        }
        if let userType = value.userType {
            let userTypeQueryItem = Smithy.URIQueryItem(name: "user-type".urlPercentEncoding(), value: Swift.String(userType.rawValue).urlPercentEncoding())
            items.append(userTypeQueryItem)
        }
        return items
    }
}

extension ListVoiceConnectorGroupsInput {

    static func urlPathProvider(_ value: ListVoiceConnectorGroupsInput) -> Swift.String? {
        return "/voice-connector-groups"
    }
}

extension ListVoiceConnectorGroupsInput {

    static func queryItemProvider(_ value: ListVoiceConnectorGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListVoiceConnectorsInput {

    static func urlPathProvider(_ value: ListVoiceConnectorsInput) -> Swift.String? {
        return "/voice-connectors"
    }
}

extension ListVoiceConnectorsInput {

    static func queryItemProvider(_ value: ListVoiceConnectorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListVoiceConnectorTerminationCredentialsInput {

    static func urlPathProvider(_ value: ListVoiceConnectorTerminationCredentialsInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

extension LogoutUserInput {

    static func urlPathProvider(_ value: LogoutUserInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

extension LogoutUserInput {

    static func queryItemProvider(_ value: LogoutUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "logout"))
        return items
    }
}

extension PutAppInstanceRetentionSettingsInput {

    static func urlPathProvider(_ value: PutAppInstanceRetentionSettingsInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/retention-settings"
    }
}

extension PutAppInstanceStreamingConfigurationsInput {

    static func urlPathProvider(_ value: PutAppInstanceStreamingConfigurationsInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/streaming-configurations"
    }
}

extension PutEventsConfigurationInput {

    static func urlPathProvider(_ value: PutEventsConfigurationInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let botId = value.botId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())/events-configuration"
    }
}

extension PutRetentionSettingsInput {

    static func urlPathProvider(_ value: PutRetentionSettingsInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/retention-settings"
    }
}

extension PutSipMediaApplicationLoggingConfigurationInput {

    static func urlPathProvider(_ value: PutSipMediaApplicationLoggingConfigurationInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/logging-configuration"
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationInput {

    static func urlPathProvider(_ value: PutVoiceConnectorEmergencyCallingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

extension PutVoiceConnectorLoggingConfigurationInput {

    static func urlPathProvider(_ value: PutVoiceConnectorLoggingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/logging-configuration"
    }
}

extension PutVoiceConnectorOriginationInput {

    static func urlPathProvider(_ value: PutVoiceConnectorOriginationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

extension PutVoiceConnectorProxyInput {

    static func urlPathProvider(_ value: PutVoiceConnectorProxyInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

extension PutVoiceConnectorStreamingConfigurationInput {

    static func urlPathProvider(_ value: PutVoiceConnectorStreamingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

extension PutVoiceConnectorTerminationInput {

    static func urlPathProvider(_ value: PutVoiceConnectorTerminationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

extension PutVoiceConnectorTerminationCredentialsInput {

    static func urlPathProvider(_ value: PutVoiceConnectorTerminationCredentialsInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

extension PutVoiceConnectorTerminationCredentialsInput {

    static func queryItemProvider(_ value: PutVoiceConnectorTerminationCredentialsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "put"))
        return items
    }
}

extension RedactChannelMessageInput {

    static func urlPathProvider(_ value: RedactChannelMessageInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let messageId = value.messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

extension RedactChannelMessageInput {

    static func headerProvider(_ value: RedactChannelMessageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension RedactChannelMessageInput {

    static func queryItemProvider(_ value: RedactChannelMessageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "redact"))
        return items
    }
}

extension RedactConversationMessageInput {

    static func urlPathProvider(_ value: RedactConversationMessageInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let conversationId = value.conversationId else {
            return nil
        }
        guard let messageId = value.messageId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/conversations/\(conversationId.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

extension RedactConversationMessageInput {

    static func queryItemProvider(_ value: RedactConversationMessageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "redact"))
        return items
    }
}

extension RedactRoomMessageInput {

    static func urlPathProvider(_ value: RedactRoomMessageInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let roomId = value.roomId else {
            return nil
        }
        guard let messageId = value.messageId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

extension RedactRoomMessageInput {

    static func queryItemProvider(_ value: RedactRoomMessageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "redact"))
        return items
    }
}

extension RegenerateSecurityTokenInput {

    static func urlPathProvider(_ value: RegenerateSecurityTokenInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let botId = value.botId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())"
    }
}

extension RegenerateSecurityTokenInput {

    static func queryItemProvider(_ value: RegenerateSecurityTokenInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "regenerate-security-token"))
        return items
    }
}

extension ResetPersonalPINInput {

    static func urlPathProvider(_ value: ResetPersonalPINInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

extension ResetPersonalPINInput {

    static func queryItemProvider(_ value: ResetPersonalPINInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "reset-personal-pin"))
        return items
    }
}

extension RestorePhoneNumberInput {

    static func urlPathProvider(_ value: RestorePhoneNumberInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

extension RestorePhoneNumberInput {

    static func queryItemProvider(_ value: RestorePhoneNumberInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "restore"))
        return items
    }
}

extension SearchAvailablePhoneNumbersInput {

    static func urlPathProvider(_ value: SearchAvailablePhoneNumbersInput) -> Swift.String? {
        return "/search"
    }
}

extension SearchAvailablePhoneNumbersInput {

    static func queryItemProvider(_ value: SearchAvailablePhoneNumbersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "type", value: "phone-numbers"))
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let state = value.state {
            let stateQueryItem = Smithy.URIQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let areaCode = value.areaCode {
            let areaCodeQueryItem = Smithy.URIQueryItem(name: "area-code".urlPercentEncoding(), value: Swift.String(areaCode).urlPercentEncoding())
            items.append(areaCodeQueryItem)
        }
        if let country = value.country {
            let countryQueryItem = Smithy.URIQueryItem(name: "country".urlPercentEncoding(), value: Swift.String(country).urlPercentEncoding())
            items.append(countryQueryItem)
        }
        if let city = value.city {
            let cityQueryItem = Smithy.URIQueryItem(name: "city".urlPercentEncoding(), value: Swift.String(city).urlPercentEncoding())
            items.append(cityQueryItem)
        }
        if let phoneNumberType = value.phoneNumberType {
            let phoneNumberTypeQueryItem = Smithy.URIQueryItem(name: "phone-number-type".urlPercentEncoding(), value: Swift.String(phoneNumberType.rawValue).urlPercentEncoding())
            items.append(phoneNumberTypeQueryItem)
        }
        if let tollFreePrefix = value.tollFreePrefix {
            let tollFreePrefixQueryItem = Smithy.URIQueryItem(name: "toll-free-prefix".urlPercentEncoding(), value: Swift.String(tollFreePrefix).urlPercentEncoding())
            items.append(tollFreePrefixQueryItem)
        }
        return items
    }
}

extension SendChannelMessageInput {

    static func urlPathProvider(_ value: SendChannelMessageInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages"
    }
}

extension SendChannelMessageInput {

    static func headerProvider(_ value: SendChannelMessageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension StartMeetingTranscriptionInput {

    static func urlPathProvider(_ value: StartMeetingTranscriptionInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/transcription"
    }
}

extension StartMeetingTranscriptionInput {

    static func queryItemProvider(_ value: StartMeetingTranscriptionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "start"))
        return items
    }
}

extension StopMeetingTranscriptionInput {

    static func urlPathProvider(_ value: StopMeetingTranscriptionInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/transcription"
    }
}

extension StopMeetingTranscriptionInput {

    static func queryItemProvider(_ value: StopMeetingTranscriptionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "stop"))
        return items
    }
}

extension TagAttendeeInput {

    static func urlPathProvider(_ value: TagAttendeeInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        guard let attendeeId = value.attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())/tags"
    }
}

extension TagAttendeeInput {

    static func queryItemProvider(_ value: TagAttendeeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "add"))
        return items
    }
}

extension TagMeetingInput {

    static func urlPathProvider(_ value: TagMeetingInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/tags"
    }
}

extension TagMeetingInput {

    static func queryItemProvider(_ value: TagMeetingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "add"))
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "tag-resource"))
        return items
    }
}

extension UntagAttendeeInput {

    static func urlPathProvider(_ value: UntagAttendeeInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        guard let attendeeId = value.attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())/tags"
    }
}

extension UntagAttendeeInput {

    static func queryItemProvider(_ value: UntagAttendeeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "delete"))
        return items
    }
}

extension UntagMeetingInput {

    static func urlPathProvider(_ value: UntagMeetingInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/tags"
    }
}

extension UntagMeetingInput {

    static func queryItemProvider(_ value: UntagMeetingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "delete"))
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "untag-resource"))
        return items
    }
}

extension UpdateAccountInput {

    static func urlPathProvider(_ value: UpdateAccountInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())"
    }
}

extension UpdateAccountSettingsInput {

    static func urlPathProvider(_ value: UpdateAccountSettingsInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/settings"
    }
}

extension UpdateAppInstanceInput {

    static func urlPathProvider(_ value: UpdateAppInstanceInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())"
    }
}

extension UpdateAppInstanceUserInput {

    static func urlPathProvider(_ value: UpdateAppInstanceUserInput) -> Swift.String? {
        guard let appInstanceUserArn = value.appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
    }
}

extension UpdateBotInput {

    static func urlPathProvider(_ value: UpdateBotInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let botId = value.botId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/bots/\(botId.urlPercentEncoding())"
    }
}

extension UpdateChannelInput {

    static func urlPathProvider(_ value: UpdateChannelInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

extension UpdateChannelInput {

    static func headerProvider(_ value: UpdateChannelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelMessageInput {

    static func urlPathProvider(_ value: UpdateChannelMessageInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let messageId = value.messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

extension UpdateChannelMessageInput {

    static func headerProvider(_ value: UpdateChannelMessageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelReadMarkerInput {

    static func urlPathProvider(_ value: UpdateChannelReadMarkerInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/readMarker"
    }
}

extension UpdateChannelReadMarkerInput {

    static func headerProvider(_ value: UpdateChannelReadMarkerInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateGlobalSettingsInput {

    static func urlPathProvider(_ value: UpdateGlobalSettingsInput) -> Swift.String? {
        return "/settings"
    }
}

extension UpdatePhoneNumberInput {

    static func urlPathProvider(_ value: UpdatePhoneNumberInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

extension UpdatePhoneNumberSettingsInput {

    static func urlPathProvider(_ value: UpdatePhoneNumberSettingsInput) -> Swift.String? {
        return "/settings/phone-number"
    }
}

extension UpdateProxySessionInput {

    static func urlPathProvider(_ value: UpdateProxySessionInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = value.proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

extension UpdateRoomInput {

    static func urlPathProvider(_ value: UpdateRoomInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let roomId = value.roomId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())"
    }
}

extension UpdateRoomMembershipInput {

    static func urlPathProvider(_ value: UpdateRoomMembershipInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let roomId = value.roomId else {
            return nil
        }
        guard let memberId = value.memberId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/rooms/\(roomId.urlPercentEncoding())/memberships/\(memberId.urlPercentEncoding())"
    }
}

extension UpdateSipMediaApplicationInput {

    static func urlPathProvider(_ value: UpdateSipMediaApplicationInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

extension UpdateSipMediaApplicationCallInput {

    static func urlPathProvider(_ value: UpdateSipMediaApplicationCallInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        guard let transactionId = value.transactionId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/calls/\(transactionId.urlPercentEncoding())"
    }
}

extension UpdateSipRuleInput {

    static func urlPathProvider(_ value: UpdateSipRuleInput) -> Swift.String? {
        guard let sipRuleId = value.sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

extension UpdateUserInput {

    static func urlPathProvider(_ value: UpdateUserInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

extension UpdateUserSettingsInput {

    static func urlPathProvider(_ value: UpdateUserSettingsInput) -> Swift.String? {
        guard let accountId = value.accountId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/accounts/\(accountId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())/settings"
    }
}

extension UpdateVoiceConnectorInput {

    static func urlPathProvider(_ value: UpdateVoiceConnectorInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

extension UpdateVoiceConnectorGroupInput {

    static func urlPathProvider(_ value: UpdateVoiceConnectorGroupInput) -> Swift.String? {
        guard let voiceConnectorGroupId = value.voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

extension ValidateE911AddressInput {

    static func urlPathProvider(_ value: ValidateE911AddressInput) -> Swift.String? {
        return "/emergency-calling/address"
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput {

    static func write(value: AssociatePhoneNumbersWithVoiceConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["E164PhoneNumbers"].writeList(value.e164PhoneNumbers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ForceAssociate"].write(value.forceAssociate)
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput {

    static func write(value: AssociatePhoneNumbersWithVoiceConnectorGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["E164PhoneNumbers"].writeList(value.e164PhoneNumbers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ForceAssociate"].write(value.forceAssociate)
    }
}

extension AssociatePhoneNumberWithUserInput {

    static func write(value: AssociatePhoneNumberWithUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["E164PhoneNumber"].write(value.e164PhoneNumber)
    }
}

extension AssociateSigninDelegateGroupsWithAccountInput {

    static func write(value: AssociateSigninDelegateGroupsWithAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SigninDelegateGroups"].writeList(value.signinDelegateGroups, memberWritingClosure: ChimeClientTypes.SigninDelegateGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchCreateAttendeeInput {

    static func write(value: BatchCreateAttendeeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attendees"].writeList(value.attendees, memberWritingClosure: ChimeClientTypes.CreateAttendeeRequestItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchCreateChannelMembershipInput {

    static func write(value: BatchCreateChannelMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MemberArns"].writeList(value.memberArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension BatchCreateRoomMembershipInput {

    static func write(value: BatchCreateRoomMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MembershipItemList"].writeList(value.membershipItemList, memberWritingClosure: ChimeClientTypes.MembershipItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeletePhoneNumberInput {

    static func write(value: BatchDeletePhoneNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PhoneNumberIds"].writeList(value.phoneNumberIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchSuspendUserInput {

    static func write(value: BatchSuspendUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserIdList"].writeList(value.userIdList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUnsuspendUserInput {

    static func write(value: BatchUnsuspendUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserIdList"].writeList(value.userIdList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdatePhoneNumberInput {

    static func write(value: BatchUpdatePhoneNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UpdatePhoneNumberRequestItems"].writeList(value.updatePhoneNumberRequestItems, memberWritingClosure: ChimeClientTypes.UpdatePhoneNumberRequestItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateUserInput {

    static func write(value: BatchUpdateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UpdateUserRequestItems"].writeList(value.updateUserRequestItems, memberWritingClosure: ChimeClientTypes.UpdateUserRequestItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAccountInput {

    static func write(value: CreateAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension CreateAppInstanceInput {

    static func write(value: CreateAppInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Metadata"].write(value.metadata)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAppInstanceAdminInput {

    static func write(value: CreateAppInstanceAdminInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppInstanceAdminArn"].write(value.appInstanceAdminArn)
    }
}

extension CreateAppInstanceUserInput {

    static func write(value: CreateAppInstanceUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppInstanceArn"].write(value.appInstanceArn)
        try writer["AppInstanceUserId"].write(value.appInstanceUserId)
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Metadata"].write(value.metadata)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAttendeeInput {

    static func write(value: CreateAttendeeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExternalUserId"].write(value.externalUserId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateBotInput {

    static func write(value: CreateBotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayName"].write(value.displayName)
        try writer["Domain"].write(value.domain)
    }
}

extension CreateChannelInput {

    static func write(value: CreateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppInstanceArn"].write(value.appInstanceArn)
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Metadata"].write(value.metadata)
        try writer["Mode"].write(value.mode)
        try writer["Name"].write(value.name)
        try writer["Privacy"].write(value.privacy)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateChannelBanInput {

    static func write(value: CreateChannelBanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MemberArn"].write(value.memberArn)
    }
}

extension CreateChannelMembershipInput {

    static func write(value: CreateChannelMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MemberArn"].write(value.memberArn)
        try writer["Type"].write(value.type)
    }
}

extension CreateChannelModeratorInput {

    static func write(value: CreateChannelModeratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelModeratorArn"].write(value.channelModeratorArn)
    }
}

extension CreateMediaCapturePipelineInput {

    static func write(value: CreateMediaCapturePipelineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChimeSdkMeetingConfiguration"].write(value.chimeSdkMeetingConfiguration, with: ChimeClientTypes.ChimeSdkMeetingConfiguration.write(value:to:))
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["SinkArn"].write(value.sinkArn)
        try writer["SinkType"].write(value.sinkType)
        try writer["SourceArn"].write(value.sourceArn)
        try writer["SourceType"].write(value.sourceType)
    }
}

extension CreateMeetingInput {

    static func write(value: CreateMeetingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["ExternalMeetingId"].write(value.externalMeetingId)
        try writer["MediaRegion"].write(value.mediaRegion)
        try writer["MeetingHostId"].write(value.meetingHostId)
        try writer["NotificationsConfiguration"].write(value.notificationsConfiguration, with: ChimeClientTypes.MeetingNotificationConfiguration.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMeetingDialOutInput {

    static func write(value: CreateMeetingDialOutInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromPhoneNumber"].write(value.fromPhoneNumber)
        try writer["JoinToken"].write(value.joinToken)
        try writer["ToPhoneNumber"].write(value.toPhoneNumber)
    }
}

extension CreateMeetingWithAttendeesInput {

    static func write(value: CreateMeetingWithAttendeesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attendees"].writeList(value.attendees, memberWritingClosure: ChimeClientTypes.CreateAttendeeRequestItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["ExternalMeetingId"].write(value.externalMeetingId)
        try writer["MediaRegion"].write(value.mediaRegion)
        try writer["MeetingHostId"].write(value.meetingHostId)
        try writer["NotificationsConfiguration"].write(value.notificationsConfiguration, with: ChimeClientTypes.MeetingNotificationConfiguration.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePhoneNumberOrderInput {

    static func write(value: CreatePhoneNumberOrderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["E164PhoneNumbers"].writeList(value.e164PhoneNumbers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProductType"].write(value.productType)
    }
}

extension CreateProxySessionInput {

    static func write(value: CreateProxySessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ChimeClientTypes.Capability>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExpiryMinutes"].write(value.expiryMinutes)
        try writer["GeoMatchLevel"].write(value.geoMatchLevel)
        try writer["GeoMatchParams"].write(value.geoMatchParams, with: ChimeClientTypes.GeoMatchParams.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["NumberSelectionBehavior"].write(value.numberSelectionBehavior)
        try writer["ParticipantPhoneNumbers"].writeList(value.participantPhoneNumbers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateRoomInput {

    static func write(value: CreateRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Name"].write(value.name)
    }
}

extension CreateRoomMembershipInput {

    static func write(value: CreateRoomMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MemberId"].write(value.memberId)
        try writer["Role"].write(value.role)
    }
}

extension CreateSipMediaApplicationInput {

    static func write(value: CreateSipMediaApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["Endpoints"].writeList(value.endpoints, memberWritingClosure: ChimeClientTypes.SipMediaApplicationEndpoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }
}

extension CreateSipMediaApplicationCallInput {

    static func write(value: CreateSipMediaApplicationCallInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromPhoneNumber"].write(value.fromPhoneNumber)
        try writer["SipHeaders"].writeMap(value.sipHeaders, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ToPhoneNumber"].write(value.toPhoneNumber)
    }
}

extension CreateSipRuleInput {

    static func write(value: CreateSipRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Disabled"].write(value.disabled)
        try writer["Name"].write(value.name)
        try writer["TargetApplications"].writeList(value.targetApplications, memberWritingClosure: ChimeClientTypes.SipRuleTargetApplication.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TriggerType"].write(value.triggerType)
        try writer["TriggerValue"].write(value.triggerValue)
    }
}

extension CreateUserInput {

    static func write(value: CreateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Email"].write(value.email)
        try writer["UserType"].write(value.userType)
        try writer["Username"].write(value.username)
    }
}

extension CreateVoiceConnectorInput {

    static func write(value: CreateVoiceConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["Name"].write(value.name)
        try writer["RequireEncryption"].write(value.requireEncryption)
    }
}

extension CreateVoiceConnectorGroupInput {

    static func write(value: CreateVoiceConnectorGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["VoiceConnectorItems"].writeList(value.voiceConnectorItems, memberWritingClosure: ChimeClientTypes.VoiceConnectorItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput {

    static func write(value: DeleteVoiceConnectorTerminationCredentialsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Usernames"].writeList(value.usernames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput {

    static func write(value: DisassociatePhoneNumbersFromVoiceConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["E164PhoneNumbers"].writeList(value.e164PhoneNumbers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput {

    static func write(value: DisassociatePhoneNumbersFromVoiceConnectorGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["E164PhoneNumbers"].writeList(value.e164PhoneNumbers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisassociateSigninDelegateGroupsFromAccountInput {

    static func write(value: DisassociateSigninDelegateGroupsFromAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupNames"].writeList(value.groupNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension InviteUsersInput {

    static func write(value: InviteUsersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserEmailList"].writeList(value.userEmailList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserType"].write(value.userType)
    }
}

extension PutAppInstanceRetentionSettingsInput {

    static func write(value: PutAppInstanceRetentionSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppInstanceRetentionSettings"].write(value.appInstanceRetentionSettings, with: ChimeClientTypes.AppInstanceRetentionSettings.write(value:to:))
    }
}

extension PutAppInstanceStreamingConfigurationsInput {

    static func write(value: PutAppInstanceStreamingConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppInstanceStreamingConfigurations"].writeList(value.appInstanceStreamingConfigurations, memberWritingClosure: ChimeClientTypes.AppInstanceStreamingConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutEventsConfigurationInput {

    static func write(value: PutEventsConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LambdaFunctionArn"].write(value.lambdaFunctionArn)
        try writer["OutboundEventsHTTPSEndpoint"].write(value.outboundEventsHTTPSEndpoint)
    }
}

extension PutRetentionSettingsInput {

    static func write(value: PutRetentionSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RetentionSettings"].write(value.retentionSettings, with: ChimeClientTypes.RetentionSettings.write(value:to:))
    }
}

extension PutSipMediaApplicationLoggingConfigurationInput {

    static func write(value: PutSipMediaApplicationLoggingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SipMediaApplicationLoggingConfiguration"].write(value.sipMediaApplicationLoggingConfiguration, with: ChimeClientTypes.SipMediaApplicationLoggingConfiguration.write(value:to:))
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationInput {

    static func write(value: PutVoiceConnectorEmergencyCallingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EmergencyCallingConfiguration"].write(value.emergencyCallingConfiguration, with: ChimeClientTypes.EmergencyCallingConfiguration.write(value:to:))
    }
}

extension PutVoiceConnectorLoggingConfigurationInput {

    static func write(value: PutVoiceConnectorLoggingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LoggingConfiguration"].write(value.loggingConfiguration, with: ChimeClientTypes.LoggingConfiguration.write(value:to:))
    }
}

extension PutVoiceConnectorOriginationInput {

    static func write(value: PutVoiceConnectorOriginationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Origination"].write(value.origination, with: ChimeClientTypes.Origination.write(value:to:))
    }
}

extension PutVoiceConnectorProxyInput {

    static func write(value: PutVoiceConnectorProxyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultSessionExpiryMinutes"].write(value.defaultSessionExpiryMinutes)
        try writer["Disabled"].write(value.disabled)
        try writer["FallBackPhoneNumber"].write(value.fallBackPhoneNumber)
        try writer["PhoneNumberPoolCountries"].writeList(value.phoneNumberPoolCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutVoiceConnectorStreamingConfigurationInput {

    static func write(value: PutVoiceConnectorStreamingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamingConfiguration"].write(value.streamingConfiguration, with: ChimeClientTypes.StreamingConfiguration.write(value:to:))
    }
}

extension PutVoiceConnectorTerminationInput {

    static func write(value: PutVoiceConnectorTerminationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Termination"].write(value.termination, with: ChimeClientTypes.Termination.write(value:to:))
    }
}

extension PutVoiceConnectorTerminationCredentialsInput {

    static func write(value: PutVoiceConnectorTerminationCredentialsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Credentials"].writeList(value.credentials, memberWritingClosure: ChimeClientTypes.Credential.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SendChannelMessageInput {

    static func write(value: SendChannelMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Content"].write(value.content)
        try writer["Metadata"].write(value.metadata)
        try writer["Persistence"].write(value.persistence)
        try writer["Type"].write(value.type)
    }
}

extension StartMeetingTranscriptionInput {

    static func write(value: StartMeetingTranscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TranscriptionConfiguration"].write(value.transcriptionConfiguration, with: ChimeClientTypes.TranscriptionConfiguration.write(value:to:))
    }
}

extension TagAttendeeInput {

    static func write(value: TagAttendeeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagMeetingInput {

    static func write(value: TagMeetingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagAttendeeInput {

    static func write(value: UntagAttendeeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagMeetingInput {

    static func write(value: UntagMeetingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAccountInput {

    static func write(value: UpdateAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultLicense"].write(value.defaultLicense)
        try writer["Name"].write(value.name)
    }
}

extension UpdateAccountSettingsInput {

    static func write(value: UpdateAccountSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountSettings"].write(value.accountSettings, with: ChimeClientTypes.AccountSettings.write(value:to:))
    }
}

extension UpdateAppInstanceInput {

    static func write(value: UpdateAppInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Metadata"].write(value.metadata)
        try writer["Name"].write(value.name)
    }
}

extension UpdateAppInstanceUserInput {

    static func write(value: UpdateAppInstanceUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Metadata"].write(value.metadata)
        try writer["Name"].write(value.name)
    }
}

extension UpdateBotInput {

    static func write(value: UpdateBotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Disabled"].write(value.disabled)
    }
}

extension UpdateChannelInput {

    static func write(value: UpdateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Metadata"].write(value.metadata)
        try writer["Mode"].write(value.mode)
        try writer["Name"].write(value.name)
    }
}

extension UpdateChannelMessageInput {

    static func write(value: UpdateChannelMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
        try writer["Metadata"].write(value.metadata)
    }
}

extension UpdateGlobalSettingsInput {

    static func write(value: UpdateGlobalSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BusinessCalling"].write(value.businessCalling, with: ChimeClientTypes.BusinessCallingSettings.write(value:to:))
        try writer["VoiceConnector"].write(value.voiceConnector, with: ChimeClientTypes.VoiceConnectorSettings.write(value:to:))
    }
}

extension UpdatePhoneNumberInput {

    static func write(value: UpdatePhoneNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CallingName"].write(value.callingName)
        try writer["ProductType"].write(value.productType)
    }
}

extension UpdatePhoneNumberSettingsInput {

    static func write(value: UpdatePhoneNumberSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CallingName"].write(value.callingName)
    }
}

extension UpdateProxySessionInput {

    static func write(value: UpdateProxySessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ChimeClientTypes.Capability>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExpiryMinutes"].write(value.expiryMinutes)
    }
}

extension UpdateRoomInput {

    static func write(value: UpdateRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateRoomMembershipInput {

    static func write(value: UpdateRoomMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Role"].write(value.role)
    }
}

extension UpdateSipMediaApplicationInput {

    static func write(value: UpdateSipMediaApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Endpoints"].writeList(value.endpoints, memberWritingClosure: ChimeClientTypes.SipMediaApplicationEndpoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }
}

extension UpdateSipMediaApplicationCallInput {

    static func write(value: UpdateSipMediaApplicationCallInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arguments"].writeMap(value.arguments, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateSipRuleInput {

    static func write(value: UpdateSipRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Disabled"].write(value.disabled)
        try writer["Name"].write(value.name)
        try writer["TargetApplications"].writeList(value.targetApplications, memberWritingClosure: ChimeClientTypes.SipRuleTargetApplication.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateUserInput {

    static func write(value: UpdateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlexaForBusinessMetadata"].write(value.alexaForBusinessMetadata, with: ChimeClientTypes.AlexaForBusinessMetadata.write(value:to:))
        try writer["LicenseType"].write(value.licenseType)
        try writer["UserType"].write(value.userType)
    }
}

extension UpdateUserSettingsInput {

    static func write(value: UpdateUserSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserSettings"].write(value.userSettings, with: ChimeClientTypes.UserSettings.write(value:to:))
    }
}

extension UpdateVoiceConnectorInput {

    static func write(value: UpdateVoiceConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["RequireEncryption"].write(value.requireEncryption)
    }
}

extension UpdateVoiceConnectorGroupInput {

    static func write(value: UpdateVoiceConnectorGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["VoiceConnectorItems"].writeList(value.voiceConnectorItems, memberWritingClosure: ChimeClientTypes.VoiceConnectorItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ValidateE911AddressInput {

    static func write(value: ValidateE911AddressInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsAccountId"].write(value.awsAccountId)
        try writer["City"].write(value.city)
        try writer["Country"].write(value.country)
        try writer["PostalCode"].write(value.postalCode)
        try writer["State"].write(value.state)
        try writer["StreetInfo"].write(value.streetInfo)
        try writer["StreetNumber"].write(value.streetNumber)
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociatePhoneNumbersWithVoiceConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociatePhoneNumbersWithVoiceConnectorOutput()
        value.phoneNumberErrors = try reader["PhoneNumberErrors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.PhoneNumberError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociatePhoneNumbersWithVoiceConnectorGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociatePhoneNumbersWithVoiceConnectorGroupOutput()
        value.phoneNumberErrors = try reader["PhoneNumberErrors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.PhoneNumberError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AssociatePhoneNumberWithUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociatePhoneNumberWithUserOutput {
        return AssociatePhoneNumberWithUserOutput()
    }
}

extension AssociateSigninDelegateGroupsWithAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateSigninDelegateGroupsWithAccountOutput {
        return AssociateSigninDelegateGroupsWithAccountOutput()
    }
}

extension BatchCreateAttendeeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateAttendeeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateAttendeeOutput()
        value.attendees = try reader["Attendees"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Attendee.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.CreateAttendeeError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchCreateChannelMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateChannelMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateChannelMembershipOutput()
        value.batchChannelMemberships = try reader["BatchChannelMemberships"].readIfPresent(with: ChimeClientTypes.BatchChannelMemberships.read(from:))
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.BatchCreateChannelMembershipError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchCreateRoomMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateRoomMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateRoomMembershipOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.MemberError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeletePhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeletePhoneNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeletePhoneNumberOutput()
        value.phoneNumberErrors = try reader["PhoneNumberErrors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.PhoneNumberError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchSuspendUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchSuspendUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchSuspendUserOutput()
        value.userErrors = try reader["UserErrors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.UserError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchUnsuspendUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUnsuspendUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUnsuspendUserOutput()
        value.userErrors = try reader["UserErrors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.UserError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchUpdatePhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdatePhoneNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdatePhoneNumberOutput()
        value.phoneNumberErrors = try reader["PhoneNumberErrors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.PhoneNumberError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchUpdateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateUserOutput()
        value.userErrors = try reader["UserErrors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.UserError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccountOutput()
        value.account = try reader["Account"].readIfPresent(with: ChimeClientTypes.Account.read(from:))
        return value
    }
}

extension CreateAppInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppInstanceOutput()
        value.appInstanceArn = try reader["AppInstanceArn"].readIfPresent()
        return value
    }
}

extension CreateAppInstanceAdminOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppInstanceAdminOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppInstanceAdminOutput()
        value.appInstanceAdmin = try reader["AppInstanceAdmin"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        value.appInstanceArn = try reader["AppInstanceArn"].readIfPresent()
        return value
    }
}

extension CreateAppInstanceUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppInstanceUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppInstanceUserOutput()
        value.appInstanceUserArn = try reader["AppInstanceUserArn"].readIfPresent()
        return value
    }
}

extension CreateAttendeeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAttendeeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAttendeeOutput()
        value.attendee = try reader["Attendee"].readIfPresent(with: ChimeClientTypes.Attendee.read(from:))
        return value
    }
}

extension CreateBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBotOutput()
        value.bot = try reader["Bot"].readIfPresent(with: ChimeClientTypes.Bot.read(from:))
        return value
    }
}

extension CreateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        return value
    }
}

extension CreateChannelBanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelBanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelBanOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.member = try reader["Member"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        return value
    }
}

extension CreateChannelMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelMembershipOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.member = try reader["Member"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        return value
    }
}

extension CreateChannelModeratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelModeratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelModeratorOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.channelModerator = try reader["ChannelModerator"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        return value
    }
}

extension CreateMediaCapturePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMediaCapturePipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMediaCapturePipelineOutput()
        value.mediaCapturePipeline = try reader["MediaCapturePipeline"].readIfPresent(with: ChimeClientTypes.MediaCapturePipeline.read(from:))
        return value
    }
}

extension CreateMeetingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMeetingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMeetingOutput()
        value.meeting = try reader["Meeting"].readIfPresent(with: ChimeClientTypes.Meeting.read(from:))
        return value
    }
}

extension CreateMeetingDialOutOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMeetingDialOutOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMeetingDialOutOutput()
        value.transactionId = try reader["TransactionId"].readIfPresent()
        return value
    }
}

extension CreateMeetingWithAttendeesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMeetingWithAttendeesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMeetingWithAttendeesOutput()
        value.attendees = try reader["Attendees"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Attendee.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.CreateAttendeeError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.meeting = try reader["Meeting"].readIfPresent(with: ChimeClientTypes.Meeting.read(from:))
        return value
    }
}

extension CreatePhoneNumberOrderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePhoneNumberOrderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePhoneNumberOrderOutput()
        value.phoneNumberOrder = try reader["PhoneNumberOrder"].readIfPresent(with: ChimeClientTypes.PhoneNumberOrder.read(from:))
        return value
    }
}

extension CreateProxySessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProxySessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProxySessionOutput()
        value.proxySession = try reader["ProxySession"].readIfPresent(with: ChimeClientTypes.ProxySession.read(from:))
        return value
    }
}

extension CreateRoomOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRoomOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRoomOutput()
        value.room = try reader["Room"].readIfPresent(with: ChimeClientTypes.Room.read(from:))
        return value
    }
}

extension CreateRoomMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRoomMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRoomMembershipOutput()
        value.roomMembership = try reader["RoomMembership"].readIfPresent(with: ChimeClientTypes.RoomMembership.read(from:))
        return value
    }
}

extension CreateSipMediaApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSipMediaApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSipMediaApplicationOutput()
        value.sipMediaApplication = try reader["SipMediaApplication"].readIfPresent(with: ChimeClientTypes.SipMediaApplication.read(from:))
        return value
    }
}

extension CreateSipMediaApplicationCallOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSipMediaApplicationCallOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSipMediaApplicationCallOutput()
        value.sipMediaApplicationCall = try reader["SipMediaApplicationCall"].readIfPresent(with: ChimeClientTypes.SipMediaApplicationCall.read(from:))
        return value
    }
}

extension CreateSipRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSipRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSipRuleOutput()
        value.sipRule = try reader["SipRule"].readIfPresent(with: ChimeClientTypes.SipRule.read(from:))
        return value
    }
}

extension CreateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserOutput()
        value.user = try reader["User"].readIfPresent(with: ChimeClientTypes.User.read(from:))
        return value
    }
}

extension CreateVoiceConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVoiceConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVoiceConnectorOutput()
        value.voiceConnector = try reader["VoiceConnector"].readIfPresent(with: ChimeClientTypes.VoiceConnector.read(from:))
        return value
    }
}

extension CreateVoiceConnectorGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVoiceConnectorGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVoiceConnectorGroupOutput()
        value.voiceConnectorGroup = try reader["VoiceConnectorGroup"].readIfPresent(with: ChimeClientTypes.VoiceConnectorGroup.read(from:))
        return value
    }
}

extension DeleteAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccountOutput {
        return DeleteAccountOutput()
    }
}

extension DeleteAppInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppInstanceOutput {
        return DeleteAppInstanceOutput()
    }
}

extension DeleteAppInstanceAdminOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppInstanceAdminOutput {
        return DeleteAppInstanceAdminOutput()
    }
}

extension DeleteAppInstanceStreamingConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppInstanceStreamingConfigurationsOutput {
        return DeleteAppInstanceStreamingConfigurationsOutput()
    }
}

extension DeleteAppInstanceUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppInstanceUserOutput {
        return DeleteAppInstanceUserOutput()
    }
}

extension DeleteAttendeeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAttendeeOutput {
        return DeleteAttendeeOutput()
    }
}

extension DeleteChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelOutput {
        return DeleteChannelOutput()
    }
}

extension DeleteChannelBanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelBanOutput {
        return DeleteChannelBanOutput()
    }
}

extension DeleteChannelMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelMembershipOutput {
        return DeleteChannelMembershipOutput()
    }
}

extension DeleteChannelMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelMessageOutput {
        return DeleteChannelMessageOutput()
    }
}

extension DeleteChannelModeratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelModeratorOutput {
        return DeleteChannelModeratorOutput()
    }
}

extension DeleteEventsConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventsConfigurationOutput {
        return DeleteEventsConfigurationOutput()
    }
}

extension DeleteMediaCapturePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMediaCapturePipelineOutput {
        return DeleteMediaCapturePipelineOutput()
    }
}

extension DeleteMeetingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMeetingOutput {
        return DeleteMeetingOutput()
    }
}

extension DeletePhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePhoneNumberOutput {
        return DeletePhoneNumberOutput()
    }
}

extension DeleteProxySessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProxySessionOutput {
        return DeleteProxySessionOutput()
    }
}

extension DeleteRoomOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRoomOutput {
        return DeleteRoomOutput()
    }
}

extension DeleteRoomMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRoomMembershipOutput {
        return DeleteRoomMembershipOutput()
    }
}

extension DeleteSipMediaApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSipMediaApplicationOutput {
        return DeleteSipMediaApplicationOutput()
    }
}

extension DeleteSipRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSipRuleOutput {
        return DeleteSipRuleOutput()
    }
}

extension DeleteVoiceConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVoiceConnectorOutput {
        return DeleteVoiceConnectorOutput()
    }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVoiceConnectorEmergencyCallingConfigurationOutput {
        return DeleteVoiceConnectorEmergencyCallingConfigurationOutput()
    }
}

extension DeleteVoiceConnectorGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVoiceConnectorGroupOutput {
        return DeleteVoiceConnectorGroupOutput()
    }
}

extension DeleteVoiceConnectorOriginationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVoiceConnectorOriginationOutput {
        return DeleteVoiceConnectorOriginationOutput()
    }
}

extension DeleteVoiceConnectorProxyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVoiceConnectorProxyOutput {
        return DeleteVoiceConnectorProxyOutput()
    }
}

extension DeleteVoiceConnectorStreamingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVoiceConnectorStreamingConfigurationOutput {
        return DeleteVoiceConnectorStreamingConfigurationOutput()
    }
}

extension DeleteVoiceConnectorTerminationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVoiceConnectorTerminationOutput {
        return DeleteVoiceConnectorTerminationOutput()
    }
}

extension DeleteVoiceConnectorTerminationCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVoiceConnectorTerminationCredentialsOutput {
        return DeleteVoiceConnectorTerminationCredentialsOutput()
    }
}

extension DescribeAppInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAppInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAppInstanceOutput()
        value.appInstance = try reader["AppInstance"].readIfPresent(with: ChimeClientTypes.AppInstance.read(from:))
        return value
    }
}

extension DescribeAppInstanceAdminOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAppInstanceAdminOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAppInstanceAdminOutput()
        value.appInstanceAdmin = try reader["AppInstanceAdmin"].readIfPresent(with: ChimeClientTypes.AppInstanceAdmin.read(from:))
        return value
    }
}

extension DescribeAppInstanceUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAppInstanceUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAppInstanceUserOutput()
        value.appInstanceUser = try reader["AppInstanceUser"].readIfPresent(with: ChimeClientTypes.AppInstanceUser.read(from:))
        return value
    }
}

extension DescribeChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelOutput()
        value.channel = try reader["Channel"].readIfPresent(with: ChimeClientTypes.Channel.read(from:))
        return value
    }
}

extension DescribeChannelBanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelBanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelBanOutput()
        value.channelBan = try reader["ChannelBan"].readIfPresent(with: ChimeClientTypes.ChannelBan.read(from:))
        return value
    }
}

extension DescribeChannelMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelMembershipOutput()
        value.channelMembership = try reader["ChannelMembership"].readIfPresent(with: ChimeClientTypes.ChannelMembership.read(from:))
        return value
    }
}

extension DescribeChannelMembershipForAppInstanceUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelMembershipForAppInstanceUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelMembershipForAppInstanceUserOutput()
        value.channelMembership = try reader["ChannelMembership"].readIfPresent(with: ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary.read(from:))
        return value
    }
}

extension DescribeChannelModeratedByAppInstanceUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelModeratedByAppInstanceUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelModeratedByAppInstanceUserOutput()
        value.channel = try reader["Channel"].readIfPresent(with: ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary.read(from:))
        return value
    }
}

extension DescribeChannelModeratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelModeratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelModeratorOutput()
        value.channelModerator = try reader["ChannelModerator"].readIfPresent(with: ChimeClientTypes.ChannelModerator.read(from:))
        return value
    }
}

extension DisassociatePhoneNumberFromUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociatePhoneNumberFromUserOutput {
        return DisassociatePhoneNumberFromUserOutput()
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociatePhoneNumbersFromVoiceConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociatePhoneNumbersFromVoiceConnectorOutput()
        value.phoneNumberErrors = try reader["PhoneNumberErrors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.PhoneNumberError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociatePhoneNumbersFromVoiceConnectorGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociatePhoneNumbersFromVoiceConnectorGroupOutput()
        value.phoneNumberErrors = try reader["PhoneNumberErrors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.PhoneNumberError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DisassociateSigninDelegateGroupsFromAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateSigninDelegateGroupsFromAccountOutput {
        return DisassociateSigninDelegateGroupsFromAccountOutput()
    }
}

extension GetAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountOutput()
        value.account = try reader["Account"].readIfPresent(with: ChimeClientTypes.Account.read(from:))
        return value
    }
}

extension GetAccountSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountSettingsOutput()
        value.accountSettings = try reader["AccountSettings"].readIfPresent(with: ChimeClientTypes.AccountSettings.read(from:))
        return value
    }
}

extension GetAppInstanceRetentionSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppInstanceRetentionSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppInstanceRetentionSettingsOutput()
        value.appInstanceRetentionSettings = try reader["AppInstanceRetentionSettings"].readIfPresent(with: ChimeClientTypes.AppInstanceRetentionSettings.read(from:))
        value.initiateDeletionTimestamp = try reader["InitiateDeletionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetAppInstanceStreamingConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppInstanceStreamingConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppInstanceStreamingConfigurationsOutput()
        value.appInstanceStreamingConfigurations = try reader["AppInstanceStreamingConfigurations"].readListIfPresent(memberReadingClosure: ChimeClientTypes.AppInstanceStreamingConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAttendeeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAttendeeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAttendeeOutput()
        value.attendee = try reader["Attendee"].readIfPresent(with: ChimeClientTypes.Attendee.read(from:))
        return value
    }
}

extension GetBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBotOutput()
        value.bot = try reader["Bot"].readIfPresent(with: ChimeClientTypes.Bot.read(from:))
        return value
    }
}

extension GetChannelMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChannelMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChannelMessageOutput()
        value.channelMessage = try reader["ChannelMessage"].readIfPresent(with: ChimeClientTypes.ChannelMessage.read(from:))
        return value
    }
}

extension GetEventsConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventsConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventsConfigurationOutput()
        value.eventsConfiguration = try reader["EventsConfiguration"].readIfPresent(with: ChimeClientTypes.EventsConfiguration.read(from:))
        return value
    }
}

extension GetGlobalSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGlobalSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGlobalSettingsOutput()
        value.businessCalling = try reader["BusinessCalling"].readIfPresent(with: ChimeClientTypes.BusinessCallingSettings.read(from:))
        value.voiceConnector = try reader["VoiceConnector"].readIfPresent(with: ChimeClientTypes.VoiceConnectorSettings.read(from:))
        return value
    }
}

extension GetMediaCapturePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMediaCapturePipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMediaCapturePipelineOutput()
        value.mediaCapturePipeline = try reader["MediaCapturePipeline"].readIfPresent(with: ChimeClientTypes.MediaCapturePipeline.read(from:))
        return value
    }
}

extension GetMeetingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMeetingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMeetingOutput()
        value.meeting = try reader["Meeting"].readIfPresent(with: ChimeClientTypes.Meeting.read(from:))
        return value
    }
}

extension GetMessagingSessionEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMessagingSessionEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMessagingSessionEndpointOutput()
        value.endpoint = try reader["Endpoint"].readIfPresent(with: ChimeClientTypes.MessagingSessionEndpoint.read(from:))
        return value
    }
}

extension GetPhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPhoneNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPhoneNumberOutput()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent(with: ChimeClientTypes.PhoneNumber.read(from:))
        return value
    }
}

extension GetPhoneNumberOrderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPhoneNumberOrderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPhoneNumberOrderOutput()
        value.phoneNumberOrder = try reader["PhoneNumberOrder"].readIfPresent(with: ChimeClientTypes.PhoneNumberOrder.read(from:))
        return value
    }
}

extension GetPhoneNumberSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPhoneNumberSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPhoneNumberSettingsOutput()
        value.callingName = try reader["CallingName"].readIfPresent()
        value.callingNameUpdatedTimestamp = try reader["CallingNameUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetProxySessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProxySessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProxySessionOutput()
        value.proxySession = try reader["ProxySession"].readIfPresent(with: ChimeClientTypes.ProxySession.read(from:))
        return value
    }
}

extension GetRetentionSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRetentionSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRetentionSettingsOutput()
        value.initiateDeletionTimestamp = try reader["InitiateDeletionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.retentionSettings = try reader["RetentionSettings"].readIfPresent(with: ChimeClientTypes.RetentionSettings.read(from:))
        return value
    }
}

extension GetRoomOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRoomOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRoomOutput()
        value.room = try reader["Room"].readIfPresent(with: ChimeClientTypes.Room.read(from:))
        return value
    }
}

extension GetSipMediaApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSipMediaApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSipMediaApplicationOutput()
        value.sipMediaApplication = try reader["SipMediaApplication"].readIfPresent(with: ChimeClientTypes.SipMediaApplication.read(from:))
        return value
    }
}

extension GetSipMediaApplicationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSipMediaApplicationLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSipMediaApplicationLoggingConfigurationOutput()
        value.sipMediaApplicationLoggingConfiguration = try reader["SipMediaApplicationLoggingConfiguration"].readIfPresent(with: ChimeClientTypes.SipMediaApplicationLoggingConfiguration.read(from:))
        return value
    }
}

extension GetSipRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSipRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSipRuleOutput()
        value.sipRule = try reader["SipRule"].readIfPresent(with: ChimeClientTypes.SipRule.read(from:))
        return value
    }
}

extension GetUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUserOutput()
        value.user = try reader["User"].readIfPresent(with: ChimeClientTypes.User.read(from:))
        return value
    }
}

extension GetUserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUserSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUserSettingsOutput()
        value.userSettings = try reader["UserSettings"].readIfPresent(with: ChimeClientTypes.UserSettings.read(from:))
        return value
    }
}

extension GetVoiceConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVoiceConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVoiceConnectorOutput()
        value.voiceConnector = try reader["VoiceConnector"].readIfPresent(with: ChimeClientTypes.VoiceConnector.read(from:))
        return value
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVoiceConnectorEmergencyCallingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVoiceConnectorEmergencyCallingConfigurationOutput()
        value.emergencyCallingConfiguration = try reader["EmergencyCallingConfiguration"].readIfPresent(with: ChimeClientTypes.EmergencyCallingConfiguration.read(from:))
        return value
    }
}

extension GetVoiceConnectorGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVoiceConnectorGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVoiceConnectorGroupOutput()
        value.voiceConnectorGroup = try reader["VoiceConnectorGroup"].readIfPresent(with: ChimeClientTypes.VoiceConnectorGroup.read(from:))
        return value
    }
}

extension GetVoiceConnectorLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVoiceConnectorLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVoiceConnectorLoggingConfigurationOutput()
        value.loggingConfiguration = try reader["LoggingConfiguration"].readIfPresent(with: ChimeClientTypes.LoggingConfiguration.read(from:))
        return value
    }
}

extension GetVoiceConnectorOriginationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVoiceConnectorOriginationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVoiceConnectorOriginationOutput()
        value.origination = try reader["Origination"].readIfPresent(with: ChimeClientTypes.Origination.read(from:))
        return value
    }
}

extension GetVoiceConnectorProxyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVoiceConnectorProxyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVoiceConnectorProxyOutput()
        value.proxy = try reader["Proxy"].readIfPresent(with: ChimeClientTypes.Proxy.read(from:))
        return value
    }
}

extension GetVoiceConnectorStreamingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVoiceConnectorStreamingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVoiceConnectorStreamingConfigurationOutput()
        value.streamingConfiguration = try reader["StreamingConfiguration"].readIfPresent(with: ChimeClientTypes.StreamingConfiguration.read(from:))
        return value
    }
}

extension GetVoiceConnectorTerminationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVoiceConnectorTerminationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVoiceConnectorTerminationOutput()
        value.termination = try reader["Termination"].readIfPresent(with: ChimeClientTypes.Termination.read(from:))
        return value
    }
}

extension GetVoiceConnectorTerminationHealthOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVoiceConnectorTerminationHealthOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVoiceConnectorTerminationHealthOutput()
        value.terminationHealth = try reader["TerminationHealth"].readIfPresent(with: ChimeClientTypes.TerminationHealth.read(from:))
        return value
    }
}

extension InviteUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InviteUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = InviteUsersOutput()
        value.invites = try reader["Invites"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Invite.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountsOutput()
        value.accounts = try reader["Accounts"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Account.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAppInstanceAdminsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAppInstanceAdminsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppInstanceAdminsOutput()
        value.appInstanceAdmins = try reader["AppInstanceAdmins"].readListIfPresent(memberReadingClosure: ChimeClientTypes.AppInstanceAdminSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.appInstanceArn = try reader["AppInstanceArn"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAppInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAppInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppInstancesOutput()
        value.appInstances = try reader["AppInstances"].readListIfPresent(memberReadingClosure: ChimeClientTypes.AppInstanceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAppInstanceUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAppInstanceUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppInstanceUsersOutput()
        value.appInstanceArn = try reader["AppInstanceArn"].readIfPresent()
        value.appInstanceUsers = try reader["AppInstanceUsers"].readListIfPresent(memberReadingClosure: ChimeClientTypes.AppInstanceUserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAttendeesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAttendeesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAttendeesOutput()
        value.attendees = try reader["Attendees"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Attendee.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAttendeeTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAttendeeTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAttendeeTagsOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListBotsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBotsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBotsOutput()
        value.bots = try reader["Bots"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Bot.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelBansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelBansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelBansOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.channelBans = try reader["ChannelBans"].readListIfPresent(memberReadingClosure: ChimeClientTypes.ChannelBanSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelMembershipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelMembershipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelMembershipsOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.channelMemberships = try reader["ChannelMemberships"].readListIfPresent(memberReadingClosure: ChimeClientTypes.ChannelMembershipSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelMembershipsForAppInstanceUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelMembershipsForAppInstanceUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelMembershipsForAppInstanceUserOutput()
        value.channelMemberships = try reader["ChannelMemberships"].readListIfPresent(memberReadingClosure: ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelMessagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelMessagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelMessagesOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.channelMessages = try reader["ChannelMessages"].readListIfPresent(memberReadingClosure: ChimeClientTypes.ChannelMessageSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelModeratorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelModeratorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelModeratorsOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.channelModerators = try reader["ChannelModerators"].readListIfPresent(memberReadingClosure: ChimeClientTypes.ChannelModeratorSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelsOutput()
        value.channels = try reader["Channels"].readListIfPresent(memberReadingClosure: ChimeClientTypes.ChannelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelsModeratedByAppInstanceUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelsModeratedByAppInstanceUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelsModeratedByAppInstanceUserOutput()
        value.channels = try reader["Channels"].readListIfPresent(memberReadingClosure: ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMediaCapturePipelinesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMediaCapturePipelinesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMediaCapturePipelinesOutput()
        value.mediaCapturePipelines = try reader["MediaCapturePipelines"].readListIfPresent(memberReadingClosure: ChimeClientTypes.MediaCapturePipeline.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMeetingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMeetingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMeetingsOutput()
        value.meetings = try reader["Meetings"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Meeting.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMeetingTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMeetingTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMeetingTagsOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPhoneNumberOrdersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPhoneNumberOrdersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPhoneNumberOrdersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.phoneNumberOrders = try reader["PhoneNumberOrders"].readListIfPresent(memberReadingClosure: ChimeClientTypes.PhoneNumberOrder.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPhoneNumbersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPhoneNumbersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPhoneNumbersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.phoneNumbers = try reader["PhoneNumbers"].readListIfPresent(memberReadingClosure: ChimeClientTypes.PhoneNumber.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProxySessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProxySessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProxySessionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.proxySessions = try reader["ProxySessions"].readListIfPresent(memberReadingClosure: ChimeClientTypes.ProxySession.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRoomMembershipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRoomMembershipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRoomMembershipsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.roomMemberships = try reader["RoomMemberships"].readListIfPresent(memberReadingClosure: ChimeClientTypes.RoomMembership.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRoomsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRoomsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRoomsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.rooms = try reader["Rooms"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Room.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSipMediaApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSipMediaApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSipMediaApplicationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sipMediaApplications = try reader["SipMediaApplications"].readListIfPresent(memberReadingClosure: ChimeClientTypes.SipMediaApplication.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSipRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSipRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSipRulesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sipRules = try reader["SipRules"].readListIfPresent(memberReadingClosure: ChimeClientTypes.SipRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSupportedPhoneNumberCountriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSupportedPhoneNumberCountriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSupportedPhoneNumberCountriesOutput()
        value.phoneNumberCountries = try reader["PhoneNumberCountries"].readListIfPresent(memberReadingClosure: ChimeClientTypes.PhoneNumberCountry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUsersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: ChimeClientTypes.User.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVoiceConnectorGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVoiceConnectorGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVoiceConnectorGroupsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.voiceConnectorGroups = try reader["VoiceConnectorGroups"].readListIfPresent(memberReadingClosure: ChimeClientTypes.VoiceConnectorGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVoiceConnectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVoiceConnectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVoiceConnectorsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.voiceConnectors = try reader["VoiceConnectors"].readListIfPresent(memberReadingClosure: ChimeClientTypes.VoiceConnector.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVoiceConnectorTerminationCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVoiceConnectorTerminationCredentialsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVoiceConnectorTerminationCredentialsOutput()
        value.usernames = try reader["Usernames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LogoutUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> LogoutUserOutput {
        return LogoutUserOutput()
    }
}

extension PutAppInstanceRetentionSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAppInstanceRetentionSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutAppInstanceRetentionSettingsOutput()
        value.appInstanceRetentionSettings = try reader["AppInstanceRetentionSettings"].readIfPresent(with: ChimeClientTypes.AppInstanceRetentionSettings.read(from:))
        value.initiateDeletionTimestamp = try reader["InitiateDeletionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PutAppInstanceStreamingConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAppInstanceStreamingConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutAppInstanceStreamingConfigurationsOutput()
        value.appInstanceStreamingConfigurations = try reader["AppInstanceStreamingConfigurations"].readListIfPresent(memberReadingClosure: ChimeClientTypes.AppInstanceStreamingConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutEventsConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutEventsConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutEventsConfigurationOutput()
        value.eventsConfiguration = try reader["EventsConfiguration"].readIfPresent(with: ChimeClientTypes.EventsConfiguration.read(from:))
        return value
    }
}

extension PutRetentionSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRetentionSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutRetentionSettingsOutput()
        value.initiateDeletionTimestamp = try reader["InitiateDeletionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.retentionSettings = try reader["RetentionSettings"].readIfPresent(with: ChimeClientTypes.RetentionSettings.read(from:))
        return value
    }
}

extension PutSipMediaApplicationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutSipMediaApplicationLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutSipMediaApplicationLoggingConfigurationOutput()
        value.sipMediaApplicationLoggingConfiguration = try reader["SipMediaApplicationLoggingConfiguration"].readIfPresent(with: ChimeClientTypes.SipMediaApplicationLoggingConfiguration.read(from:))
        return value
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutVoiceConnectorEmergencyCallingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutVoiceConnectorEmergencyCallingConfigurationOutput()
        value.emergencyCallingConfiguration = try reader["EmergencyCallingConfiguration"].readIfPresent(with: ChimeClientTypes.EmergencyCallingConfiguration.read(from:))
        return value
    }
}

extension PutVoiceConnectorLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutVoiceConnectorLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutVoiceConnectorLoggingConfigurationOutput()
        value.loggingConfiguration = try reader["LoggingConfiguration"].readIfPresent(with: ChimeClientTypes.LoggingConfiguration.read(from:))
        return value
    }
}

extension PutVoiceConnectorOriginationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutVoiceConnectorOriginationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutVoiceConnectorOriginationOutput()
        value.origination = try reader["Origination"].readIfPresent(with: ChimeClientTypes.Origination.read(from:))
        return value
    }
}

extension PutVoiceConnectorProxyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutVoiceConnectorProxyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutVoiceConnectorProxyOutput()
        value.proxy = try reader["Proxy"].readIfPresent(with: ChimeClientTypes.Proxy.read(from:))
        return value
    }
}

extension PutVoiceConnectorStreamingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutVoiceConnectorStreamingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutVoiceConnectorStreamingConfigurationOutput()
        value.streamingConfiguration = try reader["StreamingConfiguration"].readIfPresent(with: ChimeClientTypes.StreamingConfiguration.read(from:))
        return value
    }
}

extension PutVoiceConnectorTerminationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutVoiceConnectorTerminationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutVoiceConnectorTerminationOutput()
        value.termination = try reader["Termination"].readIfPresent(with: ChimeClientTypes.Termination.read(from:))
        return value
    }
}

extension PutVoiceConnectorTerminationCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutVoiceConnectorTerminationCredentialsOutput {
        return PutVoiceConnectorTerminationCredentialsOutput()
    }
}

extension RedactChannelMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RedactChannelMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RedactChannelMessageOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.messageId = try reader["MessageId"].readIfPresent()
        return value
    }
}

extension RedactConversationMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RedactConversationMessageOutput {
        return RedactConversationMessageOutput()
    }
}

extension RedactRoomMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RedactRoomMessageOutput {
        return RedactRoomMessageOutput()
    }
}

extension RegenerateSecurityTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegenerateSecurityTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegenerateSecurityTokenOutput()
        value.bot = try reader["Bot"].readIfPresent(with: ChimeClientTypes.Bot.read(from:))
        return value
    }
}

extension ResetPersonalPINOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetPersonalPINOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResetPersonalPINOutput()
        value.user = try reader["User"].readIfPresent(with: ChimeClientTypes.User.read(from:))
        return value
    }
}

extension RestorePhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestorePhoneNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestorePhoneNumberOutput()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent(with: ChimeClientTypes.PhoneNumber.read(from:))
        return value
    }
}

extension SearchAvailablePhoneNumbersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchAvailablePhoneNumbersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchAvailablePhoneNumbersOutput()
        value.e164PhoneNumbers = try reader["E164PhoneNumbers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension SendChannelMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendChannelMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendChannelMessageOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.messageId = try reader["MessageId"].readIfPresent()
        return value
    }
}

extension StartMeetingTranscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMeetingTranscriptionOutput {
        return StartMeetingTranscriptionOutput()
    }
}

extension StopMeetingTranscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopMeetingTranscriptionOutput {
        return StopMeetingTranscriptionOutput()
    }
}

extension TagAttendeeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagAttendeeOutput {
        return TagAttendeeOutput()
    }
}

extension TagMeetingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagMeetingOutput {
        return TagMeetingOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagAttendeeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagAttendeeOutput {
        return UntagAttendeeOutput()
    }
}

extension UntagMeetingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagMeetingOutput {
        return UntagMeetingOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccountOutput()
        value.account = try reader["Account"].readIfPresent(with: ChimeClientTypes.Account.read(from:))
        return value
    }
}

extension UpdateAccountSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccountSettingsOutput {
        return UpdateAccountSettingsOutput()
    }
}

extension UpdateAppInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAppInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAppInstanceOutput()
        value.appInstanceArn = try reader["AppInstanceArn"].readIfPresent()
        return value
    }
}

extension UpdateAppInstanceUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAppInstanceUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAppInstanceUserOutput()
        value.appInstanceUserArn = try reader["AppInstanceUserArn"].readIfPresent()
        return value
    }
}

extension UpdateBotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBotOutput()
        value.bot = try reader["Bot"].readIfPresent(with: ChimeClientTypes.Bot.read(from:))
        return value
    }
}

extension UpdateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateChannelOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        return value
    }
}

extension UpdateChannelMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChannelMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateChannelMessageOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.messageId = try reader["MessageId"].readIfPresent()
        return value
    }
}

extension UpdateChannelReadMarkerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChannelReadMarkerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateChannelReadMarkerOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        return value
    }
}

extension UpdateGlobalSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGlobalSettingsOutput {
        return UpdateGlobalSettingsOutput()
    }
}

extension UpdatePhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePhoneNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePhoneNumberOutput()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent(with: ChimeClientTypes.PhoneNumber.read(from:))
        return value
    }
}

extension UpdatePhoneNumberSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePhoneNumberSettingsOutput {
        return UpdatePhoneNumberSettingsOutput()
    }
}

extension UpdateProxySessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProxySessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProxySessionOutput()
        value.proxySession = try reader["ProxySession"].readIfPresent(with: ChimeClientTypes.ProxySession.read(from:))
        return value
    }
}

extension UpdateRoomOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRoomOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRoomOutput()
        value.room = try reader["Room"].readIfPresent(with: ChimeClientTypes.Room.read(from:))
        return value
    }
}

extension UpdateRoomMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRoomMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRoomMembershipOutput()
        value.roomMembership = try reader["RoomMembership"].readIfPresent(with: ChimeClientTypes.RoomMembership.read(from:))
        return value
    }
}

extension UpdateSipMediaApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSipMediaApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSipMediaApplicationOutput()
        value.sipMediaApplication = try reader["SipMediaApplication"].readIfPresent(with: ChimeClientTypes.SipMediaApplication.read(from:))
        return value
    }
}

extension UpdateSipMediaApplicationCallOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSipMediaApplicationCallOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSipMediaApplicationCallOutput()
        value.sipMediaApplicationCall = try reader["SipMediaApplicationCall"].readIfPresent(with: ChimeClientTypes.SipMediaApplicationCall.read(from:))
        return value
    }
}

extension UpdateSipRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSipRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSipRuleOutput()
        value.sipRule = try reader["SipRule"].readIfPresent(with: ChimeClientTypes.SipRule.read(from:))
        return value
    }
}

extension UpdateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUserOutput()
        value.user = try reader["User"].readIfPresent(with: ChimeClientTypes.User.read(from:))
        return value
    }
}

extension UpdateUserSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserSettingsOutput {
        return UpdateUserSettingsOutput()
    }
}

extension UpdateVoiceConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVoiceConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVoiceConnectorOutput()
        value.voiceConnector = try reader["VoiceConnector"].readIfPresent(with: ChimeClientTypes.VoiceConnector.read(from:))
        return value
    }
}

extension UpdateVoiceConnectorGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVoiceConnectorGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVoiceConnectorGroupOutput()
        value.voiceConnectorGroup = try reader["VoiceConnectorGroup"].readIfPresent(with: ChimeClientTypes.VoiceConnectorGroup.read(from:))
        return value
    }
}

extension ValidateE911AddressOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ValidateE911AddressOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ValidateE911AddressOutput()
        value.address = try reader["Address"].readIfPresent(with: ChimeClientTypes.Address.read(from:))
        value.addressExternalId = try reader["AddressExternalId"].readIfPresent()
        value.candidateAddressList = try reader["CandidateAddressList"].readListIfPresent(memberReadingClosure: ChimeClientTypes.CandidateAddress.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.validationResult = try reader["ValidationResult"].readIfPresent() ?? 0
        return value
    }
}

enum AssociatePhoneNumbersWithVoiceConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociatePhoneNumbersWithVoiceConnectorGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociatePhoneNumberWithUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateSigninDelegateGroupsWithAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchCreateAttendeeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchCreateChannelMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchCreateRoomMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeletePhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchSuspendUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUnsuspendUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdatePhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAppInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAppInstanceAdminOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAppInstanceUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAttendeeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelBanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelModeratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMediaCapturePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMeetingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMeetingDialOutOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMeetingWithAttendeesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePhoneNumberOrderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProxySessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRoomOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRoomMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSipMediaApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSipMediaApplicationCallOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSipRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVoiceConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVoiceConnectorGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppInstanceAdminOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppInstanceStreamingConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppInstanceUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAttendeeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelBanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelModeratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventsConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMediaCapturePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMeetingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProxySessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRoomOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRoomMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSipMediaApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSipRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVoiceConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVoiceConnectorEmergencyCallingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVoiceConnectorGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVoiceConnectorOriginationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVoiceConnectorProxyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVoiceConnectorStreamingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVoiceConnectorTerminationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVoiceConnectorTerminationCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAppInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAppInstanceAdminOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAppInstanceUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelBanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelMembershipForAppInstanceUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelModeratedByAppInstanceUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelModeratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociatePhoneNumberFromUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociatePhoneNumbersFromVoiceConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateSigninDelegateGroupsFromAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppInstanceRetentionSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppInstanceStreamingConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAttendeeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChannelMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventsConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGlobalSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMediaCapturePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMeetingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMessagingSessionEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPhoneNumberOrderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPhoneNumberSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProxySessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRetentionSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRoomOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSipMediaApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSipMediaApplicationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSipRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVoiceConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVoiceConnectorEmergencyCallingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVoiceConnectorGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVoiceConnectorLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVoiceConnectorOriginationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVoiceConnectorProxyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVoiceConnectorStreamingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVoiceConnectorTerminationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVoiceConnectorTerminationHealthOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InviteUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAppInstanceAdminsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAppInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAppInstanceUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAttendeesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAttendeeTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBotsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelBansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelMembershipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelMembershipsForAppInstanceUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelMessagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelModeratorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelsModeratedByAppInstanceUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMediaCapturePipelinesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMeetingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMeetingTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPhoneNumberOrdersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPhoneNumbersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProxySessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRoomMembershipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRoomsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSipMediaApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSipRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSupportedPhoneNumberCountriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVoiceConnectorGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVoiceConnectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVoiceConnectorTerminationCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum LogoutUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAppInstanceRetentionSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAppInstanceStreamingConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutEventsConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRetentionSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutSipMediaApplicationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutVoiceConnectorEmergencyCallingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutVoiceConnectorLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutVoiceConnectorOriginationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutVoiceConnectorProxyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutVoiceConnectorStreamingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutVoiceConnectorTerminationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutVoiceConnectorTerminationCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RedactChannelMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RedactConversationMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RedactRoomMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegenerateSecurityTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetPersonalPINOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestorePhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchAvailablePhoneNumbersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendChannelMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMeetingTranscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopMeetingTranscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagAttendeeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagMeetingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagAttendeeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagMeetingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccountSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAppInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAppInstanceUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChannelMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChannelReadMarkerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGlobalSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePhoneNumberSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProxySessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRoomOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRoomMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSipMediaApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSipMediaApplicationCallOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSipRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVoiceConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVoiceConnectorGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ValidateE911AddressOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceFailureException {
        let reader = baseError.errorBodyReader
        var value = ServiceFailureException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedClientException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedClientException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedClientException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottledClientException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottledClientException {
        let reader = baseError.errorBodyReader
        var value = ThrottledClientException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceLimitExceededException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnprocessableEntityException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnprocessableEntityException {
        let reader = baseError.errorBodyReader
        var value = UnprocessableEntityException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ChimeClientTypes.PhoneNumberError {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.PhoneNumberError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.PhoneNumberError()
        value.phoneNumberId = try reader["PhoneNumberId"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.Attendee {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Attendee {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Attendee()
        value.externalUserId = try reader["ExternalUserId"].readIfPresent()
        value.attendeeId = try reader["AttendeeId"].readIfPresent()
        value.joinToken = try reader["JoinToken"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.CreateAttendeeError {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.CreateAttendeeError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.CreateAttendeeError()
        value.externalUserId = try reader["ExternalUserId"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.BatchChannelMemberships {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.BatchChannelMemberships {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.BatchChannelMemberships()
        value.invitedBy = try reader["InvitedBy"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.members = try reader["Members"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Identity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.Identity {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Identity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Identity()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.BatchCreateChannelMembershipError {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.BatchCreateChannelMembershipError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.BatchCreateChannelMembershipError()
        value.memberArn = try reader["MemberArn"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.MemberError {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.MemberError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.MemberError()
        value.memberId = try reader["MemberId"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.UserError {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.UserError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.UserError()
        value.userId = try reader["UserId"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.Account {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Account {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Account()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent() ?? ""
        value.accountId = try reader["AccountId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.accountType = try reader["AccountType"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.defaultLicense = try reader["DefaultLicense"].readIfPresent()
        value.supportedLicenses = try reader["SupportedLicenses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ChimeClientTypes.License>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accountStatus = try reader["AccountStatus"].readIfPresent()
        value.signinDelegateGroups = try reader["SigninDelegateGroups"].readListIfPresent(memberReadingClosure: ChimeClientTypes.SigninDelegateGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeClientTypes.SigninDelegateGroup {

    static func write(value: ChimeClientTypes.SigninDelegateGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.SigninDelegateGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.SigninDelegateGroup()
        value.groupName = try reader["GroupName"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.Bot {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Bot {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Bot()
        value.botId = try reader["BotId"].readIfPresent()
        value.userId = try reader["UserId"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.botType = try reader["BotType"].readIfPresent()
        value.disabled = try reader["Disabled"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.botEmail = try reader["BotEmail"].readIfPresent()
        value.securityToken = try reader["SecurityToken"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.MediaCapturePipeline {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.MediaCapturePipeline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.MediaCapturePipeline()
        value.mediaPipelineId = try reader["MediaPipelineId"].readIfPresent()
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.sourceArn = try reader["SourceArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.sinkType = try reader["SinkType"].readIfPresent()
        value.sinkArn = try reader["SinkArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.chimeSdkMeetingConfiguration = try reader["ChimeSdkMeetingConfiguration"].readIfPresent(with: ChimeClientTypes.ChimeSdkMeetingConfiguration.read(from:))
        return value
    }
}

extension ChimeClientTypes.ChimeSdkMeetingConfiguration {

    static func write(value: ChimeClientTypes.ChimeSdkMeetingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArtifactsConfiguration"].write(value.artifactsConfiguration, with: ChimeClientTypes.ArtifactsConfiguration.write(value:to:))
        try writer["SourceConfiguration"].write(value.sourceConfiguration, with: ChimeClientTypes.SourceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChimeSdkMeetingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChimeSdkMeetingConfiguration()
        value.sourceConfiguration = try reader["SourceConfiguration"].readIfPresent(with: ChimeClientTypes.SourceConfiguration.read(from:))
        value.artifactsConfiguration = try reader["ArtifactsConfiguration"].readIfPresent(with: ChimeClientTypes.ArtifactsConfiguration.read(from:))
        return value
    }
}

extension ChimeClientTypes.ArtifactsConfiguration {

    static func write(value: ChimeClientTypes.ArtifactsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Audio"].write(value.audio, with: ChimeClientTypes.AudioArtifactsConfiguration.write(value:to:))
        try writer["Content"].write(value.content, with: ChimeClientTypes.ContentArtifactsConfiguration.write(value:to:))
        try writer["Video"].write(value.video, with: ChimeClientTypes.VideoArtifactsConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ArtifactsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ArtifactsConfiguration()
        value.audio = try reader["Audio"].readIfPresent(with: ChimeClientTypes.AudioArtifactsConfiguration.read(from:))
        value.video = try reader["Video"].readIfPresent(with: ChimeClientTypes.VideoArtifactsConfiguration.read(from:))
        value.content = try reader["Content"].readIfPresent(with: ChimeClientTypes.ContentArtifactsConfiguration.read(from:))
        return value
    }
}

extension ChimeClientTypes.ContentArtifactsConfiguration {

    static func write(value: ChimeClientTypes.ContentArtifactsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MuxType"].write(value.muxType)
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ContentArtifactsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ContentArtifactsConfiguration()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.muxType = try reader["MuxType"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.VideoArtifactsConfiguration {

    static func write(value: ChimeClientTypes.VideoArtifactsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MuxType"].write(value.muxType)
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.VideoArtifactsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.VideoArtifactsConfiguration()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.muxType = try reader["MuxType"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.AudioArtifactsConfiguration {

    static func write(value: ChimeClientTypes.AudioArtifactsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MuxType"].write(value.muxType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.AudioArtifactsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.AudioArtifactsConfiguration()
        value.muxType = try reader["MuxType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeClientTypes.SourceConfiguration {

    static func write(value: ChimeClientTypes.SourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SelectedVideoStreams"].write(value.selectedVideoStreams, with: ChimeClientTypes.SelectedVideoStreams.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.SourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.SourceConfiguration()
        value.selectedVideoStreams = try reader["SelectedVideoStreams"].readIfPresent(with: ChimeClientTypes.SelectedVideoStreams.read(from:))
        return value
    }
}

extension ChimeClientTypes.SelectedVideoStreams {

    static func write(value: ChimeClientTypes.SelectedVideoStreams?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttendeeIds"].writeList(value.attendeeIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExternalUserIds"].writeList(value.externalUserIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.SelectedVideoStreams {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.SelectedVideoStreams()
        value.attendeeIds = try reader["AttendeeIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.externalUserIds = try reader["ExternalUserIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeClientTypes.Meeting {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Meeting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Meeting()
        value.meetingId = try reader["MeetingId"].readIfPresent()
        value.externalMeetingId = try reader["ExternalMeetingId"].readIfPresent()
        value.mediaPlacement = try reader["MediaPlacement"].readIfPresent(with: ChimeClientTypes.MediaPlacement.read(from:))
        value.mediaRegion = try reader["MediaRegion"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.MediaPlacement {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.MediaPlacement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.MediaPlacement()
        value.audioHostUrl = try reader["AudioHostUrl"].readIfPresent()
        value.audioFallbackUrl = try reader["AudioFallbackUrl"].readIfPresent()
        value.screenDataUrl = try reader["ScreenDataUrl"].readIfPresent()
        value.screenSharingUrl = try reader["ScreenSharingUrl"].readIfPresent()
        value.screenViewingUrl = try reader["ScreenViewingUrl"].readIfPresent()
        value.signalingUrl = try reader["SignalingUrl"].readIfPresent()
        value.turnControlUrl = try reader["TurnControlUrl"].readIfPresent()
        value.eventIngestionUrl = try reader["EventIngestionUrl"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.PhoneNumberOrder {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.PhoneNumberOrder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.PhoneNumberOrder()
        value.phoneNumberOrderId = try reader["PhoneNumberOrderId"].readIfPresent()
        value.productType = try reader["ProductType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.orderedPhoneNumbers = try reader["OrderedPhoneNumbers"].readListIfPresent(memberReadingClosure: ChimeClientTypes.OrderedPhoneNumber.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeClientTypes.OrderedPhoneNumber {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.OrderedPhoneNumber {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.OrderedPhoneNumber()
        value.e164PhoneNumber = try reader["E164PhoneNumber"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.ProxySession {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ProxySession {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ProxySession()
        value.voiceConnectorId = try reader["VoiceConnectorId"].readIfPresent()
        value.proxySessionId = try reader["ProxySessionId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.expiryMinutes = try reader["ExpiryMinutes"].readIfPresent()
        value.capabilities = try reader["Capabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ChimeClientTypes.Capability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endedTimestamp = try reader["EndedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.participants = try reader["Participants"].readListIfPresent(memberReadingClosure: ChimeClientTypes.Participant.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.numberSelectionBehavior = try reader["NumberSelectionBehavior"].readIfPresent()
        value.geoMatchLevel = try reader["GeoMatchLevel"].readIfPresent()
        value.geoMatchParams = try reader["GeoMatchParams"].readIfPresent(with: ChimeClientTypes.GeoMatchParams.read(from:))
        return value
    }
}

extension ChimeClientTypes.GeoMatchParams {

    static func write(value: ChimeClientTypes.GeoMatchParams?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AreaCode"].write(value.areaCode)
        try writer["Country"].write(value.country)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.GeoMatchParams {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.GeoMatchParams()
        value.country = try reader["Country"].readIfPresent() ?? ""
        value.areaCode = try reader["AreaCode"].readIfPresent() ?? ""
        return value
    }
}

extension ChimeClientTypes.Participant {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Participant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Participant()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.proxyPhoneNumber = try reader["ProxyPhoneNumber"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.Room {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Room {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Room()
        value.roomId = try reader["RoomId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeClientTypes.RoomMembership {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.RoomMembership {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.RoomMembership()
        value.roomId = try reader["RoomId"].readIfPresent()
        value.member = try reader["Member"].readIfPresent(with: ChimeClientTypes.Member.read(from:))
        value.role = try reader["Role"].readIfPresent()
        value.invitedBy = try reader["InvitedBy"].readIfPresent()
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeClientTypes.Member {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Member {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Member()
        value.memberId = try reader["MemberId"].readIfPresent()
        value.memberType = try reader["MemberType"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        value.fullName = try reader["FullName"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.SipMediaApplication {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.SipMediaApplication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.SipMediaApplication()
        value.sipMediaApplicationId = try reader["SipMediaApplicationId"].readIfPresent()
        value.awsRegion = try reader["AwsRegion"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.endpoints = try reader["Endpoints"].readListIfPresent(memberReadingClosure: ChimeClientTypes.SipMediaApplicationEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeClientTypes.SipMediaApplicationEndpoint {

    static func write(value: ChimeClientTypes.SipMediaApplicationEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LambdaArn"].write(value.lambdaArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.SipMediaApplicationEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.SipMediaApplicationEndpoint()
        value.lambdaArn = try reader["LambdaArn"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.SipMediaApplicationCall {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.SipMediaApplicationCall {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.SipMediaApplicationCall()
        value.transactionId = try reader["TransactionId"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.SipRule {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.SipRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.SipRule()
        value.sipRuleId = try reader["SipRuleId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.disabled = try reader["Disabled"].readIfPresent()
        value.triggerType = try reader["TriggerType"].readIfPresent()
        value.triggerValue = try reader["TriggerValue"].readIfPresent()
        value.targetApplications = try reader["TargetApplications"].readListIfPresent(memberReadingClosure: ChimeClientTypes.SipRuleTargetApplication.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeClientTypes.SipRuleTargetApplication {

    static func write(value: ChimeClientTypes.SipRuleTargetApplication?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["Priority"].write(value.priority)
        try writer["SipMediaApplicationId"].write(value.sipMediaApplicationId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.SipRuleTargetApplication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.SipRuleTargetApplication()
        value.sipMediaApplicationId = try reader["SipMediaApplicationId"].readIfPresent()
        value.priority = try reader["Priority"].readIfPresent()
        value.awsRegion = try reader["AwsRegion"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.User {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.User {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.User()
        value.userId = try reader["UserId"].readIfPresent() ?? ""
        value.accountId = try reader["AccountId"].readIfPresent()
        value.primaryEmail = try reader["PrimaryEmail"].readIfPresent()
        value.primaryProvisionedNumber = try reader["PrimaryProvisionedNumber"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.licenseType = try reader["LicenseType"].readIfPresent()
        value.userType = try reader["UserType"].readIfPresent()
        value.userRegistrationStatus = try reader["UserRegistrationStatus"].readIfPresent()
        value.userInvitationStatus = try reader["UserInvitationStatus"].readIfPresent()
        value.registeredOn = try reader["RegisteredOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.invitedOn = try reader["InvitedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.alexaForBusinessMetadata = try reader["AlexaForBusinessMetadata"].readIfPresent(with: ChimeClientTypes.AlexaForBusinessMetadata.read(from:))
        value.personalPIN = try reader["PersonalPIN"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.AlexaForBusinessMetadata {

    static func write(value: ChimeClientTypes.AlexaForBusinessMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlexaForBusinessRoomArn"].write(value.alexaForBusinessRoomArn)
        try writer["IsAlexaForBusinessEnabled"].write(value.isAlexaForBusinessEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.AlexaForBusinessMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.AlexaForBusinessMetadata()
        value.isAlexaForBusinessEnabled = try reader["IsAlexaForBusinessEnabled"].readIfPresent()
        value.alexaForBusinessRoomArn = try reader["AlexaForBusinessRoomArn"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.VoiceConnector {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.VoiceConnector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.VoiceConnector()
        value.voiceConnectorId = try reader["VoiceConnectorId"].readIfPresent()
        value.awsRegion = try reader["AwsRegion"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.outboundHostName = try reader["OutboundHostName"].readIfPresent()
        value.requireEncryption = try reader["RequireEncryption"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.voiceConnectorArn = try reader["VoiceConnectorArn"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.VoiceConnectorGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.VoiceConnectorGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.VoiceConnectorGroup()
        value.voiceConnectorGroupId = try reader["VoiceConnectorGroupId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.voiceConnectorItems = try reader["VoiceConnectorItems"].readListIfPresent(memberReadingClosure: ChimeClientTypes.VoiceConnectorItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.voiceConnectorGroupArn = try reader["VoiceConnectorGroupArn"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.VoiceConnectorItem {

    static func write(value: ChimeClientTypes.VoiceConnectorItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Priority"].write(value.priority)
        try writer["VoiceConnectorId"].write(value.voiceConnectorId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.VoiceConnectorItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.VoiceConnectorItem()
        value.voiceConnectorId = try reader["VoiceConnectorId"].readIfPresent() ?? ""
        value.priority = try reader["Priority"].readIfPresent() ?? 0
        return value
    }
}

extension ChimeClientTypes.AppInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.AppInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.AppInstance()
        value.appInstanceArn = try reader["AppInstanceArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ChimeClientTypes.AppInstanceAdmin {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.AppInstanceAdmin {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.AppInstanceAdmin()
        value.admin = try reader["Admin"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        value.appInstanceArn = try reader["AppInstanceArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ChimeClientTypes.AppInstanceUser {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.AppInstanceUser {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.AppInstanceUser()
        value.appInstanceUserArn = try reader["AppInstanceUserArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metadata = try reader["Metadata"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ChimeClientTypes.Channel {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Channel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Channel()
        value.name = try reader["Name"].readIfPresent()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.mode = try reader["Mode"].readIfPresent()
        value.privacy = try reader["Privacy"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastMessageTimestamp = try reader["LastMessageTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ChimeClientTypes.ChannelBan {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChannelBan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChannelBan()
        value.member = try reader["Member"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        return value
    }
}

extension ChimeClientTypes.ChannelMembership {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChannelMembership {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChannelMembership()
        value.invitedBy = try reader["InvitedBy"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.member = try reader["Member"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChannelMembershipForAppInstanceUserSummary()
        value.channelSummary = try reader["ChannelSummary"].readIfPresent(with: ChimeClientTypes.ChannelSummary.read(from:))
        value.appInstanceUserMembershipSummary = try reader["AppInstanceUserMembershipSummary"].readIfPresent(with: ChimeClientTypes.AppInstanceUserMembershipSummary.read(from:))
        return value
    }
}

extension ChimeClientTypes.AppInstanceUserMembershipSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.AppInstanceUserMembershipSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.AppInstanceUserMembershipSummary()
        value.type = try reader["Type"].readIfPresent()
        value.readMarkerTimestamp = try reader["ReadMarkerTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ChimeClientTypes.ChannelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChannelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChannelSummary()
        value.name = try reader["Name"].readIfPresent()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.mode = try reader["Mode"].readIfPresent()
        value.privacy = try reader["Privacy"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        value.lastMessageTimestamp = try reader["LastMessageTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChannelModeratedByAppInstanceUserSummary()
        value.channelSummary = try reader["ChannelSummary"].readIfPresent(with: ChimeClientTypes.ChannelSummary.read(from:))
        return value
    }
}

extension ChimeClientTypes.ChannelModerator {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChannelModerator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChannelModerator()
        value.moderator = try reader["Moderator"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        return value
    }
}

extension ChimeClientTypes.AccountSettings {

    static func write(value: ChimeClientTypes.AccountSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisableRemoteControl"].write(value.disableRemoteControl)
        try writer["EnableDialOut"].write(value.enableDialOut)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.AccountSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.AccountSettings()
        value.disableRemoteControl = try reader["DisableRemoteControl"].readIfPresent()
        value.enableDialOut = try reader["EnableDialOut"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.AppInstanceRetentionSettings {

    static func write(value: ChimeClientTypes.AppInstanceRetentionSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelRetentionSettings"].write(value.channelRetentionSettings, with: ChimeClientTypes.ChannelRetentionSettings.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.AppInstanceRetentionSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.AppInstanceRetentionSettings()
        value.channelRetentionSettings = try reader["ChannelRetentionSettings"].readIfPresent(with: ChimeClientTypes.ChannelRetentionSettings.read(from:))
        return value
    }
}

extension ChimeClientTypes.ChannelRetentionSettings {

    static func write(value: ChimeClientTypes.ChannelRetentionSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RetentionDays"].write(value.retentionDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChannelRetentionSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChannelRetentionSettings()
        value.retentionDays = try reader["RetentionDays"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.AppInstanceStreamingConfiguration {

    static func write(value: ChimeClientTypes.AppInstanceStreamingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppInstanceDataType"].write(value.appInstanceDataType)
        try writer["ResourceArn"].write(value.resourceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.AppInstanceStreamingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.AppInstanceStreamingConfiguration()
        value.appInstanceDataType = try reader["AppInstanceDataType"].readIfPresent() ?? .sdkUnknown("")
        value.resourceArn = try reader["ResourceArn"].readIfPresent() ?? ""
        return value
    }
}

extension ChimeClientTypes.ChannelMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChannelMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChannelMessage()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.messageId = try reader["MessageId"].readIfPresent()
        value.content = try reader["Content"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastEditedTimestamp = try reader["LastEditedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sender = try reader["Sender"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        value.redacted = try reader["Redacted"].readIfPresent() ?? false
        value.persistence = try reader["Persistence"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.EventsConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.EventsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.EventsConfiguration()
        value.botId = try reader["BotId"].readIfPresent()
        value.outboundEventsHTTPSEndpoint = try reader["OutboundEventsHTTPSEndpoint"].readIfPresent()
        value.lambdaFunctionArn = try reader["LambdaFunctionArn"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.BusinessCallingSettings {

    static func write(value: ChimeClientTypes.BusinessCallingSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CdrBucket"].write(value.cdrBucket)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.BusinessCallingSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.BusinessCallingSettings()
        value.cdrBucket = try reader["CdrBucket"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.VoiceConnectorSettings {

    static func write(value: ChimeClientTypes.VoiceConnectorSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CdrBucket"].write(value.cdrBucket)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.VoiceConnectorSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.VoiceConnectorSettings()
        value.cdrBucket = try reader["CdrBucket"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.MessagingSessionEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.MessagingSessionEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.MessagingSessionEndpoint()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.PhoneNumber {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.PhoneNumber {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.PhoneNumber()
        value.phoneNumberId = try reader["PhoneNumberId"].readIfPresent()
        value.e164PhoneNumber = try reader["E164PhoneNumber"].readIfPresent()
        value.country = try reader["Country"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.productType = try reader["ProductType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.capabilities = try reader["Capabilities"].readIfPresent(with: ChimeClientTypes.PhoneNumberCapabilities.read(from:))
        value.associations = try reader["Associations"].readListIfPresent(memberReadingClosure: ChimeClientTypes.PhoneNumberAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.callingName = try reader["CallingName"].readIfPresent()
        value.callingNameStatus = try reader["CallingNameStatus"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deletionTimestamp = try reader["DeletionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeClientTypes.PhoneNumberAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.PhoneNumberAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.PhoneNumberAssociation()
        value.value = try reader["Value"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.associatedTimestamp = try reader["AssociatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeClientTypes.PhoneNumberCapabilities {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.PhoneNumberCapabilities {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.PhoneNumberCapabilities()
        value.inboundCall = try reader["InboundCall"].readIfPresent()
        value.outboundCall = try reader["OutboundCall"].readIfPresent()
        value.inboundSMS = try reader["InboundSMS"].readIfPresent()
        value.outboundSMS = try reader["OutboundSMS"].readIfPresent()
        value.inboundMMS = try reader["InboundMMS"].readIfPresent()
        value.outboundMMS = try reader["OutboundMMS"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.RetentionSettings {

    static func write(value: ChimeClientTypes.RetentionSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConversationRetentionSettings"].write(value.conversationRetentionSettings, with: ChimeClientTypes.ConversationRetentionSettings.write(value:to:))
        try writer["RoomRetentionSettings"].write(value.roomRetentionSettings, with: ChimeClientTypes.RoomRetentionSettings.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.RetentionSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.RetentionSettings()
        value.roomRetentionSettings = try reader["RoomRetentionSettings"].readIfPresent(with: ChimeClientTypes.RoomRetentionSettings.read(from:))
        value.conversationRetentionSettings = try reader["ConversationRetentionSettings"].readIfPresent(with: ChimeClientTypes.ConversationRetentionSettings.read(from:))
        return value
    }
}

extension ChimeClientTypes.ConversationRetentionSettings {

    static func write(value: ChimeClientTypes.ConversationRetentionSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RetentionDays"].write(value.retentionDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ConversationRetentionSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ConversationRetentionSettings()
        value.retentionDays = try reader["RetentionDays"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.RoomRetentionSettings {

    static func write(value: ChimeClientTypes.RoomRetentionSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RetentionDays"].write(value.retentionDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.RoomRetentionSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.RoomRetentionSettings()
        value.retentionDays = try reader["RetentionDays"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.SipMediaApplicationLoggingConfiguration {

    static func write(value: ChimeClientTypes.SipMediaApplicationLoggingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableSipMediaApplicationMessageLogs"].write(value.enableSipMediaApplicationMessageLogs)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.SipMediaApplicationLoggingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.SipMediaApplicationLoggingConfiguration()
        value.enableSipMediaApplicationMessageLogs = try reader["EnableSipMediaApplicationMessageLogs"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.UserSettings {

    static func write(value: ChimeClientTypes.UserSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Telephony"].write(value.telephony, with: ChimeClientTypes.TelephonySettings.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.UserSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.UserSettings()
        value.telephony = try reader["Telephony"].readIfPresent(with: ChimeClientTypes.TelephonySettings.read(from:))
        return value
    }
}

extension ChimeClientTypes.TelephonySettings {

    static func write(value: ChimeClientTypes.TelephonySettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InboundCalling"].write(value.inboundCalling)
        try writer["OutboundCalling"].write(value.outboundCalling)
        try writer["SMS"].write(value.sms)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.TelephonySettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.TelephonySettings()
        value.inboundCalling = try reader["InboundCalling"].readIfPresent() ?? false
        value.outboundCalling = try reader["OutboundCalling"].readIfPresent() ?? false
        value.sms = try reader["SMS"].readIfPresent() ?? false
        return value
    }
}

extension ChimeClientTypes.EmergencyCallingConfiguration {

    static func write(value: ChimeClientTypes.EmergencyCallingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DNIS"].writeList(value.dnis, memberWritingClosure: ChimeClientTypes.DNISEmergencyCallingConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.EmergencyCallingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.EmergencyCallingConfiguration()
        value.dnis = try reader["DNIS"].readListIfPresent(memberReadingClosure: ChimeClientTypes.DNISEmergencyCallingConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeClientTypes.DNISEmergencyCallingConfiguration {

    static func write(value: ChimeClientTypes.DNISEmergencyCallingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CallingCountry"].write(value.callingCountry)
        try writer["EmergencyPhoneNumber"].write(value.emergencyPhoneNumber)
        try writer["TestPhoneNumber"].write(value.testPhoneNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.DNISEmergencyCallingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.DNISEmergencyCallingConfiguration()
        value.emergencyPhoneNumber = try reader["EmergencyPhoneNumber"].readIfPresent() ?? ""
        value.testPhoneNumber = try reader["TestPhoneNumber"].readIfPresent()
        value.callingCountry = try reader["CallingCountry"].readIfPresent() ?? ""
        return value
    }
}

extension ChimeClientTypes.LoggingConfiguration {

    static func write(value: ChimeClientTypes.LoggingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableMediaMetricLogs"].write(value.enableMediaMetricLogs)
        try writer["EnableSIPLogs"].write(value.enableSIPLogs)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.LoggingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.LoggingConfiguration()
        value.enableSIPLogs = try reader["EnableSIPLogs"].readIfPresent()
        value.enableMediaMetricLogs = try reader["EnableMediaMetricLogs"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.Origination {

    static func write(value: ChimeClientTypes.Origination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Disabled"].write(value.disabled)
        try writer["Routes"].writeList(value.routes, memberWritingClosure: ChimeClientTypes.OriginationRoute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Origination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Origination()
        value.routes = try reader["Routes"].readListIfPresent(memberReadingClosure: ChimeClientTypes.OriginationRoute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.disabled = try reader["Disabled"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.OriginationRoute {

    static func write(value: ChimeClientTypes.OriginationRoute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
        try writer["Priority"].write(value.priority)
        try writer["Protocol"].write(value.`protocol`)
        try writer["Weight"].write(value.weight)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.OriginationRoute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.OriginationRoute()
        value.host = try reader["Host"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.priority = try reader["Priority"].readIfPresent()
        value.weight = try reader["Weight"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.Proxy {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Proxy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Proxy()
        value.defaultSessionExpiryMinutes = try reader["DefaultSessionExpiryMinutes"].readIfPresent()
        value.disabled = try reader["Disabled"].readIfPresent()
        value.fallBackPhoneNumber = try reader["FallBackPhoneNumber"].readIfPresent()
        value.phoneNumberCountries = try reader["PhoneNumberCountries"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeClientTypes.StreamingConfiguration {

    static func write(value: ChimeClientTypes.StreamingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataRetentionInHours"].write(value.dataRetentionInHours)
        try writer["Disabled"].write(value.disabled)
        try writer["StreamingNotificationTargets"].writeList(value.streamingNotificationTargets, memberWritingClosure: ChimeClientTypes.StreamingNotificationTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.StreamingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.StreamingConfiguration()
        value.dataRetentionInHours = try reader["DataRetentionInHours"].readIfPresent() ?? 0
        value.disabled = try reader["Disabled"].readIfPresent()
        value.streamingNotificationTargets = try reader["StreamingNotificationTargets"].readListIfPresent(memberReadingClosure: ChimeClientTypes.StreamingNotificationTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeClientTypes.StreamingNotificationTarget {

    static func write(value: ChimeClientTypes.StreamingNotificationTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NotificationTarget"].write(value.notificationTarget)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.StreamingNotificationTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.StreamingNotificationTarget()
        value.notificationTarget = try reader["NotificationTarget"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeClientTypes.Termination {

    static func write(value: ChimeClientTypes.Termination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CallingRegions"].writeList(value.callingRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CidrAllowedList"].writeList(value.cidrAllowedList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CpsLimit"].write(value.cpsLimit)
        try writer["DefaultPhoneNumber"].write(value.defaultPhoneNumber)
        try writer["Disabled"].write(value.disabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Termination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Termination()
        value.cpsLimit = try reader["CpsLimit"].readIfPresent()
        value.defaultPhoneNumber = try reader["DefaultPhoneNumber"].readIfPresent()
        value.callingRegions = try reader["CallingRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.cidrAllowedList = try reader["CidrAllowedList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.disabled = try reader["Disabled"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.TerminationHealth {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.TerminationHealth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.TerminationHealth()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.source = try reader["Source"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.Invite {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Invite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Invite()
        value.inviteId = try reader["InviteId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.emailAddress = try reader["EmailAddress"].readIfPresent()
        value.emailStatus = try reader["EmailStatus"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.AppInstanceAdminSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.AppInstanceAdminSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.AppInstanceAdminSummary()
        value.admin = try reader["Admin"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        return value
    }
}

extension ChimeClientTypes.AppInstanceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.AppInstanceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.AppInstanceSummary()
        value.appInstanceArn = try reader["AppInstanceArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.AppInstanceUserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.AppInstanceUserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.AppInstanceUserSummary()
        value.appInstanceUserArn = try reader["AppInstanceUserArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.Tag {

    static func write(value: ChimeClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension ChimeClientTypes.ChannelBanSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChannelBanSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChannelBanSummary()
        value.member = try reader["Member"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        return value
    }
}

extension ChimeClientTypes.ChannelMembershipSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChannelMembershipSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChannelMembershipSummary()
        value.member = try reader["Member"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        return value
    }
}

extension ChimeClientTypes.ChannelMessageSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChannelMessageSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChannelMessageSummary()
        value.messageId = try reader["MessageId"].readIfPresent()
        value.content = try reader["Content"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastEditedTimestamp = try reader["LastEditedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sender = try reader["Sender"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        value.redacted = try reader["Redacted"].readIfPresent() ?? false
        return value
    }
}

extension ChimeClientTypes.ChannelModeratorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.ChannelModeratorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.ChannelModeratorSummary()
        value.moderator = try reader["Moderator"].readIfPresent(with: ChimeClientTypes.Identity.read(from:))
        return value
    }
}

extension ChimeClientTypes.PhoneNumberCountry {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.PhoneNumberCountry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.PhoneNumberCountry()
        value.countryCode = try reader["CountryCode"].readIfPresent()
        value.supportedPhoneNumberTypes = try reader["SupportedPhoneNumberTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ChimeClientTypes.PhoneNumberType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeClientTypes.Address {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.Address {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.Address()
        value.streetName = try reader["streetName"].readIfPresent()
        value.streetSuffix = try reader["streetSuffix"].readIfPresent()
        value.postDirectional = try reader["postDirectional"].readIfPresent()
        value.preDirectional = try reader["preDirectional"].readIfPresent()
        value.streetNumber = try reader["streetNumber"].readIfPresent()
        value.city = try reader["city"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.postalCode = try reader["postalCode"].readIfPresent()
        value.postalCodePlus4 = try reader["postalCodePlus4"].readIfPresent()
        value.country = try reader["country"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.CandidateAddress {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeClientTypes.CandidateAddress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeClientTypes.CandidateAddress()
        value.streetInfo = try reader["streetInfo"].readIfPresent()
        value.streetNumber = try reader["streetNumber"].readIfPresent()
        value.city = try reader["city"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.postalCode = try reader["postalCode"].readIfPresent()
        value.postalCodePlus4 = try reader["postalCodePlus4"].readIfPresent()
        value.country = try reader["country"].readIfPresent()
        return value
    }
}

extension ChimeClientTypes.CreateAttendeeRequestItem {

    static func write(value: ChimeClientTypes.CreateAttendeeRequestItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExternalUserId"].write(value.externalUserId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ChimeClientTypes.MembershipItem {

    static func write(value: ChimeClientTypes.MembershipItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MemberId"].write(value.memberId)
        try writer["Role"].write(value.role)
    }
}

extension ChimeClientTypes.UpdatePhoneNumberRequestItem {

    static func write(value: ChimeClientTypes.UpdatePhoneNumberRequestItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CallingName"].write(value.callingName)
        try writer["PhoneNumberId"].write(value.phoneNumberId)
        try writer["ProductType"].write(value.productType)
    }
}

extension ChimeClientTypes.UpdateUserRequestItem {

    static func write(value: ChimeClientTypes.UpdateUserRequestItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlexaForBusinessMetadata"].write(value.alexaForBusinessMetadata, with: ChimeClientTypes.AlexaForBusinessMetadata.write(value:to:))
        try writer["LicenseType"].write(value.licenseType)
        try writer["UserId"].write(value.userId)
        try writer["UserType"].write(value.userType)
    }
}

extension ChimeClientTypes.MeetingNotificationConfiguration {

    static func write(value: ChimeClientTypes.MeetingNotificationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SnsTopicArn"].write(value.snsTopicArn)
        try writer["SqsQueueArn"].write(value.sqsQueueArn)
    }
}

extension ChimeClientTypes.Credential {

    static func write(value: ChimeClientTypes.Credential?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Password"].write(value.password)
        try writer["Username"].write(value.username)
    }
}

extension ChimeClientTypes.TranscriptionConfiguration {

    static func write(value: ChimeClientTypes.TranscriptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineTranscribeMedicalSettings"].write(value.engineTranscribeMedicalSettings, with: ChimeClientTypes.EngineTranscribeMedicalSettings.write(value:to:))
        try writer["EngineTranscribeSettings"].write(value.engineTranscribeSettings, with: ChimeClientTypes.EngineTranscribeSettings.write(value:to:))
    }
}

extension ChimeClientTypes.EngineTranscribeMedicalSettings {

    static func write(value: ChimeClientTypes.EngineTranscribeMedicalSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentIdentificationType"].write(value.contentIdentificationType)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["Region"].write(value.region)
        try writer["Specialty"].write(value.specialty)
        try writer["Type"].write(value.type)
        try writer["VocabularyName"].write(value.vocabularyName)
    }
}

extension ChimeClientTypes.EngineTranscribeSettings {

    static func write(value: ChimeClientTypes.EngineTranscribeSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentIdentificationType"].write(value.contentIdentificationType)
        try writer["ContentRedactionType"].write(value.contentRedactionType)
        try writer["EnablePartialResultsStabilization"].write(value.enablePartialResultsStabilization)
        try writer["IdentifyLanguage"].write(value.identifyLanguage)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["LanguageModelName"].write(value.languageModelName)
        try writer["LanguageOptions"].write(value.languageOptions)
        try writer["PartialResultsStability"].write(value.partialResultsStability)
        try writer["PiiEntityTypes"].write(value.piiEntityTypes)
        try writer["PreferredLanguage"].write(value.preferredLanguage)
        try writer["Region"].write(value.region)
        try writer["VocabularyFilterMethod"].write(value.vocabularyFilterMethod)
        try writer["VocabularyFilterName"].write(value.vocabularyFilterName)
        try writer["VocabularyFilterNames"].write(value.vocabularyFilterNames)
        try writer["VocabularyName"].write(value.vocabularyName)
        try writer["VocabularyNames"].write(value.vocabularyNames)
    }
}

public enum ChimeClientTypes {}
