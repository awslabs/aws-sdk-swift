// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request conflicts with an existing resource in Timestream for InfluxDB.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the Timestream for InfluxDB resource associated with the request.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of Timestream for InfluxDB resource associated with the request.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateDbInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDbInstanceInput(allocatedStorage: \(Swift.String(describing: allocatedStorage)), bucket: \(Swift.String(describing: bucket)), dbInstanceType: \(Swift.String(describing: dbInstanceType)), dbParameterGroupIdentifier: \(Swift.String(describing: dbParameterGroupIdentifier)), dbStorageType: \(Swift.String(describing: dbStorageType)), deploymentType: \(Swift.String(describing: deploymentType)), logDeliveryConfiguration: \(Swift.String(describing: logDeliveryConfiguration)), name: \(Swift.String(describing: name)), organization: \(Swift.String(describing: organization)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), tags: \(Swift.String(describing: tags)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)), vpcSubnetIds: \(Swift.String(describing: vpcSubnetIds)), password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension CreateDbInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage
        case bucket
        case dbInstanceType
        case dbParameterGroupIdentifier
        case dbStorageType
        case deploymentType
        case logDeliveryConfiguration
        case name
        case organization
        case password
        case publiclyAccessible
        case tags
        case username
        case vpcSecurityGroupIds
        case vpcSubnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = self.allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let dbInstanceType = self.dbInstanceType {
            try encodeContainer.encode(dbInstanceType.rawValue, forKey: .dbInstanceType)
        }
        if let dbParameterGroupIdentifier = self.dbParameterGroupIdentifier {
            try encodeContainer.encode(dbParameterGroupIdentifier, forKey: .dbParameterGroupIdentifier)
        }
        if let dbStorageType = self.dbStorageType {
            try encodeContainer.encode(dbStorageType.rawValue, forKey: .dbStorageType)
        }
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let logDeliveryConfiguration = self.logDeliveryConfiguration {
            try encodeContainer.encode(logDeliveryConfiguration, forKey: .logDeliveryConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organization = self.organization {
            try encodeContainer.encode(organization, forKey: .organization)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, requestTagMap0) in tags {
                try tagsContainer.encode(requestTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for vpcsecuritygroupid0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(vpcsecuritygroupid0)
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSubnetIds)
            for vpcsubnetid0 in vpcSubnetIds {
                try vpcSubnetIdsContainer.encode(vpcsubnetid0)
            }
        }
    }
}

extension CreateDbInstanceInput {

    static func urlPathProvider(_ value: CreateDbInstanceInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateDbInstanceInput: Swift.Equatable {
    /// The amount of storage to allocate for your DB storage type in GiB (gibibytes).
    /// This member is required.
    public var allocatedStorage: Swift.Int?
    /// The name of the initial InfluxDB bucket. All InfluxDB data is stored in a bucket. A bucket combines the concept of a database and a retention period (the duration of time that each data point persists). A bucket belongs to an organization.
    public var bucket: Swift.String?
    /// The Timestream for InfluxDB DB instance type to run InfluxDB on.
    /// This member is required.
    public var dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType?
    /// The id of the DB parameter group to assign to your DB instance. DB parameter groups specify how the database is configured. For example, DB parameter groups can specify the limit for query concurrency.
    public var dbParameterGroupIdentifier: Swift.String?
    /// The Timestream for InfluxDB DB storage type to read and write InfluxDB data. You can choose between 3 different types of provisioned Influx IOPS included storage according to your workloads requirements:
    ///
    /// * Influx IO Included 3000 IOPS
    ///
    /// * Influx IO Included 12000 IOPS
    ///
    /// * Influx IO Included 16000 IOPS
    public var dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType?
    /// Specifies whether the DB instance will be deployed as a standalone instance or with a Multi-AZ standby for high availability.
    public var deploymentType: TimestreamInfluxDBClientTypes.DeploymentType?
    /// Configuration for sending InfluxDB engine logs to a specified S3 bucket.
    public var logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration?
    /// The name that uniquely identifies the DB instance when interacting with the Amazon Timestream for InfluxDB API and CLI commands. This name will also be a prefix included in the endpoint. DB instance names must be unique per customer and per region.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the initial organization for the initial admin user in InfluxDB. An InfluxDB organization is a workspace for a group of users.
    public var organization: Swift.String?
    /// The password of the initial admin user created in InfluxDB. This password will allow you to access the InfluxDB UI to perform various administrative tasks and also use the InfluxDB CLI to create an operator token. These attributes will be stored in a Secret created in AWS SecretManager in your account.
    /// This member is required.
    public var password: Swift.String?
    /// Configures the DB instance with a public IP to facilitate access.
    public var publiclyAccessible: Swift.Bool?
    /// A list of key-value pairs to associate with the DB instance.
    public var tags: [Swift.String:Swift.String]?
    /// The username of the initial admin user created in InfluxDB. Must start with a letter and can't end with a hyphen or contain two consecutive hyphens. For example, my-user1. This username will allow you to access the InfluxDB UI to perform various administrative tasks and also use the InfluxDB CLI to create an operator token. These attributes will be stored in a Secret created in Amazon Secrets Manager in your account.
    public var username: Swift.String?
    /// A list of VPC security group IDs to associate with the DB instance.
    /// This member is required.
    public var vpcSecurityGroupIds: [Swift.String]?
    /// A list of VPC subnet IDs to associate with the DB instance. Provide at least two VPC subnet IDs in different availability zones when deploying with a Multi-AZ standby.
    /// This member is required.
    public var vpcSubnetIds: [Swift.String]?

    public init(
        allocatedStorage: Swift.Int? = nil,
        bucket: Swift.String? = nil,
        dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType? = nil,
        dbParameterGroupIdentifier: Swift.String? = nil,
        dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType? = nil,
        deploymentType: TimestreamInfluxDBClientTypes.DeploymentType? = nil,
        logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration? = nil,
        name: Swift.String? = nil,
        organization: Swift.String? = nil,
        password: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        username: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil,
        vpcSubnetIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.bucket = bucket
        self.dbInstanceType = dbInstanceType
        self.dbParameterGroupIdentifier = dbParameterGroupIdentifier
        self.dbStorageType = dbStorageType
        self.deploymentType = deploymentType
        self.logDeliveryConfiguration = logDeliveryConfiguration
        self.name = name
        self.organization = organization
        self.password = password
        self.publiclyAccessible = publiclyAccessible
        self.tags = tags
        self.username = username
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

struct CreateDbInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let username: Swift.String?
    let password: Swift.String?
    let organization: Swift.String?
    let bucket: Swift.String?
    let dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType?
    let vpcSubnetIds: [Swift.String]?
    let vpcSecurityGroupIds: [Swift.String]?
    let publiclyAccessible: Swift.Bool?
    let dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType?
    let allocatedStorage: Swift.Int?
    let dbParameterGroupIdentifier: Swift.String?
    let deploymentType: TimestreamInfluxDBClientTypes.DeploymentType?
    let logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDbInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage
        case bucket
        case dbInstanceType
        case dbParameterGroupIdentifier
        case dbStorageType
        case deploymentType
        case logDeliveryConfiguration
        case name
        case organization
        case password
        case publiclyAccessible
        case tags
        case username
        case vpcSecurityGroupIds
        case vpcSubnetIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let organizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organization)
        organization = organizationDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let dbInstanceTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DbInstanceType.self, forKey: .dbInstanceType)
        dbInstanceType = dbInstanceTypeDecoded
        let vpcSubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSubnetIds)
        var vpcSubnetIdsDecoded0:[Swift.String]? = nil
        if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
            vpcSubnetIdsDecoded0 = [Swift.String]()
            for string0 in vpcSubnetIdsContainer {
                if let string0 = string0 {
                    vpcSubnetIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSubnetIds = vpcSubnetIdsDecoded0
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let dbStorageTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DbStorageType.self, forKey: .dbStorageType)
        dbStorageType = dbStorageTypeDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let dbParameterGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbParameterGroupIdentifier)
        dbParameterGroupIdentifier = dbParameterGroupIdentifierDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let logDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.LogDeliveryConfiguration.self, forKey: .logDeliveryConfiguration)
        logDeliveryConfiguration = logDeliveryConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDbInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDbInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.allocatedStorage = output.allocatedStorage
            self.arn = output.arn
            self.availabilityZone = output.availabilityZone
            self.dbInstanceType = output.dbInstanceType
            self.dbParameterGroupIdentifier = output.dbParameterGroupIdentifier
            self.dbStorageType = output.dbStorageType
            self.deploymentType = output.deploymentType
            self.endpoint = output.endpoint
            self.id = output.id
            self.influxAuthParametersSecretArn = output.influxAuthParametersSecretArn
            self.logDeliveryConfiguration = output.logDeliveryConfiguration
            self.name = output.name
            self.publiclyAccessible = output.publiclyAccessible
            self.secondaryAvailabilityZone = output.secondaryAvailabilityZone
            self.status = output.status
            self.vpcSecurityGroupIds = output.vpcSecurityGroupIds
            self.vpcSubnetIds = output.vpcSubnetIds
        } else {
            self.allocatedStorage = nil
            self.arn = nil
            self.availabilityZone = nil
            self.dbInstanceType = nil
            self.dbParameterGroupIdentifier = nil
            self.dbStorageType = nil
            self.deploymentType = nil
            self.endpoint = nil
            self.id = nil
            self.influxAuthParametersSecretArn = nil
            self.logDeliveryConfiguration = nil
            self.name = nil
            self.publiclyAccessible = nil
            self.secondaryAvailabilityZone = nil
            self.status = nil
            self.vpcSecurityGroupIds = nil
            self.vpcSubnetIds = nil
        }
    }
}

public struct CreateDbInstanceOutput: Swift.Equatable {
    /// The amount of storage allocated for your DB storage type (in gibibytes).
    public var allocatedStorage: Swift.Int?
    /// The Amazon Resource Name (ARN) of the DB instance.
    /// This member is required.
    public var arn: Swift.String?
    /// The Availability Zone in which the DB instance resides.
    public var availabilityZone: Swift.String?
    /// The Timestream for InfluxDB instance type that InfluxDB runs on.
    public var dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType?
    /// The id of the DB parameter group assigned to your DB instance.
    public var dbParameterGroupIdentifier: Swift.String?
    /// The Timestream for InfluxDB DB storage type that InfluxDB stores data on.
    public var dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType?
    /// Specifies whether the Timestream for InfluxDB is deployed as Single-AZ or with a MultiAZ Standby for High availability.
    public var deploymentType: TimestreamInfluxDBClientTypes.DeploymentType?
    /// The endpoint used to connect to InfluxDB. The default InfluxDB port is 8086.
    public var endpoint: Swift.String?
    /// A service-generated unique identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.
    public var influxAuthParametersSecretArn: Swift.String?
    /// Configuration for sending InfluxDB engine logs to send to specified S3 bucket.
    public var logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration?
    /// The customer-supplied name that uniquely identifies the DB instance when interacting with the Amazon Timestream for InfluxDB API and CLI commands.
    /// This member is required.
    public var name: Swift.String?
    /// Indicates if the DB instance has a public IP to facilitate access.
    public var publiclyAccessible: Swift.Bool?
    /// The Availability Zone in which the standby instance is located when deploying with a MultiAZ standby instance.
    public var secondaryAvailabilityZone: Swift.String?
    /// The status of the DB instance.
    public var status: TimestreamInfluxDBClientTypes.Status?
    /// A list of VPC security group IDs associated with the DB instance.
    public var vpcSecurityGroupIds: [Swift.String]?
    /// A list of VPC subnet IDs associated with the DB instance.
    /// This member is required.
    public var vpcSubnetIds: [Swift.String]?

    public init(
        allocatedStorage: Swift.Int? = nil,
        arn: Swift.String? = nil,
        availabilityZone: Swift.String? = nil,
        dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType? = nil,
        dbParameterGroupIdentifier: Swift.String? = nil,
        dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType? = nil,
        deploymentType: TimestreamInfluxDBClientTypes.DeploymentType? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        influxAuthParametersSecretArn: Swift.String? = nil,
        logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration? = nil,
        name: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        secondaryAvailabilityZone: Swift.String? = nil,
        status: TimestreamInfluxDBClientTypes.Status? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil,
        vpcSubnetIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.arn = arn
        self.availabilityZone = availabilityZone
        self.dbInstanceType = dbInstanceType
        self.dbParameterGroupIdentifier = dbParameterGroupIdentifier
        self.dbStorageType = dbStorageType
        self.deploymentType = deploymentType
        self.endpoint = endpoint
        self.id = id
        self.influxAuthParametersSecretArn = influxAuthParametersSecretArn
        self.logDeliveryConfiguration = logDeliveryConfiguration
        self.name = name
        self.publiclyAccessible = publiclyAccessible
        self.secondaryAvailabilityZone = secondaryAvailabilityZone
        self.status = status
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

struct CreateDbInstanceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: TimestreamInfluxDBClientTypes.Status?
    let endpoint: Swift.String?
    let dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType?
    let dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType?
    let allocatedStorage: Swift.Int?
    let deploymentType: TimestreamInfluxDBClientTypes.DeploymentType?
    let vpcSubnetIds: [Swift.String]?
    let publiclyAccessible: Swift.Bool?
    let vpcSecurityGroupIds: [Swift.String]?
    let dbParameterGroupIdentifier: Swift.String?
    let availabilityZone: Swift.String?
    let secondaryAvailabilityZone: Swift.String?
    let logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration?
    let influxAuthParametersSecretArn: Swift.String?
}

extension CreateDbInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage
        case arn
        case availabilityZone
        case dbInstanceType
        case dbParameterGroupIdentifier
        case dbStorageType
        case deploymentType
        case endpoint
        case id
        case influxAuthParametersSecretArn
        case logDeliveryConfiguration
        case name
        case publiclyAccessible
        case secondaryAvailabilityZone
        case status
        case vpcSecurityGroupIds
        case vpcSubnetIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let dbInstanceTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DbInstanceType.self, forKey: .dbInstanceType)
        dbInstanceType = dbInstanceTypeDecoded
        let dbStorageTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DbStorageType.self, forKey: .dbStorageType)
        dbStorageType = dbStorageTypeDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let vpcSubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSubnetIds)
        var vpcSubnetIdsDecoded0:[Swift.String]? = nil
        if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
            vpcSubnetIdsDecoded0 = [Swift.String]()
            for string0 in vpcSubnetIdsContainer {
                if let string0 = string0 {
                    vpcSubnetIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSubnetIds = vpcSubnetIdsDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let dbParameterGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbParameterGroupIdentifier)
        dbParameterGroupIdentifier = dbParameterGroupIdentifierDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let logDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.LogDeliveryConfiguration.self, forKey: .logDeliveryConfiguration)
        logDeliveryConfiguration = logDeliveryConfigurationDecoded
        let influxAuthParametersSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .influxAuthParametersSecretArn)
        influxAuthParametersSecretArn = influxAuthParametersSecretArnDecoded
    }
}

enum CreateDbInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDbParameterGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case parameters
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, requestTagMap0) in tags {
                try tagsContainer.encode(requestTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDbParameterGroupInput {

    static func urlPathProvider(_ value: CreateDbParameterGroupInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateDbParameterGroupInput: Swift.Equatable {
    /// A description of the DB parameter group.
    public var description: Swift.String?
    /// The name of the DB parameter group. The name must be unique per customer and per region.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the parameters that comprise the DB parameter group.
    public var parameters: TimestreamInfluxDBClientTypes.Parameters?
    /// A list of key-value pairs to associate with the DB parameter group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: TimestreamInfluxDBClientTypes.Parameters? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
        self.tags = tags
    }
}

struct CreateDbParameterGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let parameters: TimestreamInfluxDBClientTypes.Parameters?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDbParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case parameters
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDbParameterGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDbParameterGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.parameters = output.parameters
        } else {
            self.arn = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.parameters = nil
        }
    }
}

public struct CreateDbParameterGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARM) of the DB parameter group.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the DB parameter group.
    public var description: Swift.String?
    /// A service-generated unique identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The customer-supplied name that uniquely identifies the DB parameter group when interacting with the Amazon Timestream for InfluxDB API and CLI commands.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the parameters that comprise the DB parameter group.
    public var parameters: TimestreamInfluxDBClientTypes.Parameters?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: TimestreamInfluxDBClientTypes.Parameters? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.id = id
        self.name = name
        self.parameters = parameters
    }
}

struct CreateDbParameterGroupOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let parameters: TimestreamInfluxDBClientTypes.Parameters?
}

extension CreateDbParameterGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case id
        case name
        case parameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

enum CreateDbParameterGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TimestreamInfluxDBClientTypes.DbInstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage
        case arn
        case dbInstanceType
        case dbStorageType
        case deploymentType
        case endpoint
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = self.allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dbInstanceType = self.dbInstanceType {
            try encodeContainer.encode(dbInstanceType.rawValue, forKey: .dbInstanceType)
        }
        if let dbStorageType = self.dbStorageType {
            try encodeContainer.encode(dbStorageType.rawValue, forKey: .dbStorageType)
        }
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let dbInstanceTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DbInstanceType.self, forKey: .dbInstanceType)
        dbInstanceType = dbInstanceTypeDecoded
        let dbStorageTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DbStorageType.self, forKey: .dbStorageType)
        dbStorageType = dbStorageTypeDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
    }
}

extension TimestreamInfluxDBClientTypes {
    /// Contains a summary of a DB instance.
    public struct DbInstanceSummary: Swift.Equatable {
        /// The amount of storage to allocate for your DbStorageType in GiB (gibibytes).
        public var allocatedStorage: Swift.Int?
        /// The Amazon Resource Name (ARN) of the DB instance.
        /// This member is required.
        public var arn: Swift.String?
        /// The Timestream for InfluxDB instance type to run InfluxDB on.
        public var dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType?
        /// The storage type for your DB instance.
        public var dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType?
        /// Single-Instance or with a MultiAZ Standby for High availability.
        public var deploymentType: TimestreamInfluxDBClientTypes.DeploymentType?
        /// The endpoint used to connect to InfluxDB. The default InfluxDB port is 8086.
        public var endpoint: Swift.String?
        /// The service-generated unique identifier of the DB instance.
        /// This member is required.
        public var id: Swift.String?
        /// This customer-supplied name uniquely identifies the DB instance when interacting with the Amazon Timestream for InfluxDB API and AWS CLI commands.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the DB instance.
        public var status: TimestreamInfluxDBClientTypes.Status?

        public init(
            allocatedStorage: Swift.Int? = nil,
            arn: Swift.String? = nil,
            dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType? = nil,
            dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType? = nil,
            deploymentType: TimestreamInfluxDBClientTypes.DeploymentType? = nil,
            endpoint: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: TimestreamInfluxDBClientTypes.Status? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.arn = arn
            self.dbInstanceType = dbInstanceType
            self.dbStorageType = dbStorageType
            self.deploymentType = deploymentType
            self.endpoint = endpoint
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension TimestreamInfluxDBClientTypes {
    public enum DbInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dbInflux12xlarge
        case dbInflux16xlarge
        case dbInflux2xlarge
        case dbInflux4xlarge
        case dbInflux8xlarge
        case dbInfluxLarge
        case dbInfluxMedium
        case dbInfluxXlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [DbInstanceType] {
            return [
                .dbInflux12xlarge,
                .dbInflux16xlarge,
                .dbInflux2xlarge,
                .dbInflux4xlarge,
                .dbInflux8xlarge,
                .dbInfluxLarge,
                .dbInfluxMedium,
                .dbInfluxXlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dbInflux12xlarge: return "db.influx.12xlarge"
            case .dbInflux16xlarge: return "db.influx.16xlarge"
            case .dbInflux2xlarge: return "db.influx.2xlarge"
            case .dbInflux4xlarge: return "db.influx.4xlarge"
            case .dbInflux8xlarge: return "db.influx.8xlarge"
            case .dbInfluxLarge: return "db.influx.large"
            case .dbInfluxMedium: return "db.influx.medium"
            case .dbInfluxXlarge: return "db.influx.xlarge"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DbInstanceType(rawValue: rawValue) ?? DbInstanceType.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamInfluxDBClientTypes.DbParameterGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension TimestreamInfluxDBClientTypes {
    /// Contains a summary of a DB parameter group.
    public struct DbParameterGroupSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the DB parameter group.
        /// This member is required.
        public var arn: Swift.String?
        /// A description of the DB parameter group.
        public var description: Swift.String?
        /// A service-generated unique identifier.
        /// This member is required.
        public var id: Swift.String?
        /// This customer-supplied name uniquely identifies the parameter group.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
        }
    }

}

extension TimestreamInfluxDBClientTypes {
    public enum DbStorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case influxIoIncludedT1
        case influxIoIncludedT2
        case influxIoIncludedT3
        case sdkUnknown(Swift.String)

        public static var allCases: [DbStorageType] {
            return [
                .influxIoIncludedT1,
                .influxIoIncludedT2,
                .influxIoIncludedT3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .influxIoIncludedT1: return "InfluxIOIncludedT1"
            case .influxIoIncludedT2: return "InfluxIOIncludedT2"
            case .influxIoIncludedT3: return "InfluxIOIncludedT3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DbStorageType(rawValue: rawValue) ?? DbStorageType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteDbInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension DeleteDbInstanceInput {

    static func urlPathProvider(_ value: DeleteDbInstanceInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteDbInstanceInput: Swift.Equatable {
    /// The id of the DB instance.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteDbInstanceInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension DeleteDbInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DeleteDbInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDbInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.allocatedStorage = output.allocatedStorage
            self.arn = output.arn
            self.availabilityZone = output.availabilityZone
            self.dbInstanceType = output.dbInstanceType
            self.dbParameterGroupIdentifier = output.dbParameterGroupIdentifier
            self.dbStorageType = output.dbStorageType
            self.deploymentType = output.deploymentType
            self.endpoint = output.endpoint
            self.id = output.id
            self.influxAuthParametersSecretArn = output.influxAuthParametersSecretArn
            self.logDeliveryConfiguration = output.logDeliveryConfiguration
            self.name = output.name
            self.publiclyAccessible = output.publiclyAccessible
            self.secondaryAvailabilityZone = output.secondaryAvailabilityZone
            self.status = output.status
            self.vpcSecurityGroupIds = output.vpcSecurityGroupIds
            self.vpcSubnetIds = output.vpcSubnetIds
        } else {
            self.allocatedStorage = nil
            self.arn = nil
            self.availabilityZone = nil
            self.dbInstanceType = nil
            self.dbParameterGroupIdentifier = nil
            self.dbStorageType = nil
            self.deploymentType = nil
            self.endpoint = nil
            self.id = nil
            self.influxAuthParametersSecretArn = nil
            self.logDeliveryConfiguration = nil
            self.name = nil
            self.publiclyAccessible = nil
            self.secondaryAvailabilityZone = nil
            self.status = nil
            self.vpcSecurityGroupIds = nil
            self.vpcSubnetIds = nil
        }
    }
}

public struct DeleteDbInstanceOutput: Swift.Equatable {
    /// The amount of storage allocated for your DB storage type (in gibibytes).
    public var allocatedStorage: Swift.Int?
    /// The Amazon Resource Name (ARN) of the DB instance.
    /// This member is required.
    public var arn: Swift.String?
    /// The Availability Zone in which the DB instance resides.
    public var availabilityZone: Swift.String?
    /// The Timestream for InfluxDB instance type that InfluxDB runs on.
    public var dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType?
    /// The id of the DB parameter group assigned to your DB instance.
    public var dbParameterGroupIdentifier: Swift.String?
    /// The Timestream for InfluxDB DB storage type that InfluxDB stores data on.
    public var dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType?
    /// Specifies whether the Timestream for InfluxDB is deployed as Single-AZ or with a MultiAZ Standby for High availability.
    public var deploymentType: TimestreamInfluxDBClientTypes.DeploymentType?
    /// The endpoint used to connect to InfluxDB. The default InfluxDB port is 8086.
    public var endpoint: Swift.String?
    /// A service-generated unique identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.
    public var influxAuthParametersSecretArn: Swift.String?
    /// Configuration for sending InfluxDB engine logs to send to specified S3 bucket.
    public var logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration?
    /// The customer-supplied name that uniquely identifies the DB instance when interacting with the Amazon Timestream for InfluxDB API and CLI commands.
    /// This member is required.
    public var name: Swift.String?
    /// Indicates if the DB instance has a public IP to facilitate access.
    public var publiclyAccessible: Swift.Bool?
    /// The Availability Zone in which the standby instance is located when deploying with a MultiAZ standby instance.
    public var secondaryAvailabilityZone: Swift.String?
    /// The status of the DB instance.
    public var status: TimestreamInfluxDBClientTypes.Status?
    /// A list of VPC security group IDs associated with the DB instance.
    public var vpcSecurityGroupIds: [Swift.String]?
    /// A list of VPC subnet IDs associated with the DB instance.
    /// This member is required.
    public var vpcSubnetIds: [Swift.String]?

    public init(
        allocatedStorage: Swift.Int? = nil,
        arn: Swift.String? = nil,
        availabilityZone: Swift.String? = nil,
        dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType? = nil,
        dbParameterGroupIdentifier: Swift.String? = nil,
        dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType? = nil,
        deploymentType: TimestreamInfluxDBClientTypes.DeploymentType? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        influxAuthParametersSecretArn: Swift.String? = nil,
        logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration? = nil,
        name: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        secondaryAvailabilityZone: Swift.String? = nil,
        status: TimestreamInfluxDBClientTypes.Status? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil,
        vpcSubnetIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.arn = arn
        self.availabilityZone = availabilityZone
        self.dbInstanceType = dbInstanceType
        self.dbParameterGroupIdentifier = dbParameterGroupIdentifier
        self.dbStorageType = dbStorageType
        self.deploymentType = deploymentType
        self.endpoint = endpoint
        self.id = id
        self.influxAuthParametersSecretArn = influxAuthParametersSecretArn
        self.logDeliveryConfiguration = logDeliveryConfiguration
        self.name = name
        self.publiclyAccessible = publiclyAccessible
        self.secondaryAvailabilityZone = secondaryAvailabilityZone
        self.status = status
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

struct DeleteDbInstanceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: TimestreamInfluxDBClientTypes.Status?
    let endpoint: Swift.String?
    let dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType?
    let dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType?
    let allocatedStorage: Swift.Int?
    let deploymentType: TimestreamInfluxDBClientTypes.DeploymentType?
    let vpcSubnetIds: [Swift.String]?
    let publiclyAccessible: Swift.Bool?
    let vpcSecurityGroupIds: [Swift.String]?
    let dbParameterGroupIdentifier: Swift.String?
    let availabilityZone: Swift.String?
    let secondaryAvailabilityZone: Swift.String?
    let logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration?
    let influxAuthParametersSecretArn: Swift.String?
}

extension DeleteDbInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage
        case arn
        case availabilityZone
        case dbInstanceType
        case dbParameterGroupIdentifier
        case dbStorageType
        case deploymentType
        case endpoint
        case id
        case influxAuthParametersSecretArn
        case logDeliveryConfiguration
        case name
        case publiclyAccessible
        case secondaryAvailabilityZone
        case status
        case vpcSecurityGroupIds
        case vpcSubnetIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let dbInstanceTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DbInstanceType.self, forKey: .dbInstanceType)
        dbInstanceType = dbInstanceTypeDecoded
        let dbStorageTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DbStorageType.self, forKey: .dbStorageType)
        dbStorageType = dbStorageTypeDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let vpcSubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSubnetIds)
        var vpcSubnetIdsDecoded0:[Swift.String]? = nil
        if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
            vpcSubnetIdsDecoded0 = [Swift.String]()
            for string0 in vpcSubnetIdsContainer {
                if let string0 = string0 {
                    vpcSubnetIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSubnetIds = vpcSubnetIdsDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let dbParameterGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbParameterGroupIdentifier)
        dbParameterGroupIdentifier = dbParameterGroupIdentifierDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let logDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.LogDeliveryConfiguration.self, forKey: .logDeliveryConfiguration)
        logDeliveryConfiguration = logDeliveryConfigurationDecoded
        let influxAuthParametersSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .influxAuthParametersSecretArn)
        influxAuthParametersSecretArn = influxAuthParametersSecretArnDecoded
    }
}

enum DeleteDbInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TimestreamInfluxDBClientTypes {
    public enum DeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case singleAz
        case withMultiazStandby
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentType] {
            return [
                .singleAz,
                .withMultiazStandby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .singleAz: return "SINGLE_AZ"
            case .withMultiazStandby: return "WITH_MULTIAZ_STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentType(rawValue: rawValue) ?? DeploymentType.sdkUnknown(rawValue)
        }
    }
}

extension GetDbInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension GetDbInstanceInput {

    static func urlPathProvider(_ value: GetDbInstanceInput) -> Swift.String? {
        return "/"
    }
}

public struct GetDbInstanceInput: Swift.Equatable {
    /// The id of the DB instance.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetDbInstanceInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension GetDbInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetDbInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDbInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.allocatedStorage = output.allocatedStorage
            self.arn = output.arn
            self.availabilityZone = output.availabilityZone
            self.dbInstanceType = output.dbInstanceType
            self.dbParameterGroupIdentifier = output.dbParameterGroupIdentifier
            self.dbStorageType = output.dbStorageType
            self.deploymentType = output.deploymentType
            self.endpoint = output.endpoint
            self.id = output.id
            self.influxAuthParametersSecretArn = output.influxAuthParametersSecretArn
            self.logDeliveryConfiguration = output.logDeliveryConfiguration
            self.name = output.name
            self.publiclyAccessible = output.publiclyAccessible
            self.secondaryAvailabilityZone = output.secondaryAvailabilityZone
            self.status = output.status
            self.vpcSecurityGroupIds = output.vpcSecurityGroupIds
            self.vpcSubnetIds = output.vpcSubnetIds
        } else {
            self.allocatedStorage = nil
            self.arn = nil
            self.availabilityZone = nil
            self.dbInstanceType = nil
            self.dbParameterGroupIdentifier = nil
            self.dbStorageType = nil
            self.deploymentType = nil
            self.endpoint = nil
            self.id = nil
            self.influxAuthParametersSecretArn = nil
            self.logDeliveryConfiguration = nil
            self.name = nil
            self.publiclyAccessible = nil
            self.secondaryAvailabilityZone = nil
            self.status = nil
            self.vpcSecurityGroupIds = nil
            self.vpcSubnetIds = nil
        }
    }
}

public struct GetDbInstanceOutput: Swift.Equatable {
    /// The amount of storage allocated for your DB storage type (in gibibytes).
    public var allocatedStorage: Swift.Int?
    /// The Amazon Resource Name (ARN) of the DB instance.
    /// This member is required.
    public var arn: Swift.String?
    /// The Availability Zone in which the DB instance resides.
    public var availabilityZone: Swift.String?
    /// The Timestream for InfluxDB instance type that InfluxDB runs on.
    public var dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType?
    /// The id of the DB parameter group assigned to your DB instance.
    public var dbParameterGroupIdentifier: Swift.String?
    /// The Timestream for InfluxDB DB storage type that InfluxDB stores data on.
    public var dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType?
    /// Specifies whether the Timestream for InfluxDB is deployed as Single-AZ or with a MultiAZ Standby for High availability.
    public var deploymentType: TimestreamInfluxDBClientTypes.DeploymentType?
    /// The endpoint used to connect to InfluxDB. The default InfluxDB port is 8086.
    public var endpoint: Swift.String?
    /// A service-generated unique identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.
    public var influxAuthParametersSecretArn: Swift.String?
    /// Configuration for sending InfluxDB engine logs to send to specified S3 bucket.
    public var logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration?
    /// The customer-supplied name that uniquely identifies the DB instance when interacting with the Amazon Timestream for InfluxDB API and CLI commands.
    /// This member is required.
    public var name: Swift.String?
    /// Indicates if the DB instance has a public IP to facilitate access.
    public var publiclyAccessible: Swift.Bool?
    /// The Availability Zone in which the standby instance is located when deploying with a MultiAZ standby instance.
    public var secondaryAvailabilityZone: Swift.String?
    /// The status of the DB instance.
    public var status: TimestreamInfluxDBClientTypes.Status?
    /// A list of VPC security group IDs associated with the DB instance.
    public var vpcSecurityGroupIds: [Swift.String]?
    /// A list of VPC subnet IDs associated with the DB instance.
    /// This member is required.
    public var vpcSubnetIds: [Swift.String]?

    public init(
        allocatedStorage: Swift.Int? = nil,
        arn: Swift.String? = nil,
        availabilityZone: Swift.String? = nil,
        dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType? = nil,
        dbParameterGroupIdentifier: Swift.String? = nil,
        dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType? = nil,
        deploymentType: TimestreamInfluxDBClientTypes.DeploymentType? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        influxAuthParametersSecretArn: Swift.String? = nil,
        logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration? = nil,
        name: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        secondaryAvailabilityZone: Swift.String? = nil,
        status: TimestreamInfluxDBClientTypes.Status? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil,
        vpcSubnetIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.arn = arn
        self.availabilityZone = availabilityZone
        self.dbInstanceType = dbInstanceType
        self.dbParameterGroupIdentifier = dbParameterGroupIdentifier
        self.dbStorageType = dbStorageType
        self.deploymentType = deploymentType
        self.endpoint = endpoint
        self.id = id
        self.influxAuthParametersSecretArn = influxAuthParametersSecretArn
        self.logDeliveryConfiguration = logDeliveryConfiguration
        self.name = name
        self.publiclyAccessible = publiclyAccessible
        self.secondaryAvailabilityZone = secondaryAvailabilityZone
        self.status = status
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

struct GetDbInstanceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: TimestreamInfluxDBClientTypes.Status?
    let endpoint: Swift.String?
    let dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType?
    let dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType?
    let allocatedStorage: Swift.Int?
    let deploymentType: TimestreamInfluxDBClientTypes.DeploymentType?
    let vpcSubnetIds: [Swift.String]?
    let publiclyAccessible: Swift.Bool?
    let vpcSecurityGroupIds: [Swift.String]?
    let dbParameterGroupIdentifier: Swift.String?
    let availabilityZone: Swift.String?
    let secondaryAvailabilityZone: Swift.String?
    let logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration?
    let influxAuthParametersSecretArn: Swift.String?
}

extension GetDbInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage
        case arn
        case availabilityZone
        case dbInstanceType
        case dbParameterGroupIdentifier
        case dbStorageType
        case deploymentType
        case endpoint
        case id
        case influxAuthParametersSecretArn
        case logDeliveryConfiguration
        case name
        case publiclyAccessible
        case secondaryAvailabilityZone
        case status
        case vpcSecurityGroupIds
        case vpcSubnetIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let dbInstanceTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DbInstanceType.self, forKey: .dbInstanceType)
        dbInstanceType = dbInstanceTypeDecoded
        let dbStorageTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DbStorageType.self, forKey: .dbStorageType)
        dbStorageType = dbStorageTypeDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let vpcSubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSubnetIds)
        var vpcSubnetIdsDecoded0:[Swift.String]? = nil
        if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
            vpcSubnetIdsDecoded0 = [Swift.String]()
            for string0 in vpcSubnetIdsContainer {
                if let string0 = string0 {
                    vpcSubnetIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSubnetIds = vpcSubnetIdsDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let dbParameterGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbParameterGroupIdentifier)
        dbParameterGroupIdentifier = dbParameterGroupIdentifierDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let logDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.LogDeliveryConfiguration.self, forKey: .logDeliveryConfiguration)
        logDeliveryConfiguration = logDeliveryConfigurationDecoded
        let influxAuthParametersSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .influxAuthParametersSecretArn)
        influxAuthParametersSecretArn = influxAuthParametersSecretArnDecoded
    }
}

enum GetDbInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDbParameterGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension GetDbParameterGroupInput {

    static func urlPathProvider(_ value: GetDbParameterGroupInput) -> Swift.String? {
        return "/"
    }
}

public struct GetDbParameterGroupInput: Swift.Equatable {
    /// The id of the DB parameter group.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetDbParameterGroupInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension GetDbParameterGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetDbParameterGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDbParameterGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.parameters = output.parameters
        } else {
            self.arn = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.parameters = nil
        }
    }
}

public struct GetDbParameterGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the DB parameter group.
    /// This member is required.
    public var arn: Swift.String?
    /// A description of the DB parameter group.
    public var description: Swift.String?
    /// A service-generated unique identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The customer-supplied name that uniquely identifies the DB parameter group when interacting with the Amazon Timestream for InfluxDB API and CLI commands.
    /// This member is required.
    public var name: Swift.String?
    /// The parameters that comprise the DB parameter group.
    public var parameters: TimestreamInfluxDBClientTypes.Parameters?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: TimestreamInfluxDBClientTypes.Parameters? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.id = id
        self.name = name
        self.parameters = parameters
    }
}

struct GetDbParameterGroupOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let parameters: TimestreamInfluxDBClientTypes.Parameters?
}

extension GetDbParameterGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case id
        case name
        case parameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.Parameters.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

enum GetDbParameterGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TimestreamInfluxDBClientTypes.InfluxDBv2Parameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fluxLogEnabled
        case logLevel
        case metricsDisabled
        case noTasks
        case queryConcurrency
        case queryQueueSize
        case tracingType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fluxLogEnabled = self.fluxLogEnabled {
            try encodeContainer.encode(fluxLogEnabled, forKey: .fluxLogEnabled)
        }
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let metricsDisabled = self.metricsDisabled {
            try encodeContainer.encode(metricsDisabled, forKey: .metricsDisabled)
        }
        if let noTasks = self.noTasks {
            try encodeContainer.encode(noTasks, forKey: .noTasks)
        }
        if let queryConcurrency = self.queryConcurrency {
            try encodeContainer.encode(queryConcurrency, forKey: .queryConcurrency)
        }
        if let queryQueueSize = self.queryQueueSize {
            try encodeContainer.encode(queryQueueSize, forKey: .queryQueueSize)
        }
        if let tracingType = self.tracingType {
            try encodeContainer.encode(tracingType.rawValue, forKey: .tracingType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fluxLogEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fluxLogEnabled)
        fluxLogEnabled = fluxLogEnabledDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let noTasksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noTasks)
        noTasks = noTasksDecoded
        let queryConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryConcurrency)
        queryConcurrency = queryConcurrencyDecoded
        let queryQueueSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryQueueSize)
        queryQueueSize = queryQueueSizeDecoded
        let tracingTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.TracingType.self, forKey: .tracingType)
        tracingType = tracingTypeDecoded
        let metricsDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .metricsDisabled)
        metricsDisabled = metricsDisabledDecoded
    }
}

extension TimestreamInfluxDBClientTypes {
    /// All the customer-modifiable InfluxDB v2 parameters in Timestream for InfluxDB.
    public struct InfluxDBv2Parameters: Swift.Equatable {
        /// Include option to show detailed logs for Flux queries. Default: false
        public var fluxLogEnabled: Swift.Bool?
        /// Log output level. InfluxDB outputs log entries with severity levels greater than or equal to the level specified. Default: info
        public var logLevel: TimestreamInfluxDBClientTypes.LogLevel?
        /// Disable the HTTP /metrics endpoint which exposes [internal InfluxDB metrics](https://docs.influxdata.com/influxdb/v2/reference/internals/metrics/). Default: false
        public var metricsDisabled: Swift.Bool?
        /// Disable the task scheduler. If problematic tasks prevent InfluxDB from starting, use this option to start InfluxDB without scheduling or executing tasks. Default: false
        public var noTasks: Swift.Bool?
        /// Number of queries allowed to execute concurrently. Setting to 0 allows an unlimited number of concurrent queries. Default: 0
        public var queryConcurrency: Swift.Int?
        /// Maximum number of queries allowed in execution queue. When queue limit is reached, new queries are rejected. Setting to 0 allows an unlimited number of queries in the queue. Default: 0
        public var queryQueueSize: Swift.Int?
        /// Enable tracing in InfluxDB and specifies the tracing type. Tracing is disabled by default.
        public var tracingType: TimestreamInfluxDBClientTypes.TracingType?

        public init(
            fluxLogEnabled: Swift.Bool? = nil,
            logLevel: TimestreamInfluxDBClientTypes.LogLevel? = nil,
            metricsDisabled: Swift.Bool? = nil,
            noTasks: Swift.Bool? = nil,
            queryConcurrency: Swift.Int? = nil,
            queryQueueSize: Swift.Int? = nil,
            tracingType: TimestreamInfluxDBClientTypes.TracingType? = nil
        )
        {
            self.fluxLogEnabled = fluxLogEnabled
            self.logLevel = logLevel
            self.metricsDisabled = metricsDisabled
            self.noTasks = noTasks
            self.queryConcurrency = queryConcurrency
            self.queryQueueSize = queryQueueSize
            self.tracingType = tracingType
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDbInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDbInstancesInput {

    static func urlPathProvider(_ value: ListDbInstancesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListDbInstancesInput: Swift.Equatable {
    /// The maximum number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDbInstancesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDbInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDbInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDbInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDbInstancesOutput: Swift.Equatable {
    /// A list of Timestream for InfluxDB DB instance summaries.
    /// This member is required.
    public var items: [TimestreamInfluxDBClientTypes.DbInstanceSummary]?
    /// Token from a previous call of the operation. When this value is provided, the service returns results from where the previous response left off.
    public var nextToken: Swift.String?

    public init(
        items: [TimestreamInfluxDBClientTypes.DbInstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDbInstancesOutputBody: Swift.Equatable {
    let items: [TimestreamInfluxDBClientTypes.DbInstanceSummary]?
    let nextToken: Swift.String?
}

extension ListDbInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([TimestreamInfluxDBClientTypes.DbInstanceSummary?].self, forKey: .items)
        var itemsDecoded0:[TimestreamInfluxDBClientTypes.DbInstanceSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [TimestreamInfluxDBClientTypes.DbInstanceSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDbInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDbParameterGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDbParameterGroupsInput {

    static func urlPathProvider(_ value: ListDbParameterGroupsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListDbParameterGroupsInput: Swift.Equatable {
    /// The maximum number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDbParameterGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDbParameterGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDbParameterGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDbParameterGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDbParameterGroupsOutput: Swift.Equatable {
    /// A list of Timestream for InfluxDB DB parameter group summaries.
    /// This member is required.
    public var items: [TimestreamInfluxDBClientTypes.DbParameterGroupSummary]?
    /// Token from a previous call of the operation. When this value is provided, the service returns results from where the previous response left off.
    public var nextToken: Swift.String?

    public init(
        items: [TimestreamInfluxDBClientTypes.DbParameterGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDbParameterGroupsOutputBody: Swift.Equatable {
    let items: [TimestreamInfluxDBClientTypes.DbParameterGroupSummary]?
    let nextToken: Swift.String?
}

extension ListDbParameterGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([TimestreamInfluxDBClientTypes.DbParameterGroupSummary?].self, forKey: .items)
        var itemsDecoded0:[TimestreamInfluxDBClientTypes.DbParameterGroupSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [TimestreamInfluxDBClientTypes.DbParameterGroupSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDbParameterGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the tagged resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tags used to categorize and track resources.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TimestreamInfluxDBClientTypes.LogDeliveryConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Configuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.S3Configuration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
    }
}

extension TimestreamInfluxDBClientTypes {
    /// Configuration for sending InfluxDB engine logs to send to specified S3 bucket.
    public struct LogDeliveryConfiguration: Swift.Equatable {
        /// Configuration for S3 bucket log delivery.
        /// This member is required.
        public var s3Configuration: TimestreamInfluxDBClientTypes.S3Configuration?

        public init(
            s3Configuration: TimestreamInfluxDBClientTypes.S3Configuration? = nil
        )
        {
            self.s3Configuration = s3Configuration
        }
    }

}

extension TimestreamInfluxDBClientTypes {
    public enum LogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case debug
        case error
        case info
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .debug,
                .error,
                .info,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .debug: return "debug"
            case .error: return "error"
            case .info: return "info"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
        }
    }
}

extension TimestreamInfluxDBClientTypes.Parameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case influxdbv2 = "InfluxDBv2"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .influxdbv2(influxdbv2):
                try container.encode(influxdbv2, forKey: .influxdbv2)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let influxdbv2Decoded = try values.decodeIfPresent(TimestreamInfluxDBClientTypes.InfluxDBv2Parameters.self, forKey: .influxdbv2)
        if let influxdbv2 = influxdbv2Decoded {
            self = .influxdbv2(influxdbv2)
            return
        }
        self = .sdkUnknown("")
    }
}

extension TimestreamInfluxDBClientTypes {
    /// The parameters that comprise the parameter group.
    public enum Parameters: Swift.Equatable {
        /// All the customer-modifiable InfluxDB v2 parameters in Timestream for InfluxDB.
        case influxdbv2(TimestreamInfluxDBClientTypes.InfluxDBv2Parameters)
        case sdkUnknown(Swift.String)
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource was not found or does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the Timestream for InfluxDB resource associated with the request.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of Timestream for InfluxDB resource associated with the request.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension TimestreamInfluxDBClientTypes.S3Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension TimestreamInfluxDBClientTypes {
    /// Configuration for S3 bucket log delivery.
    public struct S3Configuration: Swift.Equatable {
        /// The name of the S3 bucket to deliver logs to.
        /// This member is required.
        public var bucketName: Swift.String?
        /// Indicates whether log delivery to the S3 bucket is enabled.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init(
            bucketName: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.bucketName = bucketName
            self.enabled = enabled
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeds the service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestreamInfluxDBClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleted
        case deleting
        case failed
        case modifying
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .available,
                .creating,
                .deleted,
                .deleting,
                .failed,
                .modifying,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .modifying: return "MODIFYING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, requestTagMap0) in tags {
                try tagsContainer.encode(requestTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the tagged resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags used to categorize and track resources.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds the caller should wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum TimestreamInfluxDBClientTypes {}

extension TimestreamInfluxDBClientTypes {
    public enum TracingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jaeger
        case log
        case sdkUnknown(Swift.String)

        public static var allCases: [TracingType] {
            return [
                .jaeger,
                .log,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jaeger: return "jaeger"
            case .log: return "log"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TracingType(rawValue: rawValue) ?? TracingType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the tagged resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys used to identify the tags.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDbInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbParameterGroupIdentifier
        case identifier
        case logDeliveryConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbParameterGroupIdentifier = self.dbParameterGroupIdentifier {
            try encodeContainer.encode(dbParameterGroupIdentifier, forKey: .dbParameterGroupIdentifier)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let logDeliveryConfiguration = self.logDeliveryConfiguration {
            try encodeContainer.encode(logDeliveryConfiguration, forKey: .logDeliveryConfiguration)
        }
    }
}

extension UpdateDbInstanceInput {

    static func urlPathProvider(_ value: UpdateDbInstanceInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateDbInstanceInput: Swift.Equatable {
    /// The id of the DB parameter group to assign to your DB instance. DB parameter groups specify how the database is configured. For example, DB parameter groups can specify the limit for query concurrency.
    public var dbParameterGroupIdentifier: Swift.String?
    /// The id of the DB instance.
    /// This member is required.
    public var identifier: Swift.String?
    /// Configuration for sending InfluxDB engine logs to send to specified S3 bucket.
    public var logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration?

    public init(
        dbParameterGroupIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration? = nil
    )
    {
        self.dbParameterGroupIdentifier = dbParameterGroupIdentifier
        self.identifier = identifier
        self.logDeliveryConfiguration = logDeliveryConfiguration
    }
}

struct UpdateDbInstanceInputBody: Swift.Equatable {
    let identifier: Swift.String?
    let logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration?
    let dbParameterGroupIdentifier: Swift.String?
}

extension UpdateDbInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbParameterGroupIdentifier
        case identifier
        case logDeliveryConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let logDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.LogDeliveryConfiguration.self, forKey: .logDeliveryConfiguration)
        logDeliveryConfiguration = logDeliveryConfigurationDecoded
        let dbParameterGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbParameterGroupIdentifier)
        dbParameterGroupIdentifier = dbParameterGroupIdentifierDecoded
    }
}

extension UpdateDbInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDbInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.allocatedStorage = output.allocatedStorage
            self.arn = output.arn
            self.availabilityZone = output.availabilityZone
            self.dbInstanceType = output.dbInstanceType
            self.dbParameterGroupIdentifier = output.dbParameterGroupIdentifier
            self.dbStorageType = output.dbStorageType
            self.deploymentType = output.deploymentType
            self.endpoint = output.endpoint
            self.id = output.id
            self.influxAuthParametersSecretArn = output.influxAuthParametersSecretArn
            self.logDeliveryConfiguration = output.logDeliveryConfiguration
            self.name = output.name
            self.publiclyAccessible = output.publiclyAccessible
            self.secondaryAvailabilityZone = output.secondaryAvailabilityZone
            self.status = output.status
            self.vpcSecurityGroupIds = output.vpcSecurityGroupIds
            self.vpcSubnetIds = output.vpcSubnetIds
        } else {
            self.allocatedStorage = nil
            self.arn = nil
            self.availabilityZone = nil
            self.dbInstanceType = nil
            self.dbParameterGroupIdentifier = nil
            self.dbStorageType = nil
            self.deploymentType = nil
            self.endpoint = nil
            self.id = nil
            self.influxAuthParametersSecretArn = nil
            self.logDeliveryConfiguration = nil
            self.name = nil
            self.publiclyAccessible = nil
            self.secondaryAvailabilityZone = nil
            self.status = nil
            self.vpcSecurityGroupIds = nil
            self.vpcSubnetIds = nil
        }
    }
}

public struct UpdateDbInstanceOutput: Swift.Equatable {
    /// The amount of storage allocated for your DB storage type (in gibibytes).
    public var allocatedStorage: Swift.Int?
    /// The Amazon Resource Name (ARN) of the DB instance.
    /// This member is required.
    public var arn: Swift.String?
    /// The Availability Zone in which the DB instance resides.
    public var availabilityZone: Swift.String?
    /// The Timestream for InfluxDB instance type that InfluxDB runs on.
    public var dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType?
    /// The id of the DB parameter group assigned to your DB instance.
    public var dbParameterGroupIdentifier: Swift.String?
    /// The Timestream for InfluxDB DB storage type that InfluxDB stores data on.
    public var dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType?
    /// Specifies whether the Timestream for InfluxDB is deployed as Single-AZ or with a MultiAZ Standby for High availability.
    public var deploymentType: TimestreamInfluxDBClientTypes.DeploymentType?
    /// The endpoint used to connect to InfluxDB. The default InfluxDB port is 8086.
    public var endpoint: Swift.String?
    /// A service-generated unique identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.
    public var influxAuthParametersSecretArn: Swift.String?
    /// Configuration for sending InfluxDB engine logs to send to specified S3 bucket.
    public var logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration?
    /// This customer-supplied name uniquely identifies the DB instance when interacting with the Amazon Timestream for InfluxDB API and AWS CLI commands.
    /// This member is required.
    public var name: Swift.String?
    /// Indicates if the DB instance has a public IP to facilitate access.
    public var publiclyAccessible: Swift.Bool?
    /// The Availability Zone in which the standby instance is located when deploying with a MultiAZ standby instance.
    public var secondaryAvailabilityZone: Swift.String?
    /// The status of the DB instance.
    public var status: TimestreamInfluxDBClientTypes.Status?
    /// A list of VPC security group IDs associated with the DB instance.
    public var vpcSecurityGroupIds: [Swift.String]?
    /// A list of VPC subnet IDs associated with the DB instance.
    /// This member is required.
    public var vpcSubnetIds: [Swift.String]?

    public init(
        allocatedStorage: Swift.Int? = nil,
        arn: Swift.String? = nil,
        availabilityZone: Swift.String? = nil,
        dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType? = nil,
        dbParameterGroupIdentifier: Swift.String? = nil,
        dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType? = nil,
        deploymentType: TimestreamInfluxDBClientTypes.DeploymentType? = nil,
        endpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        influxAuthParametersSecretArn: Swift.String? = nil,
        logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration? = nil,
        name: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        secondaryAvailabilityZone: Swift.String? = nil,
        status: TimestreamInfluxDBClientTypes.Status? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil,
        vpcSubnetIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.arn = arn
        self.availabilityZone = availabilityZone
        self.dbInstanceType = dbInstanceType
        self.dbParameterGroupIdentifier = dbParameterGroupIdentifier
        self.dbStorageType = dbStorageType
        self.deploymentType = deploymentType
        self.endpoint = endpoint
        self.id = id
        self.influxAuthParametersSecretArn = influxAuthParametersSecretArn
        self.logDeliveryConfiguration = logDeliveryConfiguration
        self.name = name
        self.publiclyAccessible = publiclyAccessible
        self.secondaryAvailabilityZone = secondaryAvailabilityZone
        self.status = status
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

struct UpdateDbInstanceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let status: TimestreamInfluxDBClientTypes.Status?
    let endpoint: Swift.String?
    let dbInstanceType: TimestreamInfluxDBClientTypes.DbInstanceType?
    let dbStorageType: TimestreamInfluxDBClientTypes.DbStorageType?
    let allocatedStorage: Swift.Int?
    let deploymentType: TimestreamInfluxDBClientTypes.DeploymentType?
    let vpcSubnetIds: [Swift.String]?
    let publiclyAccessible: Swift.Bool?
    let vpcSecurityGroupIds: [Swift.String]?
    let dbParameterGroupIdentifier: Swift.String?
    let availabilityZone: Swift.String?
    let secondaryAvailabilityZone: Swift.String?
    let logDeliveryConfiguration: TimestreamInfluxDBClientTypes.LogDeliveryConfiguration?
    let influxAuthParametersSecretArn: Swift.String?
}

extension UpdateDbInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage
        case arn
        case availabilityZone
        case dbInstanceType
        case dbParameterGroupIdentifier
        case dbStorageType
        case deploymentType
        case endpoint
        case id
        case influxAuthParametersSecretArn
        case logDeliveryConfiguration
        case name
        case publiclyAccessible
        case secondaryAvailabilityZone
        case status
        case vpcSecurityGroupIds
        case vpcSubnetIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let dbInstanceTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DbInstanceType.self, forKey: .dbInstanceType)
        dbInstanceType = dbInstanceTypeDecoded
        let dbStorageTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DbStorageType.self, forKey: .dbStorageType)
        dbStorageType = dbStorageTypeDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let vpcSubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSubnetIds)
        var vpcSubnetIdsDecoded0:[Swift.String]? = nil
        if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
            vpcSubnetIdsDecoded0 = [Swift.String]()
            for string0 in vpcSubnetIdsContainer {
                if let string0 = string0 {
                    vpcSubnetIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSubnetIds = vpcSubnetIdsDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let dbParameterGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbParameterGroupIdentifier)
        dbParameterGroupIdentifier = dbParameterGroupIdentifierDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let logDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.LogDeliveryConfiguration.self, forKey: .logDeliveryConfiguration)
        logDeliveryConfiguration = logDeliveryConfigurationDecoded
        let influxAuthParametersSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .influxAuthParametersSecretArn)
        influxAuthParametersSecretArn = influxAuthParametersSecretArnDecoded
    }
}

enum UpdateDbInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by Timestream for InfluxDB.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason that validation failed.
        /// This member is required.
        public internal(set) var reason: TimestreamInfluxDBClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: TimestreamInfluxDBClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: TimestreamInfluxDBClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(TimestreamInfluxDBClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension TimestreamInfluxDBClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fieldValidationFailed
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .other,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
