// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// User does not have sufficient access to perform this action.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Updating or deleting a resource can cause an inconsistent state.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension CreateParticipantTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case duration
        case stageArn
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, participantTokenAttributes0) in attributes {
                try attributesContainer.encode(participantTokenAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for participanttokencapability0 in capabilities {
                try capabilitiesContainer.encode(participanttokencapability0.rawValue)
            }
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension CreateParticipantTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateParticipantToken"
    }
}

public struct CreateParticipantTokenInput: Swift.Equatable {
    /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    public var attributes: [Swift.String:Swift.String]?
    /// Set of capabilities that the user is allowed to perform in the stage. Default: PUBLISH, SUBSCRIBE.
    public var capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
    /// Duration (in minutes), after which the token expires. Default: 720 (12 hours).
    public var duration: Swift.Int
    /// ARN of the stage to which this token is scoped.
    /// This member is required.
    public var stageArn: Swift.String?
    /// Name that can be specified to help identify the token. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    public var userId: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil,
        duration: Swift.Int = 0,
        stageArn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.capabilities = capabilities
        self.duration = duration
        self.stageArn = stageArn
        self.userId = userId
    }
}

struct CreateParticipantTokenInputBody: Swift.Equatable {
    let stageArn: Swift.String?
    let duration: Swift.Int
    let userId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
}

extension CreateParticipantTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case duration
        case stageArn
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration) ?? 0
        duration = durationDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let capabilitiesContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.ParticipantTokenCapability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [IVSRealTimeClientTypes.ParticipantTokenCapability]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
    }
}

extension CreateParticipantTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateParticipantTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.participantToken = output.participantToken
        } else {
            self.participantToken = nil
        }
    }
}

public struct CreateParticipantTokenOutput: Swift.Equatable {
    /// The participant token that was created.
    public var participantToken: IVSRealTimeClientTypes.ParticipantToken?

    public init(
        participantToken: IVSRealTimeClientTypes.ParticipantToken? = nil
    )
    {
        self.participantToken = participantToken
    }
}

struct CreateParticipantTokenOutputBody: Swift.Equatable {
    let participantToken: IVSRealTimeClientTypes.ParticipantToken?
}

extension CreateParticipantTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantTokenDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.ParticipantToken.self, forKey: .participantToken)
        participantToken = participantTokenDecoded
    }
}

enum CreateParticipantTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case participantTokenConfigurations
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let participantTokenConfigurations = participantTokenConfigurations {
            var participantTokenConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participantTokenConfigurations)
            for participanttokenconfiguration0 in participantTokenConfigurations {
                try participantTokenConfigurationsContainer.encode(participanttokenconfiguration0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateStage"
    }
}

public struct CreateStageInput: Swift.Equatable {
    /// Optional name that can be specified for the stage being created.
    public var name: Swift.String?
    /// Array of participant token configuration objects to attach to the new stage.
    public var participantTokenConfigurations: [IVSRealTimeClientTypes.ParticipantTokenConfiguration]?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init(
        name: Swift.String? = nil,
        participantTokenConfigurations: [IVSRealTimeClientTypes.ParticipantTokenConfiguration]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.participantTokenConfigurations = participantTokenConfigurations
        self.tags = tags
    }
}

struct CreateStageInputBody: Swift.Equatable {
    let name: Swift.String?
    let participantTokenConfigurations: [IVSRealTimeClientTypes.ParticipantTokenConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case participantTokenConfigurations
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let participantTokenConfigurationsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.ParticipantTokenConfiguration?].self, forKey: .participantTokenConfigurations)
        var participantTokenConfigurationsDecoded0:[IVSRealTimeClientTypes.ParticipantTokenConfiguration]? = nil
        if let participantTokenConfigurationsContainer = participantTokenConfigurationsContainer {
            participantTokenConfigurationsDecoded0 = [IVSRealTimeClientTypes.ParticipantTokenConfiguration]()
            for structure0 in participantTokenConfigurationsContainer {
                if let structure0 = structure0 {
                    participantTokenConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        participantTokenConfigurations = participantTokenConfigurationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.participantTokens = output.participantTokens
            self.stage = output.stage
        } else {
            self.participantTokens = nil
            self.stage = nil
        }
    }
}

public struct CreateStageOutput: Swift.Equatable {
    /// Participant tokens attached to the stage. These correspond to the participants in the request.
    public var participantTokens: [IVSRealTimeClientTypes.ParticipantToken]?
    /// The stage that was created.
    public var stage: IVSRealTimeClientTypes.Stage?

    public init(
        participantTokens: [IVSRealTimeClientTypes.ParticipantToken]? = nil,
        stage: IVSRealTimeClientTypes.Stage? = nil
    )
    {
        self.participantTokens = participantTokens
        self.stage = stage
    }
}

struct CreateStageOutputBody: Swift.Equatable {
    let stage: IVSRealTimeClientTypes.Stage?
    let participantTokens: [IVSRealTimeClientTypes.ParticipantToken]?
}

extension CreateStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantTokens
        case stage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.Stage.self, forKey: .stage)
        stage = stageDecoded
        let participantTokensContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.ParticipantToken?].self, forKey: .participantTokens)
        var participantTokensDecoded0:[IVSRealTimeClientTypes.ParticipantToken]? = nil
        if let participantTokensContainer = participantTokensContainer {
            participantTokensDecoded0 = [IVSRealTimeClientTypes.ParticipantToken]()
            for structure0 in participantTokensContainer {
                if let structure0 = structure0 {
                    participantTokensDecoded0?.append(structure0)
                }
            }
        }
        participantTokens = participantTokensDecoded0
    }
}

enum CreateStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteStage"
    }
}

public struct DeleteStageInput: Swift.Equatable {
    /// ARN of the stage to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteStageInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStageOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisconnectParticipantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantId
        case reason
        case stageArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
    }
}

extension DisconnectParticipantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DisconnectParticipant"
    }
}

public struct DisconnectParticipantInput: Swift.Equatable {
    /// Identifier of the participant to be disconnected. This is assigned by IVS and returned by [CreateParticipantToken].
    /// This member is required.
    public var participantId: Swift.String?
    /// Description of why this participant is being disconnected.
    public var reason: Swift.String?
    /// ARN of the stage to which the participant is attached.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        participantId: Swift.String? = nil,
        reason: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.participantId = participantId
        self.reason = reason
        self.stageArn = stageArn
    }
}

struct DisconnectParticipantInputBody: Swift.Equatable {
    let stageArn: Swift.String?
    let participantId: Swift.String?
    let reason: Swift.String?
}

extension DisconnectParticipantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantId
        case reason
        case stageArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DisconnectParticipantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisconnectParticipantOutput: Swift.Equatable {

    public init() { }
}

enum DisconnectParticipantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IVSRealTimeClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case eventTime
        case name
        case participantId
        case remoteParticipantId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .dateTime, forKey: .eventTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let remoteParticipantId = self.remoteParticipantId {
            try encodeContainer.encode(remoteParticipantId, forKey: .remoteParticipantId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.EventName.self, forKey: .name)
        name = nameDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let remoteParticipantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteParticipantId)
        remoteParticipantId = remoteParticipantIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.EventErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// An occurrence during a stage session.
    public struct Event: Swift.Equatable {
        /// If the event is an error event, the error code is provided to give insight into the specific error that occurred. If the event is not an error event, this field is null. INSUFFICIENT_CAPABILITIES indicates that the participant tried to take an action that the participant’s token is not allowed to do. For more information about participant capabilities, see the capabilities field in [CreateParticipantToken]. QUOTA_EXCEEDED indicates that the number of participants who want to publish/subscribe to a stage exceeds the quota; for more information, see [Service Quotas](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/service-quotas.html). PUBLISHER_NOT_FOUND indicates that the participant tried to subscribe to a publisher that doesn’t exist.
        public var errorCode: IVSRealTimeClientTypes.EventErrorCode?
        /// ISO 8601 timestamp (returned as a string) for when the event occurred.
        public var eventTime: ClientRuntime.Date?
        /// The name of the event.
        public var name: IVSRealTimeClientTypes.EventName?
        /// Unique identifier for the participant who triggered the event. This is assigned by IVS.
        public var participantId: Swift.String?
        /// Unique identifier for the remote participant. For a subscribe event, this is the publisher. For a publish or join event, this is null. This is assigned by IVS.
        public var remoteParticipantId: Swift.String?

        public init(
            errorCode: IVSRealTimeClientTypes.EventErrorCode? = nil,
            eventTime: ClientRuntime.Date? = nil,
            name: IVSRealTimeClientTypes.EventName? = nil,
            participantId: Swift.String? = nil,
            remoteParticipantId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.eventTime = eventTime
            self.name = name
            self.participantId = participantId
            self.remoteParticipantId = remoteParticipantId
        }
    }

}

extension IVSRealTimeClientTypes {
    public enum EventErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insufficientCapabilities
        case publisherNotFound
        case quotaExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [EventErrorCode] {
            return [
                .insufficientCapabilities,
                .publisherNotFound,
                .quotaExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insufficientCapabilities: return "INSUFFICIENT_CAPABILITIES"
            case .publisherNotFound: return "PUBLISHER_NOT_FOUND"
            case .quotaExceeded: return "QUOTA_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventErrorCode(rawValue: rawValue) ?? EventErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IVSRealTimeClientTypes {
    public enum EventName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case joined
        case joinError
        case `left`
        case publishError
        case publishStarted
        case publishStopped
        case subscribeError
        case subscribeStarted
        case subscribeStopped
        case sdkUnknown(Swift.String)

        public static var allCases: [EventName] {
            return [
                .joined,
                .joinError,
                .left,
                .publishError,
                .publishStarted,
                .publishStopped,
                .subscribeError,
                .subscribeStarted,
                .subscribeStopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .joined: return "JOINED"
            case .joinError: return "JOIN_ERROR"
            case .left: return "LEFT"
            case .publishError: return "PUBLISH_ERROR"
            case .publishStarted: return "PUBLISH_STARTED"
            case .publishStopped: return "PUBLISH_STOPPED"
            case .subscribeError: return "SUBSCRIBE_ERROR"
            case .subscribeStarted: return "SUBSCRIBE_STARTED"
            case .subscribeStopped: return "SUBSCRIBE_STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventName(rawValue: rawValue) ?? EventName.sdkUnknown(rawValue)
        }
    }
}

extension GetParticipantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantId
        case sessionId
        case stageArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
    }
}

extension GetParticipantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetParticipant"
    }
}

public struct GetParticipantInput: Swift.Equatable {
    /// Unique identifier for the participant. This is assigned by IVS and returned by [CreateParticipantToken].
    /// This member is required.
    public var participantId: Swift.String?
    /// ID of a session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        participantId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.participantId = participantId
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

struct GetParticipantInputBody: Swift.Equatable {
    let stageArn: Swift.String?
    let sessionId: Swift.String?
    let participantId: Swift.String?
}

extension GetParticipantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantId
        case sessionId
        case stageArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
    }
}

extension GetParticipantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetParticipantOutputBody = try responseDecoder.decode(responseBody: data)
            self.participant = output.participant
        } else {
            self.participant = nil
        }
    }
}

public struct GetParticipantOutput: Swift.Equatable {
    /// The participant that is returned.
    public var participant: IVSRealTimeClientTypes.Participant?

    public init(
        participant: IVSRealTimeClientTypes.Participant? = nil
    )
    {
        self.participant = participant
    }
}

struct GetParticipantOutputBody: Swift.Equatable {
    let participant: IVSRealTimeClientTypes.Participant?
}

extension GetParticipantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participant
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.Participant.self, forKey: .participant)
        participant = participantDecoded
    }
}

enum GetParticipantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetStage"
    }
}

public struct GetStageInput: Swift.Equatable {
    /// ARN of the stage for which the information is to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetStageInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.stage = output.stage
        } else {
            self.stage = nil
        }
    }
}

public struct GetStageOutput: Swift.Equatable {
    /// The stage that is returned.
    public var stage: IVSRealTimeClientTypes.Stage?

    public init(
        stage: IVSRealTimeClientTypes.Stage? = nil
    )
    {
        self.stage = stage
    }
}

struct GetStageOutputBody: Swift.Equatable {
    let stage: IVSRealTimeClientTypes.Stage?
}

extension GetStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.Stage.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum GetStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStageSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId
        case stageArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
    }
}

extension GetStageSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetStageSession"
    }
}

public struct GetStageSessionInput: Swift.Equatable {
    /// ID of a session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// ARN of the stage for which the information is to be retrieved.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

struct GetStageSessionInputBody: Swift.Equatable {
    let stageArn: Swift.String?
    let sessionId: Swift.String?
}

extension GetStageSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId
        case stageArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension GetStageSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStageSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.stageSession = output.stageSession
        } else {
            self.stageSession = nil
        }
    }
}

public struct GetStageSessionOutput: Swift.Equatable {
    /// The stage session that is returned.
    public var stageSession: IVSRealTimeClientTypes.StageSession?

    public init(
        stageSession: IVSRealTimeClientTypes.StageSession? = nil
    )
    {
        self.stageSession = stageSession
    }
}

struct GetStageSessionOutputBody: Swift.Equatable {
    let stageSession: IVSRealTimeClientTypes.StageSession?
}

extension GetStageSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stageSession
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageSessionDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.StageSession.self, forKey: .stageSession)
        stageSession = stageSessionDecoded
    }
}

enum GetStageSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Unexpected error during processing of request.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension ListParticipantEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case participantId
        case sessionId
        case stageArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
    }
}

extension ListParticipantEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListParticipantEvents"
    }
}

public struct ListParticipantEventsInput: Swift.Equatable {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first participant to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?
    /// Unique identifier for this participant. This is assigned by IVS and returned by [CreateParticipantToken].
    /// This member is required.
    public var participantId: Swift.String?
    /// ID of a session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        participantId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.participantId = participantId
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

struct ListParticipantEventsInputBody: Swift.Equatable {
    let stageArn: Swift.String?
    let sessionId: Swift.String?
    let participantId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListParticipantEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case participantId
        case sessionId
        case stageArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListParticipantEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListParticipantEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct ListParticipantEventsOutput: Swift.Equatable {
    /// List of the matching events.
    /// This member is required.
    public var events: [IVSRealTimeClientTypes.Event]?
    /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        events: [IVSRealTimeClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct ListParticipantEventsOutputBody: Swift.Equatable {
    let events: [IVSRealTimeClientTypes.Event]?
    let nextToken: Swift.String?
}

extension ListParticipantEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[IVSRealTimeClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IVSRealTimeClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListParticipantEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListParticipantsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterByPublished
        case filterByState
        case filterByUserId
        case maxResults
        case nextToken
        case sessionId
        case stageArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterByPublished = self.filterByPublished {
            try encodeContainer.encode(filterByPublished, forKey: .filterByPublished)
        }
        if let filterByState = self.filterByState {
            try encodeContainer.encode(filterByState.rawValue, forKey: .filterByState)
        }
        if let filterByUserId = self.filterByUserId {
            try encodeContainer.encode(filterByUserId, forKey: .filterByUserId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
    }
}

extension ListParticipantsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListParticipants"
    }
}

public struct ListParticipantsInput: Swift.Equatable {
    /// Filters the response list to only show participants who published during the stage session. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request.
    public var filterByPublished: Swift.Bool?
    /// Filters the response list to only show participants in the specified state. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request.
    public var filterByState: IVSRealTimeClientTypes.ParticipantState?
    /// Filters the response list to match the specified user ID. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request. A userId is a customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems.
    public var filterByUserId: Swift.String?
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first participant to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?
    /// ID of the session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        filterByPublished: Swift.Bool? = nil,
        filterByState: IVSRealTimeClientTypes.ParticipantState? = nil,
        filterByUserId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.filterByPublished = filterByPublished
        self.filterByState = filterByState
        self.filterByUserId = filterByUserId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

struct ListParticipantsInputBody: Swift.Equatable {
    let stageArn: Swift.String?
    let sessionId: Swift.String?
    let filterByUserId: Swift.String?
    let filterByPublished: Swift.Bool?
    let filterByState: IVSRealTimeClientTypes.ParticipantState?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListParticipantsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterByPublished
        case filterByState
        case filterByUserId
        case maxResults
        case nextToken
        case sessionId
        case stageArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let filterByUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterByUserId)
        filterByUserId = filterByUserIdDecoded
        let filterByPublishedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .filterByPublished)
        filterByPublished = filterByPublishedDecoded
        let filterByStateDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.ParticipantState.self, forKey: .filterByState)
        filterByState = filterByStateDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListParticipantsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListParticipantsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.participants = output.participants
        } else {
            self.nextToken = nil
            self.participants = nil
        }
    }
}

public struct ListParticipantsOutput: Swift.Equatable {
    /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching participants (summary information only).
    /// This member is required.
    public var participants: [IVSRealTimeClientTypes.ParticipantSummary]?

    public init(
        nextToken: Swift.String? = nil,
        participants: [IVSRealTimeClientTypes.ParticipantSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.participants = participants
    }
}

struct ListParticipantsOutputBody: Swift.Equatable {
    let participants: [IVSRealTimeClientTypes.ParticipantSummary]?
    let nextToken: Swift.String?
}

extension ListParticipantsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case participants
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.ParticipantSummary?].self, forKey: .participants)
        var participantsDecoded0:[IVSRealTimeClientTypes.ParticipantSummary]? = nil
        if let participantsContainer = participantsContainer {
            participantsDecoded0 = [IVSRealTimeClientTypes.ParticipantSummary]()
            for structure0 in participantsContainer {
                if let structure0 = structure0 {
                    participantsDecoded0?.append(structure0)
                }
            }
        }
        participants = participantsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListParticipantsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStageSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case stageArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
    }
}

extension ListStageSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListStageSessions"
    }
}

public struct ListStageSessionsInput: Swift.Equatable {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first stage to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stageArn = stageArn
    }
}

struct ListStageSessionsInputBody: Swift.Equatable {
    let stageArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListStageSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case stageArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListStageSessionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStageSessionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stageSessions = output.stageSessions
        } else {
            self.nextToken = nil
            self.stageSessions = nil
        }
    }
}

public struct ListStageSessionsOutput: Swift.Equatable {
    /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of matching stage sessions.
    /// This member is required.
    public var stageSessions: [IVSRealTimeClientTypes.StageSessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        stageSessions: [IVSRealTimeClientTypes.StageSessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stageSessions = stageSessions
    }
}

struct ListStageSessionsOutputBody: Swift.Equatable {
    let stageSessions: [IVSRealTimeClientTypes.StageSessionSummary]?
    let nextToken: Swift.String?
}

extension ListStageSessionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case stageSessions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageSessionsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.StageSessionSummary?].self, forKey: .stageSessions)
        var stageSessionsDecoded0:[IVSRealTimeClientTypes.StageSessionSummary]? = nil
        if let stageSessionsContainer = stageSessionsContainer {
            stageSessionsDecoded0 = [IVSRealTimeClientTypes.StageSessionSummary]()
            for structure0 in stageSessionsContainer {
                if let structure0 = structure0 {
                    stageSessionsDecoded0?.append(structure0)
                }
            }
        }
        stageSessions = stageSessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStageSessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListStagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListStages"
    }
}

public struct ListStagesInput: Swift.Equatable {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int
    /// The first stage to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStagesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListStagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListStagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stages = output.stages
        } else {
            self.nextToken = nil
            self.stages = nil
        }
    }
}

public struct ListStagesOutput: Swift.Equatable {
    /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching stages (summary information only).
    /// This member is required.
    public var stages: [IVSRealTimeClientTypes.StageSummary]?

    public init(
        nextToken: Swift.String? = nil,
        stages: [IVSRealTimeClientTypes.StageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stages = stages
    }
}

struct ListStagesOutputBody: Swift.Equatable {
    let stages: [IVSRealTimeClientTypes.StageSummary]?
    let nextToken: Swift.String?
}

extension ListStagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case stages
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagesContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.StageSummary?].self, forKey: .stages)
        var stagesDecoded0:[IVSRealTimeClientTypes.StageSummary]? = nil
        if let stagesContainer = stagesContainer {
            stagesDecoded0 = [IVSRealTimeClientTypes.StageSummary]()
            for structure0 in stagesContainer {
                if let structure0 = structure0 {
                    stagesDecoded0?.append(structure0)
                }
            }
        }
        stages = stagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IVSRealTimeClientTypes.Participant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case firstJoinTime
        case participantId
        case published
        case state
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, participantAttributes0) in attributes {
                try attributesContainer.encode(participantAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let firstJoinTime = self.firstJoinTime {
            try encodeContainer.encodeTimestamp(firstJoinTime, format: .dateTime, forKey: .firstJoinTime)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if published != false {
            try encodeContainer.encode(published, forKey: .published)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.ParticipantState.self, forKey: .state)
        state = stateDecoded
        let firstJoinTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .firstJoinTime)
        firstJoinTime = firstJoinTimeDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let publishedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .published) ?? false
        published = publishedDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Object describing a participant that has joined a stage.
    public struct Participant: Swift.Equatable {
        /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String:Swift.String]?
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        public var firstJoinTime: ClientRuntime.Date?
        /// Unique identifier for this participant, assigned by IVS.
        public var participantId: Swift.String?
        /// Whether the participant ever published to the stage session.
        public var published: Swift.Bool
        /// Whether the participant is connected to or disconnected from the stage.
        public var state: IVSRealTimeClientTypes.ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            firstJoinTime: ClientRuntime.Date? = nil,
            participantId: Swift.String? = nil,
            published: Swift.Bool = false,
            state: IVSRealTimeClientTypes.ParticipantState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.firstJoinTime = firstJoinTime
            self.participantId = participantId
            self.published = published
            self.state = state
            self.userId = userId
        }
    }

}

extension IVSRealTimeClientTypes {
    public enum ParticipantState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantState] {
            return [
                .connected,
                .disconnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParticipantState(rawValue: rawValue) ?? ParticipantState.sdkUnknown(rawValue)
        }
    }
}

extension IVSRealTimeClientTypes.ParticipantSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firstJoinTime
        case participantId
        case published
        case state
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firstJoinTime = self.firstJoinTime {
            try encodeContainer.encodeTimestamp(firstJoinTime, format: .dateTime, forKey: .firstJoinTime)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if published != false {
            try encodeContainer.encode(published, forKey: .published)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.ParticipantState.self, forKey: .state)
        state = stateDecoded
        let firstJoinTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .firstJoinTime)
        firstJoinTime = firstJoinTimeDecoded
        let publishedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .published) ?? false
        published = publishedDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Summary object describing a participant that has joined a stage.
    public struct ParticipantSummary: Swift.Equatable {
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        public var firstJoinTime: ClientRuntime.Date?
        /// Unique identifier for this participant, assigned by IVS.
        public var participantId: Swift.String?
        /// Whether the participant ever published to the stage session.
        public var published: Swift.Bool
        /// Whether the participant is connected to or disconnected from the stage.
        public var state: IVSRealTimeClientTypes.ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            firstJoinTime: ClientRuntime.Date? = nil,
            participantId: Swift.String? = nil,
            published: Swift.Bool = false,
            state: IVSRealTimeClientTypes.ParticipantState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.firstJoinTime = firstJoinTime
            self.participantId = participantId
            self.published = published
            self.state = state
            self.userId = userId
        }
    }

}

extension IVSRealTimeClientTypes.ParticipantToken: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case duration
        case expirationTime
        case participantId
        case token
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, participantTokenAttributes0) in attributes {
                try attributesContainer.encode(participantTokenAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for participanttokencapability0 in capabilities {
                try capabilitiesContainer.encode(participanttokencapability0.rawValue)
            }
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .dateTime, forKey: .expirationTime)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration) ?? 0
        duration = durationDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.ParticipantTokenCapability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [IVSRealTimeClientTypes.ParticipantTokenCapability]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
    }
}

extension IVSRealTimeClientTypes.ParticipantToken: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParticipantToken(attributes: \(Swift.String(describing: attributes)), capabilities: \(Swift.String(describing: capabilities)), duration: \(Swift.String(describing: duration)), expirationTime: \(Swift.String(describing: expirationTime)), participantId: \(Swift.String(describing: participantId)), userId: \(Swift.String(describing: userId)), token: \"CONTENT_REDACTED\")"}
}

extension IVSRealTimeClientTypes {
    /// Object specifying a participant token in a stage. Important: Treat tokens as opaque; i.e., do not build functionality based on token contents. The format of tokens could change in the future.
    public struct ParticipantToken: Swift.Equatable {
        /// Application-provided attributes to encode into the token and attach to a stage. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String:Swift.String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public var capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
        /// Duration (in minutes), after which the participant token expires. Default: 720 (12 hours).
        public var duration: Swift.Int
        /// ISO 8601 timestamp (returned as a string) for when this token expires.
        public var expirationTime: ClientRuntime.Date?
        /// Unique identifier for this participant token, assigned by IVS.
        public var participantId: Swift.String?
        /// The issued client token, encrypted.
        public var token: Swift.String?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil,
            duration: Swift.Int = 0,
            expirationTime: ClientRuntime.Date? = nil,
            participantId: Swift.String? = nil,
            token: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.expirationTime = expirationTime
            self.participantId = participantId
            self.token = token
            self.userId = userId
        }
    }

}

extension IVSRealTimeClientTypes {
    public enum ParticipantTokenCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case publish
        case subscribe
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantTokenCapability] {
            return [
                .publish,
                .subscribe,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .publish: return "PUBLISH"
            case .subscribe: return "SUBSCRIBE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParticipantTokenCapability(rawValue: rawValue) ?? ParticipantTokenCapability.sdkUnknown(rawValue)
        }
    }
}

extension IVSRealTimeClientTypes.ParticipantTokenConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case duration
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, participantTokenAttributes0) in attributes {
                try attributesContainer.encode(participantTokenAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for participanttokencapability0 in capabilities {
                try capabilitiesContainer.encode(participanttokencapability0.rawValue)
            }
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration) ?? 0
        duration = durationDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let capabilitiesContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.ParticipantTokenCapability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [IVSRealTimeClientTypes.ParticipantTokenCapability]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying a participant token configuration in a stage.
    public struct ParticipantTokenConfiguration: Swift.Equatable {
        /// Application-provided attributes to encode into the corresponding participant token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String:Swift.String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public var capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
        /// Duration (in minutes), after which the corresponding participant token expires. Default: 720 (12 hours).
        public var duration: Swift.Int
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil,
            duration: Swift.Int = 0,
            userId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.userId = userId
        }
    }

}

extension PendingVerification {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PendingVerificationBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct PendingVerification: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Your account is pending verification.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PendingVerification" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct PendingVerificationBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension PendingVerificationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request references a resource which does not exist.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request would cause a service quota to be exceeded.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IVSRealTimeClientTypes.Stage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeSessionId
        case arn
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeSessionId = self.activeSessionId {
            try encodeContainer.encode(activeSessionId, forKey: .activeSessionId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let activeSessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeSessionId)
        activeSessionId = activeSessionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying a stage.
    public struct Stage: Swift.Equatable {
        /// ID of the active session within the stage.
        public var activeSessionId: Swift.String?
        /// Stage ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Stage name.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            activeSessionId: Swift.String? = nil,
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }

}

extension IVSRealTimeClientTypes.StageSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case sessionId
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// A stage session begins when the first participant joins a stage and ends after the last participant leaves the stage. A stage session helps with debugging stages by grouping events and participants into shorter periods of time (i.e., a session), which is helpful when stages are used over long periods of time.
    public struct StageSession: Swift.Equatable {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        public var endTime: ClientRuntime.Date?
        /// ID of the session within the stage.
        public var sessionId: Swift.String?
        /// ISO 8601 timestamp (returned as a string) when this stage session began.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            sessionId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }
    }

}

extension IVSRealTimeClientTypes.StageSessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case sessionId
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about a stage session.
    public struct StageSessionSummary: Swift.Equatable {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        public var endTime: ClientRuntime.Date?
        /// ID of the session within the stage.
        public var sessionId: Swift.String?
        /// ISO 8601 timestamp (returned as a string) when this stage session began.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            sessionId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }
    }

}

extension IVSRealTimeClientTypes.StageSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeSessionId
        case arn
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeSessionId = self.activeSessionId {
            try encodeContainer.encode(activeSessionId, forKey: .activeSessionId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let activeSessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeSessionId)
        activeSessionId = activeSessionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about a stage.
    public struct StageSummary: Swift.Equatable {
        /// ID of the active session within the stage.
        public var activeSessionId: Swift.String?
        /// Stage ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Stage name.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            activeSessionId: Swift.String? = nil,
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to be tagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints beyond what is documented there.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to be untagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints beyond what is documented there.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateStage"
    }
}

public struct UpdateStageInput: Swift.Equatable {
    /// ARN of the stage to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// Name of the stage to be updated.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct UpdateStageInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
}

extension UpdateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.stage = output.stage
        } else {
            self.stage = nil
        }
    }
}

public struct UpdateStageOutput: Swift.Equatable {
    /// The updated stage.
    public var stage: IVSRealTimeClientTypes.Stage?

    public init(
        stage: IVSRealTimeClientTypes.Stage? = nil
    )
    {
        self.stage = stage
    }
}

struct UpdateStageOutputBody: Swift.Equatable {
    let stage: IVSRealTimeClientTypes.Stage?
}

extension UpdateStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.Stage.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum UpdateStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}
