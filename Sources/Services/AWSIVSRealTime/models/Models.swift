// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// User does not have sufficient access to perform this action.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct AccessDeniedExceptionBody {
    let exceptionMessage: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IVSRealTimeClientTypes.ChannelDestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case encoderConfigurationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let encoderConfigurationArn = self.encoderConfigurationArn {
            try encodeContainer.encode(encoderConfigurationArn, forKey: .encoderConfigurationArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let encoderConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encoderConfigurationArn)
        encoderConfigurationArn = encoderConfigurationArnDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying a channel as a destination.
    public struct ChannelDestinationConfiguration {
        /// ARN of the channel to use for broadcasting. The channel and stage resources must be in the same AWS account and region. The channel must be offline (not broadcasting).
        /// This member is required.
        public var channelArn: Swift.String?
        /// ARN of the [EncoderConfiguration] resource. The encoder configuration and stage resources must be in the same AWS account and region.
        public var encoderConfigurationArn: Swift.String?

        public init(
            channelArn: Swift.String? = nil,
            encoderConfigurationArn: Swift.String? = nil
        )
        {
            self.channelArn = channelArn
            self.encoderConfigurationArn = encoderConfigurationArn
        }
    }

}

extension IVSRealTimeClientTypes.Composition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case destinations
        case endTime
        case layout
        case stageArn
        case startTime
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for destination0 in destinations {
                try destinationsContainer.encode(destination0)
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let layout = self.layout {
            try encodeContainer.encode(layout, forKey: .layout)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.CompositionState.self, forKey: .state)
        state = stateDecoded
        let layoutDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.LayoutConfiguration.self, forKey: .layout)
        layout = layoutDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[IVSRealTimeClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [IVSRealTimeClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying a Composition resource.
    public struct Composition {
        /// ARN of the Composition resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Array of Destination objects. A Composition can contain either one destination (channel or s3) or two (one channel and one s3).
        /// This member is required.
        public var destinations: [IVSRealTimeClientTypes.Destination]?
        /// UTC time of the Composition end. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var endTime: ClientRuntime.Date?
        /// Layout object to configure composition parameters.
        /// This member is required.
        public var layout: IVSRealTimeClientTypes.LayoutConfiguration?
        /// ARN of the stage used as input
        /// This member is required.
        public var stageArn: Swift.String?
        /// UTC time of the Composition start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// State of the Composition.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.CompositionState?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            destinations: [IVSRealTimeClientTypes.Destination]? = nil,
            endTime: ClientRuntime.Date? = nil,
            layout: IVSRealTimeClientTypes.LayoutConfiguration? = nil,
            stageArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IVSRealTimeClientTypes.CompositionState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.destinations = destinations
            self.endTime = endTime
            self.layout = layout
            self.stageArn = stageArn
            self.startTime = startTime
            self.state = state
            self.tags = tags
        }
    }

}

extension IVSRealTimeClientTypes {
    public enum CompositionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case failed
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [CompositionState] {
            return [
                .active,
                .failed,
                .starting,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompositionState(rawValue: rawValue) ?? CompositionState.sdkUnknown(rawValue)
        }
    }
}

extension IVSRealTimeClientTypes.CompositionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case destinations
        case endTime
        case stageArn
        case startTime
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for destinationsummary0 in destinations {
                try destinationsContainer.encode(destinationsummary0)
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.DestinationSummary?].self, forKey: .destinations)
        var destinationsDecoded0:[IVSRealTimeClientTypes.DestinationSummary]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [IVSRealTimeClientTypes.DestinationSummary]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.CompositionState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about a Composition.
    public struct CompositionSummary {
        /// ARN of the Composition resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Array of Destination objects.
        /// This member is required.
        public var destinations: [IVSRealTimeClientTypes.DestinationSummary]?
        /// UTC time of the Composition end. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var endTime: ClientRuntime.Date?
        /// ARN of the attached stage.
        /// This member is required.
        public var stageArn: Swift.String?
        /// UTC time of the Composition start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// State of the Composition resource.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.CompositionState?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            destinations: [IVSRealTimeClientTypes.DestinationSummary]? = nil,
            endTime: ClientRuntime.Date? = nil,
            stageArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IVSRealTimeClientTypes.CompositionState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.destinations = destinations
            self.endTime = endTime
            self.stageArn = stageArn
            self.startTime = startTime
            self.state = state
            self.tags = tags
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Updating or deleting a resource can cause an inconsistent state.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ConflictExceptionBody {
    let exceptionMessage: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension CreateEncoderConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case tags
        case video
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let video = self.video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }
}

extension CreateEncoderConfigurationInput {

    static func urlPathProvider(_ value: CreateEncoderConfigurationInput) -> Swift.String? {
        return "/CreateEncoderConfiguration"
    }
}

public struct CreateEncoderConfigurationInput {
    /// Optional name to identify the resource.
    public var name: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?
    /// Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps.
    public var video: IVSRealTimeClientTypes.Video?

    public init(
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        video: IVSRealTimeClientTypes.Video? = nil
    )
    {
        self.name = name
        self.tags = tags
        self.video = video
    }
}

struct CreateEncoderConfigurationInputBody {
    let name: Swift.String?
    let video: IVSRealTimeClientTypes.Video?
    let tags: [Swift.String:Swift.String]?
}

extension CreateEncoderConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case tags
        case video
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let videoDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.Video.self, forKey: .video)
        video = videoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEncoderConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEncoderConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.encoderConfiguration = output.encoderConfiguration
        } else {
            self.encoderConfiguration = nil
        }
    }
}

public struct CreateEncoderConfigurationOutput {
    /// The EncoderConfiguration that was created.
    public var encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration?

    public init(
        encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration? = nil
    )
    {
        self.encoderConfiguration = encoderConfiguration
    }
}

struct CreateEncoderConfigurationOutputBody {
    let encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration?
}

extension CreateEncoderConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encoderConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encoderConfigurationDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.EncoderConfiguration.self, forKey: .encoderConfiguration)
        encoderConfiguration = encoderConfigurationDecoded
    }
}

enum CreateEncoderConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateParticipantTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case duration
        case stageArn
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, participantTokenAttributes0) in attributes {
                try attributesContainer.encode(participantTokenAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for participanttokencapability0 in capabilities {
                try capabilitiesContainer.encode(participanttokencapability0.rawValue)
            }
        }
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension CreateParticipantTokenInput {

    static func urlPathProvider(_ value: CreateParticipantTokenInput) -> Swift.String? {
        return "/CreateParticipantToken"
    }
}

public struct CreateParticipantTokenInput {
    /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    public var attributes: [Swift.String:Swift.String]?
    /// Set of capabilities that the user is allowed to perform in the stage. Default: PUBLISH, SUBSCRIBE.
    public var capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
    /// Duration (in minutes), after which the token expires. Default: 720 (12 hours).
    public var duration: Swift.Int?
    /// ARN of the stage to which this token is scoped.
    /// This member is required.
    public var stageArn: Swift.String?
    /// Name that can be specified to help identify the token. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    public var userId: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil,
        duration: Swift.Int? = nil,
        stageArn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.capabilities = capabilities
        self.duration = duration
        self.stageArn = stageArn
        self.userId = userId
    }
}

struct CreateParticipantTokenInputBody {
    let stageArn: Swift.String?
    let duration: Swift.Int?
    let userId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
}

extension CreateParticipantTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case duration
        case stageArn
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let capabilitiesContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.ParticipantTokenCapability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [IVSRealTimeClientTypes.ParticipantTokenCapability]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
    }
}

extension CreateParticipantTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateParticipantTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.participantToken = output.participantToken
        } else {
            self.participantToken = nil
        }
    }
}

public struct CreateParticipantTokenOutput {
    /// The participant token that was created.
    public var participantToken: IVSRealTimeClientTypes.ParticipantToken?

    public init(
        participantToken: IVSRealTimeClientTypes.ParticipantToken? = nil
    )
    {
        self.participantToken = participantToken
    }
}

struct CreateParticipantTokenOutputBody {
    let participantToken: IVSRealTimeClientTypes.ParticipantToken?
}

extension CreateParticipantTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantTokenDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.ParticipantToken.self, forKey: .participantToken)
        participantToken = participantTokenDecoded
    }
}

enum CreateParticipantTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case participantTokenConfigurations
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let participantTokenConfigurations = participantTokenConfigurations {
            var participantTokenConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participantTokenConfigurations)
            for participanttokenconfiguration0 in participantTokenConfigurations {
                try participantTokenConfigurationsContainer.encode(participanttokenconfiguration0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStageInput {

    static func urlPathProvider(_ value: CreateStageInput) -> Swift.String? {
        return "/CreateStage"
    }
}

public struct CreateStageInput {
    /// Optional name that can be specified for the stage being created.
    public var name: Swift.String?
    /// Array of participant token configuration objects to attach to the new stage.
    public var participantTokenConfigurations: [IVSRealTimeClientTypes.ParticipantTokenConfiguration]?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init(
        name: Swift.String? = nil,
        participantTokenConfigurations: [IVSRealTimeClientTypes.ParticipantTokenConfiguration]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.participantTokenConfigurations = participantTokenConfigurations
        self.tags = tags
    }
}

struct CreateStageInputBody {
    let name: Swift.String?
    let participantTokenConfigurations: [IVSRealTimeClientTypes.ParticipantTokenConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case participantTokenConfigurations
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let participantTokenConfigurationsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.ParticipantTokenConfiguration?].self, forKey: .participantTokenConfigurations)
        var participantTokenConfigurationsDecoded0:[IVSRealTimeClientTypes.ParticipantTokenConfiguration]? = nil
        if let participantTokenConfigurationsContainer = participantTokenConfigurationsContainer {
            participantTokenConfigurationsDecoded0 = [IVSRealTimeClientTypes.ParticipantTokenConfiguration]()
            for structure0 in participantTokenConfigurationsContainer {
                if let structure0 = structure0 {
                    participantTokenConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        participantTokenConfigurations = participantTokenConfigurationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.participantTokens = output.participantTokens
            self.stage = output.stage
        } else {
            self.participantTokens = nil
            self.stage = nil
        }
    }
}

public struct CreateStageOutput {
    /// Participant tokens attached to the stage. These correspond to the participants in the request.
    public var participantTokens: [IVSRealTimeClientTypes.ParticipantToken]?
    /// The stage that was created.
    public var stage: IVSRealTimeClientTypes.Stage?

    public init(
        participantTokens: [IVSRealTimeClientTypes.ParticipantToken]? = nil,
        stage: IVSRealTimeClientTypes.Stage? = nil
    )
    {
        self.participantTokens = participantTokens
        self.stage = stage
    }
}

struct CreateStageOutputBody {
    let stage: IVSRealTimeClientTypes.Stage?
    let participantTokens: [IVSRealTimeClientTypes.ParticipantToken]?
}

extension CreateStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantTokens
        case stage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.Stage.self, forKey: .stage)
        stage = stageDecoded
        let participantTokensContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.ParticipantToken?].self, forKey: .participantTokens)
        var participantTokensDecoded0:[IVSRealTimeClientTypes.ParticipantToken]? = nil
        if let participantTokensContainer = participantTokensContainer {
            participantTokensDecoded0 = [IVSRealTimeClientTypes.ParticipantToken]()
            for structure0 in participantTokensContainer {
                if let structure0 = structure0 {
                    participantTokensDecoded0?.append(structure0)
                }
            }
        }
        participantTokens = participantTokensDecoded0
    }
}

enum CreateStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStorageConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case s3
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStorageConfigurationInput {

    static func urlPathProvider(_ value: CreateStorageConfigurationInput) -> Swift.String? {
        return "/CreateStorageConfiguration"
    }
}

public struct CreateStorageConfigurationInput {
    /// Storage configuration name. The value does not need to be unique.
    public var name: Swift.String?
    /// A complex type that contains a storage configuration for where recorded video will be stored.
    /// This member is required.
    public var s3: IVSRealTimeClientTypes.S3StorageConfiguration?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init(
        name: Swift.String? = nil,
        s3: IVSRealTimeClientTypes.S3StorageConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.s3 = s3
        self.tags = tags
    }
}

struct CreateStorageConfigurationInputBody {
    let name: Swift.String?
    let s3: IVSRealTimeClientTypes.S3StorageConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStorageConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case s3
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3Decoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.S3StorageConfiguration.self, forKey: .s3)
        s3 = s3Decoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStorageConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStorageConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.storageConfiguration = output.storageConfiguration
        } else {
            self.storageConfiguration = nil
        }
    }
}

public struct CreateStorageConfigurationOutput {
    /// The StorageConfiguration that was created.
    public var storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration?

    public init(
        storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration? = nil
    )
    {
        self.storageConfiguration = storageConfiguration
    }
}

struct CreateStorageConfigurationOutputBody {
    let storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration?
}

extension CreateStorageConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigurationDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.StorageConfiguration.self, forKey: .storageConfiguration)
        storageConfiguration = storageConfigurationDecoded
    }
}

enum CreateStorageConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEncoderConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteEncoderConfigurationInput {

    static func urlPathProvider(_ value: DeleteEncoderConfigurationInput) -> Swift.String? {
        return "/DeleteEncoderConfiguration"
    }
}

public struct DeleteEncoderConfigurationInput {
    /// ARN of the EncoderConfiguration.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteEncoderConfigurationInputBody {
    let arn: Swift.String?
}

extension DeleteEncoderConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteEncoderConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEncoderConfigurationOutput {

    public init() { }
}

enum DeleteEncoderConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteStageInput {

    static func urlPathProvider(_ value: DeleteStageInput) -> Swift.String? {
        return "/DeleteStage"
    }
}

public struct DeleteStageInput {
    /// ARN of the stage to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteStageInputBody {
    let arn: Swift.String?
}

extension DeleteStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStageOutput {

    public init() { }
}

enum DeleteStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStorageConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteStorageConfigurationInput {

    static func urlPathProvider(_ value: DeleteStorageConfigurationInput) -> Swift.String? {
        return "/DeleteStorageConfiguration"
    }
}

public struct DeleteStorageConfigurationInput {
    /// ARN of the storage configuration to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteStorageConfigurationInputBody {
    let arn: Swift.String?
}

extension DeleteStorageConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteStorageConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStorageConfigurationOutput {

    public init() { }
}

enum DeleteStorageConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IVSRealTimeClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case detail
        case endTime
        case id
        case startTime
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let detail = self.detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.DestinationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let detailDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.DestinationDetail.self, forKey: .detail)
        detail = detailDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying the status of a Destination.
    public struct Destination {
        /// Configuration used to create this destination.
        /// This member is required.
        public var configuration: IVSRealTimeClientTypes.DestinationConfiguration?
        /// Optional details regarding the status of the destination.
        public var detail: IVSRealTimeClientTypes.DestinationDetail?
        /// UTC time of the destination end. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var endTime: ClientRuntime.Date?
        /// Unique identifier for this destination, assigned by IVS.
        /// This member is required.
        public var id: Swift.String?
        /// UTC time of the destination start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// State of the Composition Destination.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.DestinationState?

        public init(
            configuration: IVSRealTimeClientTypes.DestinationConfiguration? = nil,
            detail: IVSRealTimeClientTypes.DestinationDetail? = nil,
            endTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IVSRealTimeClientTypes.DestinationState? = nil
        )
        {
            self.configuration = configuration
            self.detail = detail
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.state = state
        }
    }

}

extension IVSRealTimeClientTypes.DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case name
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.ChannelDestinationConfiguration.self, forKey: .channel)
        channel = channelDecoded
        let s3Decoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.S3DestinationConfiguration.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension IVSRealTimeClientTypes {
    /// Complex data type that defines destination-configuration objects.
    public struct DestinationConfiguration {
        /// An IVS channel to be used for broadcasting, for server-side composition. Either a channel or an s3 must be specified.
        public var channel: IVSRealTimeClientTypes.ChannelDestinationConfiguration?
        /// Name that can be specified to help identify the destination.
        public var name: Swift.String?
        /// An S3 storage configuration to be used for recording video data. Either a channel or an s3 must be specified.
        public var s3: IVSRealTimeClientTypes.S3DestinationConfiguration?

        public init(
            channel: IVSRealTimeClientTypes.ChannelDestinationConfiguration? = nil,
            name: Swift.String? = nil,
            s3: IVSRealTimeClientTypes.S3DestinationConfiguration? = nil
        )
        {
            self.channel = channel
            self.name = name
            self.s3 = s3
        }
    }

}

extension IVSRealTimeClientTypes.DestinationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.S3Detail.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension IVSRealTimeClientTypes {
    /// Complex data type that defines destination-detail objects.
    public struct DestinationDetail {
        /// An S3 detail object to return information about the S3 destination.
        public var s3: IVSRealTimeClientTypes.S3Detail?

        public init(
            s3: IVSRealTimeClientTypes.S3Detail? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension IVSRealTimeClientTypes {
    public enum DestinationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case failed
        case reconnecting
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationState] {
            return [
                .active,
                .failed,
                .reconnecting,
                .starting,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .reconnecting: return "RECONNECTING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationState(rawValue: rawValue) ?? DestinationState.sdkUnknown(rawValue)
        }
    }
}

extension IVSRealTimeClientTypes.DestinationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case id
        case startTime
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about a Destination.
    public struct DestinationSummary {
        /// UTC time of the destination end. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var endTime: ClientRuntime.Date?
        /// Unique identifier for this destination, assigned by IVS.
        /// This member is required.
        public var id: Swift.String?
        /// UTC time of the destination start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// State of the Composition Destination.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.DestinationState?

        public init(
            endTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IVSRealTimeClientTypes.DestinationState? = nil
        )
        {
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.state = state
        }
    }

}

extension DisconnectParticipantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantId
        case reason
        case stageArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
    }
}

extension DisconnectParticipantInput {

    static func urlPathProvider(_ value: DisconnectParticipantInput) -> Swift.String? {
        return "/DisconnectParticipant"
    }
}

public struct DisconnectParticipantInput {
    /// Identifier of the participant to be disconnected. This is assigned by IVS and returned by [CreateParticipantToken].
    /// This member is required.
    public var participantId: Swift.String?
    /// Description of why this participant is being disconnected.
    public var reason: Swift.String?
    /// ARN of the stage to which the participant is attached.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        participantId: Swift.String? = nil,
        reason: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.participantId = participantId
        self.reason = reason
        self.stageArn = stageArn
    }
}

struct DisconnectParticipantInputBody {
    let stageArn: Swift.String?
    let participantId: Swift.String?
    let reason: Swift.String?
}

extension DisconnectParticipantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantId
        case reason
        case stageArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DisconnectParticipantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisconnectParticipantOutput {

    public init() { }
}

enum DisconnectParticipantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IVSRealTimeClientTypes.EncoderConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case tags
        case video
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let video = self.video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let videoDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.Video.self, forKey: .video)
        video = videoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IVSRealTimeClientTypes {
    /// Settings for transcoding.
    public struct EncoderConfiguration {
        /// ARN of the EncoderConfiguration resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Optional name to identify the resource.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps
        public var video: IVSRealTimeClientTypes.Video?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            video: IVSRealTimeClientTypes.Video? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.tags = tags
            self.video = video
        }
    }

}

extension IVSRealTimeClientTypes.EncoderConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about an EncoderConfiguration.
    public struct EncoderConfigurationSummary {
        /// ARN of the EncoderConfiguration resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Optional name to identify the resource.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }

}

extension IVSRealTimeClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case eventTime
        case name
        case participantId
        case remoteParticipantId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .dateTime, forKey: .eventTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let remoteParticipantId = self.remoteParticipantId {
            try encodeContainer.encode(remoteParticipantId, forKey: .remoteParticipantId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.EventName.self, forKey: .name)
        name = nameDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let remoteParticipantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteParticipantId)
        remoteParticipantId = remoteParticipantIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.EventErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// An occurrence during a stage session.
    public struct Event {
        /// If the event is an error event, the error code is provided to give insight into the specific error that occurred. If the event is not an error event, this field is null. INSUFFICIENT_CAPABILITIES indicates that the participant tried to take an action that the participant’s token is not allowed to do. For more information about participant capabilities, see the capabilities field in [CreateParticipantToken]. QUOTA_EXCEEDED indicates that the number of participants who want to publish/subscribe to a stage exceeds the quota; for more information, see [Service Quotas](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/service-quotas.html). PUBLISHER_NOT_FOUND indicates that the participant tried to subscribe to a publisher that doesn’t exist.
        public var errorCode: IVSRealTimeClientTypes.EventErrorCode?
        /// ISO 8601 timestamp (returned as a string) for when the event occurred.
        public var eventTime: ClientRuntime.Date?
        /// The name of the event.
        public var name: IVSRealTimeClientTypes.EventName?
        /// Unique identifier for the participant who triggered the event. This is assigned by IVS.
        public var participantId: Swift.String?
        /// Unique identifier for the remote participant. For a subscribe event, this is the publisher. For a publish or join event, this is null. This is assigned by IVS.
        public var remoteParticipantId: Swift.String?

        public init(
            errorCode: IVSRealTimeClientTypes.EventErrorCode? = nil,
            eventTime: ClientRuntime.Date? = nil,
            name: IVSRealTimeClientTypes.EventName? = nil,
            participantId: Swift.String? = nil,
            remoteParticipantId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.eventTime = eventTime
            self.name = name
            self.participantId = participantId
            self.remoteParticipantId = remoteParticipantId
        }
    }

}

extension IVSRealTimeClientTypes {
    public enum EventErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insufficientCapabilities
        case publisherNotFound
        case quotaExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [EventErrorCode] {
            return [
                .insufficientCapabilities,
                .publisherNotFound,
                .quotaExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insufficientCapabilities: return "INSUFFICIENT_CAPABILITIES"
            case .publisherNotFound: return "PUBLISHER_NOT_FOUND"
            case .quotaExceeded: return "QUOTA_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventErrorCode(rawValue: rawValue) ?? EventErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IVSRealTimeClientTypes {
    public enum EventName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case joined
        case joinError
        case `left`
        case publishError
        case publishStarted
        case publishStopped
        case subscribeError
        case subscribeStarted
        case subscribeStopped
        case sdkUnknown(Swift.String)

        public static var allCases: [EventName] {
            return [
                .joined,
                .joinError,
                .left,
                .publishError,
                .publishStarted,
                .publishStopped,
                .subscribeError,
                .subscribeStarted,
                .subscribeStopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .joined: return "JOINED"
            case .joinError: return "JOIN_ERROR"
            case .left: return "LEFT"
            case .publishError: return "PUBLISH_ERROR"
            case .publishStarted: return "PUBLISH_STARTED"
            case .publishStopped: return "PUBLISH_STOPPED"
            case .subscribeError: return "SUBSCRIBE_ERROR"
            case .subscribeStarted: return "SUBSCRIBE_STARTED"
            case .subscribeStopped: return "SUBSCRIBE_STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventName(rawValue: rawValue) ?? EventName.sdkUnknown(rawValue)
        }
    }
}

extension GetCompositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetCompositionInput {

    static func urlPathProvider(_ value: GetCompositionInput) -> Swift.String? {
        return "/GetComposition"
    }
}

public struct GetCompositionInput {
    /// ARN of the Composition resource.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetCompositionInputBody {
    let arn: Swift.String?
}

extension GetCompositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetCompositionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCompositionOutputBody = try responseDecoder.decode(responseBody: data)
            self.composition = output.composition
        } else {
            self.composition = nil
        }
    }
}

public struct GetCompositionOutput {
    /// The Composition that was returned.
    public var composition: IVSRealTimeClientTypes.Composition?

    public init(
        composition: IVSRealTimeClientTypes.Composition? = nil
    )
    {
        self.composition = composition
    }
}

struct GetCompositionOutputBody {
    let composition: IVSRealTimeClientTypes.Composition?
}

extension GetCompositionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case composition
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compositionDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.Composition.self, forKey: .composition)
        composition = compositionDecoded
    }
}

enum GetCompositionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEncoderConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetEncoderConfigurationInput {

    static func urlPathProvider(_ value: GetEncoderConfigurationInput) -> Swift.String? {
        return "/GetEncoderConfiguration"
    }
}

public struct GetEncoderConfigurationInput {
    /// ARN of the EncoderConfiguration resource.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetEncoderConfigurationInputBody {
    let arn: Swift.String?
}

extension GetEncoderConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetEncoderConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEncoderConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.encoderConfiguration = output.encoderConfiguration
        } else {
            self.encoderConfiguration = nil
        }
    }
}

public struct GetEncoderConfigurationOutput {
    /// The EncoderConfiguration that was returned.
    public var encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration?

    public init(
        encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration? = nil
    )
    {
        self.encoderConfiguration = encoderConfiguration
    }
}

struct GetEncoderConfigurationOutputBody {
    let encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration?
}

extension GetEncoderConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encoderConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encoderConfigurationDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.EncoderConfiguration.self, forKey: .encoderConfiguration)
        encoderConfiguration = encoderConfigurationDecoded
    }
}

enum GetEncoderConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetParticipantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantId
        case sessionId
        case stageArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
    }
}

extension GetParticipantInput {

    static func urlPathProvider(_ value: GetParticipantInput) -> Swift.String? {
        return "/GetParticipant"
    }
}

public struct GetParticipantInput {
    /// Unique identifier for the participant. This is assigned by IVS and returned by [CreateParticipantToken].
    /// This member is required.
    public var participantId: Swift.String?
    /// ID of a session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        participantId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.participantId = participantId
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

struct GetParticipantInputBody {
    let stageArn: Swift.String?
    let sessionId: Swift.String?
    let participantId: Swift.String?
}

extension GetParticipantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participantId
        case sessionId
        case stageArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
    }
}

extension GetParticipantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetParticipantOutputBody = try responseDecoder.decode(responseBody: data)
            self.participant = output.participant
        } else {
            self.participant = nil
        }
    }
}

public struct GetParticipantOutput {
    /// The participant that is returned.
    public var participant: IVSRealTimeClientTypes.Participant?

    public init(
        participant: IVSRealTimeClientTypes.Participant? = nil
    )
    {
        self.participant = participant
    }
}

struct GetParticipantOutputBody {
    let participant: IVSRealTimeClientTypes.Participant?
}

extension GetParticipantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case participant
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.Participant.self, forKey: .participant)
        participant = participantDecoded
    }
}

enum GetParticipantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetStageInput {

    static func urlPathProvider(_ value: GetStageInput) -> Swift.String? {
        return "/GetStage"
    }
}

public struct GetStageInput {
    /// ARN of the stage for which the information is to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetStageInputBody {
    let arn: Swift.String?
}

extension GetStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.stage = output.stage
        } else {
            self.stage = nil
        }
    }
}

public struct GetStageOutput {
    /// The stage that is returned.
    public var stage: IVSRealTimeClientTypes.Stage?

    public init(
        stage: IVSRealTimeClientTypes.Stage? = nil
    )
    {
        self.stage = stage
    }
}

struct GetStageOutputBody {
    let stage: IVSRealTimeClientTypes.Stage?
}

extension GetStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.Stage.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum GetStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStageSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId
        case stageArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
    }
}

extension GetStageSessionInput {

    static func urlPathProvider(_ value: GetStageSessionInput) -> Swift.String? {
        return "/GetStageSession"
    }
}

public struct GetStageSessionInput {
    /// ID of a session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// ARN of the stage for which the information is to be retrieved.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

struct GetStageSessionInputBody {
    let stageArn: Swift.String?
    let sessionId: Swift.String?
}

extension GetStageSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId
        case stageArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension GetStageSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStageSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.stageSession = output.stageSession
        } else {
            self.stageSession = nil
        }
    }
}

public struct GetStageSessionOutput {
    /// The stage session that is returned.
    public var stageSession: IVSRealTimeClientTypes.StageSession?

    public init(
        stageSession: IVSRealTimeClientTypes.StageSession? = nil
    )
    {
        self.stageSession = stageSession
    }
}

struct GetStageSessionOutputBody {
    let stageSession: IVSRealTimeClientTypes.StageSession?
}

extension GetStageSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stageSession
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageSessionDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.StageSession.self, forKey: .stageSession)
        stageSession = stageSessionDecoded
    }
}

enum GetStageSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStorageConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetStorageConfigurationInput {

    static func urlPathProvider(_ value: GetStorageConfigurationInput) -> Swift.String? {
        return "/GetStorageConfiguration"
    }
}

public struct GetStorageConfigurationInput {
    /// ARN of the storage configuration to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetStorageConfigurationInputBody {
    let arn: Swift.String?
}

extension GetStorageConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetStorageConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStorageConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.storageConfiguration = output.storageConfiguration
        } else {
            self.storageConfiguration = nil
        }
    }
}

public struct GetStorageConfigurationOutput {
    /// The StorageConfiguration that was returned.
    public var storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration?

    public init(
        storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration? = nil
    )
    {
        self.storageConfiguration = storageConfiguration
    }
}

struct GetStorageConfigurationOutputBody {
    let storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration?
}

extension GetStorageConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigurationDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.StorageConfiguration.self, forKey: .storageConfiguration)
        storageConfiguration = storageConfigurationDecoded
    }
}

enum GetStorageConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IVSRealTimeClientTypes.GridConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featuredParticipantAttribute
        case gridGap
        case omitStoppedVideo
        case videoAspectRatio
        case videoFillMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featuredParticipantAttribute = self.featuredParticipantAttribute {
            try encodeContainer.encode(featuredParticipantAttribute, forKey: .featuredParticipantAttribute)
        }
        if gridGap != 0 {
            try encodeContainer.encode(gridGap, forKey: .gridGap)
        }
        if omitStoppedVideo != false {
            try encodeContainer.encode(omitStoppedVideo, forKey: .omitStoppedVideo)
        }
        if let videoAspectRatio = self.videoAspectRatio {
            try encodeContainer.encode(videoAspectRatio.rawValue, forKey: .videoAspectRatio)
        }
        if let videoFillMode = self.videoFillMode {
            try encodeContainer.encode(videoFillMode.rawValue, forKey: .videoFillMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featuredParticipantAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featuredParticipantAttribute)
        featuredParticipantAttribute = featuredParticipantAttributeDecoded
        let omitStoppedVideoDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .omitStoppedVideo) ?? false
        omitStoppedVideo = omitStoppedVideoDecoded
        let videoAspectRatioDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.VideoAspectRatio.self, forKey: .videoAspectRatio)
        videoAspectRatio = videoAspectRatioDecoded
        let videoFillModeDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.VideoFillMode.self, forKey: .videoFillMode)
        videoFillMode = videoFillModeDecoded
        let gridGapDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gridGap) ?? 0
        gridGap = gridGapDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Configuration information specific to Grid layout, for server-side composition. See "Layouts" in [Server-Side Composition](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/server-side-composition.html).
    public struct GridConfiguration {
        /// This attribute name identifies the featured slot. A participant with this attribute set to "true" (as a string value) in [ParticipantTokenConfiguration] is placed in the featured slot.
        public var featuredParticipantAttribute: Swift.String?
        /// Specifies the spacing between participant tiles in pixels. Default: 2.
        public var gridGap: Swift.Int
        /// Determines whether to omit participants with stopped video in the composition. Default: false.
        public var omitStoppedVideo: Swift.Bool
        /// Sets the non-featured participant display mode. Default: VIDEO.
        public var videoAspectRatio: IVSRealTimeClientTypes.VideoAspectRatio?
        /// Defines how video fits within the participant tile. When not set, videoFillMode defaults to COVER fill mode for participants in the grid and to CONTAIN fill mode for featured participants.
        public var videoFillMode: IVSRealTimeClientTypes.VideoFillMode?

        public init(
            featuredParticipantAttribute: Swift.String? = nil,
            gridGap: Swift.Int = 0,
            omitStoppedVideo: Swift.Bool = false,
            videoAspectRatio: IVSRealTimeClientTypes.VideoAspectRatio? = nil,
            videoFillMode: IVSRealTimeClientTypes.VideoFillMode? = nil
        )
        {
            self.featuredParticipantAttribute = featuredParticipantAttribute
            self.gridGap = gridGap
            self.omitStoppedVideo = omitStoppedVideo
            self.videoAspectRatio = videoAspectRatio
            self.videoFillMode = videoFillMode
        }
    }

}

public enum IVSRealTimeClientTypes {}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Unexpected error during processing of request.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct InternalServerExceptionBody {
    let exceptionMessage: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IVSRealTimeClientTypes.LayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grid
        case pip
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grid = self.grid {
            try encodeContainer.encode(grid, forKey: .grid)
        }
        if let pip = self.pip {
            try encodeContainer.encode(pip, forKey: .pip)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gridDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.GridConfiguration.self, forKey: .grid)
        grid = gridDecoded
        let pipDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.PipConfiguration.self, forKey: .pip)
        pip = pipDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Configuration information of supported layouts for server-side composition.
    public struct LayoutConfiguration {
        /// Configuration related to grid layout. Default: Grid layout.
        public var grid: IVSRealTimeClientTypes.GridConfiguration?
        /// Configuration related to PiP layout.
        public var pip: IVSRealTimeClientTypes.PipConfiguration?

        public init(
            grid: IVSRealTimeClientTypes.GridConfiguration? = nil,
            pip: IVSRealTimeClientTypes.PipConfiguration? = nil
        )
        {
            self.grid = grid
            self.pip = pip
        }
    }

}

extension ListCompositionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterByEncoderConfigurationArn
        case filterByStageArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterByEncoderConfigurationArn = self.filterByEncoderConfigurationArn {
            try encodeContainer.encode(filterByEncoderConfigurationArn, forKey: .filterByEncoderConfigurationArn)
        }
        if let filterByStageArn = self.filterByStageArn {
            try encodeContainer.encode(filterByStageArn, forKey: .filterByStageArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCompositionsInput {

    static func urlPathProvider(_ value: ListCompositionsInput) -> Swift.String? {
        return "/ListCompositions"
    }
}

public struct ListCompositionsInput {
    /// Filters the Composition list to match the specified EncoderConfiguration attached to at least one of its output.
    public var filterByEncoderConfigurationArn: Swift.String?
    /// Filters the Composition list to match the specified Stage ARN.
    public var filterByStageArn: Swift.String?
    /// Maximum number of results to return. Default: 100.
    public var maxResults: Swift.Int?
    /// The first Composition to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        filterByEncoderConfigurationArn: Swift.String? = nil,
        filterByStageArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterByEncoderConfigurationArn = filterByEncoderConfigurationArn
        self.filterByStageArn = filterByStageArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCompositionsInputBody {
    let filterByStageArn: Swift.String?
    let filterByEncoderConfigurationArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListCompositionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterByEncoderConfigurationArn
        case filterByStageArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterByStageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterByStageArn)
        filterByStageArn = filterByStageArnDecoded
        let filterByEncoderConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterByEncoderConfigurationArn)
        filterByEncoderConfigurationArn = filterByEncoderConfigurationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCompositionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCompositionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.compositions = output.compositions
            self.nextToken = output.nextToken
        } else {
            self.compositions = nil
            self.nextToken = nil
        }
    }
}

public struct ListCompositionsOutput {
    /// List of the matching Compositions (summary information only).
    /// This member is required.
    public var compositions: [IVSRealTimeClientTypes.CompositionSummary]?
    /// If there are more compositions than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        compositions: [IVSRealTimeClientTypes.CompositionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.compositions = compositions
        self.nextToken = nextToken
    }
}

struct ListCompositionsOutputBody {
    let compositions: [IVSRealTimeClientTypes.CompositionSummary]?
    let nextToken: Swift.String?
}

extension ListCompositionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compositions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compositionsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.CompositionSummary?].self, forKey: .compositions)
        var compositionsDecoded0:[IVSRealTimeClientTypes.CompositionSummary]? = nil
        if let compositionsContainer = compositionsContainer {
            compositionsDecoded0 = [IVSRealTimeClientTypes.CompositionSummary]()
            for structure0 in compositionsContainer {
                if let structure0 = structure0 {
                    compositionsDecoded0?.append(structure0)
                }
            }
        }
        compositions = compositionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCompositionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEncoderConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEncoderConfigurationsInput {

    static func urlPathProvider(_ value: ListEncoderConfigurationsInput) -> Swift.String? {
        return "/ListEncoderConfigurations"
    }
}

public struct ListEncoderConfigurationsInput {
    /// Maximum number of results to return. Default: 100.
    public var maxResults: Swift.Int?
    /// The first encoder configuration to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEncoderConfigurationsInputBody {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEncoderConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEncoderConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEncoderConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.encoderConfigurations = output.encoderConfigurations
            self.nextToken = output.nextToken
        } else {
            self.encoderConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListEncoderConfigurationsOutput {
    /// List of the matching EncoderConfigurations (summary information only).
    /// This member is required.
    public var encoderConfigurations: [IVSRealTimeClientTypes.EncoderConfigurationSummary]?
    /// If there are more encoder configurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        encoderConfigurations: [IVSRealTimeClientTypes.EncoderConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.encoderConfigurations = encoderConfigurations
        self.nextToken = nextToken
    }
}

struct ListEncoderConfigurationsOutputBody {
    let encoderConfigurations: [IVSRealTimeClientTypes.EncoderConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListEncoderConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encoderConfigurations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encoderConfigurationsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.EncoderConfigurationSummary?].self, forKey: .encoderConfigurations)
        var encoderConfigurationsDecoded0:[IVSRealTimeClientTypes.EncoderConfigurationSummary]? = nil
        if let encoderConfigurationsContainer = encoderConfigurationsContainer {
            encoderConfigurationsDecoded0 = [IVSRealTimeClientTypes.EncoderConfigurationSummary]()
            for structure0 in encoderConfigurationsContainer {
                if let structure0 = structure0 {
                    encoderConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        encoderConfigurations = encoderConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEncoderConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListParticipantEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case participantId
        case sessionId
        case stageArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
    }
}

extension ListParticipantEventsInput {

    static func urlPathProvider(_ value: ListParticipantEventsInput) -> Swift.String? {
        return "/ListParticipantEvents"
    }
}

public struct ListParticipantEventsInput {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first participant event to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?
    /// Unique identifier for this participant. This is assigned by IVS and returned by [CreateParticipantToken].
    /// This member is required.
    public var participantId: Swift.String?
    /// ID of a session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        participantId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.participantId = participantId
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

struct ListParticipantEventsInputBody {
    let stageArn: Swift.String?
    let sessionId: Swift.String?
    let participantId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListParticipantEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case participantId
        case sessionId
        case stageArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListParticipantEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListParticipantEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct ListParticipantEventsOutput {
    /// List of the matching events.
    /// This member is required.
    public var events: [IVSRealTimeClientTypes.Event]?
    /// If there are more events than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        events: [IVSRealTimeClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct ListParticipantEventsOutputBody {
    let events: [IVSRealTimeClientTypes.Event]?
    let nextToken: Swift.String?
}

extension ListParticipantEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[IVSRealTimeClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [IVSRealTimeClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListParticipantEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListParticipantsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterByPublished
        case filterByState
        case filterByUserId
        case maxResults
        case nextToken
        case sessionId
        case stageArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterByPublished = self.filterByPublished {
            try encodeContainer.encode(filterByPublished, forKey: .filterByPublished)
        }
        if let filterByState = self.filterByState {
            try encodeContainer.encode(filterByState.rawValue, forKey: .filterByState)
        }
        if let filterByUserId = self.filterByUserId {
            try encodeContainer.encode(filterByUserId, forKey: .filterByUserId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
    }
}

extension ListParticipantsInput {

    static func urlPathProvider(_ value: ListParticipantsInput) -> Swift.String? {
        return "/ListParticipants"
    }
}

public struct ListParticipantsInput {
    /// Filters the response list to only show participants who published during the stage session. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request.
    public var filterByPublished: Swift.Bool?
    /// Filters the response list to only show participants in the specified state. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request.
    public var filterByState: IVSRealTimeClientTypes.ParticipantState?
    /// Filters the response list to match the specified user ID. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request. A userId is a customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems.
    public var filterByUserId: Swift.String?
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first participant to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?
    /// ID of the session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        filterByPublished: Swift.Bool? = nil,
        filterByState: IVSRealTimeClientTypes.ParticipantState? = nil,
        filterByUserId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.filterByPublished = filterByPublished
        self.filterByState = filterByState
        self.filterByUserId = filterByUserId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

struct ListParticipantsInputBody {
    let stageArn: Swift.String?
    let sessionId: Swift.String?
    let filterByUserId: Swift.String?
    let filterByPublished: Swift.Bool?
    let filterByState: IVSRealTimeClientTypes.ParticipantState?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListParticipantsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterByPublished
        case filterByState
        case filterByUserId
        case maxResults
        case nextToken
        case sessionId
        case stageArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let filterByUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterByUserId)
        filterByUserId = filterByUserIdDecoded
        let filterByPublishedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .filterByPublished)
        filterByPublished = filterByPublishedDecoded
        let filterByStateDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.ParticipantState.self, forKey: .filterByState)
        filterByState = filterByStateDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListParticipantsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListParticipantsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.participants = output.participants
        } else {
            self.nextToken = nil
            self.participants = nil
        }
    }
}

public struct ListParticipantsOutput {
    /// If there are more participants than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching participants (summary information only).
    /// This member is required.
    public var participants: [IVSRealTimeClientTypes.ParticipantSummary]?

    public init(
        nextToken: Swift.String? = nil,
        participants: [IVSRealTimeClientTypes.ParticipantSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.participants = participants
    }
}

struct ListParticipantsOutputBody {
    let participants: [IVSRealTimeClientTypes.ParticipantSummary]?
    let nextToken: Swift.String?
}

extension ListParticipantsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case participants
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.ParticipantSummary?].self, forKey: .participants)
        var participantsDecoded0:[IVSRealTimeClientTypes.ParticipantSummary]? = nil
        if let participantsContainer = participantsContainer {
            participantsDecoded0 = [IVSRealTimeClientTypes.ParticipantSummary]()
            for structure0 in participantsContainer {
                if let structure0 = structure0 {
                    participantsDecoded0?.append(structure0)
                }
            }
        }
        participants = participantsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListParticipantsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStageSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case stageArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
    }
}

extension ListStageSessionsInput {

    static func urlPathProvider(_ value: ListStageSessionsInput) -> Swift.String? {
        return "/ListStageSessions"
    }
}

public struct ListStageSessionsInput {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first stage session to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stageArn = stageArn
    }
}

struct ListStageSessionsInputBody {
    let stageArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListStageSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case stageArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListStageSessionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStageSessionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stageSessions = output.stageSessions
        } else {
            self.nextToken = nil
            self.stageSessions = nil
        }
    }
}

public struct ListStageSessionsOutput {
    /// If there are more stage sessions than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of matching stage sessions.
    /// This member is required.
    public var stageSessions: [IVSRealTimeClientTypes.StageSessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        stageSessions: [IVSRealTimeClientTypes.StageSessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stageSessions = stageSessions
    }
}

struct ListStageSessionsOutputBody {
    let stageSessions: [IVSRealTimeClientTypes.StageSessionSummary]?
    let nextToken: Swift.String?
}

extension ListStageSessionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case stageSessions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageSessionsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.StageSessionSummary?].self, forKey: .stageSessions)
        var stageSessionsDecoded0:[IVSRealTimeClientTypes.StageSessionSummary]? = nil
        if let stageSessionsContainer = stageSessionsContainer {
            stageSessionsDecoded0 = [IVSRealTimeClientTypes.StageSessionSummary]()
            for structure0 in stageSessionsContainer {
                if let structure0 = structure0 {
                    stageSessionsDecoded0?.append(structure0)
                }
            }
        }
        stageSessions = stageSessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStageSessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListStagesInput {

    static func urlPathProvider(_ value: ListStagesInput) -> Swift.String? {
        return "/ListStages"
    }
}

public struct ListStagesInput {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first stage to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStagesInputBody {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListStagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListStagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stages = output.stages
        } else {
            self.nextToken = nil
            self.stages = nil
        }
    }
}

public struct ListStagesOutput {
    /// If there are more stages than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching stages (summary information only).
    /// This member is required.
    public var stages: [IVSRealTimeClientTypes.StageSummary]?

    public init(
        nextToken: Swift.String? = nil,
        stages: [IVSRealTimeClientTypes.StageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stages = stages
    }
}

struct ListStagesOutputBody {
    let stages: [IVSRealTimeClientTypes.StageSummary]?
    let nextToken: Swift.String?
}

extension ListStagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case stages
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagesContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.StageSummary?].self, forKey: .stages)
        var stagesDecoded0:[IVSRealTimeClientTypes.StageSummary]? = nil
        if let stagesContainer = stagesContainer {
            stagesDecoded0 = [IVSRealTimeClientTypes.StageSummary]()
            for structure0 in stagesContainer {
                if let structure0 = structure0 {
                    stagesDecoded0?.append(structure0)
                }
            }
        }
        stages = stagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStorageConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListStorageConfigurationsInput {

    static func urlPathProvider(_ value: ListStorageConfigurationsInput) -> Swift.String? {
        return "/ListStorageConfigurations"
    }
}

public struct ListStorageConfigurationsInput {
    /// Maximum number of storage configurations to return. Default: your service quota or 100, whichever is smaller.
    public var maxResults: Swift.Int?
    /// The first storage configuration to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStorageConfigurationsInputBody {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListStorageConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListStorageConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStorageConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.storageConfigurations = output.storageConfigurations
        } else {
            self.nextToken = nil
            self.storageConfigurations = nil
        }
    }
}

public struct ListStorageConfigurationsOutput {
    /// If there are more storage configurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching storage configurations.
    /// This member is required.
    public var storageConfigurations: [IVSRealTimeClientTypes.StorageConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        storageConfigurations: [IVSRealTimeClientTypes.StorageConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageConfigurations = storageConfigurations
    }
}

struct ListStorageConfigurationsOutputBody {
    let storageConfigurations: [IVSRealTimeClientTypes.StorageConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListStorageConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case storageConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigurationsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.StorageConfigurationSummary?].self, forKey: .storageConfigurations)
        var storageConfigurationsDecoded0:[IVSRealTimeClientTypes.StorageConfigurationSummary]? = nil
        if let storageConfigurationsContainer = storageConfigurationsContainer {
            storageConfigurationsDecoded0 = [IVSRealTimeClientTypes.StorageConfigurationSummary]()
            for structure0 in storageConfigurationsContainer {
                if let structure0 = structure0 {
                    storageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        storageConfigurations = storageConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStorageConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput {
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IVSRealTimeClientTypes.Participant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case browserName
        case browserVersion
        case firstJoinTime
        case ispName
        case osName
        case osVersion
        case participantId
        case published
        case sdkVersion
        case state
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, participantAttributes0) in attributes {
                try attributesContainer.encode(participantAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let browserName = self.browserName {
            try encodeContainer.encode(browserName, forKey: .browserName)
        }
        if let browserVersion = self.browserVersion {
            try encodeContainer.encode(browserVersion, forKey: .browserVersion)
        }
        if let firstJoinTime = self.firstJoinTime {
            try encodeContainer.encodeTimestamp(firstJoinTime, format: .dateTime, forKey: .firstJoinTime)
        }
        if let ispName = self.ispName {
            try encodeContainer.encode(ispName, forKey: .ispName)
        }
        if let osName = self.osName {
            try encodeContainer.encode(osName, forKey: .osName)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if published != false {
            try encodeContainer.encode(published, forKey: .published)
        }
        if let sdkVersion = self.sdkVersion {
            try encodeContainer.encode(sdkVersion, forKey: .sdkVersion)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.ParticipantState.self, forKey: .state)
        state = stateDecoded
        let firstJoinTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .firstJoinTime)
        firstJoinTime = firstJoinTimeDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let publishedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .published) ?? false
        published = publishedDecoded
        let ispNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ispName)
        ispName = ispNameDecoded
        let osNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osName)
        osName = osNameDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let browserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserName)
        browserName = browserNameDecoded
        let browserVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserVersion)
        browserVersion = browserVersionDecoded
        let sdkVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sdkVersion)
        sdkVersion = sdkVersionDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Object describing a participant that has joined a stage.
    public struct Participant {
        /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String:Swift.String]?
        /// The participant’s browser.
        public var browserName: Swift.String?
        /// The participant’s browser version.
        public var browserVersion: Swift.String?
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        public var firstJoinTime: ClientRuntime.Date?
        /// The participant’s Internet Service Provider.
        public var ispName: Swift.String?
        /// The participant’s operating system.
        public var osName: Swift.String?
        /// The participant’s operating system version.
        public var osVersion: Swift.String?
        /// Unique identifier for this participant, assigned by IVS.
        public var participantId: Swift.String?
        /// Whether the participant ever published to the stage session.
        public var published: Swift.Bool
        /// The participant’s SDK version.
        public var sdkVersion: Swift.String?
        /// Whether the participant is connected to or disconnected from the stage.
        public var state: IVSRealTimeClientTypes.ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            browserName: Swift.String? = nil,
            browserVersion: Swift.String? = nil,
            firstJoinTime: ClientRuntime.Date? = nil,
            ispName: Swift.String? = nil,
            osName: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            participantId: Swift.String? = nil,
            published: Swift.Bool = false,
            sdkVersion: Swift.String? = nil,
            state: IVSRealTimeClientTypes.ParticipantState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.browserName = browserName
            self.browserVersion = browserVersion
            self.firstJoinTime = firstJoinTime
            self.ispName = ispName
            self.osName = osName
            self.osVersion = osVersion
            self.participantId = participantId
            self.published = published
            self.sdkVersion = sdkVersion
            self.state = state
            self.userId = userId
        }
    }

}

extension IVSRealTimeClientTypes {
    public enum ParticipantState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantState] {
            return [
                .connected,
                .disconnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParticipantState(rawValue: rawValue) ?? ParticipantState.sdkUnknown(rawValue)
        }
    }
}

extension IVSRealTimeClientTypes.ParticipantSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firstJoinTime
        case participantId
        case published
        case state
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firstJoinTime = self.firstJoinTime {
            try encodeContainer.encodeTimestamp(firstJoinTime, format: .dateTime, forKey: .firstJoinTime)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if published != false {
            try encodeContainer.encode(published, forKey: .published)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.ParticipantState.self, forKey: .state)
        state = stateDecoded
        let firstJoinTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .firstJoinTime)
        firstJoinTime = firstJoinTimeDecoded
        let publishedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .published) ?? false
        published = publishedDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Summary object describing a participant that has joined a stage.
    public struct ParticipantSummary {
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        public var firstJoinTime: ClientRuntime.Date?
        /// Unique identifier for this participant, assigned by IVS.
        public var participantId: Swift.String?
        /// Whether the participant ever published to the stage session.
        public var published: Swift.Bool
        /// Whether the participant is connected to or disconnected from the stage.
        public var state: IVSRealTimeClientTypes.ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            firstJoinTime: ClientRuntime.Date? = nil,
            participantId: Swift.String? = nil,
            published: Swift.Bool = false,
            state: IVSRealTimeClientTypes.ParticipantState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.firstJoinTime = firstJoinTime
            self.participantId = participantId
            self.published = published
            self.state = state
            self.userId = userId
        }
    }

}

extension IVSRealTimeClientTypes.ParticipantToken: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case duration
        case expirationTime
        case participantId
        case token
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, participantTokenAttributes0) in attributes {
                try attributesContainer.encode(participantTokenAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for participanttokencapability0 in capabilities {
                try capabilitiesContainer.encode(participanttokencapability0.rawValue)
            }
        }
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .dateTime, forKey: .expirationTime)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.ParticipantTokenCapability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [IVSRealTimeClientTypes.ParticipantTokenCapability]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
    }
}

extension IVSRealTimeClientTypes.ParticipantToken: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParticipantToken(attributes: \(Swift.String(describing: attributes)), capabilities: \(Swift.String(describing: capabilities)), duration: \(Swift.String(describing: duration)), expirationTime: \(Swift.String(describing: expirationTime)), participantId: \(Swift.String(describing: participantId)), userId: \(Swift.String(describing: userId)), token: \"CONTENT_REDACTED\")"}
}

extension IVSRealTimeClientTypes {
    /// Object specifying a participant token in a stage. Important: Treat tokens as opaque; i.e., do not build functionality based on token contents. The format of tokens could change in the future.
    public struct ParticipantToken {
        /// Application-provided attributes to encode into the token and attach to a stage. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String:Swift.String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public var capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
        /// Duration (in minutes), after which the participant token expires. Default: 720 (12 hours).
        public var duration: Swift.Int?
        /// ISO 8601 timestamp (returned as a string) for when this token expires.
        public var expirationTime: ClientRuntime.Date?
        /// Unique identifier for this participant token, assigned by IVS.
        public var participantId: Swift.String?
        /// The issued client token, encrypted.
        public var token: Swift.String?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil,
            duration: Swift.Int? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            participantId: Swift.String? = nil,
            token: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.expirationTime = expirationTime
            self.participantId = participantId
            self.token = token
            self.userId = userId
        }
    }

}

extension IVSRealTimeClientTypes {
    public enum ParticipantTokenCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case publish
        case subscribe
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantTokenCapability] {
            return [
                .publish,
                .subscribe,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .publish: return "PUBLISH"
            case .subscribe: return "SUBSCRIBE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParticipantTokenCapability(rawValue: rawValue) ?? ParticipantTokenCapability.sdkUnknown(rawValue)
        }
    }
}

extension IVSRealTimeClientTypes.ParticipantTokenConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case duration
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, participantTokenAttributes0) in attributes {
                try attributesContainer.encode(participantTokenAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for participanttokencapability0 in capabilities {
                try capabilitiesContainer.encode(participanttokencapability0.rawValue)
            }
        }
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let capabilitiesContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.ParticipantTokenCapability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [IVSRealTimeClientTypes.ParticipantTokenCapability]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying a participant token configuration in a stage.
    public struct ParticipantTokenConfiguration {
        /// Application-provided attributes to encode into the corresponding participant token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String:Swift.String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public var capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
        /// Duration (in minutes), after which the corresponding participant token expires. Default: 720 (12 hours).
        public var duration: Swift.Int?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil,
            duration: Swift.Int? = nil,
            userId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.userId = userId
        }
    }

}

extension PendingVerification {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PendingVerificationBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct PendingVerification: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Your account is pending verification.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PendingVerification" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct PendingVerificationBody {
    let exceptionMessage: Swift.String?
}

extension PendingVerificationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IVSRealTimeClientTypes {
    public enum PipBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [PipBehavior] {
            return [
                .dynamic,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dynamic: return "DYNAMIC"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PipBehavior(rawValue: rawValue) ?? PipBehavior.sdkUnknown(rawValue)
        }
    }
}

extension IVSRealTimeClientTypes.PipConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featuredParticipantAttribute
        case gridGap
        case omitStoppedVideo
        case pipBehavior
        case pipHeight
        case pipOffset
        case pipParticipantAttribute
        case pipPosition
        case pipWidth
        case videoFillMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featuredParticipantAttribute = self.featuredParticipantAttribute {
            try encodeContainer.encode(featuredParticipantAttribute, forKey: .featuredParticipantAttribute)
        }
        if gridGap != 0 {
            try encodeContainer.encode(gridGap, forKey: .gridGap)
        }
        if omitStoppedVideo != false {
            try encodeContainer.encode(omitStoppedVideo, forKey: .omitStoppedVideo)
        }
        if let pipBehavior = self.pipBehavior {
            try encodeContainer.encode(pipBehavior.rawValue, forKey: .pipBehavior)
        }
        if let pipHeight = self.pipHeight {
            try encodeContainer.encode(pipHeight, forKey: .pipHeight)
        }
        if pipOffset != 0 {
            try encodeContainer.encode(pipOffset, forKey: .pipOffset)
        }
        if let pipParticipantAttribute = self.pipParticipantAttribute {
            try encodeContainer.encode(pipParticipantAttribute, forKey: .pipParticipantAttribute)
        }
        if let pipPosition = self.pipPosition {
            try encodeContainer.encode(pipPosition.rawValue, forKey: .pipPosition)
        }
        if let pipWidth = self.pipWidth {
            try encodeContainer.encode(pipWidth, forKey: .pipWidth)
        }
        if let videoFillMode = self.videoFillMode {
            try encodeContainer.encode(videoFillMode.rawValue, forKey: .videoFillMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featuredParticipantAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featuredParticipantAttribute)
        featuredParticipantAttribute = featuredParticipantAttributeDecoded
        let omitStoppedVideoDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .omitStoppedVideo) ?? false
        omitStoppedVideo = omitStoppedVideoDecoded
        let videoFillModeDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.VideoFillMode.self, forKey: .videoFillMode)
        videoFillMode = videoFillModeDecoded
        let gridGapDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gridGap) ?? 0
        gridGap = gridGapDecoded
        let pipParticipantAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipParticipantAttribute)
        pipParticipantAttribute = pipParticipantAttributeDecoded
        let pipBehaviorDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.PipBehavior.self, forKey: .pipBehavior)
        pipBehavior = pipBehaviorDecoded
        let pipOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pipOffset) ?? 0
        pipOffset = pipOffsetDecoded
        let pipPositionDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.PipPosition.self, forKey: .pipPosition)
        pipPosition = pipPositionDecoded
        let pipWidthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pipWidth)
        pipWidth = pipWidthDecoded
        let pipHeightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pipHeight)
        pipHeight = pipHeightDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Configuration information specific to Picture-in-Picture (PiP) layout, for [server-side composition](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/server-side-composition.html).
    public struct PipConfiguration {
        /// This attribute name identifies the featured slot. A participant with this attribute set to "true" (as a string value) in [ParticipantTokenConfiguration] is placed in the featured slot.
        public var featuredParticipantAttribute: Swift.String?
        /// Specifies the spacing between participant tiles in pixels. Default: 0.
        public var gridGap: Swift.Int
        /// Determines whether to omit participants with stopped video in the composition. Default: false.
        public var omitStoppedVideo: Swift.Bool
        /// Defines PiP behavior when all participants have left. Default: STATIC.
        public var pipBehavior: IVSRealTimeClientTypes.PipBehavior?
        /// Specifies the height of the PiP window in pixels. When this is not set explicitly, pipHeight’s value will be based on the size of the composition and the aspect ratio of the participant’s video.
        public var pipHeight: Swift.Int?
        /// Sets the PiP window’s offset position in pixels from the closest edges determined by PipPosition. Default: 0.
        public var pipOffset: Swift.Int
        /// Identifies the PiP slot. A participant with this attribute set to "true" (as a string value) in [ParticipantTokenConfiguration] is placed in the PiP slot.
        public var pipParticipantAttribute: Swift.String?
        /// Determines the corner position of the PiP window. Default: BOTTOM_RIGHT.
        public var pipPosition: IVSRealTimeClientTypes.PipPosition?
        /// Specifies the width of the PiP window in pixels. When this is not set explicitly, pipWidth’s value will be based on the size of the composition and the aspect ratio of the participant’s video.
        public var pipWidth: Swift.Int?
        /// Defines how video fits within the participant tile. Default: COVER.
        public var videoFillMode: IVSRealTimeClientTypes.VideoFillMode?

        public init(
            featuredParticipantAttribute: Swift.String? = nil,
            gridGap: Swift.Int = 0,
            omitStoppedVideo: Swift.Bool = false,
            pipBehavior: IVSRealTimeClientTypes.PipBehavior? = nil,
            pipHeight: Swift.Int? = nil,
            pipOffset: Swift.Int = 0,
            pipParticipantAttribute: Swift.String? = nil,
            pipPosition: IVSRealTimeClientTypes.PipPosition? = nil,
            pipWidth: Swift.Int? = nil,
            videoFillMode: IVSRealTimeClientTypes.VideoFillMode? = nil
        )
        {
            self.featuredParticipantAttribute = featuredParticipantAttribute
            self.gridGap = gridGap
            self.omitStoppedVideo = omitStoppedVideo
            self.pipBehavior = pipBehavior
            self.pipHeight = pipHeight
            self.pipOffset = pipOffset
            self.pipParticipantAttribute = pipParticipantAttribute
            self.pipPosition = pipPosition
            self.pipWidth = pipWidth
            self.videoFillMode = videoFillMode
        }
    }

}

extension IVSRealTimeClientTypes {
    public enum PipPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bottomLeft
        case bottomRight
        case topLeft
        case topRight
        case sdkUnknown(Swift.String)

        public static var allCases: [PipPosition] {
            return [
                .bottomLeft,
                .bottomRight,
                .topLeft,
                .topRight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bottomLeft: return "BOTTOM_LEFT"
            case .bottomRight: return "BOTTOM_RIGHT"
            case .topLeft: return "TOP_LEFT"
            case .topRight: return "TOP_RIGHT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PipPosition(rawValue: rawValue) ?? PipPosition.sdkUnknown(rawValue)
        }
    }
}

extension IVSRealTimeClientTypes.RecordingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.RecordingConfigurationFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// An object representing a configuration to record a stage stream.
    public struct RecordingConfiguration {
        /// The recording format for storing a recording in Amazon S3.
        public var format: IVSRealTimeClientTypes.RecordingConfigurationFormat?

        public init(
            format: IVSRealTimeClientTypes.RecordingConfigurationFormat? = nil
        )
        {
            self.format = format
        }
    }

}

extension IVSRealTimeClientTypes {
    public enum RecordingConfigurationFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hls
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingConfigurationFormat] {
            return [
                .hls,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hls: return "HLS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordingConfigurationFormat(rawValue: rawValue) ?? RecordingConfigurationFormat.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request references a resource which does not exist.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ResourceNotFoundExceptionBody {
    let exceptionMessage: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IVSRealTimeClientTypes.S3DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encoderConfigurationArns
        case recordingConfiguration
        case storageConfigurationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encoderConfigurationArns = encoderConfigurationArns {
            var encoderConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .encoderConfigurationArns)
            for encoderconfigurationarn0 in encoderConfigurationArns {
                try encoderConfigurationArnsContainer.encode(encoderconfigurationarn0)
            }
        }
        if let recordingConfiguration = self.recordingConfiguration {
            try encodeContainer.encode(recordingConfiguration, forKey: .recordingConfiguration)
        }
        if let storageConfigurationArn = self.storageConfigurationArn {
            try encodeContainer.encode(storageConfigurationArn, forKey: .storageConfigurationArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageConfigurationArn)
        storageConfigurationArn = storageConfigurationArnDecoded
        let encoderConfigurationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .encoderConfigurationArns)
        var encoderConfigurationArnsDecoded0:[Swift.String]? = nil
        if let encoderConfigurationArnsContainer = encoderConfigurationArnsContainer {
            encoderConfigurationArnsDecoded0 = [Swift.String]()
            for string0 in encoderConfigurationArnsContainer {
                if let string0 = string0 {
                    encoderConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        encoderConfigurationArns = encoderConfigurationArnsDecoded0
        let recordingConfigurationDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.RecordingConfiguration.self, forKey: .recordingConfiguration)
        recordingConfiguration = recordingConfigurationDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// A complex type that describes an S3 location where recorded videos will be stored.
    public struct S3DestinationConfiguration {
        /// ARNs of the [EncoderConfiguration] resource. The encoder configuration and stage resources must be in the same AWS account and region.
        /// This member is required.
        public var encoderConfigurationArns: [Swift.String]?
        /// Array of maps, each of the form string:string (key:value). This is an optional customer specification, currently used only to specify the recording format for storing a recording in Amazon S3.
        public var recordingConfiguration: IVSRealTimeClientTypes.RecordingConfiguration?
        /// ARN of the [StorageConfiguration] where recorded videos will be stored.
        /// This member is required.
        public var storageConfigurationArn: Swift.String?

        public init(
            encoderConfigurationArns: [Swift.String]? = nil,
            recordingConfiguration: IVSRealTimeClientTypes.RecordingConfiguration? = nil,
            storageConfigurationArn: Swift.String? = nil
        )
        {
            self.encoderConfigurationArns = encoderConfigurationArns
            self.recordingConfiguration = recordingConfiguration
            self.storageConfigurationArn = storageConfigurationArn
        }
    }

}

extension IVSRealTimeClientTypes.S3Detail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordingPrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordingPrefix = self.recordingPrefix {
            try encodeContainer.encode(recordingPrefix, forKey: .recordingPrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingPrefix)
        recordingPrefix = recordingPrefixDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Complex data type that defines S3Detail objects.
    public struct S3Detail {
        /// The S3 bucket prefix under which the recording is stored.
        /// This member is required.
        public var recordingPrefix: Swift.String?

        public init(
            recordingPrefix: Swift.String? = nil
        )
        {
            self.recordingPrefix = recordingPrefix
        }
    }

}

extension IVSRealTimeClientTypes.S3StorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// A complex type that describes an S3 location where recorded videos will be stored.
    public struct S3StorageConfiguration {
        /// Location (S3 bucket name) where recorded videos will be stored. Note that the StorageConfiguration and S3 bucket must be in the same region as the Composition.
        /// This member is required.
        public var bucketName: Swift.String?

        public init(
            bucketName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request would cause a service quota to be exceeded.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ServiceQuotaExceededExceptionBody {
    let exceptionMessage: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IVSRealTimeClientTypes.Stage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeSessionId
        case arn
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeSessionId = self.activeSessionId {
            try encodeContainer.encode(activeSessionId, forKey: .activeSessionId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let activeSessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeSessionId)
        activeSessionId = activeSessionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying a stage.
    public struct Stage {
        /// ID of the active session within the stage.
        public var activeSessionId: Swift.String?
        /// Stage ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Stage name.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            activeSessionId: Swift.String? = nil,
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }

}

extension IVSRealTimeClientTypes.StageSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case sessionId
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// A stage session begins when the first participant joins a stage and ends after the last participant leaves the stage. A stage session helps with debugging stages by grouping events and participants into shorter periods of time (i.e., a session), which is helpful when stages are used over long periods of time.
    public struct StageSession {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        public var endTime: ClientRuntime.Date?
        /// ID of the session within the stage.
        public var sessionId: Swift.String?
        /// ISO 8601 timestamp (returned as a string) when this stage session began.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            sessionId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }
    }

}

extension IVSRealTimeClientTypes.StageSessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case sessionId
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about a stage session.
    public struct StageSessionSummary {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        public var endTime: ClientRuntime.Date?
        /// ID of the session within the stage.
        public var sessionId: Swift.String?
        /// ISO 8601 timestamp (returned as a string) when this stage session began.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            sessionId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }
    }

}

extension IVSRealTimeClientTypes.StageSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeSessionId
        case arn
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeSessionId = self.activeSessionId {
            try encodeContainer.encode(activeSessionId, forKey: .activeSessionId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let activeSessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeSessionId)
        activeSessionId = activeSessionIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about a stage.
    public struct StageSummary {
        /// ID of the active session within the stage.
        public var activeSessionId: Swift.String?
        /// Stage ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Stage name.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            activeSessionId: Swift.String? = nil,
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }

}

extension StartCompositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations
        case idempotencyToken
        case layout
        case stageArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for destinationconfiguration0 in destinations {
                try destinationsContainer.encode(destinationconfiguration0)
            }
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let layout = self.layout {
            try encodeContainer.encode(layout, forKey: .layout)
        }
        if let stageArn = self.stageArn {
            try encodeContainer.encode(stageArn, forKey: .stageArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartCompositionInput {

    static func urlPathProvider(_ value: StartCompositionInput) -> Swift.String? {
        return "/StartComposition"
    }
}

public struct StartCompositionInput {
    /// Array of destination configuration.
    /// This member is required.
    public var destinations: [IVSRealTimeClientTypes.DestinationConfiguration]?
    /// Idempotency token.
    public var idempotencyToken: Swift.String?
    /// Layout object to configure composition parameters.
    public var layout: IVSRealTimeClientTypes.LayoutConfiguration?
    /// ARN of the stage to be used for compositing.
    /// This member is required.
    public var stageArn: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init(
        destinations: [IVSRealTimeClientTypes.DestinationConfiguration]? = nil,
        idempotencyToken: Swift.String? = nil,
        layout: IVSRealTimeClientTypes.LayoutConfiguration? = nil,
        stageArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.destinations = destinations
        self.idempotencyToken = idempotencyToken
        self.layout = layout
        self.stageArn = stageArn
        self.tags = tags
    }
}

struct StartCompositionInputBody {
    let stageArn: Swift.String?
    let idempotencyToken: Swift.String?
    let layout: IVSRealTimeClientTypes.LayoutConfiguration?
    let destinations: [IVSRealTimeClientTypes.DestinationConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension StartCompositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations
        case idempotencyToken
        case layout
        case stageArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageArn)
        stageArn = stageArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let layoutDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.LayoutConfiguration.self, forKey: .layout)
        layout = layoutDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([IVSRealTimeClientTypes.DestinationConfiguration?].self, forKey: .destinations)
        var destinationsDecoded0:[IVSRealTimeClientTypes.DestinationConfiguration]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [IVSRealTimeClientTypes.DestinationConfiguration]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartCompositionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartCompositionOutputBody = try responseDecoder.decode(responseBody: data)
            self.composition = output.composition
        } else {
            self.composition = nil
        }
    }
}

public struct StartCompositionOutput {
    /// The Composition that was created.
    public var composition: IVSRealTimeClientTypes.Composition?

    public init(
        composition: IVSRealTimeClientTypes.Composition? = nil
    )
    {
        self.composition = composition
    }
}

struct StartCompositionOutputBody {
    let composition: IVSRealTimeClientTypes.Composition?
}

extension StartCompositionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case composition
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compositionDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.Composition.self, forKey: .composition)
        composition = compositionDecoded
    }
}

enum StartCompositionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopCompositionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension StopCompositionInput {

    static func urlPathProvider(_ value: StopCompositionInput) -> Swift.String? {
        return "/StopComposition"
    }
}

public struct StopCompositionInput {
    /// ARN of the Composition.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct StopCompositionInputBody {
    let arn: Swift.String?
}

extension StopCompositionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopCompositionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopCompositionOutput {

    public init() { }
}

enum StopCompositionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IVSRealTimeClientTypes.StorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case s3
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3Decoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.S3StorageConfiguration.self, forKey: .s3)
        s3 = s3Decoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IVSRealTimeClientTypes {
    /// A complex type that describes a location where recorded videos will be stored.
    public struct StorageConfiguration {
        /// ARN of the storage configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Name of the storage configuration.
        public var name: Swift.String?
        /// An S3 destination configuration where recorded videos will be stored.
        public var s3: IVSRealTimeClientTypes.S3StorageConfiguration?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            s3: IVSRealTimeClientTypes.S3StorageConfiguration? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.s3 = s3
            self.tags = tags
        }
    }

}

extension IVSRealTimeClientTypes.StorageConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case s3
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3Decoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.S3StorageConfiguration.self, forKey: .s3)
        s3 = s3Decoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about a storage configuration.
    public struct StorageConfigurationSummary {
        /// ARN of the storage configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Name of the storage configuration.
        public var name: Swift.String?
        /// An S3 destination configuration where recorded videos will be stored.
        public var s3: IVSRealTimeClientTypes.S3StorageConfiguration?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            s3: IVSRealTimeClientTypes.S3StorageConfiguration? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.s3 = s3
            self.tags = tags
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput {
    /// The ARN of the resource to be tagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints beyond what is documented there.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The ARN of the resource to be untagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints beyond what is documented there.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateStageInput {

    static func urlPathProvider(_ value: UpdateStageInput) -> Swift.String? {
        return "/UpdateStage"
    }
}

public struct UpdateStageInput {
    /// ARN of the stage to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// Name of the stage to be updated.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct UpdateStageInputBody {
    let arn: Swift.String?
    let name: Swift.String?
}

extension UpdateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.stage = output.stage
        } else {
            self.stage = nil
        }
    }
}

public struct UpdateStageOutput {
    /// The updated stage.
    public var stage: IVSRealTimeClientTypes.Stage?

    public init(
        stage: IVSRealTimeClientTypes.Stage? = nil
    )
    {
        self.stage = stage
    }
}

struct UpdateStageOutputBody {
    let stage: IVSRealTimeClientTypes.Stage?
}

extension UpdateStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(IVSRealTimeClientTypes.Stage.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum UpdateStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ValidationExceptionBody {
    let exceptionMessage: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IVSRealTimeClientTypes.Video: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bitrate
        case framerate
        case height
        case width
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bitrate = self.bitrate {
            try encodeContainer.encode(bitrate, forKey: .bitrate)
        }
        if let framerate = self.framerate {
            try encodeContainer.encode(framerate, forKey: .framerate)
        }
        if let height = self.height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let width = self.width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let widthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .width)
        width = widthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .height)
        height = heightDecoded
        let framerateDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .framerate)
        framerate = framerateDecoded
        let bitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bitrate)
        bitrate = bitrateDecoded
    }
}

extension IVSRealTimeClientTypes {
    /// Settings for video.
    public struct Video {
        /// Bitrate for generated output, in bps. Default: 2500000.
        public var bitrate: Swift.Int?
        /// Video frame rate, in fps. Default: 30.
        public var framerate: Swift.Float?
        /// Video-resolution height. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        public var height: Swift.Int?
        /// Video-resolution width. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        public var width: Swift.Int?

        public init(
            bitrate: Swift.Int? = nil,
            framerate: Swift.Float? = nil,
            height: Swift.Int? = nil,
            width: Swift.Int? = nil
        )
        {
            self.bitrate = bitrate
            self.framerate = framerate
            self.height = height
            self.width = width
        }
    }

}

extension IVSRealTimeClientTypes {
    public enum VideoAspectRatio: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case portrait
        case square
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoAspectRatio] {
            return [
                .auto,
                .portrait,
                .square,
                .video,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .portrait: return "PORTRAIT"
            case .square: return "SQUARE"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VideoAspectRatio(rawValue: rawValue) ?? VideoAspectRatio.sdkUnknown(rawValue)
        }
    }
}

extension IVSRealTimeClientTypes {
    public enum VideoFillMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contain
        case cover
        case fill
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoFillMode] {
            return [
                .contain,
                .cover,
                .fill,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contain: return "CONTAIN"
            case .cover: return "COVER"
            case .fill: return "FILL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VideoFillMode(rawValue: rawValue) ?? VideoFillMode.sdkUnknown(rawValue)
        }
    }
}
