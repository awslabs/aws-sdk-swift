// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

///
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// User does not have sufficient access to perform this action.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

extension IVSRealTimeClientTypes.ChannelDestinationConfiguration {

    static func write(value: IVSRealTimeClientTypes.ChannelDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelArn"].write(value.channelArn)
        try writer["encoderConfigurationArn"].write(value.encoderConfigurationArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.ChannelDestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.ChannelDestinationConfiguration()
        value.channelArn = try reader["channelArn"].readIfPresent()
        value.encoderConfigurationArn = try reader["encoderConfigurationArn"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying a channel as a destination.
    public struct ChannelDestinationConfiguration {
        /// ARN of the channel to use for broadcasting. The channel and stage resources must be in the same AWS account and region. The channel must be offline (not broadcasting).
        /// This member is required.
        public var channelArn: Swift.String?
        /// ARN of the [EncoderConfiguration] resource. The encoder configuration and stage resources must be in the same AWS account and region.
        public var encoderConfigurationArn: Swift.String?

        public init(
            channelArn: Swift.String? = nil,
            encoderConfigurationArn: Swift.String? = nil
        )
        {
            self.channelArn = channelArn
            self.encoderConfigurationArn = encoderConfigurationArn
        }
    }

}

extension IVSRealTimeClientTypes.Composition {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.Composition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.Composition()
        value.arn = try reader["arn"].readIfPresent()
        value.stageArn = try reader["stageArn"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.layout = try reader["layout"].readIfPresent(with: IVSRealTimeClientTypes.LayoutConfiguration.read(from:))
        value.destinations = try reader["destinations"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.Destination.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying a Composition resource.
    public struct Composition {
        /// ARN of the Composition resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Array of Destination objects. A Composition can contain either one destination (channel or s3) or two (one channel and one s3).
        /// This member is required.
        public var destinations: [IVSRealTimeClientTypes.Destination]?
        /// UTC time of the Composition end. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var endTime: ClientRuntime.Date?
        /// Layout object to configure composition parameters.
        /// This member is required.
        public var layout: IVSRealTimeClientTypes.LayoutConfiguration?
        /// ARN of the stage used as input
        /// This member is required.
        public var stageArn: Swift.String?
        /// UTC time of the Composition start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// State of the Composition.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.CompositionState?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            destinations: [IVSRealTimeClientTypes.Destination]? = nil,
            endTime: ClientRuntime.Date? = nil,
            layout: IVSRealTimeClientTypes.LayoutConfiguration? = nil,
            stageArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IVSRealTimeClientTypes.CompositionState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.destinations = destinations
            self.endTime = endTime
            self.layout = layout
            self.stageArn = stageArn
            self.startTime = startTime
            self.state = state
            self.tags = tags
        }
    }

}

extension IVSRealTimeClientTypes {

    public enum CompositionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case failed
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [CompositionState] {
            return [
                .active,
                .failed,
                .starting,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes.CompositionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.CompositionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.CompositionSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.stageArn = try reader["stageArn"].readIfPresent()
        value.destinations = try reader["destinations"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.DestinationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["state"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about a Composition.
    public struct CompositionSummary {
        /// ARN of the Composition resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Array of Destination objects.
        /// This member is required.
        public var destinations: [IVSRealTimeClientTypes.DestinationSummary]?
        /// UTC time of the Composition end. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var endTime: ClientRuntime.Date?
        /// ARN of the attached stage.
        /// This member is required.
        public var stageArn: Swift.String?
        /// UTC time of the Composition start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// State of the Composition resource.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.CompositionState?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            destinations: [IVSRealTimeClientTypes.DestinationSummary]? = nil,
            endTime: ClientRuntime.Date? = nil,
            stageArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IVSRealTimeClientTypes.CompositionState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.destinations = destinations
            self.endTime = endTime
            self.stageArn = stageArn
            self.startTime = startTime
            self.state = state
            self.tags = tags
        }
    }

}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

///
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Updating or deleting a resource can cause an inconsistent state.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

extension CreateEncoderConfigurationInput {

    static func urlPathProvider(_ value: CreateEncoderConfigurationInput) -> Swift.String? {
        return "/CreateEncoderConfiguration"
    }
}

extension CreateEncoderConfigurationInput {

    static func write(value: CreateEncoderConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["video"].write(value.video, with: IVSRealTimeClientTypes.Video.write(value:to:))
    }
}

public struct CreateEncoderConfigurationInput {
    /// Optional name to identify the resource.
    public var name: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?
    /// Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps.
    public var video: IVSRealTimeClientTypes.Video?

    public init(
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        video: IVSRealTimeClientTypes.Video? = nil
    )
    {
        self.name = name
        self.tags = tags
        self.video = video
    }
}

extension CreateEncoderConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateEncoderConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEncoderConfigurationOutput()
        value.encoderConfiguration = try reader["encoderConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.EncoderConfiguration.read(from:))
        return value
    }
}

public struct CreateEncoderConfigurationOutput {
    /// The EncoderConfiguration that was created.
    public var encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration?

    public init(
        encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration? = nil
    )
    {
        self.encoderConfiguration = encoderConfiguration
    }
}

enum CreateEncoderConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateParticipantTokenInput {

    static func urlPathProvider(_ value: CreateParticipantTokenInput) -> Swift.String? {
        return "/CreateParticipantToken"
    }
}

extension CreateParticipantTokenInput {

    static func write(value: CreateParticipantTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: IVSRealTimeClientTypes.ParticipantTokenCapability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["duration"].write(value.duration)
        try writer["stageArn"].write(value.stageArn)
        try writer["userId"].write(value.userId)
    }
}

public struct CreateParticipantTokenInput {
    /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    public var attributes: [Swift.String:Swift.String]?
    /// Set of capabilities that the user is allowed to perform in the stage. Default: PUBLISH, SUBSCRIBE.
    public var capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
    /// Duration (in minutes), after which the token expires. Default: 720 (12 hours).
    public var duration: Swift.Int?
    /// ARN of the stage to which this token is scoped.
    /// This member is required.
    public var stageArn: Swift.String?
    /// Name that can be specified to help identify the token. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    public var userId: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil,
        duration: Swift.Int? = nil,
        stageArn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.capabilities = capabilities
        self.duration = duration
        self.stageArn = stageArn
        self.userId = userId
    }
}

extension CreateParticipantTokenOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateParticipantTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateParticipantTokenOutput()
        value.participantToken = try reader["participantToken"].readIfPresent(with: IVSRealTimeClientTypes.ParticipantToken.read(from:))
        return value
    }
}

public struct CreateParticipantTokenOutput {
    /// The participant token that was created.
    public var participantToken: IVSRealTimeClientTypes.ParticipantToken?

    public init(
        participantToken: IVSRealTimeClientTypes.ParticipantToken? = nil
    )
    {
        self.participantToken = participantToken
    }
}

enum CreateParticipantTokenOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateStageInput {

    static func urlPathProvider(_ value: CreateStageInput) -> Swift.String? {
        return "/CreateStage"
    }
}

extension CreateStageInput {

    static func write(value: CreateStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["participantTokenConfigurations"].writeList(value.participantTokenConfigurations, memberWritingClosure: IVSRealTimeClientTypes.ParticipantTokenConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateStageInput {
    /// Optional name that can be specified for the stage being created.
    public var name: Swift.String?
    /// Array of participant token configuration objects to attach to the new stage.
    public var participantTokenConfigurations: [IVSRealTimeClientTypes.ParticipantTokenConfiguration]?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init(
        name: Swift.String? = nil,
        participantTokenConfigurations: [IVSRealTimeClientTypes.ParticipantTokenConfiguration]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.participantTokenConfigurations = participantTokenConfigurations
        self.tags = tags
    }
}

extension CreateStageOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStageOutput()
        value.participantTokens = try reader["participantTokens"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.ParticipantToken.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.stage = try reader["stage"].readIfPresent(with: IVSRealTimeClientTypes.Stage.read(from:))
        return value
    }
}

public struct CreateStageOutput {
    /// Participant tokens attached to the stage. These correspond to the participants in the request.
    public var participantTokens: [IVSRealTimeClientTypes.ParticipantToken]?
    /// The stage that was created.
    public var stage: IVSRealTimeClientTypes.Stage?

    public init(
        participantTokens: [IVSRealTimeClientTypes.ParticipantToken]? = nil,
        stage: IVSRealTimeClientTypes.Stage? = nil
    )
    {
        self.participantTokens = participantTokens
        self.stage = stage
    }
}

enum CreateStageOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateStorageConfigurationInput {

    static func urlPathProvider(_ value: CreateStorageConfigurationInput) -> Swift.String? {
        return "/CreateStorageConfiguration"
    }
}

extension CreateStorageConfigurationInput {

    static func write(value: CreateStorageConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["s3"].write(value.s3, with: IVSRealTimeClientTypes.S3StorageConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateStorageConfigurationInput {
    /// Storage configuration name. The value does not need to be unique.
    public var name: Swift.String?
    /// A complex type that contains a storage configuration for where recorded video will be stored.
    /// This member is required.
    public var s3: IVSRealTimeClientTypes.S3StorageConfiguration?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init(
        name: Swift.String? = nil,
        s3: IVSRealTimeClientTypes.S3StorageConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.s3 = s3
        self.tags = tags
    }
}

extension CreateStorageConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateStorageConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStorageConfigurationOutput()
        value.storageConfiguration = try reader["storageConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.StorageConfiguration.read(from:))
        return value
    }
}

public struct CreateStorageConfigurationOutput {
    /// The StorageConfiguration that was created.
    public var storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration?

    public init(
        storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration? = nil
    )
    {
        self.storageConfiguration = storageConfiguration
    }
}

enum CreateStorageConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteEncoderConfigurationInput {

    static func urlPathProvider(_ value: DeleteEncoderConfigurationInput) -> Swift.String? {
        return "/DeleteEncoderConfiguration"
    }
}

extension DeleteEncoderConfigurationInput {

    static func write(value: DeleteEncoderConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

public struct DeleteEncoderConfigurationInput {
    /// ARN of the EncoderConfiguration.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DeleteEncoderConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteEncoderConfigurationOutput {
        return DeleteEncoderConfigurationOutput()
    }
}

public struct DeleteEncoderConfigurationOutput {

    public init() { }
}

enum DeleteEncoderConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteStageInput {

    static func urlPathProvider(_ value: DeleteStageInput) -> Swift.String? {
        return "/DeleteStage"
    }
}

extension DeleteStageInput {

    static func write(value: DeleteStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

public struct DeleteStageInput {
    /// ARN of the stage to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DeleteStageOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteStageOutput {
        return DeleteStageOutput()
    }
}

public struct DeleteStageOutput {

    public init() { }
}

enum DeleteStageOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteStorageConfigurationInput {

    static func urlPathProvider(_ value: DeleteStorageConfigurationInput) -> Swift.String? {
        return "/DeleteStorageConfiguration"
    }
}

extension DeleteStorageConfigurationInput {

    static func write(value: DeleteStorageConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

public struct DeleteStorageConfigurationInput {
    /// ARN of the storage configuration to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DeleteStorageConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteStorageConfigurationOutput {
        return DeleteStorageConfigurationOutput()
    }
}

public struct DeleteStorageConfigurationOutput {

    public init() { }
}

enum DeleteStorageConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension IVSRealTimeClientTypes.Destination {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.Destination()
        value.id = try reader["id"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .dateTime)
        value.configuration = try reader["configuration"].readIfPresent(with: IVSRealTimeClientTypes.DestinationConfiguration.read(from:))
        value.detail = try reader["detail"].readIfPresent(with: IVSRealTimeClientTypes.DestinationDetail.read(from:))
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying the status of a Destination.
    public struct Destination {
        /// Configuration used to create this destination.
        /// This member is required.
        public var configuration: IVSRealTimeClientTypes.DestinationConfiguration?
        /// Optional details regarding the status of the destination.
        public var detail: IVSRealTimeClientTypes.DestinationDetail?
        /// UTC time of the destination end. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var endTime: ClientRuntime.Date?
        /// Unique identifier for this destination, assigned by IVS.
        /// This member is required.
        public var id: Swift.String?
        /// UTC time of the destination start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// State of the Composition Destination.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.DestinationState?

        public init(
            configuration: IVSRealTimeClientTypes.DestinationConfiguration? = nil,
            detail: IVSRealTimeClientTypes.DestinationDetail? = nil,
            endTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IVSRealTimeClientTypes.DestinationState? = nil
        )
        {
            self.configuration = configuration
            self.detail = detail
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.state = state
        }
    }

}

extension IVSRealTimeClientTypes.DestinationConfiguration {

    static func write(value: IVSRealTimeClientTypes.DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channel"].write(value.channel, with: IVSRealTimeClientTypes.ChannelDestinationConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["s3"].write(value.s3, with: IVSRealTimeClientTypes.S3DestinationConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.DestinationConfiguration()
        value.name = try reader["name"].readIfPresent()
        value.channel = try reader["channel"].readIfPresent(with: IVSRealTimeClientTypes.ChannelDestinationConfiguration.read(from:))
        value.s3 = try reader["s3"].readIfPresent(with: IVSRealTimeClientTypes.S3DestinationConfiguration.read(from:))
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Complex data type that defines destination-configuration objects.
    public struct DestinationConfiguration {
        /// An IVS channel to be used for broadcasting, for server-side composition. Either a channel or an s3 must be specified.
        public var channel: IVSRealTimeClientTypes.ChannelDestinationConfiguration?
        /// Name that can be specified to help identify the destination.
        public var name: Swift.String?
        /// An S3 storage configuration to be used for recording video data. Either a channel or an s3 must be specified.
        public var s3: IVSRealTimeClientTypes.S3DestinationConfiguration?

        public init(
            channel: IVSRealTimeClientTypes.ChannelDestinationConfiguration? = nil,
            name: Swift.String? = nil,
            s3: IVSRealTimeClientTypes.S3DestinationConfiguration? = nil
        )
        {
            self.channel = channel
            self.name = name
            self.s3 = s3
        }
    }

}

extension IVSRealTimeClientTypes.DestinationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.DestinationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.DestinationDetail()
        value.s3 = try reader["s3"].readIfPresent(with: IVSRealTimeClientTypes.S3Detail.read(from:))
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Complex data type that defines destination-detail objects.
    public struct DestinationDetail {
        /// An S3 detail object to return information about the S3 destination.
        public var s3: IVSRealTimeClientTypes.S3Detail?

        public init(
            s3: IVSRealTimeClientTypes.S3Detail? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension IVSRealTimeClientTypes {

    public enum DestinationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case failed
        case reconnecting
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationState] {
            return [
                .active,
                .failed,
                .reconnecting,
                .starting,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .reconnecting: return "RECONNECTING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes.DestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.DestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.DestinationSummary()
        value.id = try reader["id"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about a Destination.
    public struct DestinationSummary {
        /// UTC time of the destination end. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var endTime: ClientRuntime.Date?
        /// Unique identifier for this destination, assigned by IVS.
        /// This member is required.
        public var id: Swift.String?
        /// UTC time of the destination start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// State of the Composition Destination.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.DestinationState?

        public init(
            endTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IVSRealTimeClientTypes.DestinationState? = nil
        )
        {
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.state = state
        }
    }

}

extension DisconnectParticipantInput {

    static func urlPathProvider(_ value: DisconnectParticipantInput) -> Swift.String? {
        return "/DisconnectParticipant"
    }
}

extension DisconnectParticipantInput {

    static func write(value: DisconnectParticipantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["participantId"].write(value.participantId)
        try writer["reason"].write(value.reason)
        try writer["stageArn"].write(value.stageArn)
    }
}

public struct DisconnectParticipantInput {
    /// Identifier of the participant to be disconnected. This is assigned by IVS and returned by [CreateParticipantToken].
    /// This member is required.
    public var participantId: Swift.String?
    /// Description of why this participant is being disconnected.
    public var reason: Swift.String?
    /// ARN of the stage to which the participant is attached.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        participantId: Swift.String? = nil,
        reason: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.participantId = participantId
        self.reason = reason
        self.stageArn = stageArn
    }
}

extension DisconnectParticipantOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisconnectParticipantOutput {
        return DisconnectParticipantOutput()
    }
}

public struct DisconnectParticipantOutput {

    public init() { }
}

enum DisconnectParticipantOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension IVSRealTimeClientTypes.EncoderConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.EncoderConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.EncoderConfiguration()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.video = try reader["video"].readIfPresent(with: IVSRealTimeClientTypes.Video.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Settings for transcoding.
    public struct EncoderConfiguration {
        /// ARN of the EncoderConfiguration resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Optional name to identify the resource.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps
        public var video: IVSRealTimeClientTypes.Video?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            video: IVSRealTimeClientTypes.Video? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.tags = tags
            self.video = video
        }
    }

}

extension IVSRealTimeClientTypes.EncoderConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.EncoderConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.EncoderConfigurationSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about an EncoderConfiguration.
    public struct EncoderConfigurationSummary {
        /// ARN of the EncoderConfiguration resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Optional name to identify the resource.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }

}

extension IVSRealTimeClientTypes.Event {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.Event {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.Event()
        value.name = try reader["name"].readIfPresent()
        value.participantId = try reader["participantId"].readIfPresent()
        value.eventTime = try reader["eventTime"].readTimestampIfPresent(format: .dateTime)
        value.remoteParticipantId = try reader["remoteParticipantId"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// An occurrence during a stage session.
    public struct Event {
        /// If the event is an error event, the error code is provided to give insight into the specific error that occurred. If the event is not an error event, this field is null. INSUFFICIENT_CAPABILITIES indicates that the participant tried to take an action that the participants token is not allowed to do. For more information about participant capabilities, see the capabilities field in [CreateParticipantToken]. QUOTA_EXCEEDED indicates that the number of participants who want to publish/subscribe to a stage exceeds the quota; for more information, see [Service Quotas](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/service-quotas.html). PUBLISHER_NOT_FOUND indicates that the participant tried to subscribe to a publisher that doesnt exist.
        public var errorCode: IVSRealTimeClientTypes.EventErrorCode?
        /// ISO 8601 timestamp (returned as a string) for when the event occurred.
        public var eventTime: ClientRuntime.Date?
        /// The name of the event.
        public var name: IVSRealTimeClientTypes.EventName?
        /// Unique identifier for the participant who triggered the event. This is assigned by IVS.
        public var participantId: Swift.String?
        /// Unique identifier for the remote participant. For a subscribe event, this is the publisher. For a publish or join event, this is null. This is assigned by IVS.
        public var remoteParticipantId: Swift.String?

        public init(
            errorCode: IVSRealTimeClientTypes.EventErrorCode? = nil,
            eventTime: ClientRuntime.Date? = nil,
            name: IVSRealTimeClientTypes.EventName? = nil,
            participantId: Swift.String? = nil,
            remoteParticipantId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.eventTime = eventTime
            self.name = name
            self.participantId = participantId
            self.remoteParticipantId = remoteParticipantId
        }
    }

}

extension IVSRealTimeClientTypes {

    public enum EventErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case insufficientCapabilities
        case publisherNotFound
        case quotaExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [EventErrorCode] {
            return [
                .insufficientCapabilities,
                .publisherNotFound,
                .quotaExceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .insufficientCapabilities: return "INSUFFICIENT_CAPABILITIES"
            case .publisherNotFound: return "PUBLISHER_NOT_FOUND"
            case .quotaExceeded: return "QUOTA_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    public enum EventName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case joined
        case joinError
        case `left`
        case publishError
        case publishStarted
        case publishStopped
        case subscribeError
        case subscribeStarted
        case subscribeStopped
        case sdkUnknown(Swift.String)

        public static var allCases: [EventName] {
            return [
                .joined,
                .joinError,
                .left,
                .publishError,
                .publishStarted,
                .publishStopped,
                .subscribeError,
                .subscribeStarted,
                .subscribeStopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .joined: return "JOINED"
            case .joinError: return "JOIN_ERROR"
            case .left: return "LEFT"
            case .publishError: return "PUBLISH_ERROR"
            case .publishStarted: return "PUBLISH_STARTED"
            case .publishStopped: return "PUBLISH_STOPPED"
            case .subscribeError: return "SUBSCRIBE_ERROR"
            case .subscribeStarted: return "SUBSCRIBE_STARTED"
            case .subscribeStopped: return "SUBSCRIBE_STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GetCompositionInput {

    static func urlPathProvider(_ value: GetCompositionInput) -> Swift.String? {
        return "/GetComposition"
    }
}

extension GetCompositionInput {

    static func write(value: GetCompositionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

public struct GetCompositionInput {
    /// ARN of the Composition resource.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension GetCompositionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetCompositionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCompositionOutput()
        value.composition = try reader["composition"].readIfPresent(with: IVSRealTimeClientTypes.Composition.read(from:))
        return value
    }
}

public struct GetCompositionOutput {
    /// The Composition that was returned.
    public var composition: IVSRealTimeClientTypes.Composition?

    public init(
        composition: IVSRealTimeClientTypes.Composition? = nil
    )
    {
        self.composition = composition
    }
}

enum GetCompositionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetEncoderConfigurationInput {

    static func urlPathProvider(_ value: GetEncoderConfigurationInput) -> Swift.String? {
        return "/GetEncoderConfiguration"
    }
}

extension GetEncoderConfigurationInput {

    static func write(value: GetEncoderConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

public struct GetEncoderConfigurationInput {
    /// ARN of the EncoderConfiguration resource.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension GetEncoderConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetEncoderConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEncoderConfigurationOutput()
        value.encoderConfiguration = try reader["encoderConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.EncoderConfiguration.read(from:))
        return value
    }
}

public struct GetEncoderConfigurationOutput {
    /// The EncoderConfiguration that was returned.
    public var encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration?

    public init(
        encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration? = nil
    )
    {
        self.encoderConfiguration = encoderConfiguration
    }
}

enum GetEncoderConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetParticipantInput {

    static func urlPathProvider(_ value: GetParticipantInput) -> Swift.String? {
        return "/GetParticipant"
    }
}

extension GetParticipantInput {

    static func write(value: GetParticipantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["participantId"].write(value.participantId)
        try writer["sessionId"].write(value.sessionId)
        try writer["stageArn"].write(value.stageArn)
    }
}

public struct GetParticipantInput {
    /// Unique identifier for the participant. This is assigned by IVS and returned by [CreateParticipantToken].
    /// This member is required.
    public var participantId: Swift.String?
    /// ID of a session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        participantId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.participantId = participantId
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

extension GetParticipantOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetParticipantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetParticipantOutput()
        value.participant = try reader["participant"].readIfPresent(with: IVSRealTimeClientTypes.Participant.read(from:))
        return value
    }
}

public struct GetParticipantOutput {
    /// The participant that is returned.
    public var participant: IVSRealTimeClientTypes.Participant?

    public init(
        participant: IVSRealTimeClientTypes.Participant? = nil
    )
    {
        self.participant = participant
    }
}

enum GetParticipantOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetStageInput {

    static func urlPathProvider(_ value: GetStageInput) -> Swift.String? {
        return "/GetStage"
    }
}

extension GetStageInput {

    static func write(value: GetStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

public struct GetStageInput {
    /// ARN of the stage for which the information is to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension GetStageOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStageOutput()
        value.stage = try reader["stage"].readIfPresent(with: IVSRealTimeClientTypes.Stage.read(from:))
        return value
    }
}

public struct GetStageOutput {
    /// The stage that is returned.
    public var stage: IVSRealTimeClientTypes.Stage?

    public init(
        stage: IVSRealTimeClientTypes.Stage? = nil
    )
    {
        self.stage = stage
    }
}

enum GetStageOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetStageSessionInput {

    static func urlPathProvider(_ value: GetStageSessionInput) -> Swift.String? {
        return "/GetStageSession"
    }
}

extension GetStageSessionInput {

    static func write(value: GetStageSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sessionId"].write(value.sessionId)
        try writer["stageArn"].write(value.stageArn)
    }
}

public struct GetStageSessionInput {
    /// ID of a session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// ARN of the stage for which the information is to be retrieved.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

extension GetStageSessionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetStageSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStageSessionOutput()
        value.stageSession = try reader["stageSession"].readIfPresent(with: IVSRealTimeClientTypes.StageSession.read(from:))
        return value
    }
}

public struct GetStageSessionOutput {
    /// The stage session that is returned.
    public var stageSession: IVSRealTimeClientTypes.StageSession?

    public init(
        stageSession: IVSRealTimeClientTypes.StageSession? = nil
    )
    {
        self.stageSession = stageSession
    }
}

enum GetStageSessionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetStorageConfigurationInput {

    static func urlPathProvider(_ value: GetStorageConfigurationInput) -> Swift.String? {
        return "/GetStorageConfiguration"
    }
}

extension GetStorageConfigurationInput {

    static func write(value: GetStorageConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

public struct GetStorageConfigurationInput {
    /// ARN of the storage configuration to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension GetStorageConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetStorageConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStorageConfigurationOutput()
        value.storageConfiguration = try reader["storageConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.StorageConfiguration.read(from:))
        return value
    }
}

public struct GetStorageConfigurationOutput {
    /// The StorageConfiguration that was returned.
    public var storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration?

    public init(
        storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration? = nil
    )
    {
        self.storageConfiguration = storageConfiguration
    }
}

enum GetStorageConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension IVSRealTimeClientTypes.GridConfiguration {

    static func write(value: IVSRealTimeClientTypes.GridConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["featuredParticipantAttribute"].write(value.featuredParticipantAttribute)
        try writer["gridGap"].write(value.gridGap)
        try writer["omitStoppedVideo"].write(value.omitStoppedVideo)
        try writer["videoAspectRatio"].write(value.videoAspectRatio)
        try writer["videoFillMode"].write(value.videoFillMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.GridConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.GridConfiguration()
        value.featuredParticipantAttribute = try reader["featuredParticipantAttribute"].readIfPresent()
        value.omitStoppedVideo = try reader["omitStoppedVideo"].readIfPresent() ?? false
        value.videoAspectRatio = try reader["videoAspectRatio"].readIfPresent()
        value.videoFillMode = try reader["videoFillMode"].readIfPresent()
        value.gridGap = try reader["gridGap"].readIfPresent() ?? 0
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Configuration information specific to Grid layout, for server-side composition. See "Layouts" in [Server-Side Composition](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/server-side-composition.html).
    public struct GridConfiguration {
        /// This attribute name identifies the featured slot. A participant with this attribute set to "true" (as a string value) in [ParticipantTokenConfiguration] is placed in the featured slot.
        public var featuredParticipantAttribute: Swift.String?
        /// Specifies the spacing between participant tiles in pixels. Default: 2.
        public var gridGap: Swift.Int
        /// Determines whether to omit participants with stopped video in the composition. Default: false.
        public var omitStoppedVideo: Swift.Bool
        /// Sets the non-featured participant display mode. Default: VIDEO.
        public var videoAspectRatio: IVSRealTimeClientTypes.VideoAspectRatio?
        /// Defines how video fits within the participant tile. When not set, videoFillMode defaults to COVER fill mode for participants in the grid and to CONTAIN fill mode for featured participants.
        public var videoFillMode: IVSRealTimeClientTypes.VideoFillMode?

        public init(
            featuredParticipantAttribute: Swift.String? = nil,
            gridGap: Swift.Int = 0,
            omitStoppedVideo: Swift.Bool = false,
            videoAspectRatio: IVSRealTimeClientTypes.VideoAspectRatio? = nil,
            videoFillMode: IVSRealTimeClientTypes.VideoFillMode? = nil
        )
        {
            self.featuredParticipantAttribute = featuredParticipantAttribute
            self.gridGap = gridGap
            self.omitStoppedVideo = omitStoppedVideo
            self.videoAspectRatio = videoAspectRatio
            self.videoFillMode = videoFillMode
        }
    }

}

public enum IVSRealTimeClientTypes {}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

///
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Unexpected error during processing of request.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

extension IVSRealTimeClientTypes.LayoutConfiguration {

    static func write(value: IVSRealTimeClientTypes.LayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["grid"].write(value.grid, with: IVSRealTimeClientTypes.GridConfiguration.write(value:to:))
        try writer["pip"].write(value.pip, with: IVSRealTimeClientTypes.PipConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.LayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.LayoutConfiguration()
        value.grid = try reader["grid"].readIfPresent(with: IVSRealTimeClientTypes.GridConfiguration.read(from:))
        value.pip = try reader["pip"].readIfPresent(with: IVSRealTimeClientTypes.PipConfiguration.read(from:))
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Configuration information of supported layouts for server-side composition.
    public struct LayoutConfiguration {
        /// Configuration related to grid layout. Default: Grid layout.
        public var grid: IVSRealTimeClientTypes.GridConfiguration?
        /// Configuration related to PiP layout.
        public var pip: IVSRealTimeClientTypes.PipConfiguration?

        public init(
            grid: IVSRealTimeClientTypes.GridConfiguration? = nil,
            pip: IVSRealTimeClientTypes.PipConfiguration? = nil
        )
        {
            self.grid = grid
            self.pip = pip
        }
    }

}

extension ListCompositionsInput {

    static func urlPathProvider(_ value: ListCompositionsInput) -> Swift.String? {
        return "/ListCompositions"
    }
}

extension ListCompositionsInput {

    static func write(value: ListCompositionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterByEncoderConfigurationArn"].write(value.filterByEncoderConfigurationArn)
        try writer["filterByStageArn"].write(value.filterByStageArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListCompositionsInput {
    /// Filters the Composition list to match the specified EncoderConfiguration attached to at least one of its output.
    public var filterByEncoderConfigurationArn: Swift.String?
    /// Filters the Composition list to match the specified Stage ARN.
    public var filterByStageArn: Swift.String?
    /// Maximum number of results to return. Default: 100.
    public var maxResults: Swift.Int?
    /// The first Composition to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        filterByEncoderConfigurationArn: Swift.String? = nil,
        filterByStageArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterByEncoderConfigurationArn = filterByEncoderConfigurationArn
        self.filterByStageArn = filterByStageArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListCompositionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListCompositionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCompositionsOutput()
        value.compositions = try reader["compositions"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.CompositionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListCompositionsOutput {
    /// List of the matching Compositions (summary information only).
    /// This member is required.
    public var compositions: [IVSRealTimeClientTypes.CompositionSummary]?
    /// If there are more compositions than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        compositions: [IVSRealTimeClientTypes.CompositionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.compositions = compositions
        self.nextToken = nextToken
    }
}

enum ListCompositionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListEncoderConfigurationsInput {

    static func urlPathProvider(_ value: ListEncoderConfigurationsInput) -> Swift.String? {
        return "/ListEncoderConfigurations"
    }
}

extension ListEncoderConfigurationsInput {

    static func write(value: ListEncoderConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListEncoderConfigurationsInput {
    /// Maximum number of results to return. Default: 100.
    public var maxResults: Swift.Int?
    /// The first encoder configuration to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListEncoderConfigurationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListEncoderConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEncoderConfigurationsOutput()
        value.encoderConfigurations = try reader["encoderConfigurations"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.EncoderConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListEncoderConfigurationsOutput {
    /// List of the matching EncoderConfigurations (summary information only).
    /// This member is required.
    public var encoderConfigurations: [IVSRealTimeClientTypes.EncoderConfigurationSummary]?
    /// If there are more encoder configurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        encoderConfigurations: [IVSRealTimeClientTypes.EncoderConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.encoderConfigurations = encoderConfigurations
        self.nextToken = nextToken
    }
}

enum ListEncoderConfigurationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListParticipantEventsInput {

    static func urlPathProvider(_ value: ListParticipantEventsInput) -> Swift.String? {
        return "/ListParticipantEvents"
    }
}

extension ListParticipantEventsInput {

    static func write(value: ListParticipantEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["participantId"].write(value.participantId)
        try writer["sessionId"].write(value.sessionId)
        try writer["stageArn"].write(value.stageArn)
    }
}

public struct ListParticipantEventsInput {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first participant event to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?
    /// Unique identifier for this participant. This is assigned by IVS and returned by [CreateParticipantToken].
    /// This member is required.
    public var participantId: Swift.String?
    /// ID of a session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        participantId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.participantId = participantId
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

extension ListParticipantEventsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListParticipantEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListParticipantEventsOutput()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListParticipantEventsOutput {
    /// List of the matching events.
    /// This member is required.
    public var events: [IVSRealTimeClientTypes.Event]?
    /// If there are more events than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        events: [IVSRealTimeClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

enum ListParticipantEventsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListParticipantsInput {

    static func urlPathProvider(_ value: ListParticipantsInput) -> Swift.String? {
        return "/ListParticipants"
    }
}

extension ListParticipantsInput {

    static func write(value: ListParticipantsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterByPublished"].write(value.filterByPublished)
        try writer["filterByState"].write(value.filterByState)
        try writer["filterByUserId"].write(value.filterByUserId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sessionId"].write(value.sessionId)
        try writer["stageArn"].write(value.stageArn)
    }
}

public struct ListParticipantsInput {
    /// Filters the response list to only show participants who published during the stage session. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request.
    public var filterByPublished: Swift.Bool?
    /// Filters the response list to only show participants in the specified state. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request.
    public var filterByState: IVSRealTimeClientTypes.ParticipantState?
    /// Filters the response list to match the specified user ID. Only one of filterByUserId, filterByPublished, or filterByState can be provided per request. A userId is a customer-assigned name to help identify the token; this can be used to link a participant to a user in the customers own systems.
    public var filterByUserId: Swift.String?
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first participant to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?
    /// ID of the session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        filterByPublished: Swift.Bool? = nil,
        filterByState: IVSRealTimeClientTypes.ParticipantState? = nil,
        filterByUserId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.filterByPublished = filterByPublished
        self.filterByState = filterByState
        self.filterByUserId = filterByUserId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

extension ListParticipantsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListParticipantsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListParticipantsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.participants = try reader["participants"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.ParticipantSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListParticipantsOutput {
    /// If there are more participants than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching participants (summary information only).
    /// This member is required.
    public var participants: [IVSRealTimeClientTypes.ParticipantSummary]?

    public init(
        nextToken: Swift.String? = nil,
        participants: [IVSRealTimeClientTypes.ParticipantSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.participants = participants
    }
}

enum ListParticipantsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListStageSessionsInput {

    static func urlPathProvider(_ value: ListStageSessionsInput) -> Swift.String? {
        return "/ListStageSessions"
    }
}

extension ListStageSessionsInput {

    static func write(value: ListStageSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["stageArn"].write(value.stageArn)
    }
}

public struct ListStageSessionsInput {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first stage session to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stageArn = stageArn
    }
}

extension ListStageSessionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListStageSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStageSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.stageSessions = try reader["stageSessions"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.StageSessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListStageSessionsOutput {
    /// If there are more stage sessions than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of matching stage sessions.
    /// This member is required.
    public var stageSessions: [IVSRealTimeClientTypes.StageSessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        stageSessions: [IVSRealTimeClientTypes.StageSessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stageSessions = stageSessions
    }
}

enum ListStageSessionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListStagesInput {

    static func urlPathProvider(_ value: ListStagesInput) -> Swift.String? {
        return "/ListStages"
    }
}

extension ListStagesInput {

    static func write(value: ListStagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListStagesInput {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first stage to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListStagesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListStagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStagesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.stages = try reader["stages"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.StageSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListStagesOutput {
    /// If there are more stages than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching stages (summary information only).
    /// This member is required.
    public var stages: [IVSRealTimeClientTypes.StageSummary]?

    public init(
        nextToken: Swift.String? = nil,
        stages: [IVSRealTimeClientTypes.StageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stages = stages
    }
}

enum ListStagesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListStorageConfigurationsInput {

    static func urlPathProvider(_ value: ListStorageConfigurationsInput) -> Swift.String? {
        return "/ListStorageConfigurations"
    }
}

extension ListStorageConfigurationsInput {

    static func write(value: ListStorageConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListStorageConfigurationsInput {
    /// Maximum number of storage configurations to return. Default: your service quota or 100, whichever is smaller.
    public var maxResults: Swift.Int?
    /// The first storage configuration to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListStorageConfigurationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListStorageConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStorageConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.storageConfigurations = try reader["storageConfigurations"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.StorageConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListStorageConfigurationsOutput {
    /// If there are more storage configurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching storage configurations.
    /// This member is required.
    public var storageConfigurations: [IVSRealTimeClientTypes.StorageConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        storageConfigurations: [IVSRealTimeClientTypes.StorageConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageConfigurations = storageConfigurations
    }
}

enum ListStorageConfigurationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension IVSRealTimeClientTypes.Participant {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.Participant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.Participant()
        value.participantId = try reader["participantId"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.firstJoinTime = try reader["firstJoinTime"].readTimestampIfPresent(format: .dateTime)
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.published = try reader["published"].readIfPresent() ?? false
        value.ispName = try reader["ispName"].readIfPresent()
        value.osName = try reader["osName"].readIfPresent()
        value.osVersion = try reader["osVersion"].readIfPresent()
        value.browserName = try reader["browserName"].readIfPresent()
        value.browserVersion = try reader["browserVersion"].readIfPresent()
        value.sdkVersion = try reader["sdkVersion"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Object describing a participant that has joined a stage.
    public struct Participant {
        /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String:Swift.String]?
        /// The participants browser.
        public var browserName: Swift.String?
        /// The participants browser version.
        public var browserVersion: Swift.String?
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        public var firstJoinTime: ClientRuntime.Date?
        /// The participants Internet Service Provider.
        public var ispName: Swift.String?
        /// The participants operating system.
        public var osName: Swift.String?
        /// The participants operating system version.
        public var osVersion: Swift.String?
        /// Unique identifier for this participant, assigned by IVS.
        public var participantId: Swift.String?
        /// Whether the participant ever published to the stage session.
        public var published: Swift.Bool
        /// The participants SDK version.
        public var sdkVersion: Swift.String?
        /// Whether the participant is connected to or disconnected from the stage.
        public var state: IVSRealTimeClientTypes.ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customers own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            browserName: Swift.String? = nil,
            browserVersion: Swift.String? = nil,
            firstJoinTime: ClientRuntime.Date? = nil,
            ispName: Swift.String? = nil,
            osName: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            participantId: Swift.String? = nil,
            published: Swift.Bool = false,
            sdkVersion: Swift.String? = nil,
            state: IVSRealTimeClientTypes.ParticipantState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.browserName = browserName
            self.browserVersion = browserVersion
            self.firstJoinTime = firstJoinTime
            self.ispName = ispName
            self.osName = osName
            self.osVersion = osVersion
            self.participantId = participantId
            self.published = published
            self.sdkVersion = sdkVersion
            self.state = state
            self.userId = userId
        }
    }

}

extension IVSRealTimeClientTypes {

    public enum ParticipantState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantState] {
            return [
                .connected,
                .disconnected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes.ParticipantSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.ParticipantSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.ParticipantSummary()
        value.participantId = try reader["participantId"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.firstJoinTime = try reader["firstJoinTime"].readTimestampIfPresent(format: .dateTime)
        value.published = try reader["published"].readIfPresent() ?? false
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Summary object describing a participant that has joined a stage.
    public struct ParticipantSummary {
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        public var firstJoinTime: ClientRuntime.Date?
        /// Unique identifier for this participant, assigned by IVS.
        public var participantId: Swift.String?
        /// Whether the participant ever published to the stage session.
        public var published: Swift.Bool
        /// Whether the participant is connected to or disconnected from the stage.
        public var state: IVSRealTimeClientTypes.ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customers own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            firstJoinTime: ClientRuntime.Date? = nil,
            participantId: Swift.String? = nil,
            published: Swift.Bool = false,
            state: IVSRealTimeClientTypes.ParticipantState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.firstJoinTime = firstJoinTime
            self.participantId = participantId
            self.published = published
            self.state = state
            self.userId = userId
        }
    }

}

extension IVSRealTimeClientTypes.ParticipantToken: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParticipantToken(attributes: \(Swift.String(describing: attributes)), capabilities: \(Swift.String(describing: capabilities)), duration: \(Swift.String(describing: duration)), expirationTime: \(Swift.String(describing: expirationTime)), participantId: \(Swift.String(describing: participantId)), userId: \(Swift.String(describing: userId)), token: \"CONTENT_REDACTED\")"}
}

extension IVSRealTimeClientTypes.ParticipantToken {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.ParticipantToken {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.ParticipantToken()
        value.participantId = try reader["participantId"].readIfPresent()
        value.token = try reader["token"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.duration = try reader["duration"].readIfPresent()
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.ParticipantTokenCapability.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.expirationTime = try reader["expirationTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying a participant token in a stage. Important: Treat tokens as opaque; i.e., do not build functionality based on token contents. The format of tokens could change in the future.
    public struct ParticipantToken {
        /// Application-provided attributes to encode into the token and attach to a stage. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String:Swift.String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public var capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
        /// Duration (in minutes), after which the participant token expires. Default: 720 (12 hours).
        public var duration: Swift.Int?
        /// ISO 8601 timestamp (returned as a string) for when this token expires.
        public var expirationTime: ClientRuntime.Date?
        /// Unique identifier for this participant token, assigned by IVS.
        public var participantId: Swift.String?
        /// The issued client token, encrypted.
        public var token: Swift.String?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customers own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil,
            duration: Swift.Int? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            participantId: Swift.String? = nil,
            token: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.expirationTime = expirationTime
            self.participantId = participantId
            self.token = token
            self.userId = userId
        }
    }

}

extension IVSRealTimeClientTypes {

    public enum ParticipantTokenCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case publish
        case subscribe
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantTokenCapability] {
            return [
                .publish,
                .subscribe
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .publish: return "PUBLISH"
            case .subscribe: return "SUBSCRIBE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes.ParticipantTokenConfiguration {

    static func write(value: IVSRealTimeClientTypes.ParticipantTokenConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: IVSRealTimeClientTypes.ParticipantTokenCapability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["duration"].write(value.duration)
        try writer["userId"].write(value.userId)
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying a participant token configuration in a stage.
    public struct ParticipantTokenConfiguration {
        /// Application-provided attributes to encode into the corresponding participant token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String:Swift.String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public var capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
        /// Duration (in minutes), after which the corresponding participant token expires. Default: 720 (12 hours).
        public var duration: Swift.Int?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customers own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil,
            duration: Swift.Int? = nil,
            userId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.userId = userId
        }
    }

}

extension PendingVerification {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PendingVerification {
        let reader = baseError.errorBodyReader
        var value = PendingVerification()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

///
public struct PendingVerification: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Your account is pending verification.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PendingVerification" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

extension IVSRealTimeClientTypes {

    public enum PipBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [PipBehavior] {
            return [
                .dynamic,
                .static
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dynamic: return "DYNAMIC"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes.PipConfiguration {

    static func write(value: IVSRealTimeClientTypes.PipConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["featuredParticipantAttribute"].write(value.featuredParticipantAttribute)
        try writer["gridGap"].write(value.gridGap)
        try writer["omitStoppedVideo"].write(value.omitStoppedVideo)
        try writer["pipBehavior"].write(value.pipBehavior)
        try writer["pipHeight"].write(value.pipHeight)
        try writer["pipOffset"].write(value.pipOffset)
        try writer["pipParticipantAttribute"].write(value.pipParticipantAttribute)
        try writer["pipPosition"].write(value.pipPosition)
        try writer["pipWidth"].write(value.pipWidth)
        try writer["videoFillMode"].write(value.videoFillMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.PipConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.PipConfiguration()
        value.featuredParticipantAttribute = try reader["featuredParticipantAttribute"].readIfPresent()
        value.omitStoppedVideo = try reader["omitStoppedVideo"].readIfPresent() ?? false
        value.videoFillMode = try reader["videoFillMode"].readIfPresent()
        value.gridGap = try reader["gridGap"].readIfPresent() ?? 0
        value.pipParticipantAttribute = try reader["pipParticipantAttribute"].readIfPresent()
        value.pipBehavior = try reader["pipBehavior"].readIfPresent()
        value.pipOffset = try reader["pipOffset"].readIfPresent() ?? 0
        value.pipPosition = try reader["pipPosition"].readIfPresent()
        value.pipWidth = try reader["pipWidth"].readIfPresent()
        value.pipHeight = try reader["pipHeight"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Configuration information specific to Picture-in-Picture (PiP) layout, for [server-side composition](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/server-side-composition.html).
    public struct PipConfiguration {
        /// This attribute name identifies the featured slot. A participant with this attribute set to "true" (as a string value) in [ParticipantTokenConfiguration] is placed in the featured slot.
        public var featuredParticipantAttribute: Swift.String?
        /// Specifies the spacing between participant tiles in pixels. Default: 0.
        public var gridGap: Swift.Int
        /// Determines whether to omit participants with stopped video in the composition. Default: false.
        public var omitStoppedVideo: Swift.Bool
        /// Defines PiP behavior when all participants have left. Default: STATIC.
        public var pipBehavior: IVSRealTimeClientTypes.PipBehavior?
        /// Specifies the height of the PiP window in pixels. When this is not set explicitly, pipHeights value will be based on the size of the composition and the aspect ratio of the participants video.
        public var pipHeight: Swift.Int?
        /// Sets the PiP windows offset position in pixels from the closest edges determined by PipPosition. Default: 0.
        public var pipOffset: Swift.Int
        /// Identifies the PiP slot. A participant with this attribute set to "true" (as a string value) in [ParticipantTokenConfiguration] is placed in the PiP slot.
        public var pipParticipantAttribute: Swift.String?
        /// Determines the corner position of the PiP window. Default: BOTTOM_RIGHT.
        public var pipPosition: IVSRealTimeClientTypes.PipPosition?
        /// Specifies the width of the PiP window in pixels. When this is not set explicitly, pipWidths value will be based on the size of the composition and the aspect ratio of the participants video.
        public var pipWidth: Swift.Int?
        /// Defines how video fits within the participant tile. Default: COVER.
        public var videoFillMode: IVSRealTimeClientTypes.VideoFillMode?

        public init(
            featuredParticipantAttribute: Swift.String? = nil,
            gridGap: Swift.Int = 0,
            omitStoppedVideo: Swift.Bool = false,
            pipBehavior: IVSRealTimeClientTypes.PipBehavior? = nil,
            pipHeight: Swift.Int? = nil,
            pipOffset: Swift.Int = 0,
            pipParticipantAttribute: Swift.String? = nil,
            pipPosition: IVSRealTimeClientTypes.PipPosition? = nil,
            pipWidth: Swift.Int? = nil,
            videoFillMode: IVSRealTimeClientTypes.VideoFillMode? = nil
        )
        {
            self.featuredParticipantAttribute = featuredParticipantAttribute
            self.gridGap = gridGap
            self.omitStoppedVideo = omitStoppedVideo
            self.pipBehavior = pipBehavior
            self.pipHeight = pipHeight
            self.pipOffset = pipOffset
            self.pipParticipantAttribute = pipParticipantAttribute
            self.pipPosition = pipPosition
            self.pipWidth = pipWidth
            self.videoFillMode = videoFillMode
        }
    }

}

extension IVSRealTimeClientTypes {

    public enum PipPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bottomLeft
        case bottomRight
        case topLeft
        case topRight
        case sdkUnknown(Swift.String)

        public static var allCases: [PipPosition] {
            return [
                .bottomLeft,
                .bottomRight,
                .topLeft,
                .topRight
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bottomLeft: return "BOTTOM_LEFT"
            case .bottomRight: return "BOTTOM_RIGHT"
            case .topLeft: return "TOP_LEFT"
            case .topRight: return "TOP_RIGHT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes.RecordingConfiguration {

    static func write(value: IVSRealTimeClientTypes.RecordingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["format"].write(value.format)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.RecordingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.RecordingConfiguration()
        value.format = try reader["format"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// An object representing a configuration to record a stage stream.
    public struct RecordingConfiguration {
        /// The recording format for storing a recording in Amazon S3.
        public var format: IVSRealTimeClientTypes.RecordingConfigurationFormat?

        public init(
            format: IVSRealTimeClientTypes.RecordingConfigurationFormat? = nil
        )
        {
            self.format = format
        }
    }

}

extension IVSRealTimeClientTypes {

    public enum RecordingConfigurationFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hls
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingConfigurationFormat] {
            return [
                .hls
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hls: return "HLS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request references a resource which does not exist.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

extension IVSRealTimeClientTypes.S3DestinationConfiguration {

    static func write(value: IVSRealTimeClientTypes.S3DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encoderConfigurationArns"].writeList(value.encoderConfigurationArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["recordingConfiguration"].write(value.recordingConfiguration, with: IVSRealTimeClientTypes.RecordingConfiguration.write(value:to:))
        try writer["storageConfigurationArn"].write(value.storageConfigurationArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.S3DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.S3DestinationConfiguration()
        value.storageConfigurationArn = try reader["storageConfigurationArn"].readIfPresent()
        value.encoderConfigurationArns = try reader["encoderConfigurationArns"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.recordingConfiguration = try reader["recordingConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.RecordingConfiguration.read(from:))
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// A complex type that describes an S3 location where recorded videos will be stored.
    public struct S3DestinationConfiguration {
        /// ARNs of the [EncoderConfiguration] resource. The encoder configuration and stage resources must be in the same AWS account and region.
        /// This member is required.
        public var encoderConfigurationArns: [Swift.String]?
        /// Array of maps, each of the form string:string (key:value). This is an optional customer specification, currently used only to specify the recording format for storing a recording in Amazon S3.
        public var recordingConfiguration: IVSRealTimeClientTypes.RecordingConfiguration?
        /// ARN of the [StorageConfiguration] where recorded videos will be stored.
        /// This member is required.
        public var storageConfigurationArn: Swift.String?

        public init(
            encoderConfigurationArns: [Swift.String]? = nil,
            recordingConfiguration: IVSRealTimeClientTypes.RecordingConfiguration? = nil,
            storageConfigurationArn: Swift.String? = nil
        )
        {
            self.encoderConfigurationArns = encoderConfigurationArns
            self.recordingConfiguration = recordingConfiguration
            self.storageConfigurationArn = storageConfigurationArn
        }
    }

}

extension IVSRealTimeClientTypes.S3Detail {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.S3Detail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.S3Detail()
        value.recordingPrefix = try reader["recordingPrefix"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Complex data type that defines S3Detail objects.
    public struct S3Detail {
        /// The S3 bucket prefix under which the recording is stored.
        /// This member is required.
        public var recordingPrefix: Swift.String?

        public init(
            recordingPrefix: Swift.String? = nil
        )
        {
            self.recordingPrefix = recordingPrefix
        }
    }

}

extension IVSRealTimeClientTypes.S3StorageConfiguration {

    static func write(value: IVSRealTimeClientTypes.S3StorageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.S3StorageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.S3StorageConfiguration()
        value.bucketName = try reader["bucketName"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// A complex type that describes an S3 location where recorded videos will be stored.
    public struct S3StorageConfiguration {
        /// Location (S3 bucket name) where recorded videos will be stored. Note that the StorageConfiguration and S3 bucket must be in the same region as the Composition.
        /// This member is required.
        public var bucketName: Swift.String?

        public init(
            bucketName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
        }
    }

}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

///
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request would cause a service quota to be exceeded.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

extension IVSRealTimeClientTypes.Stage {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.Stage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.Stage()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.activeSessionId = try reader["activeSessionId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Object specifying a stage.
    public struct Stage {
        /// ID of the active session within the stage.
        public var activeSessionId: Swift.String?
        /// Stage ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Stage name.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            activeSessionId: Swift.String? = nil,
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }

}

extension IVSRealTimeClientTypes.StageSession {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.StageSession {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.StageSession()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// A stage session begins when the first participant joins a stage and ends after the last participant leaves the stage. A stage session helps with debugging stages by grouping events and participants into shorter periods of time (i.e., a session), which is helpful when stages are used over long periods of time.
    public struct StageSession {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        public var endTime: ClientRuntime.Date?
        /// ID of the session within the stage.
        public var sessionId: Swift.String?
        /// ISO 8601 timestamp (returned as a string) when this stage session began.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            sessionId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }
    }

}

extension IVSRealTimeClientTypes.StageSessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.StageSessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.StageSessionSummary()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: .dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about a stage session.
    public struct StageSessionSummary {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        public var endTime: ClientRuntime.Date?
        /// ID of the session within the stage.
        public var sessionId: Swift.String?
        /// ISO 8601 timestamp (returned as a string) when this stage session began.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            sessionId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }
    }

}

extension IVSRealTimeClientTypes.StageSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.StageSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.StageSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.activeSessionId = try reader["activeSessionId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about a stage.
    public struct StageSummary {
        /// ID of the active session within the stage.
        public var activeSessionId: Swift.String?
        /// Stage ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Stage name.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            activeSessionId: Swift.String? = nil,
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }

}

extension StartCompositionInput {

    static func urlPathProvider(_ value: StartCompositionInput) -> Swift.String? {
        return "/StartComposition"
    }
}

extension StartCompositionInput {

    static func write(value: StartCompositionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinations"].writeList(value.destinations, memberWritingClosure: IVSRealTimeClientTypes.DestinationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["idempotencyToken"].write(value.idempotencyToken)
        try writer["layout"].write(value.layout, with: IVSRealTimeClientTypes.LayoutConfiguration.write(value:to:))
        try writer["stageArn"].write(value.stageArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct StartCompositionInput {
    /// Array of destination configuration.
    /// This member is required.
    public var destinations: [IVSRealTimeClientTypes.DestinationConfiguration]?
    /// Idempotency token.
    public var idempotencyToken: Swift.String?
    /// Layout object to configure composition parameters.
    public var layout: IVSRealTimeClientTypes.LayoutConfiguration?
    /// ARN of the stage to be used for compositing.
    /// This member is required.
    public var stageArn: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init(
        destinations: [IVSRealTimeClientTypes.DestinationConfiguration]? = nil,
        idempotencyToken: Swift.String? = nil,
        layout: IVSRealTimeClientTypes.LayoutConfiguration? = nil,
        stageArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.destinations = destinations
        self.idempotencyToken = idempotencyToken
        self.layout = layout
        self.stageArn = stageArn
        self.tags = tags
    }
}

extension StartCompositionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartCompositionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartCompositionOutput()
        value.composition = try reader["composition"].readIfPresent(with: IVSRealTimeClientTypes.Composition.read(from:))
        return value
    }
}

public struct StartCompositionOutput {
    /// The Composition that was created.
    public var composition: IVSRealTimeClientTypes.Composition?

    public init(
        composition: IVSRealTimeClientTypes.Composition? = nil
    )
    {
        self.composition = composition
    }
}

enum StartCompositionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StopCompositionInput {

    static func urlPathProvider(_ value: StopCompositionInput) -> Swift.String? {
        return "/StopComposition"
    }
}

extension StopCompositionInput {

    static func write(value: StopCompositionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

public struct StopCompositionInput {
    /// ARN of the Composition.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension StopCompositionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StopCompositionOutput {
        return StopCompositionOutput()
    }
}

public struct StopCompositionOutput {

    public init() { }
}

enum StopCompositionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension IVSRealTimeClientTypes.StorageConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.StorageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.StorageConfiguration()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.s3 = try reader["s3"].readIfPresent(with: IVSRealTimeClientTypes.S3StorageConfiguration.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// A complex type that describes a location where recorded videos will be stored.
    public struct StorageConfiguration {
        /// ARN of the storage configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Name of the storage configuration.
        public var name: Swift.String?
        /// An S3 destination configuration where recorded videos will be stored.
        public var s3: IVSRealTimeClientTypes.S3StorageConfiguration?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            s3: IVSRealTimeClientTypes.S3StorageConfiguration? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.s3 = s3
            self.tags = tags
        }
    }

}

extension IVSRealTimeClientTypes.StorageConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.StorageConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.StorageConfigurationSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.s3 = try reader["s3"].readIfPresent(with: IVSRealTimeClientTypes.S3StorageConfiguration.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Summary information about a storage configuration.
    public struct StorageConfigurationSummary {
        /// ARN of the storage configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Name of the storage configuration.
        public var name: Swift.String?
        /// An S3 destination configuration where recorded videos will be stored.
        public var s3: IVSRealTimeClientTypes.S3StorageConfiguration?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            s3: IVSRealTimeClientTypes.S3StorageConfiguration? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.s3 = s3
            self.tags = tags
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The ARN of the resource to be tagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints beyond what is documented there.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The ARN of the resource to be untagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints beyond what is documented there.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateStageInput {

    static func urlPathProvider(_ value: UpdateStageInput) -> Swift.String? {
        return "/UpdateStage"
    }
}

extension UpdateStageInput {

    static func write(value: UpdateStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["name"].write(value.name)
    }
}

public struct UpdateStageInput {
    /// ARN of the stage to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// Name of the stage to be updated.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension UpdateStageOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStageOutput()
        value.stage = try reader["stage"].readIfPresent(with: IVSRealTimeClientTypes.Stage.read(from:))
        return value
    }
}

public struct UpdateStageOutput {
    /// The updated stage.
    public var stage: IVSRealTimeClientTypes.Stage?

    public init(
        stage: IVSRealTimeClientTypes.Stage? = nil
    )
    {
        self.stage = stage
    }
}

enum UpdateStageOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

///
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

extension IVSRealTimeClientTypes.Video {

    static func write(value: IVSRealTimeClientTypes.Video?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bitrate"].write(value.bitrate)
        try writer["framerate"].write(value.framerate)
        try writer["height"].write(value.height)
        try writer["width"].write(value.width)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.Video {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.Video()
        value.width = try reader["width"].readIfPresent()
        value.height = try reader["height"].readIfPresent()
        value.framerate = try reader["framerate"].readIfPresent()
        value.bitrate = try reader["bitrate"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes {
    /// Settings for video.
    public struct Video {
        /// Bitrate for generated output, in bps. Default: 2500000.
        public var bitrate: Swift.Int?
        /// Video frame rate, in fps. Default: 30.
        public var framerate: Swift.Float?
        /// Video-resolution height. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        public var height: Swift.Int?
        /// Video-resolution width. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        public var width: Swift.Int?

        public init(
            bitrate: Swift.Int? = nil,
            framerate: Swift.Float? = nil,
            height: Swift.Int? = nil,
            width: Swift.Int? = nil
        )
        {
            self.bitrate = bitrate
            self.framerate = framerate
            self.height = height
            self.width = width
        }
    }

}

extension IVSRealTimeClientTypes {

    public enum VideoAspectRatio: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case portrait
        case square
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoAspectRatio] {
            return [
                .auto,
                .portrait,
                .square,
                .video
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .portrait: return "PORTRAIT"
            case .square: return "SQUARE"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    public enum VideoFillMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contain
        case cover
        case fill
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoFillMode] {
            return [
                .contain,
                .cover,
                .fill
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contain: return "CONTAIN"
            case .cover: return "COVER"
            case .fill: return "FILL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}
