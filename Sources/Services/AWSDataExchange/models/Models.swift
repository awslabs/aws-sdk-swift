// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access to the resource is denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Access to the resource is denied.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataExchangeClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportRevisionToS3 = "ExportRevisionToS3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportRevisionToS3 = self.exportRevisionToS3 {
            try encodeContainer.encode(exportRevisionToS3, forKey: .exportRevisionToS3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportRevisionToS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AutoExportRevisionToS3RequestDetails.self, forKey: .exportRevisionToS3)
        exportRevisionToS3 = exportRevisionToS3Decoded
    }
}

extension DataExchangeClientTypes {
    /// What occurs after a certain event.
    public struct Action {
        /// Details for the export revision to Amazon S3 action.
        public var exportRevisionToS3: DataExchangeClientTypes.AutoExportRevisionToS3RequestDetails?

        public init(
            exportRevisionToS3: DataExchangeClientTypes.AutoExportRevisionToS3RequestDetails? = nil
        )
        {
            self.exportRevisionToS3 = exportRevisionToS3
        }
    }

}

extension DataExchangeClientTypes.ApiGatewayApiAsset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDescription = "ApiDescription"
        case apiEndpoint = "ApiEndpoint"
        case apiId = "ApiId"
        case apiKey = "ApiKey"
        case apiName = "ApiName"
        case apiSpecificationDownloadUrl = "ApiSpecificationDownloadUrl"
        case apiSpecificationDownloadUrlExpiresAt = "ApiSpecificationDownloadUrlExpiresAt"
        case protocolType = "ProtocolType"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiDescription = self.apiDescription {
            try encodeContainer.encode(apiDescription, forKey: .apiDescription)
        }
        if let apiEndpoint = self.apiEndpoint {
            try encodeContainer.encode(apiEndpoint, forKey: .apiEndpoint)
        }
        if let apiId = self.apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiKey = self.apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let apiName = self.apiName {
            try encodeContainer.encode(apiName, forKey: .apiName)
        }
        if let apiSpecificationDownloadUrl = self.apiSpecificationDownloadUrl {
            try encodeContainer.encode(apiSpecificationDownloadUrl, forKey: .apiSpecificationDownloadUrl)
        }
        if let apiSpecificationDownloadUrlExpiresAt = self.apiSpecificationDownloadUrlExpiresAt {
            try encodeContainer.encodeTimestamp(apiSpecificationDownloadUrlExpiresAt, format: .dateTime, forKey: .apiSpecificationDownloadUrlExpiresAt)
        }
        if let protocolType = self.protocolType {
            try encodeContainer.encode(protocolType.rawValue, forKey: .protocolType)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDescription)
        apiDescription = apiDescriptionDecoded
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let apiNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiName)
        apiName = apiNameDecoded
        let apiSpecificationDownloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiSpecificationDownloadUrl)
        apiSpecificationDownloadUrl = apiSpecificationDownloadUrlDecoded
        let apiSpecificationDownloadUrlExpiresAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .apiSpecificationDownloadUrlExpiresAt)
        apiSpecificationDownloadUrlExpiresAt = apiSpecificationDownloadUrlExpiresAtDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension DataExchangeClientTypes {
    /// The API Gateway API that is the asset.
    public struct ApiGatewayApiAsset {
        /// The API description of the API asset.
        public var apiDescription: Swift.String?
        /// The API endpoint of the API asset.
        public var apiEndpoint: Swift.String?
        /// The unique identifier of the API asset.
        public var apiId: Swift.String?
        /// The API key of the API asset.
        public var apiKey: Swift.String?
        /// The API name of the API asset.
        public var apiName: Swift.String?
        /// The download URL of the API specification of the API asset.
        public var apiSpecificationDownloadUrl: Swift.String?
        /// The date and time that the upload URL expires, in ISO 8601 format.
        public var apiSpecificationDownloadUrlExpiresAt: ClientRuntime.Date?
        /// The protocol type of the API asset.
        public var protocolType: DataExchangeClientTypes.ProtocolType?
        /// The stage of the API asset.
        public var stage: Swift.String?

        public init(
            apiDescription: Swift.String? = nil,
            apiEndpoint: Swift.String? = nil,
            apiId: Swift.String? = nil,
            apiKey: Swift.String? = nil,
            apiName: Swift.String? = nil,
            apiSpecificationDownloadUrl: Swift.String? = nil,
            apiSpecificationDownloadUrlExpiresAt: ClientRuntime.Date? = nil,
            protocolType: DataExchangeClientTypes.ProtocolType? = nil,
            stage: Swift.String? = nil
        )
        {
            self.apiDescription = apiDescription
            self.apiEndpoint = apiEndpoint
            self.apiId = apiId
            self.apiKey = apiKey
            self.apiName = apiName
            self.apiSpecificationDownloadUrl = apiSpecificationDownloadUrl
            self.apiSpecificationDownloadUrlExpiresAt = apiSpecificationDownloadUrlExpiresAt
            self.protocolType = protocolType
            self.stage = stage
        }
    }

}

extension DataExchangeClientTypes.AssetDestinationEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId = "AssetId"
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension DataExchangeClientTypes {
    /// The destination for the asset.
    public struct AssetDestinationEntry {
        /// The unique identifier for the asset.
        /// This member is required.
        public var assetId: Swift.String?
        /// The Amazon S3 bucket that is the destination for the asset.
        /// This member is required.
        public var bucket: Swift.String?
        /// The name of the object in Amazon S3 for the asset.
        public var key: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.bucket = bucket
            self.key = key
        }
    }

}

extension DataExchangeClientTypes.AssetDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayApiAsset = "ApiGatewayApiAsset"
        case lakeFormationDataPermissionAsset = "LakeFormationDataPermissionAsset"
        case redshiftDataShareAsset = "RedshiftDataShareAsset"
        case s3DataAccessAsset = "S3DataAccessAsset"
        case s3SnapshotAsset = "S3SnapshotAsset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayApiAsset = self.apiGatewayApiAsset {
            try encodeContainer.encode(apiGatewayApiAsset, forKey: .apiGatewayApiAsset)
        }
        if let lakeFormationDataPermissionAsset = self.lakeFormationDataPermissionAsset {
            try encodeContainer.encode(lakeFormationDataPermissionAsset, forKey: .lakeFormationDataPermissionAsset)
        }
        if let redshiftDataShareAsset = self.redshiftDataShareAsset {
            try encodeContainer.encode(redshiftDataShareAsset, forKey: .redshiftDataShareAsset)
        }
        if let s3DataAccessAsset = self.s3DataAccessAsset {
            try encodeContainer.encode(s3DataAccessAsset, forKey: .s3DataAccessAsset)
        }
        if let s3SnapshotAsset = self.s3SnapshotAsset {
            try encodeContainer.encode(s3SnapshotAsset, forKey: .s3SnapshotAsset)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3SnapshotAssetDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.S3SnapshotAsset.self, forKey: .s3SnapshotAsset)
        s3SnapshotAsset = s3SnapshotAssetDecoded
        let redshiftDataShareAssetDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.RedshiftDataShareAsset.self, forKey: .redshiftDataShareAsset)
        redshiftDataShareAsset = redshiftDataShareAssetDecoded
        let apiGatewayApiAssetDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ApiGatewayApiAsset.self, forKey: .apiGatewayApiAsset)
        apiGatewayApiAsset = apiGatewayApiAssetDecoded
        let s3DataAccessAssetDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.S3DataAccessAsset.self, forKey: .s3DataAccessAsset)
        s3DataAccessAsset = s3DataAccessAssetDecoded
        let lakeFormationDataPermissionAssetDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.LakeFormationDataPermissionAsset.self, forKey: .lakeFormationDataPermissionAsset)
        lakeFormationDataPermissionAsset = lakeFormationDataPermissionAssetDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details about the asset.
    public struct AssetDetails {
        /// Information about the API Gateway API asset.
        public var apiGatewayApiAsset: DataExchangeClientTypes.ApiGatewayApiAsset?
        /// The AWS Lake Formation data permission that is the asset.
        public var lakeFormationDataPermissionAsset: DataExchangeClientTypes.LakeFormationDataPermissionAsset?
        /// The Amazon Redshift datashare that is the asset.
        public var redshiftDataShareAsset: DataExchangeClientTypes.RedshiftDataShareAsset?
        /// The Amazon S3 data access that is the asset.
        public var s3DataAccessAsset: DataExchangeClientTypes.S3DataAccessAsset?
        /// The Amazon S3 object that is the asset.
        public var s3SnapshotAsset: DataExchangeClientTypes.S3SnapshotAsset?

        public init(
            apiGatewayApiAsset: DataExchangeClientTypes.ApiGatewayApiAsset? = nil,
            lakeFormationDataPermissionAsset: DataExchangeClientTypes.LakeFormationDataPermissionAsset? = nil,
            redshiftDataShareAsset: DataExchangeClientTypes.RedshiftDataShareAsset? = nil,
            s3DataAccessAsset: DataExchangeClientTypes.S3DataAccessAsset? = nil,
            s3SnapshotAsset: DataExchangeClientTypes.S3SnapshotAsset? = nil
        )
        {
            self.apiGatewayApiAsset = apiGatewayApiAsset
            self.lakeFormationDataPermissionAsset = lakeFormationDataPermissionAsset
            self.redshiftDataShareAsset = redshiftDataShareAsset
            self.s3DataAccessAsset = s3DataAccessAsset
            self.s3SnapshotAsset = s3SnapshotAsset
        }
    }

}

extension DataExchangeClientTypes.AssetEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetDetails = "AssetDetails"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case id = "Id"
        case name = "Name"
        case revisionId = "RevisionId"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetDetails = self.assetDetails {
            try encodeContainer.encode(assetDetails, forKey: .assetDetails)
        }
        if let assetType = self.assetType {
            try encodeContainer.encode(assetType.rawValue, forKey: .assetType)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetDetails.self, forKey: .assetDetails)
        assetDetails = assetDetailsDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataExchangeClientTypes {
    /// An asset in AWS Data Exchange is a piece of data (Amazon S3 object) or a means of fulfilling data (Amazon Redshift datashare or Amazon API Gateway API, AWS Lake Formation data permission, or Amazon S3 data access). The asset can be a structured data file, an image file, or some other data file that can be stored as an Amazon S3 object, an Amazon API Gateway API, or an Amazon Redshift datashare, an AWS Lake Formation data permission, or an Amazon S3 data access. When you create an import job for your files, API Gateway APIs, Amazon Redshift datashares, AWS Lake Formation data permission, or Amazon S3 data access, you create an asset in AWS Data Exchange.
    public struct AssetEntry {
        /// The ARN for the asset.
        /// This member is required.
        public var arn: Swift.String?
        /// Details about the asset.
        /// This member is required.
        public var assetDetails: DataExchangeClientTypes.AssetDetails?
        /// The type of asset that is added to a data set.
        /// This member is required.
        public var assetType: DataExchangeClientTypes.AssetType?
        /// The date and time that the asset was created, in ISO 8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The unique identifier for the data set associated with this asset.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the asset.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the asset. When importing from Amazon S3, the Amazon S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target Amazon S3 object key. When importing from Amazon API Gateway API, the API name is used as the asset name. When importing from Amazon Redshift, the datashare name is used as the asset name. When importing from AWS Lake Formation, the static values of "Database(s) included in LF-tag policy" or "Table(s) included in LF-tag policy" are used as the asset name.
        /// This member is required.
        public var name: Swift.String?
        /// The unique identifier for the revision associated with this asset.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.
        public var sourceId: Swift.String?
        /// The date and time that the asset was last updated, in ISO 8601 format.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            assetDetails: DataExchangeClientTypes.AssetDetails? = nil,
            assetType: DataExchangeClientTypes.AssetType? = nil,
            createdAt: ClientRuntime.Date? = nil,
            dataSetId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            sourceId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.assetDetails = assetDetails
            self.assetType = assetType
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.id = id
            self.name = name
            self.revisionId = revisionId
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }
    }

}

extension DataExchangeClientTypes.AssetSourceEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension DataExchangeClientTypes {
    /// The source of the assets.
    public struct AssetSourceEntry {
        /// The Amazon S3 bucket that's part of the source of the asset.
        /// This member is required.
        public var bucket: Swift.String?
        /// The name of the object in Amazon S3 for the asset.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension DataExchangeClientTypes {
    public enum AssetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiGatewayApi
        case lakeFormationDataPermission
        case redshiftDataShare
        case s3DataAccess
        case s3Snapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetType] {
            return [
                .apiGatewayApi,
                .lakeFormationDataPermission,
                .redshiftDataShare,
                .s3DataAccess,
                .s3Snapshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiGatewayApi: return "API_GATEWAY_API"
            case .lakeFormationDataPermission: return "LAKE_FORMATION_DATA_PERMISSION"
            case .redshiftDataShare: return "REDSHIFT_DATA_SHARE"
            case .s3DataAccess: return "S3_DATA_ACCESS"
            case .s3Snapshot: return "S3_SNAPSHOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetType(rawValue: rawValue) ?? AssetType.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.AutoExportRevisionDestinationEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case keyPattern = "KeyPattern"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPattern = self.keyPattern {
            try encodeContainer.encode(keyPattern, forKey: .keyPattern)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPattern)
        keyPattern = keyPatternDecoded
    }
}

extension DataExchangeClientTypes {
    /// A revision destination is the Amazon S3 bucket folder destination to where the export will be sent.
    public struct AutoExportRevisionDestinationEntry {
        /// The Amazon S3 bucket that is the destination for the event action.
        /// This member is required.
        public var bucket: Swift.String?
        /// A string representing the pattern for generated names of the individual assets in the revision. For more information about key patterns, see [Key patterns when exporting revisions](https://docs.aws.amazon.com/data-exchange/latest/userguide/jobs.html#revision-export-keypatterns).
        public var keyPattern: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            keyPattern: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.keyPattern = keyPattern
        }
    }

}

extension DataExchangeClientTypes.AutoExportRevisionToS3RequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "Encryption"
        case revisionDestination = "RevisionDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let revisionDestination = self.revisionDestination {
            try encodeContainer.encode(revisionDestination, forKey: .revisionDestination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionDestinationDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AutoExportRevisionDestinationEntry.self, forKey: .revisionDestination)
        revisionDestination = revisionDestinationDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details of the operation to be performed by the job.
    public struct AutoExportRevisionToS3RequestDetails {
        /// Encryption configuration for the auto export job.
        public var encryption: DataExchangeClientTypes.ExportServerSideEncryption?
        /// A revision destination is the Amazon S3 bucket folder destination to where the export will be sent.
        /// This member is required.
        public var revisionDestination: DataExchangeClientTypes.AutoExportRevisionDestinationEntry?

        public init(
            encryption: DataExchangeClientTypes.ExportServerSideEncryption? = nil,
            revisionDestination: DataExchangeClientTypes.AutoExportRevisionDestinationEntry? = nil
        )
        {
            self.encryption = encryption
            self.revisionDestination = revisionDestination
        }
    }

}

extension CancelJobInput {

    static func urlPathProvider(_ value: CancelJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/v1/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct CancelJobInput {
    /// The unique identifier for a job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelJobInputBody {
}

extension CancelJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelJobOutput {

    public init() { }
}

enum CancelJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataExchangeClientTypes {
    public enum Code: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDeniedException
        case internalServerException
        case malwareDetected
        case malwareScanEncryptedFile
        case resourceNotFoundException
        case serviceQuotaExceededException
        case validationException
        case sdkUnknown(Swift.String)

        public static var allCases: [Code] {
            return [
                .accessDeniedException,
                .internalServerException,
                .malwareDetected,
                .malwareScanEncryptedFile,
                .resourceNotFoundException,
                .serviceQuotaExceededException,
                .validationException,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDeniedException: return "ACCESS_DENIED_EXCEPTION"
            case .internalServerException: return "INTERNAL_SERVER_EXCEPTION"
            case .malwareDetected: return "MALWARE_DETECTED"
            case .malwareScanEncryptedFile: return "MALWARE_SCAN_ENCRYPTED_FILE"
            case .resourceNotFoundException: return "RESOURCE_NOT_FOUND_EXCEPTION"
            case .serviceQuotaExceededException: return "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
            case .validationException: return "VALIDATION_EXCEPTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Code(rawValue: rawValue) ?? Code.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request couldn't be completed because it conflicted with the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The request couldn't be completed because it conflicted with the current state of the resource.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the resource with the conflict.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource with the conflict.
        public internal(set) var resourceType: DataExchangeClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: DataExchangeClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: DataExchangeClientTypes.ResourceType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateDataSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetType = "AssetType"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetType = self.assetType {
            try encodeContainer.encode(assetType.rawValue, forKey: .assetType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOf__string0) in tags {
                try tagsContainer.encode(mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDataSetInput {

    static func urlPathProvider(_ value: CreateDataSetInput) -> Swift.String? {
        return "/v1/data-sets"
    }
}

public struct CreateDataSetInput {
    /// The type of asset that is added to a data set.
    /// This member is required.
    public var assetType: DataExchangeClientTypes.AssetType?
    /// A description for the data set. This value can be up to 16,348 characters long.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the data set.
    /// This member is required.
    public var name: Swift.String?
    /// A data set tag is an optional label that you can assign to a data set when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to these data sets and revisions.
    public var tags: [Swift.String:Swift.String]?

    public init(
        assetType: DataExchangeClientTypes.AssetType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assetType = assetType
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateDataSetInputBody {
    let assetType: DataExchangeClientTypes.AssetType?
    let description: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDataSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetType = "AssetType"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDataSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.origin = output.origin
            self.originDetails = output.originDetails
            self.sourceId = output.sourceId
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetType = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.origin = nil
            self.originDetails = nil
            self.sourceId = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateDataSetOutput {
    /// The ARN for the data set.
    public var arn: Swift.String?
    /// The type of asset that is added to a data set.
    public var assetType: DataExchangeClientTypes.AssetType?
    /// The date and time that the data set was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The description for the data set.
    public var description: Swift.String?
    /// The unique identifier for the data set.
    public var id: Swift.String?
    /// The name of the data set.
    public var name: Swift.String?
    /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
    public var origin: DataExchangeClientTypes.Origin?
    /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
    public var originDetails: DataExchangeClientTypes.OriginDetails?
    /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
    public var sourceId: Swift.String?
    /// The tags for the data set.
    public var tags: [Swift.String:Swift.String]?
    /// The date and time that the data set was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        assetType: DataExchangeClientTypes.AssetType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        origin: DataExchangeClientTypes.Origin? = nil,
        originDetails: DataExchangeClientTypes.OriginDetails? = nil,
        sourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.assetType = assetType
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.origin = origin
        self.originDetails = originDetails
        self.sourceId = sourceId
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct CreateDataSetOutputBody {
    let arn: Swift.String?
    let assetType: DataExchangeClientTypes.AssetType?
    let createdAt: ClientRuntime.Date?
    let description: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let origin: DataExchangeClientTypes.Origin?
    let originDetails: DataExchangeClientTypes.OriginDetails?
    let sourceId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let updatedAt: ClientRuntime.Date?
}

extension CreateDataSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case origin = "Origin"
        case originDetails = "OriginDetails"
        case sourceId = "SourceId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let originDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Origin.self, forKey: .origin)
        origin = originDecoded
        let originDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.OriginDetails.self, forKey: .originDetails)
        originDetails = originDetailsDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum CreateDataSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLimitExceededException": return try await ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEventActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case event = "Event"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
    }
}

extension CreateEventActionInput {

    static func urlPathProvider(_ value: CreateEventActionInput) -> Swift.String? {
        return "/v1/event-actions"
    }
}

public struct CreateEventActionInput {
    /// What occurs after a certain event.
    /// This member is required.
    public var action: DataExchangeClientTypes.Action?
    /// What occurs to start an action.
    /// This member is required.
    public var event: DataExchangeClientTypes.Event?

    public init(
        action: DataExchangeClientTypes.Action? = nil,
        event: DataExchangeClientTypes.Event? = nil
    )
    {
        self.action = action
        self.event = event
    }
}

struct CreateEventActionInputBody {
    let action: DataExchangeClientTypes.Action?
    let event: DataExchangeClientTypes.Event?
}

extension CreateEventActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case event = "Event"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let eventDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Event.self, forKey: .event)
        event = eventDecoded
    }
}

extension CreateEventActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEventActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.event = output.event
            self.id = output.id
            self.updatedAt = output.updatedAt
        } else {
            self.action = nil
            self.arn = nil
            self.createdAt = nil
            self.event = nil
            self.id = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateEventActionOutput {
    /// What occurs after a certain event.
    public var action: DataExchangeClientTypes.Action?
    /// The ARN for the event action.
    public var arn: Swift.String?
    /// The date and time that the event action was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// What occurs to start an action.
    public var event: DataExchangeClientTypes.Event?
    /// The unique identifier for the event action.
    public var id: Swift.String?
    /// The date and time that the event action was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        action: DataExchangeClientTypes.Action? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        event: DataExchangeClientTypes.Event? = nil,
        id: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.createdAt = createdAt
        self.event = event
        self.id = id
        self.updatedAt = updatedAt
    }
}

struct CreateEventActionOutputBody {
    let action: DataExchangeClientTypes.Action?
    let arn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let event: DataExchangeClientTypes.Event?
    let id: Swift.String?
    let updatedAt: ClientRuntime.Date?
}

extension CreateEventActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case event = "Event"
        case id = "Id"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let eventDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum CreateEventActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLimitExceededException": return try await ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateJobInput {

    static func urlPathProvider(_ value: CreateJobInput) -> Swift.String? {
        return "/v1/jobs"
    }
}

public struct CreateJobInput {
    /// The details for the CreateJob request.
    /// This member is required.
    public var details: DataExchangeClientTypes.RequestDetails?
    /// The type of job to be created.
    /// This member is required.
    public var type: DataExchangeClientTypes.ModelType?

    public init(
        details: DataExchangeClientTypes.RequestDetails? = nil,
        type: DataExchangeClientTypes.ModelType? = nil
    )
    {
        self.details = details
        self.type = type
    }
}

struct CreateJobInputBody {
    let details: DataExchangeClientTypes.RequestDetails?
    let type: DataExchangeClientTypes.ModelType?
}

extension CreateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.RequestDetails.self, forKey: .details)
        details = detailsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.details = output.details
            self.errors = output.errors
            self.id = output.id
            self.state = output.state
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.details = nil
            self.errors = nil
            self.id = nil
            self.state = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateJobOutput {
    /// The ARN for the job.
    public var arn: Swift.String?
    /// The date and time that the job was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// Details about the job.
    public var details: DataExchangeClientTypes.ResponseDetails?
    /// The errors associated with jobs.
    public var errors: [DataExchangeClientTypes.JobError]?
    /// The unique identifier for the job.
    public var id: Swift.String?
    /// The state of the job.
    public var state: DataExchangeClientTypes.State?
    /// The job type.
    public var type: DataExchangeClientTypes.ModelType?
    /// The date and time that the job was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        details: DataExchangeClientTypes.ResponseDetails? = nil,
        errors: [DataExchangeClientTypes.JobError]? = nil,
        id: Swift.String? = nil,
        state: DataExchangeClientTypes.State? = nil,
        type: DataExchangeClientTypes.ModelType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.details = details
        self.errors = errors
        self.id = id
        self.state = state
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct CreateJobOutputBody {
    let arn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let details: DataExchangeClientTypes.ResponseDetails?
    let errors: [DataExchangeClientTypes.JobError]?
    let id: Swift.String?
    let state: DataExchangeClientTypes.State?
    let type: DataExchangeClientTypes.ModelType?
    let updatedAt: ClientRuntime.Date?
}

extension CreateJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case details = "Details"
        case errors = "Errors"
        case id = "Id"
        case state = "State"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ResponseDetails.self, forKey: .details)
        details = detailsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.JobError?].self, forKey: .errors)
        var errorsDecoded0:[DataExchangeClientTypes.JobError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [DataExchangeClientTypes.JobError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum CreateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRevisionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOf__string0) in tags {
                try tagsContainer.encode(mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRevisionInput {

    static func urlPathProvider(_ value: CreateRevisionInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions"
    }
}

public struct CreateRevisionInput {
    /// An optional comment about the revision.
    public var comment: Swift.String?
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// A revision tag is an optional label that you can assign to a revision when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to these data sets and revisions.
    public var tags: [Swift.String:Swift.String]?

    public init(
        comment: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.comment = comment
        self.dataSetId = dataSetId
        self.tags = tags
    }
}

struct CreateRevisionInputBody {
    let comment: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRevisionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRevisionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRevisionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.comment = output.comment
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.finalized = output.finalized
            self.id = output.id
            self.revocationComment = output.revocationComment
            self.revoked = output.revoked
            self.revokedAt = output.revokedAt
            self.sourceId = output.sourceId
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.comment = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.finalized = nil
            self.id = nil
            self.revocationComment = nil
            self.revoked = nil
            self.revokedAt = nil
            self.sourceId = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateRevisionOutput {
    /// The ARN for the revision.
    public var arn: Swift.String?
    /// An optional comment about the revision.
    public var comment: Swift.String?
    /// The date and time that the revision was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The unique identifier for the data set associated with the data set revision.
    public var dataSetId: Swift.String?
    /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
    public var finalized: Swift.Bool?
    /// The unique identifier for the revision.
    public var id: Swift.String?
    /// A required comment to inform subscribers of the reason their access to the revision was revoked.
    public var revocationComment: Swift.String?
    /// A status indicating that subscribers' access to the revision was revoked.
    public var revoked: Swift.Bool?
    /// The date and time that the revision was revoked, in ISO 8601 format.
    public var revokedAt: ClientRuntime.Date?
    /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
    public var sourceId: Swift.String?
    /// The tags for the revision.
    public var tags: [Swift.String:Swift.String]?
    /// The date and time that the revision was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        comment: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        dataSetId: Swift.String? = nil,
        finalized: Swift.Bool? = nil,
        id: Swift.String? = nil,
        revocationComment: Swift.String? = nil,
        revoked: Swift.Bool? = nil,
        revokedAt: ClientRuntime.Date? = nil,
        sourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.comment = comment
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.id = id
        self.revocationComment = revocationComment
        self.revoked = revoked
        self.revokedAt = revokedAt
        self.sourceId = sourceId
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct CreateRevisionOutputBody {
    let arn: Swift.String?
    let comment: Swift.String?
    let createdAt: ClientRuntime.Date?
    let dataSetId: Swift.String?
    let finalized: Swift.Bool?
    let id: Swift.String?
    let sourceId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let updatedAt: ClientRuntime.Date?
    let revocationComment: Swift.String?
    let revoked: Swift.Bool?
    let revokedAt: ClientRuntime.Date?
}

extension CreateRevisionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case revocationComment = "RevocationComment"
        case revoked = "Revoked"
        case revokedAt = "RevokedAt"
        case sourceId = "SourceId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let revocationCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revocationComment)
        revocationComment = revocationCommentDecoded
        let revokedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .revoked)
        revoked = revokedDecoded
        let revokedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
    }
}

enum CreateRevisionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataExchangeClientTypes.CreateS3DataAccessFromS3BucketRequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSource = "AssetSource"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetSource = self.assetSource {
            try encodeContainer.encode(assetSource, forKey: .assetSource)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSourceDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.S3DataAccessAssetSourceEntry.self, forKey: .assetSource)
        assetSource = assetSourceDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details of the operation to create an Amazon S3 data access from an S3 bucket.
    public struct CreateS3DataAccessFromS3BucketRequestDetails {
        /// Details about the S3 data access source asset.
        /// This member is required.
        public var assetSource: DataExchangeClientTypes.S3DataAccessAssetSourceEntry?
        /// The unique identifier for the data set associated with the creation of this Amazon S3 data access.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for a revision.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetSource: DataExchangeClientTypes.S3DataAccessAssetSourceEntry? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetSource = assetSource
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.CreateS3DataAccessFromS3BucketResponseDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSource = "AssetSource"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetSource = self.assetSource {
            try encodeContainer.encode(assetSource, forKey: .assetSource)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSourceDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.S3DataAccessAssetSourceEntry.self, forKey: .assetSource)
        assetSource = assetSourceDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details about the response of the operation to create an S3 data access from an S3 bucket.
    public struct CreateS3DataAccessFromS3BucketResponseDetails {
        /// Details about the asset source from an Amazon S3 bucket.
        /// This member is required.
        public var assetSource: DataExchangeClientTypes.S3DataAccessAssetSourceEntry?
        /// The unique identifier for this data set.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetSource: DataExchangeClientTypes.S3DataAccessAssetSourceEntry? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetSource = assetSource
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }
    }

}

public enum DataExchangeClientTypes {}

extension DataExchangeClientTypes.DataSetEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case origin = "Origin"
        case originDetails = "OriginDetails"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetType = self.assetType {
            try encodeContainer.encode(assetType.rawValue, forKey: .assetType)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let origin = self.origin {
            try encodeContainer.encode(origin.rawValue, forKey: .origin)
        }
        if let originDetails = self.originDetails {
            try encodeContainer.encode(originDetails, forKey: .originDetails)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let originDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Origin.self, forKey: .origin)
        origin = originDecoded
        let originDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.OriginDetails.self, forKey: .originDetails)
        originDetails = originDetailsDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataExchangeClientTypes {
    /// A data set is an AWS resource with one or more revisions.
    public struct DataSetEntry {
        /// The ARN for the data set.
        /// This member is required.
        public var arn: Swift.String?
        /// The type of asset that is added to a data set.
        /// This member is required.
        public var assetType: DataExchangeClientTypes.AssetType?
        /// The date and time that the data set was created, in ISO 8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description for the data set.
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier for the data set.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the data set.
        /// This member is required.
        public var name: Swift.String?
        /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
        /// This member is required.
        public var origin: DataExchangeClientTypes.Origin?
        /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
        public var originDetails: DataExchangeClientTypes.OriginDetails?
        /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
        public var sourceId: Swift.String?
        /// The date and time that the data set was last updated, in ISO 8601 format.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            assetType: DataExchangeClientTypes.AssetType? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            origin: DataExchangeClientTypes.Origin? = nil,
            originDetails: DataExchangeClientTypes.OriginDetails? = nil,
            sourceId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.assetType = assetType
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.origin = origin
            self.originDetails = originDetails
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }
    }

}

extension DataExchangeClientTypes.DataUpdateRequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataUpdatedAt = "DataUpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataUpdatedAt = self.dataUpdatedAt {
            try encodeContainer.encodeTimestamp(dataUpdatedAt, format: .dateTime, forKey: .dataUpdatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .dataUpdatedAt)
        dataUpdatedAt = dataUpdatedAtDecoded
    }
}

extension DataExchangeClientTypes {
    /// Extra details specific to a data update type notification.
    public struct DataUpdateRequestDetails {
        /// A datetime in the past when the data was updated. This typically means that the underlying resource supporting the data set was updated.
        public var dataUpdatedAt: ClientRuntime.Date?

        public init(
            dataUpdatedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataUpdatedAt = dataUpdatedAt
        }
    }

}

extension DataExchangeClientTypes.DatabaseLFTagPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            var expressionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expression)
            for lftag0 in expression {
                try expressionContainer.encode(lftag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.LFTag?].self, forKey: .expression)
        var expressionDecoded0:[DataExchangeClientTypes.LFTag]? = nil
        if let expressionContainer = expressionContainer {
            expressionDecoded0 = [DataExchangeClientTypes.LFTag]()
            for structure0 in expressionContainer {
                if let structure0 = structure0 {
                    expressionDecoded0?.append(structure0)
                }
            }
        }
        expression = expressionDecoded0
    }
}

extension DataExchangeClientTypes {
    /// The LF-tag policy for database resources.
    public struct DatabaseLFTagPolicy {
        /// A list of LF-tag conditions that apply to database resources.
        /// This member is required.
        public var expression: [DataExchangeClientTypes.LFTag]?

        public init(
            expression: [DataExchangeClientTypes.LFTag]? = nil
        )
        {
            self.expression = expression
        }
    }

}

extension DataExchangeClientTypes.DatabaseLFTagPolicyAndPermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case permissions = "Permissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            var expressionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expression)
            for lftag0 in expression {
                try expressionContainer.encode(lftag0)
            }
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for databaselftagpolicypermission0 in permissions {
                try permissionsContainer.encode(databaselftagpolicypermission0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.LFTag?].self, forKey: .expression)
        var expressionDecoded0:[DataExchangeClientTypes.LFTag]? = nil
        if let expressionContainer = expressionContainer {
            expressionDecoded0 = [DataExchangeClientTypes.LFTag]()
            for structure0 in expressionContainer {
                if let structure0 = structure0 {
                    expressionDecoded0?.append(structure0)
                }
            }
        }
        expression = expressionDecoded0
        let permissionsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.DatabaseLFTagPolicyPermission?].self, forKey: .permissions)
        var permissionsDecoded0:[DataExchangeClientTypes.DatabaseLFTagPolicyPermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [DataExchangeClientTypes.DatabaseLFTagPolicyPermission]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

extension DataExchangeClientTypes {
    /// The LF-tag policy and permissions for database resources.
    public struct DatabaseLFTagPolicyAndPermissions {
        /// A list of LF-tag conditions that apply to database resources.
        /// This member is required.
        public var expression: [DataExchangeClientTypes.LFTag]?
        /// The permissions granted to subscribers on database resources.
        /// This member is required.
        public var permissions: [DataExchangeClientTypes.DatabaseLFTagPolicyPermission]?

        public init(
            expression: [DataExchangeClientTypes.LFTag]? = nil,
            permissions: [DataExchangeClientTypes.DatabaseLFTagPolicyPermission]? = nil
        )
        {
            self.expression = expression
            self.permissions = permissions
        }
    }

}

extension DataExchangeClientTypes {
    public enum DatabaseLFTagPolicyPermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case describe
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseLFTagPolicyPermission] {
            return [
                .describe,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .describe: return "DESCRIBE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatabaseLFTagPolicyPermission(rawValue: rawValue) ?? DatabaseLFTagPolicyPermission.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAssetInput {

    static func urlPathProvider(_ value: DeleteAssetInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let revisionId = value.revisionId else {
            return nil
        }
        guard let assetId = value.assetId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())/assets/\(assetId.urlPercentEncoding())"
    }
}

public struct DeleteAssetInput {
    /// The unique identifier for an asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

struct DeleteAssetInputBody {
}

extension DeleteAssetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAssetOutput {

    public init() { }
}

enum DeleteAssetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDataSetInput {

    static func urlPathProvider(_ value: DeleteDataSetInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())"
    }
}

public struct DeleteDataSetInput {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init(
        dataSetId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
    }
}

struct DeleteDataSetInputBody {
}

extension DeleteDataSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDataSetOutput {

    public init() { }
}

enum DeleteDataSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventActionInput {

    static func urlPathProvider(_ value: DeleteEventActionInput) -> Swift.String? {
        guard let eventActionId = value.eventActionId else {
            return nil
        }
        return "/v1/event-actions/\(eventActionId.urlPercentEncoding())"
    }
}

public struct DeleteEventActionInput {
    /// The unique identifier for the event action.
    /// This member is required.
    public var eventActionId: Swift.String?

    public init(
        eventActionId: Swift.String? = nil
    )
    {
        self.eventActionId = eventActionId
    }
}

struct DeleteEventActionInputBody {
}

extension DeleteEventActionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEventActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEventActionOutput {

    public init() { }
}

enum DeleteEventActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRevisionInput {

    static func urlPathProvider(_ value: DeleteRevisionInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let revisionId = value.revisionId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())"
    }
}

public struct DeleteRevisionInput {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

struct DeleteRevisionInputBody {
}

extension DeleteRevisionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRevisionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRevisionOutput {

    public init() { }
}

enum DeleteRevisionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataExchangeClientTypes.DeprecationRequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deprecationAt = "DeprecationAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deprecationAt = self.deprecationAt {
            try encodeContainer.encodeTimestamp(deprecationAt, format: .dateTime, forKey: .deprecationAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deprecationAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .deprecationAt)
        deprecationAt = deprecationAtDecoded
    }
}

extension DataExchangeClientTypes {
    /// Extra details specific to a deprecation type notification.
    public struct DeprecationRequestDetails {
        /// A datetime in the future when the data set will be deprecated.
        /// This member is required.
        public var deprecationAt: ClientRuntime.Date?

        public init(
            deprecationAt: ClientRuntime.Date? = nil
        )
        {
            self.deprecationAt = deprecationAt
        }
    }

}

extension DataExchangeClientTypes.Details: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importAssetFromSignedUrlJobErrorDetails = "ImportAssetFromSignedUrlJobErrorDetails"
        case importAssetsFromS3JobErrorDetails = "ImportAssetsFromS3JobErrorDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importAssetFromSignedUrlJobErrorDetails = self.importAssetFromSignedUrlJobErrorDetails {
            try encodeContainer.encode(importAssetFromSignedUrlJobErrorDetails, forKey: .importAssetFromSignedUrlJobErrorDetails)
        }
        if let importAssetsFromS3JobErrorDetails = importAssetsFromS3JobErrorDetails {
            var importAssetsFromS3JobErrorDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .importAssetsFromS3JobErrorDetails)
            for assetsourceentry0 in importAssetsFromS3JobErrorDetails {
                try importAssetsFromS3JobErrorDetailsContainer.encode(assetsourceentry0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importAssetFromSignedUrlJobErrorDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetFromSignedUrlJobErrorDetails.self, forKey: .importAssetFromSignedUrlJobErrorDetails)
        importAssetFromSignedUrlJobErrorDetails = importAssetFromSignedUrlJobErrorDetailsDecoded
        let importAssetsFromS3JobErrorDetailsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.AssetSourceEntry?].self, forKey: .importAssetsFromS3JobErrorDetails)
        var importAssetsFromS3JobErrorDetailsDecoded0:[DataExchangeClientTypes.AssetSourceEntry]? = nil
        if let importAssetsFromS3JobErrorDetailsContainer = importAssetsFromS3JobErrorDetailsContainer {
            importAssetsFromS3JobErrorDetailsDecoded0 = [DataExchangeClientTypes.AssetSourceEntry]()
            for structure0 in importAssetsFromS3JobErrorDetailsContainer {
                if let structure0 = structure0 {
                    importAssetsFromS3JobErrorDetailsDecoded0?.append(structure0)
                }
            }
        }
        importAssetsFromS3JobErrorDetails = importAssetsFromS3JobErrorDetailsDecoded0
    }
}

extension DataExchangeClientTypes {
    /// Information about the job error.
    public struct Details {
        /// Information about the job error.
        public var importAssetFromSignedUrlJobErrorDetails: DataExchangeClientTypes.ImportAssetFromSignedUrlJobErrorDetails?
        /// Details about the job error.
        public var importAssetsFromS3JobErrorDetails: [DataExchangeClientTypes.AssetSourceEntry]?

        public init(
            importAssetFromSignedUrlJobErrorDetails: DataExchangeClientTypes.ImportAssetFromSignedUrlJobErrorDetails? = nil,
            importAssetsFromS3JobErrorDetails: [DataExchangeClientTypes.AssetSourceEntry]? = nil
        )
        {
            self.importAssetFromSignedUrlJobErrorDetails = importAssetFromSignedUrlJobErrorDetails
            self.importAssetsFromS3JobErrorDetails = importAssetsFromS3JobErrorDetails
        }
    }

}

extension DataExchangeClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revisionPublished = "RevisionPublished"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revisionPublished = self.revisionPublished {
            try encodeContainer.encode(revisionPublished, forKey: .revisionPublished)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionPublishedDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.RevisionPublished.self, forKey: .revisionPublished)
        revisionPublished = revisionPublishedDecoded
    }
}

extension DataExchangeClientTypes {
    /// What occurs to start an action.
    public struct Event {
        /// What occurs to start the revision publish action.
        public var revisionPublished: DataExchangeClientTypes.RevisionPublished?

        public init(
            revisionPublished: DataExchangeClientTypes.RevisionPublished? = nil
        )
        {
            self.revisionPublished = revisionPublished
        }
    }

}

extension DataExchangeClientTypes.EventActionEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case event = "Event"
        case id = "Id"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let eventDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataExchangeClientTypes {
    /// An event action is an object that defines the relationship between a specific event and an automated action that will be taken on behalf of the customer.
    public struct EventActionEntry {
        /// What occurs after a certain event.
        /// This member is required.
        public var action: DataExchangeClientTypes.Action?
        /// The Amazon Resource Name (ARN) for the event action.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the event action was created, in ISO 8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// What occurs to start an action.
        /// This member is required.
        public var event: DataExchangeClientTypes.Event?
        /// The unique identifier for the event action.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time that the event action was last updated, in ISO 8601 format.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            action: DataExchangeClientTypes.Action? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            event: DataExchangeClientTypes.Event? = nil,
            id: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.event = event
            self.id = id
            self.updatedAt = updatedAt
        }
    }

}

extension DataExchangeClientTypes {
    public enum ExceptionCause: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insufficients3bucketpolicy
        case s3accessdenied
        case sdkUnknown(Swift.String)

        public static var allCases: [ExceptionCause] {
            return [
                .insufficients3bucketpolicy,
                .s3accessdenied,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insufficients3bucketpolicy: return "InsufficientS3BucketPolicy"
            case .s3accessdenied: return "S3AccessDenied"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExceptionCause(rawValue: rawValue) ?? ExceptionCause.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.ExportAssetToSignedUrlRequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId = "AssetId"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details of the operation to be performed by the job.
    public struct ExportAssetToSignedUrlRequestDetails {
        /// The unique identifier for the asset that is exported to a signed URL.
        /// This member is required.
        public var assetId: Swift.String?
        /// The unique identifier for the data set associated with this export job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision associated with this export request.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ExportAssetToSignedUrlResponseDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId = "AssetId"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
        case signedUrl = "SignedUrl"
        case signedUrlExpiresAt = "SignedUrlExpiresAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let signedUrl = self.signedUrl {
            try encodeContainer.encode(signedUrl, forKey: .signedUrl)
        }
        if let signedUrlExpiresAt = self.signedUrlExpiresAt {
            try encodeContainer.encodeTimestamp(signedUrlExpiresAt, format: .dateTime, forKey: .signedUrlExpiresAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let signedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signedUrl)
        signedUrl = signedUrlDecoded
        let signedUrlExpiresAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .signedUrlExpiresAt)
        signedUrlExpiresAt = signedUrlExpiresAtDecoded
    }
}

extension DataExchangeClientTypes {
    /// The details of the export to signed URL response.
    public struct ExportAssetToSignedUrlResponseDetails {
        /// The unique identifier for the asset associated with this export job.
        /// This member is required.
        public var assetId: Swift.String?
        /// The unique identifier for the data set associated with this export job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision associated with this export response.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The signed URL for the export request.
        public var signedUrl: Swift.String?
        /// The date and time that the signed URL expires, in ISO 8601 format.
        public var signedUrlExpiresAt: ClientRuntime.Date?

        public init(
            assetId: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            signedUrl: Swift.String? = nil,
            signedUrlExpiresAt: ClientRuntime.Date? = nil
        )
        {
            self.assetId = assetId
            self.dataSetId = dataSetId
            self.revisionId = revisionId
            self.signedUrl = signedUrl
            self.signedUrlExpiresAt = signedUrlExpiresAt
        }
    }

}

extension DataExchangeClientTypes.ExportAssetsToS3RequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetDestinations = "AssetDestinations"
        case dataSetId = "DataSetId"
        case encryption = "Encryption"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetDestinations = assetDestinations {
            var assetDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetDestinations)
            for assetdestinationentry0 in assetDestinations {
                try assetDestinationsContainer.encode(assetdestinationentry0)
            }
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetDestinationsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.AssetDestinationEntry?].self, forKey: .assetDestinations)
        var assetDestinationsDecoded0:[DataExchangeClientTypes.AssetDestinationEntry]? = nil
        if let assetDestinationsContainer = assetDestinationsContainer {
            assetDestinationsDecoded0 = [DataExchangeClientTypes.AssetDestinationEntry]()
            for structure0 in assetDestinationsContainer {
                if let structure0 = structure0 {
                    assetDestinationsDecoded0?.append(structure0)
                }
            }
        }
        assetDestinations = assetDestinationsDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details of the operation to be performed by the job.
    public struct ExportAssetsToS3RequestDetails {
        /// The destination for the asset.
        /// This member is required.
        public var assetDestinations: [DataExchangeClientTypes.AssetDestinationEntry]?
        /// The unique identifier for the data set associated with this export job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// Encryption configuration for the export job.
        public var encryption: DataExchangeClientTypes.ExportServerSideEncryption?
        /// The unique identifier for the revision associated with this export request.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetDestinations: [DataExchangeClientTypes.AssetDestinationEntry]? = nil,
            dataSetId: Swift.String? = nil,
            encryption: DataExchangeClientTypes.ExportServerSideEncryption? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetDestinations = assetDestinations
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ExportAssetsToS3ResponseDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetDestinations = "AssetDestinations"
        case dataSetId = "DataSetId"
        case encryption = "Encryption"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetDestinations = assetDestinations {
            var assetDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetDestinations)
            for assetdestinationentry0 in assetDestinations {
                try assetDestinationsContainer.encode(assetdestinationentry0)
            }
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetDestinationsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.AssetDestinationEntry?].self, forKey: .assetDestinations)
        var assetDestinationsDecoded0:[DataExchangeClientTypes.AssetDestinationEntry]? = nil
        if let assetDestinationsContainer = assetDestinationsContainer {
            assetDestinationsDecoded0 = [DataExchangeClientTypes.AssetDestinationEntry]()
            for structure0 in assetDestinationsContainer {
                if let structure0 = structure0 {
                    assetDestinationsDecoded0?.append(structure0)
                }
            }
        }
        assetDestinations = assetDestinationsDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details about the export to Amazon S3 response.
    public struct ExportAssetsToS3ResponseDetails {
        /// The destination in Amazon S3 where the asset is exported.
        /// This member is required.
        public var assetDestinations: [DataExchangeClientTypes.AssetDestinationEntry]?
        /// The unique identifier for the data set associated with this export job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// Encryption configuration of the export job.
        public var encryption: DataExchangeClientTypes.ExportServerSideEncryption?
        /// The unique identifier for the revision associated with this export response.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetDestinations: [DataExchangeClientTypes.AssetDestinationEntry]? = nil,
            dataSetId: Swift.String? = nil,
            encryption: DataExchangeClientTypes.ExportServerSideEncryption? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetDestinations = assetDestinations
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ExportRevisionsToS3RequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetId = "DataSetId"
        case encryption = "Encryption"
        case revisionDestinations = "RevisionDestinations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let revisionDestinations = revisionDestinations {
            var revisionDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revisionDestinations)
            for revisiondestinationentry0 in revisionDestinations {
                try revisionDestinationsContainer.encode(revisiondestinationentry0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionDestinationsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.RevisionDestinationEntry?].self, forKey: .revisionDestinations)
        var revisionDestinationsDecoded0:[DataExchangeClientTypes.RevisionDestinationEntry]? = nil
        if let revisionDestinationsContainer = revisionDestinationsContainer {
            revisionDestinationsDecoded0 = [DataExchangeClientTypes.RevisionDestinationEntry]()
            for structure0 in revisionDestinationsContainer {
                if let structure0 = structure0 {
                    revisionDestinationsDecoded0?.append(structure0)
                }
            }
        }
        revisionDestinations = revisionDestinationsDecoded0
    }
}

extension DataExchangeClientTypes {
    /// Details of the operation to be performed by the job.
    public struct ExportRevisionsToS3RequestDetails {
        /// The unique identifier for the data set associated with this export job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// Encryption configuration for the export job.
        public var encryption: DataExchangeClientTypes.ExportServerSideEncryption?
        /// The destination for the revision.
        /// This member is required.
        public var revisionDestinations: [DataExchangeClientTypes.RevisionDestinationEntry]?

        public init(
            dataSetId: Swift.String? = nil,
            encryption: DataExchangeClientTypes.ExportServerSideEncryption? = nil,
            revisionDestinations: [DataExchangeClientTypes.RevisionDestinationEntry]? = nil
        )
        {
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.revisionDestinations = revisionDestinations
        }
    }

}

extension DataExchangeClientTypes.ExportRevisionsToS3ResponseDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetId = "DataSetId"
        case encryption = "Encryption"
        case eventActionArn = "EventActionArn"
        case revisionDestinations = "RevisionDestinations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let encryption = self.encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let eventActionArn = self.eventActionArn {
            try encodeContainer.encode(eventActionArn, forKey: .eventActionArn)
        }
        if let revisionDestinations = revisionDestinations {
            var revisionDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .revisionDestinations)
            for revisiondestinationentry0 in revisionDestinations {
                try revisionDestinationsContainer.encode(revisiondestinationentry0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportServerSideEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let revisionDestinationsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.RevisionDestinationEntry?].self, forKey: .revisionDestinations)
        var revisionDestinationsDecoded0:[DataExchangeClientTypes.RevisionDestinationEntry]? = nil
        if let revisionDestinationsContainer = revisionDestinationsContainer {
            revisionDestinationsDecoded0 = [DataExchangeClientTypes.RevisionDestinationEntry]()
            for structure0 in revisionDestinationsContainer {
                if let structure0 = structure0 {
                    revisionDestinationsDecoded0?.append(structure0)
                }
            }
        }
        revisionDestinations = revisionDestinationsDecoded0
        let eventActionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventActionArn)
        eventActionArn = eventActionArnDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details about the export revisions to Amazon S3 response.
    public struct ExportRevisionsToS3ResponseDetails {
        /// The unique identifier for the data set associated with this export job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// Encryption configuration of the export job.
        public var encryption: DataExchangeClientTypes.ExportServerSideEncryption?
        /// The Amazon Resource Name (ARN) of the event action.
        public var eventActionArn: Swift.String?
        /// The destination in Amazon S3 where the revision is exported.
        /// This member is required.
        public var revisionDestinations: [DataExchangeClientTypes.RevisionDestinationEntry]?

        public init(
            dataSetId: Swift.String? = nil,
            encryption: DataExchangeClientTypes.ExportServerSideEncryption? = nil,
            eventActionArn: Swift.String? = nil,
            revisionDestinations: [DataExchangeClientTypes.RevisionDestinationEntry]? = nil
        )
        {
            self.dataSetId = dataSetId
            self.encryption = encryption
            self.eventActionArn = eventActionArn
            self.revisionDestinations = revisionDestinations
        }
    }

}

extension DataExchangeClientTypes.ExportServerSideEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn = "KmsKeyArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ServerSideEncryptionTypes.self, forKey: .type)
        type = typeDecoded
    }
}

extension DataExchangeClientTypes {
    /// Encryption configuration of the export job. Includes the encryption type in addition to the AWS KMS key. The KMS key is only necessary if you chose the KMS encryption type.
    public struct ExportServerSideEncryption {
        /// The Amazon Resource Name (ARN) of the AWS KMS key you want to use to encrypt the Amazon S3 objects. This parameter is required if you choose aws:kms as an encryption type.
        public var kmsKeyArn: Swift.String?
        /// The type of server side encryption used for encrypting the objects in Amazon S3.
        /// This member is required.
        public var type: DataExchangeClientTypes.ServerSideEncryptionTypes?

        public init(
            kmsKeyArn: Swift.String? = nil,
            type: DataExchangeClientTypes.ServerSideEncryptionTypes? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.type = type
        }
    }

}

extension GetAssetInput {

    static func urlPathProvider(_ value: GetAssetInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let revisionId = value.revisionId else {
            return nil
        }
        guard let assetId = value.assetId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())/assets/\(assetId.urlPercentEncoding())"
    }
}

public struct GetAssetInput {
    /// The unique identifier for an asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

struct GetAssetInputBody {
}

extension GetAssetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssetOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.assetDetails = output.assetDetails
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.id = output.id
            self.name = output.name
            self.revisionId = output.revisionId
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetDetails = nil
            self.assetType = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.id = nil
            self.name = nil
            self.revisionId = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct GetAssetOutput {
    /// The ARN for the asset.
    public var arn: Swift.String?
    /// Details about the asset.
    public var assetDetails: DataExchangeClientTypes.AssetDetails?
    /// The type of asset that is added to a data set.
    public var assetType: DataExchangeClientTypes.AssetType?
    /// The date and time that the asset was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The unique identifier for the data set associated with this asset.
    public var dataSetId: Swift.String?
    /// The unique identifier for the asset.
    public var id: Swift.String?
    /// The name of the asset. When importing from Amazon S3, the Amazon S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target Amazon S3 object key. When importing from Amazon API Gateway API, the API name is used as the asset name. When importing from Amazon Redshift, the datashare name is used as the asset name. When importing from AWS Lake Formation, the static values of "Database(s) included in the LF-tag policy" or "Table(s) included in the LF-tag policy" are used as the asset name.
    public var name: Swift.String?
    /// The unique identifier for the revision associated with this asset.
    public var revisionId: Swift.String?
    /// The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.
    public var sourceId: Swift.String?
    /// The date and time that the asset was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        assetDetails: DataExchangeClientTypes.AssetDetails? = nil,
        assetType: DataExchangeClientTypes.AssetType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        dataSetId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        sourceId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.assetDetails = assetDetails
        self.assetType = assetType
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.id = id
        self.name = name
        self.revisionId = revisionId
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct GetAssetOutputBody {
    let arn: Swift.String?
    let assetDetails: DataExchangeClientTypes.AssetDetails?
    let assetType: DataExchangeClientTypes.AssetType?
    let createdAt: ClientRuntime.Date?
    let dataSetId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let revisionId: Swift.String?
    let sourceId: Swift.String?
    let updatedAt: ClientRuntime.Date?
}

extension GetAssetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetDetails = "AssetDetails"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case id = "Id"
        case name = "Name"
        case revisionId = "RevisionId"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetDetails.self, forKey: .assetDetails)
        assetDetails = assetDetailsDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetAssetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataSetInput {

    static func urlPathProvider(_ value: GetDataSetInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())"
    }
}

public struct GetDataSetInput {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init(
        dataSetId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
    }
}

struct GetDataSetInputBody {
}

extension GetDataSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.origin = output.origin
            self.originDetails = output.originDetails
            self.sourceId = output.sourceId
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetType = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.origin = nil
            self.originDetails = nil
            self.sourceId = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDataSetOutput {
    /// The ARN for the data set.
    public var arn: Swift.String?
    /// The type of asset that is added to a data set.
    public var assetType: DataExchangeClientTypes.AssetType?
    /// The date and time that the data set was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The description for the data set.
    public var description: Swift.String?
    /// The unique identifier for the data set.
    public var id: Swift.String?
    /// The name of the data set.
    public var name: Swift.String?
    /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
    public var origin: DataExchangeClientTypes.Origin?
    /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
    public var originDetails: DataExchangeClientTypes.OriginDetails?
    /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
    public var sourceId: Swift.String?
    /// The tags for the data set.
    public var tags: [Swift.String:Swift.String]?
    /// The date and time that the data set was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        assetType: DataExchangeClientTypes.AssetType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        origin: DataExchangeClientTypes.Origin? = nil,
        originDetails: DataExchangeClientTypes.OriginDetails? = nil,
        sourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.assetType = assetType
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.origin = origin
        self.originDetails = originDetails
        self.sourceId = sourceId
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetDataSetOutputBody {
    let arn: Swift.String?
    let assetType: DataExchangeClientTypes.AssetType?
    let createdAt: ClientRuntime.Date?
    let description: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let origin: DataExchangeClientTypes.Origin?
    let originDetails: DataExchangeClientTypes.OriginDetails?
    let sourceId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let updatedAt: ClientRuntime.Date?
}

extension GetDataSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case origin = "Origin"
        case originDetails = "OriginDetails"
        case sourceId = "SourceId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let originDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Origin.self, forKey: .origin)
        origin = originDecoded
        let originDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.OriginDetails.self, forKey: .originDetails)
        originDetails = originDetailsDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetDataSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEventActionInput {

    static func urlPathProvider(_ value: GetEventActionInput) -> Swift.String? {
        guard let eventActionId = value.eventActionId else {
            return nil
        }
        return "/v1/event-actions/\(eventActionId.urlPercentEncoding())"
    }
}

public struct GetEventActionInput {
    /// The unique identifier for the event action.
    /// This member is required.
    public var eventActionId: Swift.String?

    public init(
        eventActionId: Swift.String? = nil
    )
    {
        self.eventActionId = eventActionId
    }
}

struct GetEventActionInputBody {
}

extension GetEventActionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEventActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEventActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.event = output.event
            self.id = output.id
            self.updatedAt = output.updatedAt
        } else {
            self.action = nil
            self.arn = nil
            self.createdAt = nil
            self.event = nil
            self.id = nil
            self.updatedAt = nil
        }
    }
}

public struct GetEventActionOutput {
    /// What occurs after a certain event.
    public var action: DataExchangeClientTypes.Action?
    /// The ARN for the event action.
    public var arn: Swift.String?
    /// The date and time that the event action was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// What occurs to start an action.
    public var event: DataExchangeClientTypes.Event?
    /// The unique identifier for the event action.
    public var id: Swift.String?
    /// The date and time that the event action was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        action: DataExchangeClientTypes.Action? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        event: DataExchangeClientTypes.Event? = nil,
        id: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.createdAt = createdAt
        self.event = event
        self.id = id
        self.updatedAt = updatedAt
    }
}

struct GetEventActionOutputBody {
    let action: DataExchangeClientTypes.Action?
    let arn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let event: DataExchangeClientTypes.Event?
    let id: Swift.String?
    let updatedAt: ClientRuntime.Date?
}

extension GetEventActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case event = "Event"
        case id = "Id"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let eventDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetEventActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetJobInput {

    static func urlPathProvider(_ value: GetJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/v1/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct GetJobInput {
    /// The unique identifier for a job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobInputBody {
}

extension GetJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.details = output.details
            self.errors = output.errors
            self.id = output.id
            self.state = output.state
            self.type = output.type
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.details = nil
            self.errors = nil
            self.id = nil
            self.state = nil
            self.type = nil
            self.updatedAt = nil
        }
    }
}

public struct GetJobOutput {
    /// The ARN for the job.
    public var arn: Swift.String?
    /// The date and time that the job was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// Details about the job.
    public var details: DataExchangeClientTypes.ResponseDetails?
    /// The errors associated with jobs.
    public var errors: [DataExchangeClientTypes.JobError]?
    /// The unique identifier for the job.
    public var id: Swift.String?
    /// The state of the job.
    public var state: DataExchangeClientTypes.State?
    /// The job type.
    public var type: DataExchangeClientTypes.ModelType?
    /// The date and time that the job was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        details: DataExchangeClientTypes.ResponseDetails? = nil,
        errors: [DataExchangeClientTypes.JobError]? = nil,
        id: Swift.String? = nil,
        state: DataExchangeClientTypes.State? = nil,
        type: DataExchangeClientTypes.ModelType? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.details = details
        self.errors = errors
        self.id = id
        self.state = state
        self.type = type
        self.updatedAt = updatedAt
    }
}

struct GetJobOutputBody {
    let arn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let details: DataExchangeClientTypes.ResponseDetails?
    let errors: [DataExchangeClientTypes.JobError]?
    let id: Swift.String?
    let state: DataExchangeClientTypes.State?
    let type: DataExchangeClientTypes.ModelType?
    let updatedAt: ClientRuntime.Date?
}

extension GetJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case details = "Details"
        case errors = "Errors"
        case id = "Id"
        case state = "State"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ResponseDetails.self, forKey: .details)
        details = detailsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.JobError?].self, forKey: .errors)
        var errorsDecoded0:[DataExchangeClientTypes.JobError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [DataExchangeClientTypes.JobError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRevisionInput {

    static func urlPathProvider(_ value: GetRevisionInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let revisionId = value.revisionId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())"
    }
}

public struct GetRevisionInput {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.revisionId = revisionId
    }
}

struct GetRevisionInputBody {
}

extension GetRevisionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRevisionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRevisionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.comment = output.comment
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.finalized = output.finalized
            self.id = output.id
            self.revocationComment = output.revocationComment
            self.revoked = output.revoked
            self.revokedAt = output.revokedAt
            self.sourceId = output.sourceId
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.comment = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.finalized = nil
            self.id = nil
            self.revocationComment = nil
            self.revoked = nil
            self.revokedAt = nil
            self.sourceId = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetRevisionOutput {
    /// The ARN for the revision.
    public var arn: Swift.String?
    /// An optional comment about the revision.
    public var comment: Swift.String?
    /// The date and time that the revision was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The unique identifier for the data set associated with the data set revision.
    public var dataSetId: Swift.String?
    /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
    public var finalized: Swift.Bool?
    /// The unique identifier for the revision.
    public var id: Swift.String?
    /// A required comment to inform subscribers of the reason their access to the revision was revoked.
    public var revocationComment: Swift.String?
    /// A status indicating that subscribers' access to the revision was revoked.
    public var revoked: Swift.Bool?
    /// The date and time that the revision was revoked, in ISO 8601 format.
    public var revokedAt: ClientRuntime.Date?
    /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
    public var sourceId: Swift.String?
    /// The tags for the revision.
    public var tags: [Swift.String:Swift.String]?
    /// The date and time that the revision was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        comment: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        dataSetId: Swift.String? = nil,
        finalized: Swift.Bool? = nil,
        id: Swift.String? = nil,
        revocationComment: Swift.String? = nil,
        revoked: Swift.Bool? = nil,
        revokedAt: ClientRuntime.Date? = nil,
        sourceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.comment = comment
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.id = id
        self.revocationComment = revocationComment
        self.revoked = revoked
        self.revokedAt = revokedAt
        self.sourceId = sourceId
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetRevisionOutputBody {
    let arn: Swift.String?
    let comment: Swift.String?
    let createdAt: ClientRuntime.Date?
    let dataSetId: Swift.String?
    let finalized: Swift.Bool?
    let id: Swift.String?
    let sourceId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let updatedAt: ClientRuntime.Date?
    let revocationComment: Swift.String?
    let revoked: Swift.Bool?
    let revokedAt: ClientRuntime.Date?
}

extension GetRevisionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case revocationComment = "RevocationComment"
        case revoked = "Revoked"
        case revokedAt = "RevokedAt"
        case sourceId = "SourceId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let revocationCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revocationComment)
        revocationComment = revocationCommentDecoded
        let revokedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .revoked)
        revoked = revokedDecoded
        let revokedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
    }
}

enum GetRevisionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataExchangeClientTypes.ImportAssetFromApiGatewayApiRequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDescription = "ApiDescription"
        case apiId = "ApiId"
        case apiKey = "ApiKey"
        case apiName = "ApiName"
        case apiSpecificationMd5Hash = "ApiSpecificationMd5Hash"
        case dataSetId = "DataSetId"
        case protocolType = "ProtocolType"
        case revisionId = "RevisionId"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiDescription = self.apiDescription {
            try encodeContainer.encode(apiDescription, forKey: .apiDescription)
        }
        if let apiId = self.apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiKey = self.apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let apiName = self.apiName {
            try encodeContainer.encode(apiName, forKey: .apiName)
        }
        if let apiSpecificationMd5Hash = self.apiSpecificationMd5Hash {
            try encodeContainer.encode(apiSpecificationMd5Hash, forKey: .apiSpecificationMd5Hash)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let protocolType = self.protocolType {
            try encodeContainer.encode(protocolType.rawValue, forKey: .protocolType)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDescription)
        apiDescription = apiDescriptionDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let apiNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiName)
        apiName = apiNameDecoded
        let apiSpecificationMd5HashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiSpecificationMd5Hash)
        apiSpecificationMd5Hash = apiSpecificationMd5HashDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension DataExchangeClientTypes {
    /// The request details.
    public struct ImportAssetFromApiGatewayApiRequestDetails {
        /// The API description. Markdown supported.
        public var apiDescription: Swift.String?
        /// The API Gateway API ID.
        /// This member is required.
        public var apiId: Swift.String?
        /// The API Gateway API key.
        public var apiKey: Swift.String?
        /// The API name.
        /// This member is required.
        public var apiName: Swift.String?
        /// The Base64-encoded MD5 hash of the OpenAPI 3.0 JSON API specification file. It is used to ensure the integrity of the file.
        /// This member is required.
        public var apiSpecificationMd5Hash: Swift.String?
        /// The data set ID.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The protocol type.
        /// This member is required.
        public var protocolType: DataExchangeClientTypes.ProtocolType?
        /// The revision ID.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The API stage.
        /// This member is required.
        public var stage: Swift.String?

        public init(
            apiDescription: Swift.String? = nil,
            apiId: Swift.String? = nil,
            apiKey: Swift.String? = nil,
            apiName: Swift.String? = nil,
            apiSpecificationMd5Hash: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            protocolType: DataExchangeClientTypes.ProtocolType? = nil,
            revisionId: Swift.String? = nil,
            stage: Swift.String? = nil
        )
        {
            self.apiDescription = apiDescription
            self.apiId = apiId
            self.apiKey = apiKey
            self.apiName = apiName
            self.apiSpecificationMd5Hash = apiSpecificationMd5Hash
            self.dataSetId = dataSetId
            self.protocolType = protocolType
            self.revisionId = revisionId
            self.stage = stage
        }
    }

}

extension DataExchangeClientTypes.ImportAssetFromApiGatewayApiResponseDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiDescription = "ApiDescription"
        case apiId = "ApiId"
        case apiKey = "ApiKey"
        case apiName = "ApiName"
        case apiSpecificationMd5Hash = "ApiSpecificationMd5Hash"
        case apiSpecificationUploadUrl = "ApiSpecificationUploadUrl"
        case apiSpecificationUploadUrlExpiresAt = "ApiSpecificationUploadUrlExpiresAt"
        case dataSetId = "DataSetId"
        case protocolType = "ProtocolType"
        case revisionId = "RevisionId"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiDescription = self.apiDescription {
            try encodeContainer.encode(apiDescription, forKey: .apiDescription)
        }
        if let apiId = self.apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiKey = self.apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let apiName = self.apiName {
            try encodeContainer.encode(apiName, forKey: .apiName)
        }
        if let apiSpecificationMd5Hash = self.apiSpecificationMd5Hash {
            try encodeContainer.encode(apiSpecificationMd5Hash, forKey: .apiSpecificationMd5Hash)
        }
        if let apiSpecificationUploadUrl = self.apiSpecificationUploadUrl {
            try encodeContainer.encode(apiSpecificationUploadUrl, forKey: .apiSpecificationUploadUrl)
        }
        if let apiSpecificationUploadUrlExpiresAt = self.apiSpecificationUploadUrlExpiresAt {
            try encodeContainer.encodeTimestamp(apiSpecificationUploadUrlExpiresAt, format: .dateTime, forKey: .apiSpecificationUploadUrlExpiresAt)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let protocolType = self.protocolType {
            try encodeContainer.encode(protocolType.rawValue, forKey: .protocolType)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiDescription)
        apiDescription = apiDescriptionDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let apiNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiName)
        apiName = apiNameDecoded
        let apiSpecificationMd5HashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiSpecificationMd5Hash)
        apiSpecificationMd5Hash = apiSpecificationMd5HashDecoded
        let apiSpecificationUploadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiSpecificationUploadUrl)
        apiSpecificationUploadUrl = apiSpecificationUploadUrlDecoded
        let apiSpecificationUploadUrlExpiresAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .apiSpecificationUploadUrlExpiresAt)
        apiSpecificationUploadUrlExpiresAt = apiSpecificationUploadUrlExpiresAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension DataExchangeClientTypes {
    /// The response details.
    public struct ImportAssetFromApiGatewayApiResponseDetails {
        /// The API description.
        public var apiDescription: Swift.String?
        /// The API ID.
        /// This member is required.
        public var apiId: Swift.String?
        /// The API key.
        public var apiKey: Swift.String?
        /// The API name.
        /// This member is required.
        public var apiName: Swift.String?
        /// The Base64-encoded Md5 hash for the API asset, used to ensure the integrity of the API at that location.
        /// This member is required.
        public var apiSpecificationMd5Hash: Swift.String?
        /// The upload URL of the API specification.
        /// This member is required.
        public var apiSpecificationUploadUrl: Swift.String?
        /// The date and time that the upload URL expires, in ISO 8601 format.
        /// This member is required.
        public var apiSpecificationUploadUrlExpiresAt: ClientRuntime.Date?
        /// The data set ID.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The protocol type.
        /// This member is required.
        public var protocolType: DataExchangeClientTypes.ProtocolType?
        /// The revision ID.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The API stage.
        /// This member is required.
        public var stage: Swift.String?

        public init(
            apiDescription: Swift.String? = nil,
            apiId: Swift.String? = nil,
            apiKey: Swift.String? = nil,
            apiName: Swift.String? = nil,
            apiSpecificationMd5Hash: Swift.String? = nil,
            apiSpecificationUploadUrl: Swift.String? = nil,
            apiSpecificationUploadUrlExpiresAt: ClientRuntime.Date? = nil,
            dataSetId: Swift.String? = nil,
            protocolType: DataExchangeClientTypes.ProtocolType? = nil,
            revisionId: Swift.String? = nil,
            stage: Swift.String? = nil
        )
        {
            self.apiDescription = apiDescription
            self.apiId = apiId
            self.apiKey = apiKey
            self.apiName = apiName
            self.apiSpecificationMd5Hash = apiSpecificationMd5Hash
            self.apiSpecificationUploadUrl = apiSpecificationUploadUrl
            self.apiSpecificationUploadUrlExpiresAt = apiSpecificationUploadUrlExpiresAt
            self.dataSetId = dataSetId
            self.protocolType = protocolType
            self.revisionId = revisionId
            self.stage = stage
        }
    }

}

extension DataExchangeClientTypes.ImportAssetFromSignedUrlJobErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetName = "AssetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetName = self.assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details about the job error.
    public struct ImportAssetFromSignedUrlJobErrorDetails {
        /// Details about the job error.
        /// This member is required.
        public var assetName: Swift.String?

        public init(
            assetName: Swift.String? = nil
        )
        {
            self.assetName = assetName
        }
    }

}

extension DataExchangeClientTypes.ImportAssetFromSignedUrlRequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetName = "AssetName"
        case dataSetId = "DataSetId"
        case md5Hash = "Md5Hash"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetName = self.assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let md5Hash = self.md5Hash {
            try encodeContainer.encode(md5Hash, forKey: .md5Hash)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let md5HashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .md5Hash)
        md5Hash = md5HashDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details of the operation to be performed by the job.
    public struct ImportAssetFromSignedUrlRequestDetails {
        /// The name of the asset. When importing from Amazon S3, the Amazon S3 object key is used as the asset name.
        /// This member is required.
        public var assetName: Swift.String?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The Base64-encoded Md5 hash for the asset, used to ensure the integrity of the file at that location.
        /// This member is required.
        public var md5Hash: Swift.String?
        /// The unique identifier for the revision associated with this import request.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetName: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            md5Hash: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetName = assetName
            self.dataSetId = dataSetId
            self.md5Hash = md5Hash
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ImportAssetFromSignedUrlResponseDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetName = "AssetName"
        case dataSetId = "DataSetId"
        case md5Hash = "Md5Hash"
        case revisionId = "RevisionId"
        case signedUrl = "SignedUrl"
        case signedUrlExpiresAt = "SignedUrlExpiresAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetName = self.assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let md5Hash = self.md5Hash {
            try encodeContainer.encode(md5Hash, forKey: .md5Hash)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let signedUrl = self.signedUrl {
            try encodeContainer.encode(signedUrl, forKey: .signedUrl)
        }
        if let signedUrlExpiresAt = self.signedUrlExpiresAt {
            try encodeContainer.encodeTimestamp(signedUrlExpiresAt, format: .dateTime, forKey: .signedUrlExpiresAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let md5HashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .md5Hash)
        md5Hash = md5HashDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let signedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signedUrl)
        signedUrl = signedUrlDecoded
        let signedUrlExpiresAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .signedUrlExpiresAt)
        signedUrlExpiresAt = signedUrlExpiresAtDecoded
    }
}

extension DataExchangeClientTypes {
    /// The details in the response for an import request, including the signed URL and other information.
    public struct ImportAssetFromSignedUrlResponseDetails {
        /// The name for the asset associated with this import job.
        /// This member is required.
        public var assetName: Swift.String?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The Base64-encoded Md5 hash for the asset, used to ensure the integrity of the file at that location.
        public var md5Hash: Swift.String?
        /// The unique identifier for the revision associated with this import response.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The signed URL.
        public var signedUrl: Swift.String?
        /// The time and date at which the signed URL expires, in ISO 8601 format.
        public var signedUrlExpiresAt: ClientRuntime.Date?

        public init(
            assetName: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            md5Hash: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            signedUrl: Swift.String? = nil,
            signedUrlExpiresAt: ClientRuntime.Date? = nil
        )
        {
            self.assetName = assetName
            self.dataSetId = dataSetId
            self.md5Hash = md5Hash
            self.revisionId = revisionId
            self.signedUrl = signedUrl
            self.signedUrlExpiresAt = signedUrlExpiresAt
        }
    }

}

extension DataExchangeClientTypes.ImportAssetsFromLakeFormationTagPolicyRequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case dataSetId = "DataSetId"
        case database = "Database"
        case revisionId = "RevisionId"
        case roleArn = "RoleArn"
        case table = "Table"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let table = self.table {
            try encodeContainer.encode(table, forKey: .table)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.DatabaseLFTagPolicyAndPermissions.self, forKey: .database)
        database = databaseDecoded
        let tableDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.TableLFTagPolicyAndPermissions.self, forKey: .table)
        table = tableDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details about the assets imported from an AWS Lake Formation tag policy request.
    public struct ImportAssetsFromLakeFormationTagPolicyRequestDetails {
        /// The identifier for the AWS Glue Data Catalog.
        /// This member is required.
        public var catalogId: Swift.String?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// A structure for the database object.
        public var database: DataExchangeClientTypes.DatabaseLFTagPolicyAndPermissions?
        /// The unique identifier for the revision associated with this import job.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The IAM role's ARN that allows AWS Data Exchange to assume the role and grant and revoke permissions of subscribers to AWS Lake Formation data permissions.
        /// This member is required.
        public var roleArn: Swift.String?
        /// A structure for the table object.
        public var table: DataExchangeClientTypes.TableLFTagPolicyAndPermissions?

        public init(
            catalogId: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            database: DataExchangeClientTypes.DatabaseLFTagPolicyAndPermissions? = nil,
            revisionId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            table: DataExchangeClientTypes.TableLFTagPolicyAndPermissions? = nil
        )
        {
            self.catalogId = catalogId
            self.dataSetId = dataSetId
            self.database = database
            self.revisionId = revisionId
            self.roleArn = roleArn
            self.table = table
        }
    }

}

extension DataExchangeClientTypes.ImportAssetsFromLakeFormationTagPolicyResponseDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case dataSetId = "DataSetId"
        case database = "Database"
        case revisionId = "RevisionId"
        case roleArn = "RoleArn"
        case table = "Table"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let table = self.table {
            try encodeContainer.encode(table, forKey: .table)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.DatabaseLFTagPolicyAndPermissions.self, forKey: .database)
        database = databaseDecoded
        let tableDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.TableLFTagPolicyAndPermissions.self, forKey: .table)
        table = tableDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details from an import AWS Lake Formation tag policy job response.
    public struct ImportAssetsFromLakeFormationTagPolicyResponseDetails {
        /// The identifier for the AWS Glue Data Catalog.
        /// This member is required.
        public var catalogId: Swift.String?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// A structure for the database object.
        public var database: DataExchangeClientTypes.DatabaseLFTagPolicyAndPermissions?
        /// The unique identifier for the revision associated with this import job.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The IAM role's ARN that allows AWS Data Exchange to assume the role and grant and revoke permissions to AWS Lake Formation data permissions.
        /// This member is required.
        public var roleArn: Swift.String?
        /// A structure for the table object.
        public var table: DataExchangeClientTypes.TableLFTagPolicyAndPermissions?

        public init(
            catalogId: Swift.String? = nil,
            dataSetId: Swift.String? = nil,
            database: DataExchangeClientTypes.DatabaseLFTagPolicyAndPermissions? = nil,
            revisionId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            table: DataExchangeClientTypes.TableLFTagPolicyAndPermissions? = nil
        )
        {
            self.catalogId = catalogId
            self.dataSetId = dataSetId
            self.database = database
            self.revisionId = revisionId
            self.roleArn = roleArn
            self.table = table
        }
    }

}

extension DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesRequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSources = "AssetSources"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetSources = assetSources {
            var assetSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetSources)
            for redshiftdatashareassetsourceentry0 in assetSources {
                try assetSourcesContainer.encode(redshiftdatashareassetsourceentry0)
            }
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSourcesContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry?].self, forKey: .assetSources)
        var assetSourcesDecoded0:[DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]? = nil
        if let assetSourcesContainer = assetSourcesContainer {
            assetSourcesDecoded0 = [DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]()
            for structure0 in assetSourcesContainer {
                if let structure0 = structure0 {
                    assetSourcesDecoded0?.append(structure0)
                }
            }
        }
        assetSources = assetSourcesDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details from an import from Amazon Redshift datashare request.
    public struct ImportAssetsFromRedshiftDataSharesRequestDetails {
        /// A list of Amazon Redshift datashare assets.
        /// This member is required.
        public var assetSources: [DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision associated with this import job.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetSources: [DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesResponseDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSources = "AssetSources"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetSources = assetSources {
            var assetSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetSources)
            for redshiftdatashareassetsourceentry0 in assetSources {
                try assetSourcesContainer.encode(redshiftdatashareassetsourceentry0)
            }
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSourcesContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry?].self, forKey: .assetSources)
        var assetSourcesDecoded0:[DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]? = nil
        if let assetSourcesContainer = assetSourcesContainer {
            assetSourcesDecoded0 = [DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]()
            for structure0 in assetSourcesContainer {
                if let structure0 = structure0 {
                    assetSourcesDecoded0?.append(structure0)
                }
            }
        }
        assetSources = assetSourcesDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details from an import from Amazon Redshift datashare response.
    public struct ImportAssetsFromRedshiftDataSharesResponseDetails {
        /// A list of Amazon Redshift datashare asset sources.
        /// This member is required.
        public var assetSources: [DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision associated with this import job.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetSources: [DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry]? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ImportAssetsFromS3RequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSources = "AssetSources"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetSources = assetSources {
            var assetSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetSources)
            for assetsourceentry0 in assetSources {
                try assetSourcesContainer.encode(assetsourceentry0)
            }
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSourcesContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.AssetSourceEntry?].self, forKey: .assetSources)
        var assetSourcesDecoded0:[DataExchangeClientTypes.AssetSourceEntry]? = nil
        if let assetSourcesContainer = assetSourcesContainer {
            assetSourcesDecoded0 = [DataExchangeClientTypes.AssetSourceEntry]()
            for structure0 in assetSourcesContainer {
                if let structure0 = structure0 {
                    assetSourcesDecoded0?.append(structure0)
                }
            }
        }
        assetSources = assetSourcesDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details of the operation to be performed by the job.
    public struct ImportAssetsFromS3RequestDetails {
        /// Is a list of Amazon S3 bucket and object key pairs.
        /// This member is required.
        public var assetSources: [DataExchangeClientTypes.AssetSourceEntry]?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision associated with this import request.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetSources: [DataExchangeClientTypes.AssetSourceEntry]? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.ImportAssetsFromS3ResponseDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSources = "AssetSources"
        case dataSetId = "DataSetId"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetSources = assetSources {
            var assetSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetSources)
            for assetsourceentry0 in assetSources {
                try assetSourcesContainer.encode(assetsourceentry0)
            }
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSourcesContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.AssetSourceEntry?].self, forKey: .assetSources)
        var assetSourcesDecoded0:[DataExchangeClientTypes.AssetSourceEntry]? = nil
        if let assetSourcesContainer = assetSourcesContainer {
            assetSourcesDecoded0 = [DataExchangeClientTypes.AssetSourceEntry]()
            for structure0 in assetSourcesContainer {
                if let structure0 = structure0 {
                    assetSourcesDecoded0?.append(structure0)
                }
            }
        }
        assetSources = assetSourcesDecoded0
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details from an import from Amazon S3 response.
    public struct ImportAssetsFromS3ResponseDetails {
        /// Is a list of Amazon S3 bucket and object key pairs.
        /// This member is required.
        public var assetSources: [DataExchangeClientTypes.AssetSourceEntry]?
        /// The unique identifier for the data set associated with this import job.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// The unique identifier for the revision associated with this import response.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            assetSources: [DataExchangeClientTypes.AssetSourceEntry]? = nil,
            dataSetId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.assetSources = assetSources
            self.dataSetId = dataSetId
            self.revisionId = revisionId
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception occurred with the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message identifying the service exception that occurred.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataExchangeClientTypes.JobEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case details = "Details"
        case errors = "Errors"
        case id = "Id"
        case state = "State"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for joberror0 in errors {
                try errorsContainer.encode(joberror0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ResponseDetails.self, forKey: .details)
        details = detailsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.JobError?].self, forKey: .errors)
        var errorsDecoded0:[DataExchangeClientTypes.JobError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [DataExchangeClientTypes.JobError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension DataExchangeClientTypes {
    /// AWS Data Exchange Jobs are asynchronous import or export operations used to create or copy assets. A data set owner can both import and export as they see fit. Someone with an entitlement to a data set can only export. Jobs are deleted 90 days after they are created.
    public struct JobEntry {
        /// The ARN for the job.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the job was created, in ISO 8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Details of the operation to be performed by the job, such as export destination details or import source details.
        /// This member is required.
        public var details: DataExchangeClientTypes.ResponseDetails?
        /// Errors for jobs.
        public var errors: [DataExchangeClientTypes.JobError]?
        /// The unique identifier for the job.
        /// This member is required.
        public var id: Swift.String?
        /// The state of the job.
        /// This member is required.
        public var state: DataExchangeClientTypes.State?
        /// The job type.
        /// This member is required.
        public var type: DataExchangeClientTypes.ModelType?
        /// The date and time that the job was last updated, in ISO 8601 format.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            details: DataExchangeClientTypes.ResponseDetails? = nil,
            errors: [DataExchangeClientTypes.JobError]? = nil,
            id: Swift.String? = nil,
            state: DataExchangeClientTypes.State? = nil,
            type: DataExchangeClientTypes.ModelType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.details = details
            self.errors = errors
            self.id = id
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension DataExchangeClientTypes.JobError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case details = "Details"
        case limitName = "LimitName"
        case limitValue = "LimitValue"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let limitName = self.limitName {
            try encodeContainer.encode(limitName.rawValue, forKey: .limitName)
        }
        if let limitValue = self.limitValue {
            try encodeContainer.encode(limitValue, forKey: .limitValue)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Code.self, forKey: .code)
        code = codeDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Details.self, forKey: .details)
        details = detailsDecoded
        let limitNameDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.JobErrorLimitName.self, forKey: .limitName)
        limitName = limitNameDecoded
        let limitValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .limitValue)
        limitValue = limitValueDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.JobErrorResourceTypes.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DataExchangeClientTypes {
    /// An error that occurred with the job request.
    public struct JobError {
        /// The code for the job error.
        /// This member is required.
        public var code: DataExchangeClientTypes.Code?
        /// The details about the job error.
        public var details: DataExchangeClientTypes.Details?
        /// The name of the limit that was reached.
        public var limitName: DataExchangeClientTypes.JobErrorLimitName?
        /// The value of the exceeded limit.
        public var limitValue: Swift.Double?
        /// The message related to the job error.
        /// This member is required.
        public var message: Swift.String?
        /// The unique identifier for the resource related to the error.
        public var resourceId: Swift.String?
        /// The type of resource related to the error.
        public var resourceType: DataExchangeClientTypes.JobErrorResourceTypes?

        public init(
            code: DataExchangeClientTypes.Code? = nil,
            details: DataExchangeClientTypes.Details? = nil,
            limitName: DataExchangeClientTypes.JobErrorLimitName? = nil,
            limitValue: Swift.Double? = nil,
            message: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: DataExchangeClientTypes.JobErrorResourceTypes? = nil
        )
        {
            self.code = code
            self.details = details
            self.limitName = limitName
            self.limitValue = limitValue
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension DataExchangeClientTypes {
    public enum JobErrorLimitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsLakeFormationDataPermissionAssetsPerRevision
        case amazonRedshiftDatashareAssetsPerRevision
        case amazonS3DataAccessAssetsPerRevision
        case assetSizeInGb
        case assetsPerRevision
        case sdkUnknown(Swift.String)

        public static var allCases: [JobErrorLimitName] {
            return [
                .awsLakeFormationDataPermissionAssetsPerRevision,
                .amazonRedshiftDatashareAssetsPerRevision,
                .amazonS3DataAccessAssetsPerRevision,
                .assetSizeInGb,
                .assetsPerRevision,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsLakeFormationDataPermissionAssetsPerRevision: return "AWS Lake Formation data permission assets per revision"
            case .amazonRedshiftDatashareAssetsPerRevision: return "Amazon Redshift datashare assets per revision"
            case .amazonS3DataAccessAssetsPerRevision: return "Amazon S3 data access assets per revision"
            case .assetSizeInGb: return "Asset size in GB"
            case .assetsPerRevision: return "Assets per revision"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobErrorLimitName(rawValue: rawValue) ?? JobErrorLimitName.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes {
    public enum JobErrorResourceTypes: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asset
        case dataSet
        case revision
        case sdkUnknown(Swift.String)

        public static var allCases: [JobErrorResourceTypes] {
            return [
                .asset,
                .dataSet,
                .revision,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case .dataSet: return "DATA_SET"
            case .revision: return "REVISION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobErrorResourceTypes(rawValue: rawValue) ?? JobErrorResourceTypes.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.KmsKeyToGrant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension DataExchangeClientTypes {
    /// The Amazon Resource Name (ARN) of the AWS KMS key used to encrypt the shared S3 objects.
    public struct KmsKeyToGrant {
        /// The AWS KMS CMK (Key Management System Customer Managed Key) used to encrypt S3 objects in the shared S3 Bucket. AWS Data exchange will create a KMS grant for each subscriber to allow them to access and decrypt their entitled data that is encrypted using this KMS key specified.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension DataExchangeClientTypes {
    public enum LFPermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case describe
        case select
        case sdkUnknown(Swift.String)

        public static var allCases: [LFPermission] {
            return [
                .describe,
                .select,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .describe: return "DESCRIBE"
            case .select: return "SELECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LFPermission(rawValue: rawValue) ?? LFPermission.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.LFResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case table = "Table"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let table = self.table {
            try encodeContainer.encode(table, forKey: .table)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.DatabaseLFTagPolicy.self, forKey: .database)
        database = databaseDecoded
        let tableDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.TableLFTagPolicy.self, forKey: .table)
        table = tableDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details about the AWS Lake Formation resource (Table or Database) included in the AWS Lake Formation data permission.
    public struct LFResourceDetails {
        /// Details about the database resource included in the AWS Lake Formation data permission.
        public var database: DataExchangeClientTypes.DatabaseLFTagPolicy?
        /// Details about the table resource included in the AWS Lake Formation data permission.
        public var table: DataExchangeClientTypes.TableLFTagPolicy?

        public init(
            database: DataExchangeClientTypes.DatabaseLFTagPolicy? = nil,
            table: DataExchangeClientTypes.TableLFTagPolicy? = nil
        )
        {
            self.database = database
            self.table = table
        }
    }

}

extension DataExchangeClientTypes {
    public enum LFResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case database
        case table
        case sdkUnknown(Swift.String)

        public static var allCases: [LFResourceType] {
            return [
                .database,
                .table,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .database: return "DATABASE"
            case .table: return "TABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LFResourceType(rawValue: rawValue) ?? LFResourceType.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.LFTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKey = "TagKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for string0 in tagValues {
                try tagValuesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension DataExchangeClientTypes {
    /// A structure that allows an LF-admin to grant permissions on certain conditions.
    public struct LFTag {
        /// The key name for the LF-tag.
        /// This member is required.
        public var tagKey: Swift.String?
        /// A list of LF-tag values.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            tagKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.tagKey = tagKey
            self.tagValues = tagValues
        }
    }

}

extension DataExchangeClientTypes.LFTagPolicyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogId = "CatalogId"
        case resourceDetails = "ResourceDetails"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = self.catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let resourceDetails = self.resourceDetails {
            try encodeContainer.encode(resourceDetails, forKey: .resourceDetails)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.LFResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.LFResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details about the LF-tag policy.
    public struct LFTagPolicyDetails {
        /// The identifier for the AWS Glue Data Catalog.
        /// This member is required.
        public var catalogId: Swift.String?
        /// Details for the Lake Formation Resources included in the LF-tag policy.
        /// This member is required.
        public var resourceDetails: DataExchangeClientTypes.LFResourceDetails?
        /// The resource type for which the LF-tag policy applies.
        /// This member is required.
        public var resourceType: DataExchangeClientTypes.LFResourceType?

        public init(
            catalogId: Swift.String? = nil,
            resourceDetails: DataExchangeClientTypes.LFResourceDetails? = nil,
            resourceType: DataExchangeClientTypes.LFResourceType? = nil
        )
        {
            self.catalogId = catalogId
            self.resourceDetails = resourceDetails
            self.resourceType = resourceType
        }
    }

}

extension DataExchangeClientTypes.LakeFormationDataPermissionAsset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lakeFormationDataPermissionDetails = "LakeFormationDataPermissionDetails"
        case lakeFormationDataPermissionType = "LakeFormationDataPermissionType"
        case permissions = "Permissions"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lakeFormationDataPermissionDetails = self.lakeFormationDataPermissionDetails {
            try encodeContainer.encode(lakeFormationDataPermissionDetails, forKey: .lakeFormationDataPermissionDetails)
        }
        if let lakeFormationDataPermissionType = self.lakeFormationDataPermissionType {
            try encodeContainer.encode(lakeFormationDataPermissionType.rawValue, forKey: .lakeFormationDataPermissionType)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for lfpermission0 in permissions {
                try permissionsContainer.encode(lfpermission0.rawValue)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lakeFormationDataPermissionDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.LakeFormationDataPermissionDetails.self, forKey: .lakeFormationDataPermissionDetails)
        lakeFormationDataPermissionDetails = lakeFormationDataPermissionDetailsDecoded
        let lakeFormationDataPermissionTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.LakeFormationDataPermissionType.self, forKey: .lakeFormationDataPermissionType)
        lakeFormationDataPermissionType = lakeFormationDataPermissionTypeDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.LFPermission?].self, forKey: .permissions)
        var permissionsDecoded0:[DataExchangeClientTypes.LFPermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [DataExchangeClientTypes.LFPermission]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension DataExchangeClientTypes {
    /// The AWS Lake Formation data permission asset.
    public struct LakeFormationDataPermissionAsset {
        /// Details about the AWS Lake Formation data permission.
        /// This member is required.
        public var lakeFormationDataPermissionDetails: DataExchangeClientTypes.LakeFormationDataPermissionDetails?
        /// The data permission type.
        /// This member is required.
        public var lakeFormationDataPermissionType: DataExchangeClientTypes.LakeFormationDataPermissionType?
        /// The permissions granted to the subscribers on the resource.
        /// This member is required.
        public var permissions: [DataExchangeClientTypes.LFPermission]?
        /// The IAM role's ARN that allows AWS Data Exchange to assume the role and grant and revoke permissions to AWS Lake Formation data permissions.
        public var roleArn: Swift.String?

        public init(
            lakeFormationDataPermissionDetails: DataExchangeClientTypes.LakeFormationDataPermissionDetails? = nil,
            lakeFormationDataPermissionType: DataExchangeClientTypes.LakeFormationDataPermissionType? = nil,
            permissions: [DataExchangeClientTypes.LFPermission]? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.lakeFormationDataPermissionDetails = lakeFormationDataPermissionDetails
            self.lakeFormationDataPermissionType = lakeFormationDataPermissionType
            self.permissions = permissions
            self.roleArn = roleArn
        }
    }

}

extension DataExchangeClientTypes.LakeFormationDataPermissionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lfTagPolicy = "LFTagPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lfTagPolicy = self.lfTagPolicy {
            try encodeContainer.encode(lfTagPolicy, forKey: .lfTagPolicy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lfTagPolicyDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.LFTagPolicyDetails.self, forKey: .lfTagPolicy)
        lfTagPolicy = lfTagPolicyDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details about the AWS Lake Formation data permission.
    public struct LakeFormationDataPermissionDetails {
        /// Details about the LF-tag policy.
        public var lfTagPolicy: DataExchangeClientTypes.LFTagPolicyDetails?

        public init(
            lfTagPolicy: DataExchangeClientTypes.LFTagPolicyDetails? = nil
        )
        {
            self.lfTagPolicy = lfTagPolicy
        }
    }

}

extension DataExchangeClientTypes {
    public enum LakeFormationDataPermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lftagpolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [LakeFormationDataPermissionType] {
            return [
                .lftagpolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lftagpolicy: return "LFTagPolicy"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LakeFormationDataPermissionType(rawValue: rawValue) ?? LakeFormationDataPermissionType.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.LakeFormationTagPolicyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case table = "Table"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let table = self.table {
            try encodeContainer.encode(table, forKey: .table)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let tableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .table)
        table = tableDecoded
    }
}

extension DataExchangeClientTypes {
    /// Extra details specific to the affected scope in this LF data set.
    public struct LakeFormationTagPolicyDetails {
        /// The underlying Glue database that the notification is referring to.
        public var database: Swift.String?
        /// The underlying Glue table that the notification is referring to.
        public var table: Swift.String?

        public init(
            database: Swift.String? = nil,
            table: Swift.String? = nil
        )
        {
            self.database = database
            self.table = table
        }
    }

}

extension DataExchangeClientTypes {
    public enum LimitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsLakeFormationDataPermissionAssetsPerRevision
        case amazonApiGatewayApiAssetsPerRevision
        case amazonRedshiftDatashareAssetsPerImportJobFromRedshift
        case amazonRedshiftDatashareAssetsPerRevision
        case amazonS3DataAccessAssetsPerRevision
        case assetPerExportJobFromAmazonS3
        case assetSizeInGb
        case assetsPerImportJobFromAmazonS3
        case assetsPerRevision
        case autoExportEventActionsPerDataSet
        case concurrentInProgressJobsToCreateAmazonS3DataAccessAssetsFromS3Buckets
        case concurrentInProgressJobsToExportAssetsToAmazonS3
        case concurrentInProgressJobsToExportAssetsToASignedUrl
        case concurrentInProgressJobsToExportRevisionsToAmazonS3
        case concurrentInProgressJobsToImportAssetsFromAmazonRedshiftDatashares
        case concurrentInProgressJobsToImportAssetsFromAmazonS3
        case concurrentInProgressJobsToImportAssetsFromASignedUrl
        case concurrentInProgressJobsToImportAssetsFromAnApiGatewayApi
        case concurrentInProgressJobsToImportAssetsFromAnAwsLakeFormationTagPolicy
        case dataSetsPerAccount
        case dataSetsPerProduct
        case eventActionsPerAccount
        case productsPerAccount
        case revisionsPerAwsLakeFormationDataPermissionDataSet
        case revisionsPerAmazonApiGatewayApiDataSet
        case revisionsPerAmazonRedshiftDatashareDataSet
        case revisionsPerAmazonS3DataAccessDataSet
        case revisionsPerDataSet
        case sdkUnknown(Swift.String)

        public static var allCases: [LimitName] {
            return [
                .awsLakeFormationDataPermissionAssetsPerRevision,
                .amazonApiGatewayApiAssetsPerRevision,
                .amazonRedshiftDatashareAssetsPerImportJobFromRedshift,
                .amazonRedshiftDatashareAssetsPerRevision,
                .amazonS3DataAccessAssetsPerRevision,
                .assetPerExportJobFromAmazonS3,
                .assetSizeInGb,
                .assetsPerImportJobFromAmazonS3,
                .assetsPerRevision,
                .autoExportEventActionsPerDataSet,
                .concurrentInProgressJobsToCreateAmazonS3DataAccessAssetsFromS3Buckets,
                .concurrentInProgressJobsToExportAssetsToAmazonS3,
                .concurrentInProgressJobsToExportAssetsToASignedUrl,
                .concurrentInProgressJobsToExportRevisionsToAmazonS3,
                .concurrentInProgressJobsToImportAssetsFromAmazonRedshiftDatashares,
                .concurrentInProgressJobsToImportAssetsFromAmazonS3,
                .concurrentInProgressJobsToImportAssetsFromASignedUrl,
                .concurrentInProgressJobsToImportAssetsFromAnApiGatewayApi,
                .concurrentInProgressJobsToImportAssetsFromAnAwsLakeFormationTagPolicy,
                .dataSetsPerAccount,
                .dataSetsPerProduct,
                .eventActionsPerAccount,
                .productsPerAccount,
                .revisionsPerAwsLakeFormationDataPermissionDataSet,
                .revisionsPerAmazonApiGatewayApiDataSet,
                .revisionsPerAmazonRedshiftDatashareDataSet,
                .revisionsPerAmazonS3DataAccessDataSet,
                .revisionsPerDataSet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsLakeFormationDataPermissionAssetsPerRevision: return "AWS Lake Formation data permission assets per revision"
            case .amazonApiGatewayApiAssetsPerRevision: return "Amazon API Gateway API assets per revision"
            case .amazonRedshiftDatashareAssetsPerImportJobFromRedshift: return "Amazon Redshift datashare assets per import job from Redshift"
            case .amazonRedshiftDatashareAssetsPerRevision: return "Amazon Redshift datashare assets per revision"
            case .amazonS3DataAccessAssetsPerRevision: return "Amazon S3 data access assets per revision"
            case .assetPerExportJobFromAmazonS3: return "Asset per export job from Amazon S3"
            case .assetSizeInGb: return "Asset size in GB"
            case .assetsPerImportJobFromAmazonS3: return "Assets per import job from Amazon S3"
            case .assetsPerRevision: return "Assets per revision"
            case .autoExportEventActionsPerDataSet: return "Auto export event actions per data set"
            case .concurrentInProgressJobsToCreateAmazonS3DataAccessAssetsFromS3Buckets: return "Concurrent in progress jobs to create Amazon S3 data access assets from S3 buckets"
            case .concurrentInProgressJobsToExportAssetsToAmazonS3: return "Concurrent in progress jobs to export assets to Amazon S3"
            case .concurrentInProgressJobsToExportAssetsToASignedUrl: return "Concurrent in progress jobs to export assets to a signed URL"
            case .concurrentInProgressJobsToExportRevisionsToAmazonS3: return "Concurrent in progress jobs to export revisions to Amazon S3"
            case .concurrentInProgressJobsToImportAssetsFromAmazonRedshiftDatashares: return "Concurrent in progress jobs to import assets from Amazon Redshift datashares"
            case .concurrentInProgressJobsToImportAssetsFromAmazonS3: return "Concurrent in progress jobs to import assets from Amazon S3"
            case .concurrentInProgressJobsToImportAssetsFromASignedUrl: return "Concurrent in progress jobs to import assets from a signed URL"
            case .concurrentInProgressJobsToImportAssetsFromAnApiGatewayApi: return "Concurrent in progress jobs to import assets from an API Gateway API"
            case .concurrentInProgressJobsToImportAssetsFromAnAwsLakeFormationTagPolicy: return "Concurrent in progress jobs to import assets from an AWS Lake Formation tag policy"
            case .dataSetsPerAccount: return "Data sets per account"
            case .dataSetsPerProduct: return "Data sets per product"
            case .eventActionsPerAccount: return "Event actions per account"
            case .productsPerAccount: return "Products per account"
            case .revisionsPerAwsLakeFormationDataPermissionDataSet: return "Revisions per AWS Lake Formation data permission data set"
            case .revisionsPerAmazonApiGatewayApiDataSet: return "Revisions per Amazon API Gateway API data set"
            case .revisionsPerAmazonRedshiftDatashareDataSet: return "Revisions per Amazon Redshift datashare data set"
            case .revisionsPerAmazonS3DataAccessDataSet: return "Revisions per Amazon S3 data access data set"
            case .revisionsPerDataSet: return "Revisions per data set"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LimitName(rawValue: rawValue) ?? LimitName.sdkUnknown(rawValue)
        }
    }
}

extension ListDataSetRevisionsInput {

    static func queryItemProvider(_ value: ListDataSetRevisionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataSetRevisionsInput {

    static func urlPathProvider(_ value: ListDataSetRevisionsInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions"
    }
}

public struct ListDataSetRevisionsInput {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The maximum number of results returned by a single call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSetRevisionsInputBody {
}

extension ListDataSetRevisionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSetRevisionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataSetRevisionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.revisions = output.revisions
        } else {
            self.nextToken = nil
            self.revisions = nil
        }
    }
}

public struct ListDataSetRevisionsOutput {
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// The asset objects listed by the request.
    public var revisions: [DataExchangeClientTypes.RevisionEntry]?

    public init(
        nextToken: Swift.String? = nil,
        revisions: [DataExchangeClientTypes.RevisionEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.revisions = revisions
    }
}

struct ListDataSetRevisionsOutputBody {
    let nextToken: Swift.String?
    let revisions: [DataExchangeClientTypes.RevisionEntry]?
}

extension ListDataSetRevisionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case revisions = "Revisions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let revisionsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.RevisionEntry?].self, forKey: .revisions)
        var revisionsDecoded0:[DataExchangeClientTypes.RevisionEntry]? = nil
        if let revisionsContainer = revisionsContainer {
            revisionsDecoded0 = [DataExchangeClientTypes.RevisionEntry]()
            for structure0 in revisionsContainer {
                if let structure0 = structure0 {
                    revisionsDecoded0?.append(structure0)
                }
            }
        }
        revisions = revisionsDecoded0
    }
}

enum ListDataSetRevisionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataSetsInput {

    static func queryItemProvider(_ value: ListDataSetsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let origin = value.origin {
            let originQueryItem = ClientRuntime.SDKURLQueryItem(name: "origin".urlPercentEncoding(), value: Swift.String(origin).urlPercentEncoding())
            items.append(originQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataSetsInput {

    static func urlPathProvider(_ value: ListDataSetsInput) -> Swift.String? {
        return "/v1/data-sets"
    }
}

public struct ListDataSetsInput {
    /// The maximum number of results returned by a single call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
    public var origin: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        origin: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.origin = origin
    }
}

struct ListDataSetsInputBody {
}

extension ListDataSetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSets = output.dataSets
            self.nextToken = output.nextToken
        } else {
            self.dataSets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSetsOutput {
    /// The data set objects listed by the request.
    public var dataSets: [DataExchangeClientTypes.DataSetEntry]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        dataSets: [DataExchangeClientTypes.DataSetEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSets = dataSets
        self.nextToken = nextToken
    }
}

struct ListDataSetsOutputBody {
    let dataSets: [DataExchangeClientTypes.DataSetEntry]?
    let nextToken: Swift.String?
}

extension ListDataSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSets = "DataSets"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.DataSetEntry?].self, forKey: .dataSets)
        var dataSetsDecoded0:[DataExchangeClientTypes.DataSetEntry]? = nil
        if let dataSetsContainer = dataSetsContainer {
            dataSetsDecoded0 = [DataExchangeClientTypes.DataSetEntry]()
            for structure0 in dataSetsContainer {
                if let structure0 = structure0 {
                    dataSetsDecoded0?.append(structure0)
                }
            }
        }
        dataSets = dataSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEventActionsInput {

    static func queryItemProvider(_ value: ListEventActionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let eventSourceId = value.eventSourceId {
            let eventSourceIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "eventSourceId".urlPercentEncoding(), value: Swift.String(eventSourceId).urlPercentEncoding())
            items.append(eventSourceIdQueryItem)
        }
        return items
    }
}

extension ListEventActionsInput {

    static func urlPathProvider(_ value: ListEventActionsInput) -> Swift.String? {
        return "/v1/event-actions"
    }
}

public struct ListEventActionsInput {
    /// The unique identifier for the event source.
    public var eventSourceId: Swift.String?
    /// The maximum number of results returned by a single call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        eventSourceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventSourceId = eventSourceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventActionsInputBody {
}

extension ListEventActionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEventActionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEventActionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventActions = output.eventActions
            self.nextToken = output.nextToken
        } else {
            self.eventActions = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventActionsOutput {
    /// The event action objects listed by the request.
    public var eventActions: [DataExchangeClientTypes.EventActionEntry]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        eventActions: [DataExchangeClientTypes.EventActionEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventActions = eventActions
        self.nextToken = nextToken
    }
}

struct ListEventActionsOutputBody {
    let eventActions: [DataExchangeClientTypes.EventActionEntry]?
    let nextToken: Swift.String?
}

extension ListEventActionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventActions = "EventActions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventActionsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.EventActionEntry?].self, forKey: .eventActions)
        var eventActionsDecoded0:[DataExchangeClientTypes.EventActionEntry]? = nil
        if let eventActionsContainer = eventActionsContainer {
            eventActionsDecoded0 = [DataExchangeClientTypes.EventActionEntry]()
            for structure0 in eventActionsContainer {
                if let structure0 = structure0 {
                    eventActionsDecoded0?.append(structure0)
                }
            }
        }
        eventActions = eventActionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEventActionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobsInput {

    static func queryItemProvider(_ value: ListJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let dataSetId = value.dataSetId {
            let dataSetIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "dataSetId".urlPercentEncoding(), value: Swift.String(dataSetId).urlPercentEncoding())
            items.append(dataSetIdQueryItem)
        }
        if let revisionId = value.revisionId {
            let revisionIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "revisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
        }
        return items
    }
}

extension ListJobsInput {

    static func urlPathProvider(_ value: ListJobsInput) -> Swift.String? {
        return "/v1/jobs"
    }
}

public struct ListJobsInput {
    /// The unique identifier for a data set.
    public var dataSetId: Swift.String?
    /// The maximum number of results returned by a single call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// The unique identifier for a revision.
    public var revisionId: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.revisionId = revisionId
    }
}

struct ListJobsInputBody {
}

extension ListJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutput {
    /// The jobs listed by the request.
    public var jobs: [DataExchangeClientTypes.JobEntry]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        jobs: [DataExchangeClientTypes.JobEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputBody {
    let jobs: [DataExchangeClientTypes.JobEntry]?
    let nextToken: Swift.String?
}

extension ListJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.JobEntry?].self, forKey: .jobs)
        var jobsDecoded0:[DataExchangeClientTypes.JobEntry]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [DataExchangeClientTypes.JobEntry]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRevisionAssetsInput {

    static func queryItemProvider(_ value: ListRevisionAssetsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRevisionAssetsInput {

    static func urlPathProvider(_ value: ListRevisionAssetsInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let revisionId = value.revisionId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())/assets"
    }
}

public struct ListRevisionAssetsInput {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The maximum number of results returned by a single call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.revisionId = revisionId
    }
}

struct ListRevisionAssetsInputBody {
}

extension ListRevisionAssetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRevisionAssetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRevisionAssetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assets = output.assets
            self.nextToken = output.nextToken
        } else {
            self.assets = nil
            self.nextToken = nil
        }
    }
}

public struct ListRevisionAssetsOutput {
    /// The asset objects listed by the request.
    public var assets: [DataExchangeClientTypes.AssetEntry]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        assets: [DataExchangeClientTypes.AssetEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assets = assets
        self.nextToken = nextToken
    }
}

struct ListRevisionAssetsOutputBody {
    let assets: [DataExchangeClientTypes.AssetEntry]?
    let nextToken: Swift.String?
}

extension ListRevisionAssetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets = "Assets"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.AssetEntry?].self, forKey: .assets)
        var assetsDecoded0:[DataExchangeClientTypes.AssetEntry]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [DataExchangeClientTypes.AssetEntry]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRevisionAssetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// An Amazon Resource Name (ARN) that uniquely identifies an AWS resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput {
    /// A label that consists of a customer-defined key and an optional value.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataExchangeClientTypes.NotificationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataUpdate = "DataUpdate"
        case deprecation = "Deprecation"
        case schemaChange = "SchemaChange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataUpdate = self.dataUpdate {
            try encodeContainer.encode(dataUpdate, forKey: .dataUpdate)
        }
        if let deprecation = self.deprecation {
            try encodeContainer.encode(deprecation, forKey: .deprecation)
        }
        if let schemaChange = self.schemaChange {
            try encodeContainer.encode(schemaChange, forKey: .schemaChange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataUpdateDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.DataUpdateRequestDetails.self, forKey: .dataUpdate)
        dataUpdate = dataUpdateDecoded
        let deprecationDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.DeprecationRequestDetails.self, forKey: .deprecation)
        deprecation = deprecationDecoded
        let schemaChangeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.SchemaChangeRequestDetails.self, forKey: .schemaChange)
        schemaChange = schemaChangeDecoded
    }
}

extension DataExchangeClientTypes {
    /// Extra details specific to this notification.
    public struct NotificationDetails {
        /// Extra details specific to a data update type notification.
        public var dataUpdate: DataExchangeClientTypes.DataUpdateRequestDetails?
        /// Extra details specific to a deprecation type notification.
        public var deprecation: DataExchangeClientTypes.DeprecationRequestDetails?
        /// Extra details specific to a schema change type notification.
        public var schemaChange: DataExchangeClientTypes.SchemaChangeRequestDetails?

        public init(
            dataUpdate: DataExchangeClientTypes.DataUpdateRequestDetails? = nil,
            deprecation: DataExchangeClientTypes.DeprecationRequestDetails? = nil,
            schemaChange: DataExchangeClientTypes.SchemaChangeRequestDetails? = nil
        )
        {
            self.dataUpdate = dataUpdate
            self.deprecation = deprecation
            self.schemaChange = schemaChange
        }
    }

}

extension DataExchangeClientTypes {
    public enum NotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dataDelay
        case dataUpdate
        case deprecation
        case schemaChange
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .dataDelay,
                .dataUpdate,
                .deprecation,
                .schemaChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dataDelay: return "DATA_DELAY"
            case .dataUpdate: return "DATA_UPDATE"
            case .deprecation: return "DEPRECATION"
            case .schemaChange: return "SCHEMA_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes {
    public enum Origin: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case entitled
        case owned
        case sdkUnknown(Swift.String)

        public static var allCases: [Origin] {
            return [
                .entitled,
                .owned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .entitled: return "ENTITLED"
            case .owned: return "OWNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Origin(rawValue: rawValue) ?? Origin.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.OriginDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details about the origin of the data set.
    public struct OriginDetails {
        /// The product ID of the origin of the data set.
        public var productId: Swift.String?

        public init(
            productId: Swift.String? = nil
        )
        {
            self.productId = productId
        }
    }

}

extension DataExchangeClientTypes {
    public enum ProtocolType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rest
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtocolType] {
            return [
                .rest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rest: return "REST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtocolType(rawValue: rawValue) ?? ProtocolType.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.RedshiftDataShareAsset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DataExchangeClientTypes {
    /// The Amazon Redshift datashare asset.
    public struct RedshiftDataShareAsset {
        /// The Amazon Resource Name (ARN) of the datashare asset.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension DataExchangeClientTypes.RedshiftDataShareAssetSourceEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataShareArn = "DataShareArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataShareArn = self.dataShareArn {
            try encodeContainer.encode(dataShareArn, forKey: .dataShareArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataShareArn)
        dataShareArn = dataShareArnDecoded
    }
}

extension DataExchangeClientTypes {
    /// The source of the Amazon Redshift datashare asset.
    public struct RedshiftDataShareAssetSourceEntry {
        /// The Amazon Resource Name (ARN) of the datashare asset.
        /// This member is required.
        public var dataShareArn: Swift.String?

        public init(
            dataShareArn: Swift.String? = nil
        )
        {
            self.dataShareArn = dataShareArn
        }
    }

}

extension DataExchangeClientTypes.RedshiftDataShareDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case database = "Database"
        case function = "Function"
        case schema = "Schema"
        case table = "Table"
        case view = "View"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let function = self.function {
            try encodeContainer.encode(function, forKey: .function)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let table = self.table {
            try encodeContainer.encode(table, forKey: .table)
        }
        if let view = self.view {
            try encodeContainer.encode(view, forKey: .view)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let functionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .function)
        function = functionDecoded
        let tableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .table)
        table = tableDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let viewDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .view)
        view = viewDecoded
    }
}

extension DataExchangeClientTypes {
    /// Extra details specific to the affected scope in this Redshift data set.
    public struct RedshiftDataShareDetails {
        /// The ARN of the underlying Redshift data share that is being affected by this notification.
        /// This member is required.
        public var arn: Swift.String?
        /// The database name in the Redshift data share that is being affected by this notification.
        /// This member is required.
        public var database: Swift.String?
        /// A function name in the Redshift database that is being affected by this notification.
        public var function: Swift.String?
        /// A schema name in the Redshift database that is being affected by this notification.
        public var schema: Swift.String?
        /// A table name in the Redshift database that is being affected by this notification.
        public var table: Swift.String?
        /// A view name in the Redshift database that is being affected by this notification.
        public var view: Swift.String?

        public init(
            arn: Swift.String? = nil,
            database: Swift.String? = nil,
            function: Swift.String? = nil,
            schema: Swift.String? = nil,
            table: Swift.String? = nil,
            view: Swift.String? = nil
        )
        {
            self.arn = arn
            self.database = database
            self.function = function
            self.schema = schema
            self.table = table
            self.view = view
        }
    }

}

extension DataExchangeClientTypes.RequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createS3DataAccessFromS3Bucket = "CreateS3DataAccessFromS3Bucket"
        case exportAssetToSignedUrl = "ExportAssetToSignedUrl"
        case exportAssetsToS3 = "ExportAssetsToS3"
        case exportRevisionsToS3 = "ExportRevisionsToS3"
        case importAssetFromApiGatewayApi = "ImportAssetFromApiGatewayApi"
        case importAssetFromSignedUrl = "ImportAssetFromSignedUrl"
        case importAssetsFromLakeFormationTagPolicy = "ImportAssetsFromLakeFormationTagPolicy"
        case importAssetsFromRedshiftDataShares = "ImportAssetsFromRedshiftDataShares"
        case importAssetsFromS3 = "ImportAssetsFromS3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createS3DataAccessFromS3Bucket = self.createS3DataAccessFromS3Bucket {
            try encodeContainer.encode(createS3DataAccessFromS3Bucket, forKey: .createS3DataAccessFromS3Bucket)
        }
        if let exportAssetToSignedUrl = self.exportAssetToSignedUrl {
            try encodeContainer.encode(exportAssetToSignedUrl, forKey: .exportAssetToSignedUrl)
        }
        if let exportAssetsToS3 = self.exportAssetsToS3 {
            try encodeContainer.encode(exportAssetsToS3, forKey: .exportAssetsToS3)
        }
        if let exportRevisionsToS3 = self.exportRevisionsToS3 {
            try encodeContainer.encode(exportRevisionsToS3, forKey: .exportRevisionsToS3)
        }
        if let importAssetFromApiGatewayApi = self.importAssetFromApiGatewayApi {
            try encodeContainer.encode(importAssetFromApiGatewayApi, forKey: .importAssetFromApiGatewayApi)
        }
        if let importAssetFromSignedUrl = self.importAssetFromSignedUrl {
            try encodeContainer.encode(importAssetFromSignedUrl, forKey: .importAssetFromSignedUrl)
        }
        if let importAssetsFromLakeFormationTagPolicy = self.importAssetsFromLakeFormationTagPolicy {
            try encodeContainer.encode(importAssetsFromLakeFormationTagPolicy, forKey: .importAssetsFromLakeFormationTagPolicy)
        }
        if let importAssetsFromRedshiftDataShares = self.importAssetsFromRedshiftDataShares {
            try encodeContainer.encode(importAssetsFromRedshiftDataShares, forKey: .importAssetsFromRedshiftDataShares)
        }
        if let importAssetsFromS3 = self.importAssetsFromS3 {
            try encodeContainer.encode(importAssetsFromS3, forKey: .importAssetsFromS3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportAssetToSignedUrlDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportAssetToSignedUrlRequestDetails.self, forKey: .exportAssetToSignedUrl)
        exportAssetToSignedUrl = exportAssetToSignedUrlDecoded
        let exportAssetsToS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportAssetsToS3RequestDetails.self, forKey: .exportAssetsToS3)
        exportAssetsToS3 = exportAssetsToS3Decoded
        let exportRevisionsToS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportRevisionsToS3RequestDetails.self, forKey: .exportRevisionsToS3)
        exportRevisionsToS3 = exportRevisionsToS3Decoded
        let importAssetFromSignedUrlDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetFromSignedUrlRequestDetails.self, forKey: .importAssetFromSignedUrl)
        importAssetFromSignedUrl = importAssetFromSignedUrlDecoded
        let importAssetsFromS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetsFromS3RequestDetails.self, forKey: .importAssetsFromS3)
        importAssetsFromS3 = importAssetsFromS3Decoded
        let importAssetsFromRedshiftDataSharesDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesRequestDetails.self, forKey: .importAssetsFromRedshiftDataShares)
        importAssetsFromRedshiftDataShares = importAssetsFromRedshiftDataSharesDecoded
        let importAssetFromApiGatewayApiDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetFromApiGatewayApiRequestDetails.self, forKey: .importAssetFromApiGatewayApi)
        importAssetFromApiGatewayApi = importAssetFromApiGatewayApiDecoded
        let createS3DataAccessFromS3BucketDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.CreateS3DataAccessFromS3BucketRequestDetails.self, forKey: .createS3DataAccessFromS3Bucket)
        createS3DataAccessFromS3Bucket = createS3DataAccessFromS3BucketDecoded
        let importAssetsFromLakeFormationTagPolicyDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetsFromLakeFormationTagPolicyRequestDetails.self, forKey: .importAssetsFromLakeFormationTagPolicy)
        importAssetsFromLakeFormationTagPolicy = importAssetsFromLakeFormationTagPolicyDecoded
    }
}

extension DataExchangeClientTypes {
    /// The details for the request.
    public struct RequestDetails {
        /// Details of the request to create S3 data access from the Amazon S3 bucket.
        public var createS3DataAccessFromS3Bucket: DataExchangeClientTypes.CreateS3DataAccessFromS3BucketRequestDetails?
        /// Details about the export to signed URL request.
        public var exportAssetToSignedUrl: DataExchangeClientTypes.ExportAssetToSignedUrlRequestDetails?
        /// Details about the export to Amazon S3 request.
        public var exportAssetsToS3: DataExchangeClientTypes.ExportAssetsToS3RequestDetails?
        /// Details about the export to Amazon S3 request.
        public var exportRevisionsToS3: DataExchangeClientTypes.ExportRevisionsToS3RequestDetails?
        /// Details about the import from signed URL request.
        public var importAssetFromApiGatewayApi: DataExchangeClientTypes.ImportAssetFromApiGatewayApiRequestDetails?
        /// Details about the import from Amazon S3 request.
        public var importAssetFromSignedUrl: DataExchangeClientTypes.ImportAssetFromSignedUrlRequestDetails?
        /// Request details for the ImportAssetsFromLakeFormationTagPolicy job.
        public var importAssetsFromLakeFormationTagPolicy: DataExchangeClientTypes.ImportAssetsFromLakeFormationTagPolicyRequestDetails?
        /// Details from an import from Amazon Redshift datashare request.
        public var importAssetsFromRedshiftDataShares: DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesRequestDetails?
        /// Details about the import asset from API Gateway API request.
        public var importAssetsFromS3: DataExchangeClientTypes.ImportAssetsFromS3RequestDetails?

        public init(
            createS3DataAccessFromS3Bucket: DataExchangeClientTypes.CreateS3DataAccessFromS3BucketRequestDetails? = nil,
            exportAssetToSignedUrl: DataExchangeClientTypes.ExportAssetToSignedUrlRequestDetails? = nil,
            exportAssetsToS3: DataExchangeClientTypes.ExportAssetsToS3RequestDetails? = nil,
            exportRevisionsToS3: DataExchangeClientTypes.ExportRevisionsToS3RequestDetails? = nil,
            importAssetFromApiGatewayApi: DataExchangeClientTypes.ImportAssetFromApiGatewayApiRequestDetails? = nil,
            importAssetFromSignedUrl: DataExchangeClientTypes.ImportAssetFromSignedUrlRequestDetails? = nil,
            importAssetsFromLakeFormationTagPolicy: DataExchangeClientTypes.ImportAssetsFromLakeFormationTagPolicyRequestDetails? = nil,
            importAssetsFromRedshiftDataShares: DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesRequestDetails? = nil,
            importAssetsFromS3: DataExchangeClientTypes.ImportAssetsFromS3RequestDetails? = nil
        )
        {
            self.createS3DataAccessFromS3Bucket = createS3DataAccessFromS3Bucket
            self.exportAssetToSignedUrl = exportAssetToSignedUrl
            self.exportAssetsToS3 = exportAssetsToS3
            self.exportRevisionsToS3 = exportRevisionsToS3
            self.importAssetFromApiGatewayApi = importAssetFromApiGatewayApi
            self.importAssetFromSignedUrl = importAssetFromSignedUrl
            self.importAssetsFromLakeFormationTagPolicy = importAssetsFromLakeFormationTagPolicy
            self.importAssetsFromRedshiftDataShares = importAssetsFromRedshiftDataShares
            self.importAssetsFromS3 = importAssetsFromS3
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource couldn't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The resource couldn't be found.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the resource that couldn't be found.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that couldn't be found.
        public internal(set) var resourceType: DataExchangeClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: DataExchangeClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: DataExchangeClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DataExchangeClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asset
        case dataSet
        case eventAction
        case job
        case revision
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .asset,
                .dataSet,
                .eventAction,
                .job,
                .revision,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case .dataSet: return "DATA_SET"
            case .eventAction: return "EVENT_ACTION"
            case .job: return "JOB"
            case .revision: return "REVISION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.ResponseDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createS3DataAccessFromS3Bucket = "CreateS3DataAccessFromS3Bucket"
        case exportAssetToSignedUrl = "ExportAssetToSignedUrl"
        case exportAssetsToS3 = "ExportAssetsToS3"
        case exportRevisionsToS3 = "ExportRevisionsToS3"
        case importAssetFromApiGatewayApi = "ImportAssetFromApiGatewayApi"
        case importAssetFromSignedUrl = "ImportAssetFromSignedUrl"
        case importAssetsFromLakeFormationTagPolicy = "ImportAssetsFromLakeFormationTagPolicy"
        case importAssetsFromRedshiftDataShares = "ImportAssetsFromRedshiftDataShares"
        case importAssetsFromS3 = "ImportAssetsFromS3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createS3DataAccessFromS3Bucket = self.createS3DataAccessFromS3Bucket {
            try encodeContainer.encode(createS3DataAccessFromS3Bucket, forKey: .createS3DataAccessFromS3Bucket)
        }
        if let exportAssetToSignedUrl = self.exportAssetToSignedUrl {
            try encodeContainer.encode(exportAssetToSignedUrl, forKey: .exportAssetToSignedUrl)
        }
        if let exportAssetsToS3 = self.exportAssetsToS3 {
            try encodeContainer.encode(exportAssetsToS3, forKey: .exportAssetsToS3)
        }
        if let exportRevisionsToS3 = self.exportRevisionsToS3 {
            try encodeContainer.encode(exportRevisionsToS3, forKey: .exportRevisionsToS3)
        }
        if let importAssetFromApiGatewayApi = self.importAssetFromApiGatewayApi {
            try encodeContainer.encode(importAssetFromApiGatewayApi, forKey: .importAssetFromApiGatewayApi)
        }
        if let importAssetFromSignedUrl = self.importAssetFromSignedUrl {
            try encodeContainer.encode(importAssetFromSignedUrl, forKey: .importAssetFromSignedUrl)
        }
        if let importAssetsFromLakeFormationTagPolicy = self.importAssetsFromLakeFormationTagPolicy {
            try encodeContainer.encode(importAssetsFromLakeFormationTagPolicy, forKey: .importAssetsFromLakeFormationTagPolicy)
        }
        if let importAssetsFromRedshiftDataShares = self.importAssetsFromRedshiftDataShares {
            try encodeContainer.encode(importAssetsFromRedshiftDataShares, forKey: .importAssetsFromRedshiftDataShares)
        }
        if let importAssetsFromS3 = self.importAssetsFromS3 {
            try encodeContainer.encode(importAssetsFromS3, forKey: .importAssetsFromS3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportAssetToSignedUrlDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportAssetToSignedUrlResponseDetails.self, forKey: .exportAssetToSignedUrl)
        exportAssetToSignedUrl = exportAssetToSignedUrlDecoded
        let exportAssetsToS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportAssetsToS3ResponseDetails.self, forKey: .exportAssetsToS3)
        exportAssetsToS3 = exportAssetsToS3Decoded
        let exportRevisionsToS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExportRevisionsToS3ResponseDetails.self, forKey: .exportRevisionsToS3)
        exportRevisionsToS3 = exportRevisionsToS3Decoded
        let importAssetFromSignedUrlDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetFromSignedUrlResponseDetails.self, forKey: .importAssetFromSignedUrl)
        importAssetFromSignedUrl = importAssetFromSignedUrlDecoded
        let importAssetsFromS3Decoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetsFromS3ResponseDetails.self, forKey: .importAssetsFromS3)
        importAssetsFromS3 = importAssetsFromS3Decoded
        let importAssetsFromRedshiftDataSharesDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesResponseDetails.self, forKey: .importAssetsFromRedshiftDataShares)
        importAssetsFromRedshiftDataShares = importAssetsFromRedshiftDataSharesDecoded
        let importAssetFromApiGatewayApiDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetFromApiGatewayApiResponseDetails.self, forKey: .importAssetFromApiGatewayApi)
        importAssetFromApiGatewayApi = importAssetFromApiGatewayApiDecoded
        let createS3DataAccessFromS3BucketDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.CreateS3DataAccessFromS3BucketResponseDetails.self, forKey: .createS3DataAccessFromS3Bucket)
        createS3DataAccessFromS3Bucket = createS3DataAccessFromS3BucketDecoded
        let importAssetsFromLakeFormationTagPolicyDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ImportAssetsFromLakeFormationTagPolicyResponseDetails.self, forKey: .importAssetsFromLakeFormationTagPolicy)
        importAssetsFromLakeFormationTagPolicy = importAssetsFromLakeFormationTagPolicyDecoded
    }
}

extension DataExchangeClientTypes {
    /// Details for the response.
    public struct ResponseDetails {
        /// Response details from the CreateS3DataAccessFromS3Bucket job.
        public var createS3DataAccessFromS3Bucket: DataExchangeClientTypes.CreateS3DataAccessFromS3BucketResponseDetails?
        /// Details for the export to signed URL response.
        public var exportAssetToSignedUrl: DataExchangeClientTypes.ExportAssetToSignedUrlResponseDetails?
        /// Details for the export to Amazon S3 response.
        public var exportAssetsToS3: DataExchangeClientTypes.ExportAssetsToS3ResponseDetails?
        /// Details for the export revisions to Amazon S3 response.
        public var exportRevisionsToS3: DataExchangeClientTypes.ExportRevisionsToS3ResponseDetails?
        /// The response details.
        public var importAssetFromApiGatewayApi: DataExchangeClientTypes.ImportAssetFromApiGatewayApiResponseDetails?
        /// Details for the import from signed URL response.
        public var importAssetFromSignedUrl: DataExchangeClientTypes.ImportAssetFromSignedUrlResponseDetails?
        /// Response details from the ImportAssetsFromLakeFormationTagPolicy job.
        public var importAssetsFromLakeFormationTagPolicy: DataExchangeClientTypes.ImportAssetsFromLakeFormationTagPolicyResponseDetails?
        /// Details from an import from Amazon Redshift datashare response.
        public var importAssetsFromRedshiftDataShares: DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesResponseDetails?
        /// Details for the import from Amazon S3 response.
        public var importAssetsFromS3: DataExchangeClientTypes.ImportAssetsFromS3ResponseDetails?

        public init(
            createS3DataAccessFromS3Bucket: DataExchangeClientTypes.CreateS3DataAccessFromS3BucketResponseDetails? = nil,
            exportAssetToSignedUrl: DataExchangeClientTypes.ExportAssetToSignedUrlResponseDetails? = nil,
            exportAssetsToS3: DataExchangeClientTypes.ExportAssetsToS3ResponseDetails? = nil,
            exportRevisionsToS3: DataExchangeClientTypes.ExportRevisionsToS3ResponseDetails? = nil,
            importAssetFromApiGatewayApi: DataExchangeClientTypes.ImportAssetFromApiGatewayApiResponseDetails? = nil,
            importAssetFromSignedUrl: DataExchangeClientTypes.ImportAssetFromSignedUrlResponseDetails? = nil,
            importAssetsFromLakeFormationTagPolicy: DataExchangeClientTypes.ImportAssetsFromLakeFormationTagPolicyResponseDetails? = nil,
            importAssetsFromRedshiftDataShares: DataExchangeClientTypes.ImportAssetsFromRedshiftDataSharesResponseDetails? = nil,
            importAssetsFromS3: DataExchangeClientTypes.ImportAssetsFromS3ResponseDetails? = nil
        )
        {
            self.createS3DataAccessFromS3Bucket = createS3DataAccessFromS3Bucket
            self.exportAssetToSignedUrl = exportAssetToSignedUrl
            self.exportAssetsToS3 = exportAssetsToS3
            self.exportRevisionsToS3 = exportRevisionsToS3
            self.importAssetFromApiGatewayApi = importAssetFromApiGatewayApi
            self.importAssetFromSignedUrl = importAssetFromSignedUrl
            self.importAssetsFromLakeFormationTagPolicy = importAssetsFromLakeFormationTagPolicy
            self.importAssetsFromRedshiftDataShares = importAssetsFromRedshiftDataShares
            self.importAssetsFromS3 = importAssetsFromS3
        }
    }

}

extension DataExchangeClientTypes.RevisionDestinationEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case keyPattern = "KeyPattern"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPattern = self.keyPattern {
            try encodeContainer.encode(keyPattern, forKey: .keyPattern)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPattern)
        keyPattern = keyPatternDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// The destination where the assets in the revision will be exported.
    public struct RevisionDestinationEntry {
        /// The Amazon S3 bucket that is the destination for the assets in the revision.
        /// This member is required.
        public var bucket: Swift.String?
        /// A string representing the pattern for generated names of the individual assets in the revision. For more information about key patterns, see [Key patterns when exporting revisions](https://docs.aws.amazon.com/data-exchange/latest/userguide/jobs.html#revision-export-keypatterns).
        public var keyPattern: Swift.String?
        /// The unique identifier for the revision.
        /// This member is required.
        public var revisionId: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            keyPattern: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.keyPattern = keyPattern
            self.revisionId = revisionId
        }
    }

}

extension DataExchangeClientTypes.RevisionEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case revocationComment = "RevocationComment"
        case revoked = "Revoked"
        case revokedAt = "RevokedAt"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
        if let finalized = self.finalized {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revocationComment = self.revocationComment {
            try encodeContainer.encode(revocationComment, forKey: .revocationComment)
        }
        if let revoked = self.revoked {
            try encodeContainer.encode(revoked, forKey: .revoked)
        }
        if let revokedAt = self.revokedAt {
            try encodeContainer.encodeTimestamp(revokedAt, format: .dateTime, forKey: .revokedAt)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let revocationCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revocationComment)
        revocationComment = revocationCommentDecoded
        let revokedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .revoked)
        revoked = revokedDecoded
        let revokedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
    }
}

extension DataExchangeClientTypes {
    /// A revision is a container for one or more assets.
    public struct RevisionEntry {
        /// The ARN for the revision.
        /// This member is required.
        public var arn: Swift.String?
        /// An optional comment about the revision.
        public var comment: Swift.String?
        /// The date and time that the revision was created, in ISO 8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The unique identifier for the data set associated with the data set revision.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
        public var finalized: Swift.Bool?
        /// The unique identifier for the revision.
        /// This member is required.
        public var id: Swift.String?
        /// A required comment to inform subscribers of the reason their access to the revision was revoked.
        public var revocationComment: Swift.String?
        /// A status indicating that subscribers' access to the revision was revoked.
        public var revoked: Swift.Bool?
        /// The date and time that the revision was revoked, in ISO 8601 format.
        public var revokedAt: ClientRuntime.Date?
        /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
        public var sourceId: Swift.String?
        /// The date and time that the revision was last updated, in ISO 8601 format.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            comment: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            dataSetId: Swift.String? = nil,
            finalized: Swift.Bool? = nil,
            id: Swift.String? = nil,
            revocationComment: Swift.String? = nil,
            revoked: Swift.Bool? = nil,
            revokedAt: ClientRuntime.Date? = nil,
            sourceId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.comment = comment
            self.createdAt = createdAt
            self.dataSetId = dataSetId
            self.finalized = finalized
            self.id = id
            self.revocationComment = revocationComment
            self.revoked = revoked
            self.revokedAt = revokedAt
            self.sourceId = sourceId
            self.updatedAt = updatedAt
        }
    }

}

extension DataExchangeClientTypes.RevisionPublished: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSetId = "DataSetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSetId = self.dataSetId {
            try encodeContainer.encode(dataSetId, forKey: .dataSetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
    }
}

extension DataExchangeClientTypes {
    /// Information about the published revision.
    public struct RevisionPublished {
        /// The data set ID of the published revision.
        /// This member is required.
        public var dataSetId: Swift.String?

        public init(
            dataSetId: Swift.String? = nil
        )
        {
            self.dataSetId = dataSetId
        }
    }

}

extension RevokeRevisionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revocationComment = "RevocationComment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revocationComment = self.revocationComment {
            try encodeContainer.encode(revocationComment, forKey: .revocationComment)
        }
    }
}

extension RevokeRevisionInput {

    static func urlPathProvider(_ value: RevokeRevisionInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let revisionId = value.revisionId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())/revoke"
    }
}

public struct RevokeRevisionInput {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?
    /// A required comment to inform subscribers of the reason their access to the revision was revoked.
    /// This member is required.
    public var revocationComment: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        revocationComment: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.revisionId = revisionId
        self.revocationComment = revocationComment
    }
}

struct RevokeRevisionInputBody {
    let revocationComment: Swift.String?
}

extension RevokeRevisionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revocationComment = "RevocationComment"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revocationCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revocationComment)
        revocationComment = revocationCommentDecoded
    }
}

extension RevokeRevisionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RevokeRevisionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.comment = output.comment
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.finalized = output.finalized
            self.id = output.id
            self.revocationComment = output.revocationComment
            self.revoked = output.revoked
            self.revokedAt = output.revokedAt
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.comment = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.finalized = nil
            self.id = nil
            self.revocationComment = nil
            self.revoked = nil
            self.revokedAt = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct RevokeRevisionOutput {
    /// The ARN for the revision.
    public var arn: Swift.String?
    /// An optional comment about the revision.
    public var comment: Swift.String?
    /// The date and time that the revision was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The unique identifier for the data set associated with the data set revision.
    public var dataSetId: Swift.String?
    /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
    public var finalized: Swift.Bool?
    /// The unique identifier for the revision.
    public var id: Swift.String?
    /// A required comment to inform subscribers of the reason their access to the revision was revoked.
    public var revocationComment: Swift.String?
    /// A status indicating that subscribers' access to the revision was revoked.
    public var revoked: Swift.Bool?
    /// The date and time that the revision was revoked, in ISO 8601 format.
    public var revokedAt: ClientRuntime.Date?
    /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
    public var sourceId: Swift.String?
    /// The date and time that the revision was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        comment: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        dataSetId: Swift.String? = nil,
        finalized: Swift.Bool? = nil,
        id: Swift.String? = nil,
        revocationComment: Swift.String? = nil,
        revoked: Swift.Bool? = nil,
        revokedAt: ClientRuntime.Date? = nil,
        sourceId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.comment = comment
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.id = id
        self.revocationComment = revocationComment
        self.revoked = revoked
        self.revokedAt = revokedAt
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct RevokeRevisionOutputBody {
    let arn: Swift.String?
    let comment: Swift.String?
    let createdAt: ClientRuntime.Date?
    let dataSetId: Swift.String?
    let finalized: Swift.Bool?
    let id: Swift.String?
    let sourceId: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let revocationComment: Swift.String?
    let revoked: Swift.Bool?
    let revokedAt: ClientRuntime.Date?
}

extension RevokeRevisionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case revocationComment = "RevocationComment"
        case revoked = "Revoked"
        case revokedAt = "RevokedAt"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let revocationCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revocationComment)
        revocationComment = revocationCommentDecoded
        let revokedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .revoked)
        revoked = revokedDecoded
        let revokedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
    }
}

enum RevokeRevisionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataExchangeClientTypes.S3DataAccessAsset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case keyPrefixes = "KeyPrefixes"
        case keys = "Keys"
        case kmsKeysToGrant = "KmsKeysToGrant"
        case s3AccessPointAlias = "S3AccessPointAlias"
        case s3AccessPointArn = "S3AccessPointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefixes = keyPrefixes {
            var keyPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keyPrefixes)
            for __string0 in keyPrefixes {
                try keyPrefixesContainer.encode(__string0)
            }
        }
        if let keys = keys {
            var keysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keys)
            for __string0 in keys {
                try keysContainer.encode(__string0)
            }
        }
        if let kmsKeysToGrant = kmsKeysToGrant {
            var kmsKeysToGrantContainer = encodeContainer.nestedUnkeyedContainer(forKey: .kmsKeysToGrant)
            for kmskeytogrant0 in kmsKeysToGrant {
                try kmsKeysToGrantContainer.encode(kmskeytogrant0)
            }
        }
        if let s3AccessPointAlias = self.s3AccessPointAlias {
            try encodeContainer.encode(s3AccessPointAlias, forKey: .s3AccessPointAlias)
        }
        if let s3AccessPointArn = self.s3AccessPointArn {
            try encodeContainer.encode(s3AccessPointArn, forKey: .s3AccessPointArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keyPrefixes)
        var keyPrefixesDecoded0:[Swift.String]? = nil
        if let keyPrefixesContainer = keyPrefixesContainer {
            keyPrefixesDecoded0 = [Swift.String]()
            for string0 in keyPrefixesContainer {
                if let string0 = string0 {
                    keyPrefixesDecoded0?.append(string0)
                }
            }
        }
        keyPrefixes = keyPrefixesDecoded0
        let keysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keys)
        var keysDecoded0:[Swift.String]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [Swift.String]()
            for string0 in keysContainer {
                if let string0 = string0 {
                    keysDecoded0?.append(string0)
                }
            }
        }
        keys = keysDecoded0
        let s3AccessPointAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3AccessPointAlias)
        s3AccessPointAlias = s3AccessPointAliasDecoded
        let s3AccessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3AccessPointArn)
        s3AccessPointArn = s3AccessPointArnDecoded
        let kmsKeysToGrantContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.KmsKeyToGrant?].self, forKey: .kmsKeysToGrant)
        var kmsKeysToGrantDecoded0:[DataExchangeClientTypes.KmsKeyToGrant]? = nil
        if let kmsKeysToGrantContainer = kmsKeysToGrantContainer {
            kmsKeysToGrantDecoded0 = [DataExchangeClientTypes.KmsKeyToGrant]()
            for structure0 in kmsKeysToGrantContainer {
                if let structure0 = structure0 {
                    kmsKeysToGrantDecoded0?.append(structure0)
                }
            }
        }
        kmsKeysToGrant = kmsKeysToGrantDecoded0
    }
}

extension DataExchangeClientTypes {
    /// The Amazon S3 data access that is the asset.
    public struct S3DataAccessAsset {
        /// The Amazon S3 bucket hosting data to be shared in the S3 data access.
        /// This member is required.
        public var bucket: Swift.String?
        /// The Amazon S3 bucket used for hosting shared data in the Amazon S3 data access.
        public var keyPrefixes: [Swift.String]?
        /// S3 keys made available using this asset.
        public var keys: [Swift.String]?
        /// List of AWS KMS CMKs (Key Management System Customer Managed Keys) and ARNs used to encrypt S3 objects being shared in this S3 Data Access asset. Providers must include all AWS KMS keys used to encrypt these shared S3 objects.
        public var kmsKeysToGrant: [DataExchangeClientTypes.KmsKeyToGrant]?
        /// The automatically-generated bucket-style alias for your Amazon S3 Access Point. Customers can access their entitled data using the S3 Access Point alias.
        public var s3AccessPointAlias: Swift.String?
        /// The ARN for your Amazon S3 Access Point. Customers can also access their entitled data using the S3 Access Point ARN.
        public var s3AccessPointArn: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            keyPrefixes: [Swift.String]? = nil,
            keys: [Swift.String]? = nil,
            kmsKeysToGrant: [DataExchangeClientTypes.KmsKeyToGrant]? = nil,
            s3AccessPointAlias: Swift.String? = nil,
            s3AccessPointArn: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.keyPrefixes = keyPrefixes
            self.keys = keys
            self.kmsKeysToGrant = kmsKeysToGrant
            self.s3AccessPointAlias = s3AccessPointAlias
            self.s3AccessPointArn = s3AccessPointArn
        }
    }

}

extension DataExchangeClientTypes.S3DataAccessAssetSourceEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case keyPrefixes = "KeyPrefixes"
        case keys = "Keys"
        case kmsKeysToGrant = "KmsKeysToGrant"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefixes = keyPrefixes {
            var keyPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keyPrefixes)
            for __string0 in keyPrefixes {
                try keyPrefixesContainer.encode(__string0)
            }
        }
        if let keys = keys {
            var keysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keys)
            for __string0 in keys {
                try keysContainer.encode(__string0)
            }
        }
        if let kmsKeysToGrant = kmsKeysToGrant {
            var kmsKeysToGrantContainer = encodeContainer.nestedUnkeyedContainer(forKey: .kmsKeysToGrant)
            for kmskeytogrant0 in kmsKeysToGrant {
                try kmsKeysToGrantContainer.encode(kmskeytogrant0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keyPrefixes)
        var keyPrefixesDecoded0:[Swift.String]? = nil
        if let keyPrefixesContainer = keyPrefixesContainer {
            keyPrefixesDecoded0 = [Swift.String]()
            for string0 in keyPrefixesContainer {
                if let string0 = string0 {
                    keyPrefixesDecoded0?.append(string0)
                }
            }
        }
        keyPrefixes = keyPrefixesDecoded0
        let keysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keys)
        var keysDecoded0:[Swift.String]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [Swift.String]()
            for string0 in keysContainer {
                if let string0 = string0 {
                    keysDecoded0?.append(string0)
                }
            }
        }
        keys = keysDecoded0
        let kmsKeysToGrantContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.KmsKeyToGrant?].self, forKey: .kmsKeysToGrant)
        var kmsKeysToGrantDecoded0:[DataExchangeClientTypes.KmsKeyToGrant]? = nil
        if let kmsKeysToGrantContainer = kmsKeysToGrantContainer {
            kmsKeysToGrantDecoded0 = [DataExchangeClientTypes.KmsKeyToGrant]()
            for structure0 in kmsKeysToGrantContainer {
                if let structure0 = structure0 {
                    kmsKeysToGrantDecoded0?.append(structure0)
                }
            }
        }
        kmsKeysToGrant = kmsKeysToGrantDecoded0
    }
}

extension DataExchangeClientTypes {
    /// Source details for an Amazon S3 data access asset.
    public struct S3DataAccessAssetSourceEntry {
        /// The Amazon S3 bucket used for hosting shared data in the Amazon S3 data access.
        /// This member is required.
        public var bucket: Swift.String?
        /// Organizes Amazon S3 asset key prefixes stored in an Amazon S3 bucket.
        public var keyPrefixes: [Swift.String]?
        /// The keys used to create the Amazon S3 data access.
        public var keys: [Swift.String]?
        /// List of AWS KMS CMKs (Key Management System Customer Managed Keys) and ARNs used to encrypt S3 objects being shared in this S3 Data Access asset.
        public var kmsKeysToGrant: [DataExchangeClientTypes.KmsKeyToGrant]?

        public init(
            bucket: Swift.String? = nil,
            keyPrefixes: [Swift.String]? = nil,
            keys: [Swift.String]? = nil,
            kmsKeysToGrant: [DataExchangeClientTypes.KmsKeyToGrant]? = nil
        )
        {
            self.bucket = bucket
            self.keyPrefixes = keyPrefixes
            self.keys = keys
            self.kmsKeysToGrant = kmsKeysToGrant
        }
    }

}

extension DataExchangeClientTypes.S3DataAccessDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyPrefixes = "KeyPrefixes"
        case keys = "Keys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyPrefixes = keyPrefixes {
            var keyPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keyPrefixes)
            for __string0 in keyPrefixes {
                try keyPrefixesContainer.encode(__string0)
            }
        }
        if let keys = keys {
            var keysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keys)
            for __string0 in keys {
                try keysContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPrefixesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keyPrefixes)
        var keyPrefixesDecoded0:[Swift.String]? = nil
        if let keyPrefixesContainer = keyPrefixesContainer {
            keyPrefixesDecoded0 = [Swift.String]()
            for string0 in keyPrefixesContainer {
                if let string0 = string0 {
                    keyPrefixesDecoded0?.append(string0)
                }
            }
        }
        keyPrefixes = keyPrefixesDecoded0
        let keysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keys)
        var keysDecoded0:[Swift.String]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [Swift.String]()
            for string0 in keysContainer {
                if let string0 = string0 {
                    keysDecoded0?.append(string0)
                }
            }
        }
        keys = keysDecoded0
    }
}

extension DataExchangeClientTypes {
    /// Extra details specific to the affected scope in this S3 Data Access data set.
    public struct S3DataAccessDetails {
        /// A list of the key prefixes affected by this notification. This can have up to 50 entries.
        public var keyPrefixes: [Swift.String]?
        /// A list of the keys affected by this notification. This can have up to 50 entries.
        public var keys: [Swift.String]?

        public init(
            keyPrefixes: [Swift.String]? = nil,
            keys: [Swift.String]? = nil
        )
        {
            self.keyPrefixes = keyPrefixes
            self.keys = keys
        }
    }

}

extension DataExchangeClientTypes.S3SnapshotAsset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .size)
        size = sizeDecoded
    }
}

extension DataExchangeClientTypes {
    /// The Amazon S3 object that is the asset.
    public struct S3SnapshotAsset {
        /// The size of the Amazon S3 object that is the object.
        /// This member is required.
        public var size: Swift.Double?

        public init(
            size: Swift.Double? = nil
        )
        {
            self.size = size
        }
    }

}

extension DataExchangeClientTypes.SchemaChangeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.SchemaChangeType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DataExchangeClientTypes {
    /// Object encompassing information about a schema change to a single, particular field, a notification can have up to 100 of these.
    public struct SchemaChangeDetails {
        /// Description of what's changing about this field. This value can be up to 512 characters long.
        public var description: Swift.String?
        /// Name of the changing field. This value can be up to 255 characters long.
        /// This member is required.
        public var name: Swift.String?
        /// Is the field being added, removed, or modified?
        /// This member is required.
        public var type: DataExchangeClientTypes.SchemaChangeType?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: DataExchangeClientTypes.SchemaChangeType? = nil
        )
        {
            self.description = description
            self.name = name
            self.type = type
        }
    }

}

extension DataExchangeClientTypes.SchemaChangeRequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changes = "Changes"
        case schemaChangeAt = "SchemaChangeAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changes = changes {
            var changesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .changes)
            for schemachangedetails0 in changes {
                try changesContainer.encode(schemachangedetails0)
            }
        }
        if let schemaChangeAt = self.schemaChangeAt {
            try encodeContainer.encodeTimestamp(schemaChangeAt, format: .dateTime, forKey: .schemaChangeAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.SchemaChangeDetails?].self, forKey: .changes)
        var changesDecoded0:[DataExchangeClientTypes.SchemaChangeDetails]? = nil
        if let changesContainer = changesContainer {
            changesDecoded0 = [DataExchangeClientTypes.SchemaChangeDetails]()
            for structure0 in changesContainer {
                if let structure0 = structure0 {
                    changesDecoded0?.append(structure0)
                }
            }
        }
        changes = changesDecoded0
        let schemaChangeAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .schemaChangeAt)
        schemaChangeAt = schemaChangeAtDecoded
    }
}

extension DataExchangeClientTypes {
    /// Extra details specific to this schema change type notification.
    public struct SchemaChangeRequestDetails {
        /// List of schema changes happening in the scope of this notification. This can have up to 100 entries.
        public var changes: [DataExchangeClientTypes.SchemaChangeDetails]?
        /// A date in the future when the schema change is taking effect.
        /// This member is required.
        public var schemaChangeAt: ClientRuntime.Date?

        public init(
            changes: [DataExchangeClientTypes.SchemaChangeDetails]? = nil,
            schemaChangeAt: ClientRuntime.Date? = nil
        )
        {
            self.changes = changes
            self.schemaChangeAt = schemaChangeAt
        }
    }

}

extension DataExchangeClientTypes {
    public enum SchemaChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case modify
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaChangeType] {
            return [
                .add,
                .modify,
                .remove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .modify: return "MODIFY"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaChangeType(rawValue: rawValue) ?? SchemaChangeType.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.ScopeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lakeFormationTagPolicies = "LakeFormationTagPolicies"
        case redshiftDataShares = "RedshiftDataShares"
        case s3DataAccesses = "S3DataAccesses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lakeFormationTagPolicies = lakeFormationTagPolicies {
            var lakeFormationTagPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lakeFormationTagPolicies)
            for lakeformationtagpolicydetails0 in lakeFormationTagPolicies {
                try lakeFormationTagPoliciesContainer.encode(lakeformationtagpolicydetails0)
            }
        }
        if let redshiftDataShares = redshiftDataShares {
            var redshiftDataSharesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redshiftDataShares)
            for redshiftdatasharedetails0 in redshiftDataShares {
                try redshiftDataSharesContainer.encode(redshiftdatasharedetails0)
            }
        }
        if let s3DataAccesses = s3DataAccesses {
            var s3DataAccessesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3DataAccesses)
            for s3dataaccessdetails0 in s3DataAccesses {
                try s3DataAccessesContainer.encode(s3dataaccessdetails0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lakeFormationTagPoliciesContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.LakeFormationTagPolicyDetails?].self, forKey: .lakeFormationTagPolicies)
        var lakeFormationTagPoliciesDecoded0:[DataExchangeClientTypes.LakeFormationTagPolicyDetails]? = nil
        if let lakeFormationTagPoliciesContainer = lakeFormationTagPoliciesContainer {
            lakeFormationTagPoliciesDecoded0 = [DataExchangeClientTypes.LakeFormationTagPolicyDetails]()
            for structure0 in lakeFormationTagPoliciesContainer {
                if let structure0 = structure0 {
                    lakeFormationTagPoliciesDecoded0?.append(structure0)
                }
            }
        }
        lakeFormationTagPolicies = lakeFormationTagPoliciesDecoded0
        let redshiftDataSharesContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.RedshiftDataShareDetails?].self, forKey: .redshiftDataShares)
        var redshiftDataSharesDecoded0:[DataExchangeClientTypes.RedshiftDataShareDetails]? = nil
        if let redshiftDataSharesContainer = redshiftDataSharesContainer {
            redshiftDataSharesDecoded0 = [DataExchangeClientTypes.RedshiftDataShareDetails]()
            for structure0 in redshiftDataSharesContainer {
                if let structure0 = structure0 {
                    redshiftDataSharesDecoded0?.append(structure0)
                }
            }
        }
        redshiftDataShares = redshiftDataSharesDecoded0
        let s3DataAccessesContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.S3DataAccessDetails?].self, forKey: .s3DataAccesses)
        var s3DataAccessesDecoded0:[DataExchangeClientTypes.S3DataAccessDetails]? = nil
        if let s3DataAccessesContainer = s3DataAccessesContainer {
            s3DataAccessesDecoded0 = [DataExchangeClientTypes.S3DataAccessDetails]()
            for structure0 in s3DataAccessesContainer {
                if let structure0 = structure0 {
                    s3DataAccessesDecoded0?.append(structure0)
                }
            }
        }
        s3DataAccesses = s3DataAccessesDecoded0
    }
}

extension DataExchangeClientTypes {
    /// Details about the scope of the notifications such as the affected resources.
    public struct ScopeDetails {
        /// Underlying LF resources that will be affected by this notification.
        public var lakeFormationTagPolicies: [DataExchangeClientTypes.LakeFormationTagPolicyDetails]?
        /// Underlying Redshift resources that will be affected by this notification.
        public var redshiftDataShares: [DataExchangeClientTypes.RedshiftDataShareDetails]?
        /// Underlying S3 resources that will be affected by this notification.
        public var s3DataAccesses: [DataExchangeClientTypes.S3DataAccessDetails]?

        public init(
            lakeFormationTagPolicies: [DataExchangeClientTypes.LakeFormationTagPolicyDetails]? = nil,
            redshiftDataShares: [DataExchangeClientTypes.RedshiftDataShareDetails]? = nil,
            s3DataAccesses: [DataExchangeClientTypes.S3DataAccessDetails]? = nil
        )
        {
            self.lakeFormationTagPolicies = lakeFormationTagPolicies
            self.redshiftDataShares = redshiftDataShares
            self.s3DataAccesses = s3DataAccesses
        }
    }

}

extension SendApiAssetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
    }
}

extension SendApiAssetInput {

    static func headerProvider(_ value: SendApiAssetInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let assetId = value.assetId {
            items.add(Header(name: "x-amzn-dataexchange-asset-id", value: Swift.String(assetId)))
        }
        if let dataSetId = value.dataSetId {
            items.add(Header(name: "x-amzn-dataexchange-data-set-id", value: Swift.String(dataSetId)))
        }
        if let method = value.method {
            items.add(Header(name: "x-amzn-dataexchange-http-method", value: Swift.String(method)))
        }
        if let path = value.path {
            items.add(Header(name: "x-amzn-dataexchange-path", value: Swift.String(path)))
        }
        if let revisionId = value.revisionId {
            items.add(Header(name: "x-amzn-dataexchange-revision-id", value: Swift.String(revisionId)))
        }
        if let requestHeaders = value.requestHeaders {
            for (prefixHeaderMapKey, prefixHeaderMapValue) in requestHeaders {
                items.add(Header(name: "x-amzn-dataexchange-header-\(prefixHeaderMapKey)", value: Swift.String(prefixHeaderMapValue)))
            }
        }
        return items
    }
}

extension SendApiAssetInput {

    static func queryItemProvider(_ value: SendApiAssetInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let queryStringParameters = value.queryStringParameters {
            let currentQueryItemNames = items.map({$0.name})
            queryStringParameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = ClientRuntime.SDKURLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    items.append(queryItem)
                }
            }
        }
        return items
    }
}

extension SendApiAssetInput {

    static func urlPathProvider(_ value: SendApiAssetInput) -> Swift.String? {
        return "/v1"
    }
}

public struct SendApiAssetInput {
    /// Asset ID value for the API request.
    /// This member is required.
    public var assetId: Swift.String?
    /// The request body.
    public var body: Swift.String?
    /// Data set ID value for the API request.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// HTTP method value for the API request. Alternatively, you can use the appropriate verb in your request.
    public var method: Swift.String?
    /// URI path value for the API request. Alternatively, you can set the URI path directly by invoking /v1/{pathValue}.
    public var path: Swift.String?
    /// Attach query string parameters to the end of the URI (for example, /v1/examplePath?exampleParam=exampleValue).
    public var queryStringParameters: [Swift.String:Swift.String]?
    /// Any header value prefixed with x-amzn-dataexchange-header- will have that stripped before sending the Asset API request. Use this when you want to override a header that AWS Data Exchange uses. Alternatively, you can use the header without a prefix to the HTTP request.
    public var requestHeaders: [Swift.String:Swift.String]?
    /// Revision ID value for the API request.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        body: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        method: Swift.String? = nil,
        path: Swift.String? = nil,
        queryStringParameters: [Swift.String:Swift.String]? = nil,
        requestHeaders: [Swift.String:Swift.String]? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.body = body
        self.dataSetId = dataSetId
        self.method = method
        self.path = path
        self.queryStringParameters = queryStringParameters
        self.requestHeaders = requestHeaders
        self.revisionId = revisionId
    }
}

struct SendApiAssetInputBody {
    let body: Swift.String?
}

extension SendApiAssetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
    }
}

extension SendApiAssetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        let keysForResponseHeaders = httpResponse.headers.dictionary.keys
        if (!keysForResponseHeaders.isEmpty) {
            var mapMember = [Swift.String: String]()
            for headerKey in keysForResponseHeaders {
                let mapMemberValue = httpResponse.headers.dictionary[headerKey]?[0]
                mapMember[headerKey] = mapMemberValue
            }
            self.responseHeaders = mapMember
        } else {
            self.responseHeaders = [:]
        }
        if let data = try await httpResponse.body.readData(), let output = Swift.String(data: data, encoding: .utf8) {
            self.body = output
        } else {
            self.body = nil
        }
    }
}

public struct SendApiAssetOutput {
    /// The response body from the underlying API tracked by the API asset.
    public var body: Swift.String?
    /// The response headers from the underlying API tracked by the API asset.
    public var responseHeaders: [Swift.String:Swift.String]?

    public init(
        body: Swift.String? = nil,
        responseHeaders: [Swift.String:Swift.String]? = nil
    )
    {
        self.body = body
        self.responseHeaders = responseHeaders
    }
}

struct SendApiAssetOutputBody {
    let body: Swift.String?
}

extension SendApiAssetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
    }
}

enum SendApiAssetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SendDataSetNotificationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case comment = "Comment"
        case details = "Details"
        case scope = "Scope"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension SendDataSetNotificationInput {

    static func urlPathProvider(_ value: SendDataSetNotificationInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())/notification"
    }
}

public struct SendDataSetNotificationInput {
    /// Idempotency key for the notification, this key allows us to deduplicate notifications that are sent in quick succession erroneously.
    public var clientToken: Swift.String?
    /// Free-form text field for providers to add information about their notifications.
    public var comment: Swift.String?
    /// Affected data set of the notification.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// Extra details specific to this notification type.
    public var details: DataExchangeClientTypes.NotificationDetails?
    /// Affected scope of this notification such as the underlying resources affected by the notification event.
    public var scope: DataExchangeClientTypes.ScopeDetails?
    /// The type of the notification. Describing the kind of event the notification is alerting you to.
    /// This member is required.
    public var type: DataExchangeClientTypes.NotificationType?

    public init(
        clientToken: Swift.String? = nil,
        comment: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        details: DataExchangeClientTypes.NotificationDetails? = nil,
        scope: DataExchangeClientTypes.ScopeDetails? = nil,
        type: DataExchangeClientTypes.NotificationType? = nil
    )
    {
        self.clientToken = clientToken
        self.comment = comment
        self.dataSetId = dataSetId
        self.details = details
        self.scope = scope
        self.type = type
    }
}

struct SendDataSetNotificationInputBody {
    let scope: DataExchangeClientTypes.ScopeDetails?
    let clientToken: Swift.String?
    let comment: Swift.String?
    let details: DataExchangeClientTypes.NotificationDetails?
    let type: DataExchangeClientTypes.NotificationType?
}

extension SendDataSetNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case comment = "Comment"
        case details = "Details"
        case scope = "Scope"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ScopeDetails.self, forKey: .scope)
        scope = scopeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.NotificationDetails.self, forKey: .details)
        details = detailsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.NotificationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SendDataSetNotificationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SendDataSetNotificationOutput {

    public init() { }
}

enum SendDataSetNotificationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataExchangeClientTypes {
    public enum ServerSideEncryptionTypes: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes256
        case awsKms
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerSideEncryptionTypes] {
            return [
                .aes256,
                .awsKms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes256: return "AES256"
            case .awsKms: return "aws:kms"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerSideEncryptionTypes(rawValue: rawValue) ?? ServerSideEncryptionTypes.sdkUnknown(rawValue)
        }
    }
}

extension ServiceLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.limitName = output.limitName
            self.properties.limitValue = output.limitValue
            self.properties.message = output.message
        } else {
            self.properties.limitName = nil
            self.properties.limitValue = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has exceeded the quotas imposed by the service.
public struct ServiceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The name of the limit that was reached.
        public internal(set) var limitName: DataExchangeClientTypes.LimitName? = nil
        /// The value of the exceeded limit.
        public internal(set) var limitValue: Swift.Double? = nil
        /// The request has exceeded the quotas imposed by the service.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limitName: DataExchangeClientTypes.LimitName? = nil,
        limitValue: Swift.Double? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.limitName = limitName
        self.properties.limitValue = limitValue
        self.properties.message = message
    }
}

struct ServiceLimitExceededExceptionBody {
    let limitName: DataExchangeClientTypes.LimitName?
    let limitValue: Swift.Double?
    let message: Swift.String?
}

extension ServiceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitName = "LimitName"
        case limitValue = "LimitValue"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitNameDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.LimitName.self, forKey: .limitName)
        limitName = limitNameDecoded
        let limitValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .limitValue)
        limitValue = limitValueDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartJobInput {

    static func urlPathProvider(_ value: StartJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/v1/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct StartJobInput {
    /// The unique identifier for a job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartJobInputBody {
}

extension StartJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartJobOutput {

    public init() { }
}

enum StartJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataExchangeClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case error
        case inProgress
        case timedOut
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .cancelled,
                .completed,
                .error,
                .inProgress,
                .timedOut,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case .timedOut: return "TIMED_OUT"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension DataExchangeClientTypes.TableLFTagPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            var expressionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expression)
            for lftag0 in expression {
                try expressionContainer.encode(lftag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.LFTag?].self, forKey: .expression)
        var expressionDecoded0:[DataExchangeClientTypes.LFTag]? = nil
        if let expressionContainer = expressionContainer {
            expressionDecoded0 = [DataExchangeClientTypes.LFTag]()
            for structure0 in expressionContainer {
                if let structure0 = structure0 {
                    expressionDecoded0?.append(structure0)
                }
            }
        }
        expression = expressionDecoded0
    }
}

extension DataExchangeClientTypes {
    /// The LF-tag policy for a table resource.
    public struct TableLFTagPolicy {
        /// A list of LF-tag conditions that apply to table resources.
        /// This member is required.
        public var expression: [DataExchangeClientTypes.LFTag]?

        public init(
            expression: [DataExchangeClientTypes.LFTag]? = nil
        )
        {
            self.expression = expression
        }
    }

}

extension DataExchangeClientTypes.TableLFTagPolicyAndPermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case permissions = "Permissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            var expressionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .expression)
            for lftag0 in expression {
                try expressionContainer.encode(lftag0)
            }
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for tabletagpolicylfpermission0 in permissions {
                try permissionsContainer.encode(tabletagpolicylfpermission0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.LFTag?].self, forKey: .expression)
        var expressionDecoded0:[DataExchangeClientTypes.LFTag]? = nil
        if let expressionContainer = expressionContainer {
            expressionDecoded0 = [DataExchangeClientTypes.LFTag]()
            for structure0 in expressionContainer {
                if let structure0 = structure0 {
                    expressionDecoded0?.append(structure0)
                }
            }
        }
        expression = expressionDecoded0
        let permissionsContainer = try containerValues.decodeIfPresent([DataExchangeClientTypes.TableTagPolicyLFPermission?].self, forKey: .permissions)
        var permissionsDecoded0:[DataExchangeClientTypes.TableTagPolicyLFPermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [DataExchangeClientTypes.TableTagPolicyLFPermission]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

extension DataExchangeClientTypes {
    /// The LF-tag policy and permissions that apply to table resources.
    public struct TableLFTagPolicyAndPermissions {
        /// A list of LF-tag conditions that apply to table resources.
        /// This member is required.
        public var expression: [DataExchangeClientTypes.LFTag]?
        /// The permissions granted to subscribers on table resources.
        /// This member is required.
        public var permissions: [DataExchangeClientTypes.TableTagPolicyLFPermission]?

        public init(
            expression: [DataExchangeClientTypes.LFTag]? = nil,
            permissions: [DataExchangeClientTypes.TableTagPolicyLFPermission]? = nil
        )
        {
            self.expression = expression
            self.permissions = permissions
        }
    }

}

extension DataExchangeClientTypes {
    public enum TableTagPolicyLFPermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case describe
        case select
        case sdkUnknown(Swift.String)

        public static var allCases: [TableTagPolicyLFPermission] {
            return [
                .describe,
                .select,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .describe: return "DESCRIBE"
            case .select: return "SELECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableTagPolicyLFPermission(rawValue: rawValue) ?? TableTagPolicyLFPermission.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapOf__string0) in tags {
                try tagsContainer.encode(mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput {
    /// An Amazon Resource Name (ARN) that uniquely identifies an AWS resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A label that consists of a customer-defined key and an optional value.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The limit on the number of requests per second was exceeded.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataExchangeClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createS3DataAccessFromS3Bucket
        case exportAssetsToS3
        case exportAssetToSignedUrl
        case exportRevisionsToS3
        case importAssetsFromLakeFormationTagPolicy
        case importAssetsFromRedshiftDataShares
        case importAssetsFromS3
        case importAssetFromApiGatewayApi
        case importAssetFromSignedUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .createS3DataAccessFromS3Bucket,
                .exportAssetsToS3,
                .exportAssetToSignedUrl,
                .exportRevisionsToS3,
                .importAssetsFromLakeFormationTagPolicy,
                .importAssetsFromRedshiftDataShares,
                .importAssetsFromS3,
                .importAssetFromApiGatewayApi,
                .importAssetFromSignedUrl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createS3DataAccessFromS3Bucket: return "CREATE_S3_DATA_ACCESS_FROM_S3_BUCKET"
            case .exportAssetsToS3: return "EXPORT_ASSETS_TO_S3"
            case .exportAssetToSignedUrl: return "EXPORT_ASSET_TO_SIGNED_URL"
            case .exportRevisionsToS3: return "EXPORT_REVISIONS_TO_S3"
            case .importAssetsFromLakeFormationTagPolicy: return "IMPORT_ASSETS_FROM_LAKE_FORMATION_TAG_POLICY"
            case .importAssetsFromRedshiftDataShares: return "IMPORT_ASSETS_FROM_REDSHIFT_DATA_SHARES"
            case .importAssetsFromS3: return "IMPORT_ASSETS_FROM_S3"
            case .importAssetFromApiGatewayApi: return "IMPORT_ASSET_FROM_API_GATEWAY_API"
            case .importAssetFromSignedUrl: return "IMPORT_ASSET_FROM_SIGNED_URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// An Amazon Resource Name (ARN) that uniquely identifies an AWS resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key tags.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAssetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAssetInput {

    static func urlPathProvider(_ value: UpdateAssetInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let revisionId = value.revisionId else {
            return nil
        }
        guard let assetId = value.assetId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())/assets/\(assetId.urlPercentEncoding())"
    }
}

public struct UpdateAssetInput {
    /// The unique identifier for an asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The name of the asset. When importing from Amazon S3, the Amazon S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target Amazon S3 object key. When importing from Amazon API Gateway API, the API name is used as the asset name. When importing from Amazon Redshift, the datashare name is used as the asset name. When importing from AWS Lake Formation, the static values of "Database(s) included in the LF-tag policy" or "Table(s) included in LF-tag policy" are used as the name.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.dataSetId = dataSetId
        self.name = name
        self.revisionId = revisionId
    }
}

struct UpdateAssetInputBody {
    let name: Swift.String?
}

extension UpdateAssetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateAssetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAssetOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.assetDetails = output.assetDetails
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.id = output.id
            self.name = output.name
            self.revisionId = output.revisionId
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetDetails = nil
            self.assetType = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.id = nil
            self.name = nil
            self.revisionId = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateAssetOutput {
    /// The ARN for the asset.
    public var arn: Swift.String?
    /// Details about the asset.
    public var assetDetails: DataExchangeClientTypes.AssetDetails?
    /// The type of asset that is added to a data set.
    public var assetType: DataExchangeClientTypes.AssetType?
    /// The date and time that the asset was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The unique identifier for the data set associated with this asset.
    public var dataSetId: Swift.String?
    /// The unique identifier for the asset.
    public var id: Swift.String?
    /// The name of the asset. When importing from Amazon S3, the Amazon S3 object key is used as the asset name. When exporting to Amazon S3, the asset name is used as default target Amazon S3 object key. When importing from Amazon API Gateway API, the API name is used as the asset name. When importing from Amazon Redshift, the datashare name is used as the asset name. When importing from AWS Lake Formation, the static values of "Database(s) included in the LF-tag policy"- or "Table(s) included in LF-tag policy" are used as the asset name.
    public var name: Swift.String?
    /// The unique identifier for the revision associated with this asset.
    public var revisionId: Swift.String?
    /// The asset ID of the owned asset corresponding to the entitled asset being viewed. This parameter is returned when an asset owner is viewing the entitled copy of its owned asset.
    public var sourceId: Swift.String?
    /// The date and time that the asset was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        assetDetails: DataExchangeClientTypes.AssetDetails? = nil,
        assetType: DataExchangeClientTypes.AssetType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        dataSetId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        sourceId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.assetDetails = assetDetails
        self.assetType = assetType
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.id = id
        self.name = name
        self.revisionId = revisionId
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct UpdateAssetOutputBody {
    let arn: Swift.String?
    let assetDetails: DataExchangeClientTypes.AssetDetails?
    let assetType: DataExchangeClientTypes.AssetType?
    let createdAt: ClientRuntime.Date?
    let dataSetId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let revisionId: Swift.String?
    let sourceId: Swift.String?
    let updatedAt: ClientRuntime.Date?
}

extension UpdateAssetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetDetails = "AssetDetails"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case id = "Id"
        case name = "Name"
        case revisionId = "RevisionId"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetDetails.self, forKey: .assetDetails)
        assetDetails = assetDetailsDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum UpdateAssetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDataSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateDataSetInput {

    static func urlPathProvider(_ value: UpdateDataSetInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())"
    }
}

public struct UpdateDataSetInput {
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The description for the data set.
    public var description: Swift.String?
    /// The name of the data set.
    public var name: Swift.String?

    public init(
        dataSetId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.dataSetId = dataSetId
        self.description = description
        self.name = name
    }
}

struct UpdateDataSetInputBody {
    let description: Swift.String?
    let name: Swift.String?
}

extension UpdateDataSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateDataSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDataSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.assetType = output.assetType
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.origin = output.origin
            self.originDetails = output.originDetails
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.assetType = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.origin = nil
            self.originDetails = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateDataSetOutput {
    /// The ARN for the data set.
    public var arn: Swift.String?
    /// The type of asset that is added to a data set.
    public var assetType: DataExchangeClientTypes.AssetType?
    /// The date and time that the data set was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The description for the data set.
    public var description: Swift.String?
    /// The unique identifier for the data set.
    public var id: Swift.String?
    /// The name of the data set.
    public var name: Swift.String?
    /// A property that defines the data set as OWNED by the account (for providers) or ENTITLED to the account (for subscribers).
    public var origin: DataExchangeClientTypes.Origin?
    /// If the origin of this data set is ENTITLED, includes the details for the product on AWS Marketplace.
    public var originDetails: DataExchangeClientTypes.OriginDetails?
    /// The data set ID of the owned data set corresponding to the entitled data set being viewed. This parameter is returned when a data set owner is viewing the entitled copy of its owned data set.
    public var sourceId: Swift.String?
    /// The date and time that the data set was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        assetType: DataExchangeClientTypes.AssetType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        origin: DataExchangeClientTypes.Origin? = nil,
        originDetails: DataExchangeClientTypes.OriginDetails? = nil,
        sourceId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.assetType = assetType
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.origin = origin
        self.originDetails = originDetails
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct UpdateDataSetOutputBody {
    let arn: Swift.String?
    let assetType: DataExchangeClientTypes.AssetType?
    let createdAt: ClientRuntime.Date?
    let description: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let origin: DataExchangeClientTypes.Origin?
    let originDetails: DataExchangeClientTypes.OriginDetails?
    let sourceId: Swift.String?
    let updatedAt: ClientRuntime.Date?
}

extension UpdateDataSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assetType = "AssetType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case origin = "Origin"
        case originDetails = "OriginDetails"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let originDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Origin.self, forKey: .origin)
        origin = originDecoded
        let originDetailsDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.OriginDetails.self, forKey: .originDetails)
        originDetails = originDetailsDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum UpdateDataSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEventActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
    }
}

extension UpdateEventActionInput {

    static func urlPathProvider(_ value: UpdateEventActionInput) -> Swift.String? {
        guard let eventActionId = value.eventActionId else {
            return nil
        }
        return "/v1/event-actions/\(eventActionId.urlPercentEncoding())"
    }
}

public struct UpdateEventActionInput {
    /// What occurs after a certain event.
    public var action: DataExchangeClientTypes.Action?
    /// The unique identifier for the event action.
    /// This member is required.
    public var eventActionId: Swift.String?

    public init(
        action: DataExchangeClientTypes.Action? = nil,
        eventActionId: Swift.String? = nil
    )
    {
        self.action = action
        self.eventActionId = eventActionId
    }
}

struct UpdateEventActionInputBody {
    let action: DataExchangeClientTypes.Action?
}

extension UpdateEventActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateEventActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEventActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.event = output.event
            self.id = output.id
            self.updatedAt = output.updatedAt
        } else {
            self.action = nil
            self.arn = nil
            self.createdAt = nil
            self.event = nil
            self.id = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateEventActionOutput {
    /// What occurs after a certain event.
    public var action: DataExchangeClientTypes.Action?
    /// The ARN for the event action.
    public var arn: Swift.String?
    /// The date and time that the event action was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// What occurs to start an action.
    public var event: DataExchangeClientTypes.Event?
    /// The unique identifier for the event action.
    public var id: Swift.String?
    /// The date and time that the event action was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        action: DataExchangeClientTypes.Action? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        event: DataExchangeClientTypes.Event? = nil,
        id: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.createdAt = createdAt
        self.event = event
        self.id = id
        self.updatedAt = updatedAt
    }
}

struct UpdateEventActionOutputBody {
    let action: DataExchangeClientTypes.Action?
    let arn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let event: DataExchangeClientTypes.Event?
    let id: Swift.String?
    let updatedAt: ClientRuntime.Date?
}

extension UpdateEventActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case event = "Event"
        case id = "Id"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let eventDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum UpdateEventActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRevisionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case finalized = "Finalized"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let finalized = self.finalized {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
    }
}

extension UpdateRevisionInput {

    static func urlPathProvider(_ value: UpdateRevisionInput) -> Swift.String? {
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let revisionId = value.revisionId else {
            return nil
        }
        return "/v1/data-sets/\(dataSetId.urlPercentEncoding())/revisions/\(revisionId.urlPercentEncoding())"
    }
}

public struct UpdateRevisionInput {
    /// An optional comment about the revision.
    public var comment: Swift.String?
    /// The unique identifier for a data set.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// Finalizing a revision tells AWS Data Exchange that your changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products.
    public var finalized: Swift.Bool?
    /// The unique identifier for a revision.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        comment: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        finalized: Swift.Bool? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.comment = comment
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.revisionId = revisionId
    }
}

struct UpdateRevisionInputBody {
    let comment: Swift.String?
    let finalized: Swift.Bool?
}

extension UpdateRevisionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case finalized = "Finalized"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
    }
}

extension UpdateRevisionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRevisionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.comment = output.comment
            self.createdAt = output.createdAt
            self.dataSetId = output.dataSetId
            self.finalized = output.finalized
            self.id = output.id
            self.revocationComment = output.revocationComment
            self.revoked = output.revoked
            self.revokedAt = output.revokedAt
            self.sourceId = output.sourceId
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.comment = nil
            self.createdAt = nil
            self.dataSetId = nil
            self.finalized = nil
            self.id = nil
            self.revocationComment = nil
            self.revoked = nil
            self.revokedAt = nil
            self.sourceId = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateRevisionOutput {
    /// The ARN for the revision.
    public var arn: Swift.String?
    /// An optional comment about the revision.
    public var comment: Swift.String?
    /// The date and time that the revision was created, in ISO 8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The unique identifier for the data set associated with the data set revision.
    public var dataSetId: Swift.String?
    /// To publish a revision to a data set in a product, the revision must first be finalized. Finalizing a revision tells AWS Data Exchange that changes to the assets in the revision are complete. After it's in this read-only state, you can publish the revision to your products. Finalized revisions can be published through the AWS Data Exchange console or the AWS Marketplace Catalog API, using the StartChangeSet AWS Marketplace Catalog API action. When using the API, revisions are uniquely identified by their ARN.
    public var finalized: Swift.Bool?
    /// The unique identifier for the revision.
    public var id: Swift.String?
    /// A required comment to inform subscribers of the reason their access to the revision was revoked.
    public var revocationComment: Swift.String?
    /// A status indicating that subscribers' access to the revision was revoked.
    public var revoked: Swift.Bool?
    /// The date and time that the revision was revoked, in ISO 8601 format.
    public var revokedAt: ClientRuntime.Date?
    /// The revision ID of the owned revision corresponding to the entitled revision being viewed. This parameter is returned when a revision owner is viewing the entitled copy of its owned revision.
    public var sourceId: Swift.String?
    /// The date and time that the revision was last updated, in ISO 8601 format.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        comment: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        dataSetId: Swift.String? = nil,
        finalized: Swift.Bool? = nil,
        id: Swift.String? = nil,
        revocationComment: Swift.String? = nil,
        revoked: Swift.Bool? = nil,
        revokedAt: ClientRuntime.Date? = nil,
        sourceId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.comment = comment
        self.createdAt = createdAt
        self.dataSetId = dataSetId
        self.finalized = finalized
        self.id = id
        self.revocationComment = revocationComment
        self.revoked = revoked
        self.revokedAt = revokedAt
        self.sourceId = sourceId
        self.updatedAt = updatedAt
    }
}

struct UpdateRevisionOutputBody {
    let arn: Swift.String?
    let comment: Swift.String?
    let createdAt: ClientRuntime.Date?
    let dataSetId: Swift.String?
    let finalized: Swift.Bool?
    let id: Swift.String?
    let sourceId: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let revocationComment: Swift.String?
    let revoked: Swift.Bool?
    let revokedAt: ClientRuntime.Date?
}

extension UpdateRevisionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case comment = "Comment"
        case createdAt = "CreatedAt"
        case dataSetId = "DataSetId"
        case finalized = "Finalized"
        case id = "Id"
        case revocationComment = "RevocationComment"
        case revoked = "Revoked"
        case revokedAt = "RevokedAt"
        case sourceId = "SourceId"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let dataSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSetId)
        dataSetId = dataSetIdDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .finalized)
        finalized = finalizedDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let revocationCommentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revocationComment)
        revocationComment = revocationCommentDecoded
        let revokedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .revoked)
        revoked = revokedDecoded
        let revokedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
    }
}

enum UpdateRevisionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionCause = output.exceptionCause
            self.properties.message = output.message
        } else {
            self.properties.exceptionCause = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The unique identifier for the resource that couldn't be found.
        public internal(set) var exceptionCause: DataExchangeClientTypes.ExceptionCause? = nil
        /// The message that informs you about what was invalid about the request.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionCause: DataExchangeClientTypes.ExceptionCause? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.exceptionCause = exceptionCause
        self.properties.message = message
    }
}

struct ValidationExceptionBody {
    let message: Swift.String?
    let exceptionCause: DataExchangeClientTypes.ExceptionCause?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionCause = "ExceptionCause"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let exceptionCauseDecoded = try containerValues.decodeIfPresent(DataExchangeClientTypes.ExceptionCause.self, forKey: .exceptionCause)
        exceptionCause = exceptionCauseDecoded
    }
}
