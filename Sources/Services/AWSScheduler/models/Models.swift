// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SchedulerClientTypes {
    public enum AssignPublicIp: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AssignPublicIp] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssignPublicIp(rawValue: rawValue) ?? AssignPublicIp.sdkUnknown(rawValue)
        }
    }
}

extension SchedulerClientTypes.AwsVpcConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignPublicIp = "AssignPublicIp"
        case securityGroups = "SecurityGroups"
        case subnets = "Subnets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignPublicIp = self.assignPublicIp {
            try encodeContainer.encode(assignPublicIp.rawValue, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroup0 in securityGroups {
                try securityGroupsContainer.encode(securitygroup0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnet0 in subnets {
                try subnetsContainer.encode(subnet0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let assignPublicIpDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.AssignPublicIp.self, forKey: .assignPublicIp)
        assignPublicIp = assignPublicIpDecoded
    }
}

extension SchedulerClientTypes {
    /// This structure specifies the VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.
    public struct AwsVpcConfiguration: Swift.Equatable {
        /// Specifies whether the task's elastic network interface receives a public IP address. You can specify ENABLED only when LaunchType in EcsParameters is set to FARGATE.
        public var assignPublicIp: SchedulerClientTypes.AssignPublicIp?
        /// Specifies the security groups associated with the task. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.
        public var securityGroups: [Swift.String]?
        /// Specifies the subnets associated with the task. These subnets must all be in the same VPC. You can specify as many as 16 subnets.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init (
            assignPublicIp: SchedulerClientTypes.AssignPublicIp? = nil,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

extension SchedulerClientTypes.CapacityProviderStrategyItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base
        case capacityProvider
        case weight
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if base != 0 {
            try encodeContainer.encode(base, forKey: .base)
        }
        if let capacityProvider = self.capacityProvider {
            try encodeContainer.encode(capacityProvider, forKey: .capacityProvider)
        }
        if weight != 0 {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityProvider)
        capacityProvider = capacityProviderDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight) ?? 0
        weight = weightDecoded
        let baseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .base) ?? 0
        base = baseDecoded
    }
}

extension SchedulerClientTypes {
    /// The details of a capacity provider strategy.
    public struct CapacityProviderStrategyItem: Swift.Equatable {
        /// The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of 0 is used.
        public var base: Swift.Int
        /// The short name of the capacity provider.
        /// This member is required.
        public var capacityProvider: Swift.String?
        /// The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.
        public var weight: Swift.Int

        public init (
            base: Swift.Int = 0,
            capacityProvider: Swift.String? = nil,
            weight: Swift.Int = 0
        )
        {
            self.base = base
            self.capacityProvider = capacityProvider
            self.weight = weight
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting the resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateScheduleGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateScheduleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/schedule-groups/\(name.urlPercentEncoding())"
    }
}

public struct CreateScheduleGroupInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The name of the schedule group that you are creating.
    /// This member is required.
    public var name: Swift.String?
    /// The list of tags to associate with the schedule group.
    public var tags: [SchedulerClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [SchedulerClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.tags = tags
    }
}

struct CreateScheduleGroupInputBody: Swift.Equatable {
    let tags: [SchedulerClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateScheduleGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([SchedulerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SchedulerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SchedulerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateScheduleGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateScheduleGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateScheduleGroupOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateScheduleGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateScheduleGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.scheduleGroupArn = output.scheduleGroupArn
        } else {
            self.scheduleGroupArn = nil
        }
    }
}

public struct CreateScheduleGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schedule group.
    /// This member is required.
    public var scheduleGroupArn: Swift.String?

    public init (
        scheduleGroupArn: Swift.String? = nil
    )
    {
        self.scheduleGroupArn = scheduleGroupArn
    }
}

struct CreateScheduleGroupOutputResponseBody: Swift.Equatable {
    let scheduleGroupArn: Swift.String?
}

extension CreateScheduleGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduleGroupArn = "ScheduleGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleGroupArn)
        scheduleGroupArn = scheduleGroupArnDecoded
    }
}

extension CreateScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case endDate = "EndDate"
        case flexibleTimeWindow = "FlexibleTimeWindow"
        case groupName = "GroupName"
        case kmsKeyArn = "KmsKeyArn"
        case scheduleExpression = "ScheduleExpression"
        case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
        case startDate = "StartDate"
        case state = "State"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endDate = self.endDate {
            try encodeContainer.encodeTimestamp(endDate, format: .epochSeconds, forKey: .endDate)
        }
        if let flexibleTimeWindow = self.flexibleTimeWindow {
            try encodeContainer.encode(flexibleTimeWindow, forKey: .flexibleTimeWindow)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let scheduleExpressionTimezone = self.scheduleExpressionTimezone {
            try encodeContainer.encode(scheduleExpressionTimezone, forKey: .scheduleExpressionTimezone)
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .epochSeconds, forKey: .startDate)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension CreateScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/schedules/\(name.urlPercentEncoding())"
    }
}

public struct CreateScheduleInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The description you specify for the schedule.
    public var description: Swift.String?
    /// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the EndDate you specify. EventBridge Scheduler ignores EndDate for one-time schedules.
    public var endDate: ClientRuntime.Date?
    /// Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
    /// This member is required.
    public var flexibleTimeWindow: SchedulerClientTypes.FlexibleTimeWindow?
    /// The name of the schedule group to associate with this schedule. If you omit this, the default schedule group is used.
    public var groupName: Swift.String?
    /// The Amazon Resource Name (ARN) for the customer managed KMS key that EventBridge Scheduler will use to encrypt and decrypt your data.
    public var kmsKeyArn: Swift.String?
    /// The name of the schedule that you are creating.
    /// This member is required.
    public var name: Swift.String?
    /// The expression that defines when the schedule runs. The following formats are supported.
    ///
    /// * at expression - at(yyyy-mm-ddThh:mm:ss)
    ///
    /// * rate expression - rate(unit value)
    ///
    /// * cron expression - cron(fields)
    ///
    ///
    /// You can use at expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use rate and cron expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. A cron expression consists of six fields separated by white spaces: (minutes hours day_of_month month day_of_week year). A rate expression consists of a value as a positive integer, and a unit with the following options: minute | minutes | hour | hours | day | days For more information and examples, see [Schedule types on EventBridge Scheduler](https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html) in the EventBridge Scheduler User Guide.
    /// This member is required.
    public var scheduleExpression: Swift.String?
    /// The timezone in which the scheduling expression is evaluated.
    public var scheduleExpressionTimezone: Swift.String?
    /// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the StartDate you specify. EventBridge Scheduler ignores StartDate for one-time schedules.
    public var startDate: ClientRuntime.Date?
    /// Specifies whether the schedule is enabled or disabled.
    public var state: SchedulerClientTypes.ScheduleState?
    /// The schedule's target.
    /// This member is required.
    public var target: SchedulerClientTypes.Target?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        endDate: ClientRuntime.Date? = nil,
        flexibleTimeWindow: SchedulerClientTypes.FlexibleTimeWindow? = nil,
        groupName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        scheduleExpression: Swift.String? = nil,
        scheduleExpressionTimezone: Swift.String? = nil,
        startDate: ClientRuntime.Date? = nil,
        state: SchedulerClientTypes.ScheduleState? = nil,
        target: SchedulerClientTypes.Target? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.endDate = endDate
        self.flexibleTimeWindow = flexibleTimeWindow
        self.groupName = groupName
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.scheduleExpression = scheduleExpression
        self.scheduleExpressionTimezone = scheduleExpressionTimezone
        self.startDate = startDate
        self.state = state
        self.target = target
    }
}

struct CreateScheduleInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let scheduleExpression: Swift.String?
    let startDate: ClientRuntime.Date?
    let endDate: ClientRuntime.Date?
    let description: Swift.String?
    let scheduleExpressionTimezone: Swift.String?
    let state: SchedulerClientTypes.ScheduleState?
    let kmsKeyArn: Swift.String?
    let target: SchedulerClientTypes.Target?
    let flexibleTimeWindow: SchedulerClientTypes.FlexibleTimeWindow?
    let clientToken: Swift.String?
}

extension CreateScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case endDate = "EndDate"
        case flexibleTimeWindow = "FlexibleTimeWindow"
        case groupName = "GroupName"
        case kmsKeyArn = "KmsKeyArn"
        case scheduleExpression = "ScheduleExpression"
        case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
        case startDate = "StartDate"
        case state = "State"
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDate)
        endDate = endDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scheduleExpressionTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpressionTimezone)
        scheduleExpressionTimezone = scheduleExpressionTimezoneDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.ScheduleState.self, forKey: .state)
        state = stateDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let targetDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.Target.self, forKey: .target)
        target = targetDecoded
        let flexibleTimeWindowDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.FlexibleTimeWindow.self, forKey: .flexibleTimeWindow)
        flexibleTimeWindow = flexibleTimeWindowDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateScheduleOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.scheduleArn = output.scheduleArn
        } else {
            self.scheduleArn = nil
        }
    }
}

public struct CreateScheduleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schedule.
    /// This member is required.
    public var scheduleArn: Swift.String?

    public init (
        scheduleArn: Swift.String? = nil
    )
    {
        self.scheduleArn = scheduleArn
    }
}

struct CreateScheduleOutputResponseBody: Swift.Equatable {
    let scheduleArn: Swift.String?
}

extension CreateScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduleArn = "ScheduleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
    }
}

extension SchedulerClientTypes.DeadLetterConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SchedulerClientTypes {
    /// An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.
    public struct DeadLetterConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the SQS queue specified as the destination for the dead-letter queue.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension DeleteScheduleGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteScheduleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/schedule-groups/\(name.urlPercentEncoding())"
    }
}

public struct DeleteScheduleGroupInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The name of the schedule group to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
    }
}

struct DeleteScheduleGroupInputBody: Swift.Equatable {
}

extension DeleteScheduleGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteScheduleGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteScheduleGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteScheduleGroupOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteScheduleGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteScheduleGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteScheduleInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let groupName = groupName {
                let groupNameQueryItem = ClientRuntime.URLQueryItem(name: "groupName".urlPercentEncoding(), value: Swift.String(groupName).urlPercentEncoding())
                items.append(groupNameQueryItem)
            }
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/schedules/\(name.urlPercentEncoding())"
    }
}

public struct DeleteScheduleInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The name of the schedule group associated with this schedule. If you omit this, the default schedule group is used.
    public var groupName: Swift.String?
    /// The name of the schedule to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        groupName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.groupName = groupName
        self.name = name
    }
}

struct DeleteScheduleInputBody: Swift.Equatable {
}

extension DeleteScheduleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteScheduleOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteScheduleOutputResponse: Swift.Equatable {

    public init () { }
}

extension SchedulerClientTypes.EcsParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityProviderStrategy = "CapacityProviderStrategy"
        case enableECSManagedTags = "EnableECSManagedTags"
        case enableExecuteCommand = "EnableExecuteCommand"
        case group = "Group"
        case launchType = "LaunchType"
        case networkConfiguration = "NetworkConfiguration"
        case placementConstraints = "PlacementConstraints"
        case placementStrategy = "PlacementStrategy"
        case platformVersion = "PlatformVersion"
        case propagateTags = "PropagateTags"
        case referenceId = "ReferenceId"
        case tags = "Tags"
        case taskCount = "TaskCount"
        case taskDefinitionArn = "TaskDefinitionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityProviderStrategy = capacityProviderStrategy {
            var capacityProviderStrategyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capacityProviderStrategy)
            for capacityproviderstrategyitem0 in capacityProviderStrategy {
                try capacityProviderStrategyContainer.encode(capacityproviderstrategyitem0)
            }
        }
        if let enableECSManagedTags = self.enableECSManagedTags {
            try encodeContainer.encode(enableECSManagedTags, forKey: .enableECSManagedTags)
        }
        if let enableExecuteCommand = self.enableExecuteCommand {
            try encodeContainer.encode(enableExecuteCommand, forKey: .enableExecuteCommand)
        }
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let launchType = self.launchType {
            try encodeContainer.encode(launchType.rawValue, forKey: .launchType)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let placementConstraints = placementConstraints {
            var placementConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementConstraints)
            for placementconstraint0 in placementConstraints {
                try placementConstraintsContainer.encode(placementconstraint0)
            }
        }
        if let placementStrategy = placementStrategy {
            var placementStrategyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementStrategy)
            for placementstrategy0 in placementStrategy {
                try placementStrategyContainer.encode(placementstrategy0)
            }
        }
        if let platformVersion = self.platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let propagateTags = self.propagateTags {
            try encodeContainer.encode(propagateTags.rawValue, forKey: .propagateTags)
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagmap0 in tags {
                var tagmap0Container = tagsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, tagMap1) in tagmap0 {
                    try tagmap0Container.encode(tagMap1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let taskCount = self.taskCount {
            try encodeContainer.encode(taskCount, forKey: .taskCount)
        }
        if let taskDefinitionArn = self.taskDefinitionArn {
            try encodeContainer.encode(taskDefinitionArn, forKey: .taskDefinitionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskDefinitionArn)
        taskDefinitionArn = taskDefinitionArnDecoded
        let taskCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .taskCount)
        taskCount = taskCountDecoded
        let launchTypeDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.LaunchType.self, forKey: .launchType)
        launchType = launchTypeDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let capacityProviderStrategyContainer = try containerValues.decodeIfPresent([SchedulerClientTypes.CapacityProviderStrategyItem?].self, forKey: .capacityProviderStrategy)
        var capacityProviderStrategyDecoded0:[SchedulerClientTypes.CapacityProviderStrategyItem]? = nil
        if let capacityProviderStrategyContainer = capacityProviderStrategyContainer {
            capacityProviderStrategyDecoded0 = [SchedulerClientTypes.CapacityProviderStrategyItem]()
            for structure0 in capacityProviderStrategyContainer {
                if let structure0 = structure0 {
                    capacityProviderStrategyDecoded0?.append(structure0)
                }
            }
        }
        capacityProviderStrategy = capacityProviderStrategyDecoded0
        let enableECSManagedTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableECSManagedTags)
        enableECSManagedTags = enableECSManagedTagsDecoded
        let enableExecuteCommandDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableExecuteCommand)
        enableExecuteCommand = enableExecuteCommandDecoded
        let placementConstraintsContainer = try containerValues.decodeIfPresent([SchedulerClientTypes.PlacementConstraint?].self, forKey: .placementConstraints)
        var placementConstraintsDecoded0:[SchedulerClientTypes.PlacementConstraint]? = nil
        if let placementConstraintsContainer = placementConstraintsContainer {
            placementConstraintsDecoded0 = [SchedulerClientTypes.PlacementConstraint]()
            for structure0 in placementConstraintsContainer {
                if let structure0 = structure0 {
                    placementConstraintsDecoded0?.append(structure0)
                }
            }
        }
        placementConstraints = placementConstraintsDecoded0
        let placementStrategyContainer = try containerValues.decodeIfPresent([SchedulerClientTypes.PlacementStrategy?].self, forKey: .placementStrategy)
        var placementStrategyDecoded0:[SchedulerClientTypes.PlacementStrategy]? = nil
        if let placementStrategyContainer = placementStrategyContainer {
            placementStrategyDecoded0 = [SchedulerClientTypes.PlacementStrategy]()
            for structure0 in placementStrategyContainer {
                if let structure0 = structure0 {
                    placementStrategyDecoded0?.append(structure0)
                }
            }
        }
        placementStrategy = placementStrategyDecoded0
        let propagateTagsDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.PropagateTags.self, forKey: .propagateTags)
        propagateTags = propagateTagsDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .tags)
        var tagsDecoded0:[[Swift.String:Swift.String]]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in tagsContainer {
                var tagsContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    tagsContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, tagvalue1) in map0 {
                        if let tagvalue1 = tagvalue1 {
                            tagsContainerDecoded0?[key1] = tagvalue1
                        }
                    }
                }
                if let tagsContainerDecoded0 = tagsContainerDecoded0 {
                    tagsDecoded0?.append(tagsContainerDecoded0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SchedulerClientTypes {
    /// The templated target type for the Amazon ECS [RunTask](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) API operation.
    public struct EcsParameters: Swift.Equatable {
        /// The capacity provider strategy to use for the task.
        public var capacityProviderStrategy: [SchedulerClientTypes.CapacityProviderStrategyItem]?
        /// Specifies whether to enable Amazon ECS managed tags for the task. For more information, see [Tagging Your Amazon ECS Resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the Amazon ECS Developer Guide.
        public var enableECSManagedTags: Swift.Bool?
        /// Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.
        public var enableExecuteCommand: Swift.Bool?
        /// Specifies an ECS task group for the task. The maximum length is 255 characters.
        public var group: Swift.String?
        /// Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The FARGATE value is supported only in the Regions where Fargate with Amazon ECS is supported. For more information, see [AWS Fargate on Amazon ECS](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html) in the Amazon ECS Developer Guide.
        public var launchType: SchedulerClientTypes.LaunchType?
        /// This structure specifies the network configuration for an ECS task.
        public var networkConfiguration: SchedulerClientTypes.NetworkConfiguration?
        /// An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).
        public var placementConstraints: [SchedulerClientTypes.PlacementConstraint]?
        /// The task placement strategy for a task or service.
        public var placementStrategy: [SchedulerClientTypes.PlacementStrategy]?
        /// Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0.
        public var platformVersion: Swift.String?
        /// Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use Amazon ECS's [TagResource](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html) API action.
        public var propagateTags: SchedulerClientTypes.PropagateTags?
        /// The reference ID to use for the task.
        public var referenceId: Swift.String?
        /// The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. For more information, see [RunTask](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) in the Amazon ECS API Reference.
        public var tags: [[Swift.String:Swift.String]]?
        /// The number of tasks to create based on TaskDefinition. The default is 1.
        public var taskCount: Swift.Int?
        /// The Amazon Resource Name (ARN) of the task definition to use if the event target is an Amazon ECS task.
        /// This member is required.
        public var taskDefinitionArn: Swift.String?

        public init (
            capacityProviderStrategy: [SchedulerClientTypes.CapacityProviderStrategyItem]? = nil,
            enableECSManagedTags: Swift.Bool? = nil,
            enableExecuteCommand: Swift.Bool? = nil,
            group: Swift.String? = nil,
            launchType: SchedulerClientTypes.LaunchType? = nil,
            networkConfiguration: SchedulerClientTypes.NetworkConfiguration? = nil,
            placementConstraints: [SchedulerClientTypes.PlacementConstraint]? = nil,
            placementStrategy: [SchedulerClientTypes.PlacementStrategy]? = nil,
            platformVersion: Swift.String? = nil,
            propagateTags: SchedulerClientTypes.PropagateTags? = nil,
            referenceId: Swift.String? = nil,
            tags: [[Swift.String:Swift.String]]? = nil,
            taskCount: Swift.Int? = nil,
            taskDefinitionArn: Swift.String? = nil
        )
        {
            self.capacityProviderStrategy = capacityProviderStrategy
            self.enableECSManagedTags = enableECSManagedTags
            self.enableExecuteCommand = enableExecuteCommand
            self.group = group
            self.launchType = launchType
            self.networkConfiguration = networkConfiguration
            self.placementConstraints = placementConstraints
            self.placementStrategy = placementStrategy
            self.platformVersion = platformVersion
            self.propagateTags = propagateTags
            self.referenceId = referenceId
            self.tags = tags
            self.taskCount = taskCount
            self.taskDefinitionArn = taskDefinitionArn
        }
    }

}

extension SchedulerClientTypes.EventBridgeParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detailType = "DetailType"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailType = self.detailType {
            try encodeContainer.encode(detailType, forKey: .detailType)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension SchedulerClientTypes {
    /// The templated target type for the EventBridge [PutEvents](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html) API operation.
    public struct EventBridgeParameters: Swift.Equatable {
        /// A free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.
        /// This member is required.
        public var detailType: Swift.String?
        /// The source of the event.
        /// This member is required.
        public var source: Swift.String?

        public init (
            detailType: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.detailType = detailType
            self.source = source
        }
    }

}

extension SchedulerClientTypes.FlexibleTimeWindow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumWindowInMinutes = "MaximumWindowInMinutes"
        case mode = "Mode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumWindowInMinutes = self.maximumWindowInMinutes {
            try encodeContainer.encode(maximumWindowInMinutes, forKey: .maximumWindowInMinutes)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.FlexibleTimeWindowMode.self, forKey: .mode)
        mode = modeDecoded
        let maximumWindowInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumWindowInMinutes)
        maximumWindowInMinutes = maximumWindowInMinutesDecoded
    }
}

extension SchedulerClientTypes {
    /// Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
    public struct FlexibleTimeWindow: Swift.Equatable {
        /// The maximum time window during which a schedule can be invoked.
        public var maximumWindowInMinutes: Swift.Int?
        /// Determines whether the schedule is invoked within a flexible time window.
        /// This member is required.
        public var mode: SchedulerClientTypes.FlexibleTimeWindowMode?

        public init (
            maximumWindowInMinutes: Swift.Int? = nil,
            mode: SchedulerClientTypes.FlexibleTimeWindowMode? = nil
        )
        {
            self.maximumWindowInMinutes = maximumWindowInMinutes
            self.mode = mode
        }
    }

}

extension SchedulerClientTypes {
    public enum FlexibleTimeWindowMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case flexible
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [FlexibleTimeWindowMode] {
            return [
                .flexible,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .flexible: return "FLEXIBLE"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FlexibleTimeWindowMode(rawValue: rawValue) ?? FlexibleTimeWindowMode.sdkUnknown(rawValue)
        }
    }
}

extension GetScheduleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/schedule-groups/\(name.urlPercentEncoding())"
    }
}

public struct GetScheduleGroupInput: Swift.Equatable {
    /// The name of the schedule group to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetScheduleGroupInputBody: Swift.Equatable {
}

extension GetScheduleGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetScheduleGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetScheduleGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetScheduleGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetScheduleGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetScheduleGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDate = output.creationDate
            self.lastModificationDate = output.lastModificationDate
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDate = nil
            self.lastModificationDate = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct GetScheduleGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schedule group.
    public var arn: Swift.String?
    /// The time at which the schedule group was created.
    public var creationDate: ClientRuntime.Date?
    /// The time at which the schedule group was last modified.
    public var lastModificationDate: ClientRuntime.Date?
    /// The name of the schedule group.
    public var name: Swift.String?
    /// Specifies the state of the schedule group.
    public var state: SchedulerClientTypes.ScheduleGroupState?

    public init (
        arn: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        lastModificationDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        state: SchedulerClientTypes.ScheduleGroupState? = nil
    )
    {
        self.arn = arn
        self.creationDate = creationDate
        self.lastModificationDate = lastModificationDate
        self.name = name
        self.state = state
    }
}

struct GetScheduleGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let state: SchedulerClientTypes.ScheduleGroupState?
    let creationDate: ClientRuntime.Date?
    let lastModificationDate: ClientRuntime.Date?
}

extension GetScheduleGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationDate = "CreationDate"
        case lastModificationDate = "LastModificationDate"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.ScheduleGroupState.self, forKey: .state)
        state = stateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModificationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationDate)
        lastModificationDate = lastModificationDateDecoded
    }
}

extension GetScheduleInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let groupName = groupName {
                let groupNameQueryItem = ClientRuntime.URLQueryItem(name: "groupName".urlPercentEncoding(), value: Swift.String(groupName).urlPercentEncoding())
                items.append(groupNameQueryItem)
            }
            return items
        }
    }
}

extension GetScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/schedules/\(name.urlPercentEncoding())"
    }
}

public struct GetScheduleInput: Swift.Equatable {
    /// The name of the schedule group associated with this schedule. If you omit this, EventBridge Scheduler assumes that the schedule is associated with the default group.
    public var groupName: Swift.String?
    /// The name of the schedule to retrieve.
    /// This member is required.
    public var name: Swift.String?

    public init (
        groupName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.groupName = groupName
        self.name = name
    }
}

struct GetScheduleInputBody: Swift.Equatable {
}

extension GetScheduleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetScheduleOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDate = output.creationDate
            self.description = output.description
            self.endDate = output.endDate
            self.flexibleTimeWindow = output.flexibleTimeWindow
            self.groupName = output.groupName
            self.kmsKeyArn = output.kmsKeyArn
            self.lastModificationDate = output.lastModificationDate
            self.name = output.name
            self.scheduleExpression = output.scheduleExpression
            self.scheduleExpressionTimezone = output.scheduleExpressionTimezone
            self.startDate = output.startDate
            self.state = output.state
            self.target = output.target
        } else {
            self.arn = nil
            self.creationDate = nil
            self.description = nil
            self.endDate = nil
            self.flexibleTimeWindow = nil
            self.groupName = nil
            self.kmsKeyArn = nil
            self.lastModificationDate = nil
            self.name = nil
            self.scheduleExpression = nil
            self.scheduleExpressionTimezone = nil
            self.startDate = nil
            self.state = nil
            self.target = nil
        }
    }
}

public struct GetScheduleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schedule.
    public var arn: Swift.String?
    /// The time at which the schedule was created.
    public var creationDate: ClientRuntime.Date?
    /// The description of the schedule.
    public var description: Swift.String?
    /// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the EndDate you specify. EventBridge Scheduler ignores EndDate for one-time schedules.
    public var endDate: ClientRuntime.Date?
    /// Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
    public var flexibleTimeWindow: SchedulerClientTypes.FlexibleTimeWindow?
    /// The name of the schedule group associated with this schedule.
    public var groupName: Swift.String?
    /// The ARN for a customer managed KMS Key that is be used to encrypt and decrypt your data.
    public var kmsKeyArn: Swift.String?
    /// The time at which the schedule was last modified.
    public var lastModificationDate: ClientRuntime.Date?
    /// The name of the schedule.
    public var name: Swift.String?
    /// The expression that defines when the schedule runs. The following formats are supported.
    ///
    /// * at expression - at(yyyy-mm-ddThh:mm:ss)
    ///
    /// * rate expression - rate(unit value)
    ///
    /// * cron expression - cron(fields)
    ///
    ///
    /// You can use at expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use rate and cron expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. A cron expression consists of six fields separated by white spaces: (minutes hours day_of_month month day_of_week year). A rate expression consists of a value as a positive integer, and a unit with the following options: minute | minutes | hour | hours | day | days For more information and examples, see [Schedule types on EventBridge Scheduler](https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html) in the EventBridge Scheduler User Guide.
    public var scheduleExpression: Swift.String?
    /// The timezone in which the scheduling expression is evaluated.
    public var scheduleExpressionTimezone: Swift.String?
    /// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the StartDate you specify. EventBridge Scheduler ignores StartDate for one-time schedules.
    public var startDate: ClientRuntime.Date?
    /// Specifies whether the schedule is enabled or disabled.
    public var state: SchedulerClientTypes.ScheduleState?
    /// The schedule target.
    public var target: SchedulerClientTypes.Target?

    public init (
        arn: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        endDate: ClientRuntime.Date? = nil,
        flexibleTimeWindow: SchedulerClientTypes.FlexibleTimeWindow? = nil,
        groupName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModificationDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        scheduleExpression: Swift.String? = nil,
        scheduleExpressionTimezone: Swift.String? = nil,
        startDate: ClientRuntime.Date? = nil,
        state: SchedulerClientTypes.ScheduleState? = nil,
        target: SchedulerClientTypes.Target? = nil
    )
    {
        self.arn = arn
        self.creationDate = creationDate
        self.description = description
        self.endDate = endDate
        self.flexibleTimeWindow = flexibleTimeWindow
        self.groupName = groupName
        self.kmsKeyArn = kmsKeyArn
        self.lastModificationDate = lastModificationDate
        self.name = name
        self.scheduleExpression = scheduleExpression
        self.scheduleExpressionTimezone = scheduleExpressionTimezone
        self.startDate = startDate
        self.state = state
        self.target = target
    }
}

struct GetScheduleOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let groupName: Swift.String?
    let name: Swift.String?
    let scheduleExpression: Swift.String?
    let startDate: ClientRuntime.Date?
    let endDate: ClientRuntime.Date?
    let description: Swift.String?
    let scheduleExpressionTimezone: Swift.String?
    let state: SchedulerClientTypes.ScheduleState?
    let creationDate: ClientRuntime.Date?
    let lastModificationDate: ClientRuntime.Date?
    let kmsKeyArn: Swift.String?
    let target: SchedulerClientTypes.Target?
    let flexibleTimeWindow: SchedulerClientTypes.FlexibleTimeWindow?
}

extension GetScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationDate = "CreationDate"
        case description = "Description"
        case endDate = "EndDate"
        case flexibleTimeWindow = "FlexibleTimeWindow"
        case groupName = "GroupName"
        case kmsKeyArn = "KmsKeyArn"
        case lastModificationDate = "LastModificationDate"
        case name = "Name"
        case scheduleExpression = "ScheduleExpression"
        case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
        case startDate = "StartDate"
        case state = "State"
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDate)
        endDate = endDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scheduleExpressionTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpressionTimezone)
        scheduleExpressionTimezone = scheduleExpressionTimezoneDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.ScheduleState.self, forKey: .state)
        state = stateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModificationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationDate)
        lastModificationDate = lastModificationDateDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let targetDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.Target.self, forKey: .target)
        target = targetDecoded
        let flexibleTimeWindowDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.FlexibleTimeWindow.self, forKey: .flexibleTimeWindow)
        flexibleTimeWindow = flexibleTimeWindowDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unexpected error encountered while processing the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchedulerClientTypes.KinesisParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case partitionKey = "PartitionKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let partitionKey = self.partitionKey {
            try encodeContainer.encode(partitionKey, forKey: .partitionKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partitionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partitionKey)
        partitionKey = partitionKeyDecoded
    }
}

extension SchedulerClientTypes {
    /// The templated target type for the Amazon Kinesis [PutRecord] API operation.
    public struct KinesisParameters: Swift.Equatable {
        /// Specifies the shard to which EventBridge Scheduler sends the event. For more information, see [Amazon Kinesis Data Streams terminology and concepts](https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html) in the Amazon Kinesis Streams Developer Guide.
        /// This member is required.
        public var partitionKey: Swift.String?

        public init (
            partitionKey: Swift.String? = nil
        )
        {
            self.partitionKey = partitionKey
        }
    }

}

extension SchedulerClientTypes {
    public enum LaunchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case external
        case fargate
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchType] {
            return [
                .ec2,
                .external,
                .fargate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .external: return "EXTERNAL"
            case .fargate: return "FARGATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchType(rawValue: rawValue) ?? LaunchType.sdkUnknown(rawValue)
        }
    }
}

extension ListScheduleGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let namePrefix = namePrefix {
                let namePrefixQueryItem = ClientRuntime.URLQueryItem(name: "NamePrefix".urlPercentEncoding(), value: Swift.String(namePrefix).urlPercentEncoding())
                items.append(namePrefixQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListScheduleGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/schedule-groups"
    }
}

public struct ListScheduleGroupsInput: Swift.Equatable {
    /// If specified, limits the number of results returned by this operation. The operation also returns a NextToken which you can use in a subsequent operation to retrieve the next set of results.
    public var maxResults: Swift.Int?
    /// The name prefix that you can use to return a filtered list of your schedule groups.
    public var namePrefix: Swift.String?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListScheduleGroupsInputBody: Swift.Equatable {
}

extension ListScheduleGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListScheduleGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListScheduleGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListScheduleGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListScheduleGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListScheduleGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.scheduleGroups = output.scheduleGroups
        } else {
            self.nextToken = nil
            self.scheduleGroups = nil
        }
    }
}

public struct ListScheduleGroupsOutputResponse: Swift.Equatable {
    /// Indicates whether there are additional results to retrieve. If the value is null, there are no more results.
    public var nextToken: Swift.String?
    /// The schedule groups that match the specified criteria.
    /// This member is required.
    public var scheduleGroups: [SchedulerClientTypes.ScheduleGroupSummary]?

    public init (
        nextToken: Swift.String? = nil,
        scheduleGroups: [SchedulerClientTypes.ScheduleGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.scheduleGroups = scheduleGroups
    }
}

struct ListScheduleGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let scheduleGroups: [SchedulerClientTypes.ScheduleGroupSummary]?
}

extension ListScheduleGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case scheduleGroups = "ScheduleGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let scheduleGroupsContainer = try containerValues.decodeIfPresent([SchedulerClientTypes.ScheduleGroupSummary?].self, forKey: .scheduleGroups)
        var scheduleGroupsDecoded0:[SchedulerClientTypes.ScheduleGroupSummary]? = nil
        if let scheduleGroupsContainer = scheduleGroupsContainer {
            scheduleGroupsDecoded0 = [SchedulerClientTypes.ScheduleGroupSummary]()
            for structure0 in scheduleGroupsContainer {
                if let structure0 = structure0 {
                    scheduleGroupsDecoded0?.append(structure0)
                }
            }
        }
        scheduleGroups = scheduleGroupsDecoded0
    }
}

extension ListSchedulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let groupName = groupName {
                let groupNameQueryItem = ClientRuntime.URLQueryItem(name: "ScheduleGroup".urlPercentEncoding(), value: Swift.String(groupName).urlPercentEncoding())
                items.append(groupNameQueryItem)
            }
            if let namePrefix = namePrefix {
                let namePrefixQueryItem = ClientRuntime.URLQueryItem(name: "NamePrefix".urlPercentEncoding(), value: Swift.String(namePrefix).urlPercentEncoding())
                items.append(namePrefixQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let state = state {
                let stateQueryItem = ClientRuntime.URLQueryItem(name: "State".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
                items.append(stateQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSchedulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/schedules"
    }
}

public struct ListSchedulesInput: Swift.Equatable {
    /// If specified, only lists the schedules whose associated schedule group matches the given filter.
    public var groupName: Swift.String?
    /// If specified, limits the number of results returned by this operation. The operation also returns a NextToken which you can use in a subsequent operation to retrieve the next set of results.
    public var maxResults: Swift.Int?
    /// Schedule name prefix to return the filtered list of resources.
    public var namePrefix: Swift.String?
    /// The token returned by a previous call to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// If specified, only lists the schedules whose current state matches the given filter.
    public var state: SchedulerClientTypes.ScheduleState?

    public init (
        groupName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        state: SchedulerClientTypes.ScheduleState? = nil
    )
    {
        self.groupName = groupName
        self.maxResults = maxResults
        self.namePrefix = namePrefix
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListSchedulesInputBody: Swift.Equatable {
}

extension ListSchedulesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSchedulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchedulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSchedulesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchedulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSchedulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schedules = output.schedules
        } else {
            self.nextToken = nil
            self.schedules = nil
        }
    }
}

public struct ListSchedulesOutputResponse: Swift.Equatable {
    /// Indicates whether there are additional results to retrieve. If the value is null, there are no more results.
    public var nextToken: Swift.String?
    /// The schedules that match the specified criteria.
    /// This member is required.
    public var schedules: [SchedulerClientTypes.ScheduleSummary]?

    public init (
        nextToken: Swift.String? = nil,
        schedules: [SchedulerClientTypes.ScheduleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schedules = schedules
    }
}

struct ListSchedulesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let schedules: [SchedulerClientTypes.ScheduleSummary]?
}

extension ListSchedulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schedules = "Schedules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let schedulesContainer = try containerValues.decodeIfPresent([SchedulerClientTypes.ScheduleSummary?].self, forKey: .schedules)
        var schedulesDecoded0:[SchedulerClientTypes.ScheduleSummary]? = nil
        if let schedulesContainer = schedulesContainer {
            schedulesDecoded0 = [SchedulerClientTypes.ScheduleSummary]()
            for structure0 in schedulesContainer {
                if let structure0 = structure0 {
                    schedulesDecoded0?.append(structure0)
                }
            }
        }
        schedules = schedulesDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the EventBridge Scheduler resource for which you want to view tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags associated with the specified resource.
    public var tags: [SchedulerClientTypes.Tag]?

    public init (
        tags: [SchedulerClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [SchedulerClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([SchedulerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SchedulerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SchedulerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SchedulerClientTypes.NetworkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsvpcConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsvpcConfiguration = self.awsvpcConfiguration {
            try encodeContainer.encode(awsvpcConfiguration, forKey: .awsvpcConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsvpcConfigurationDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.AwsVpcConfiguration.self, forKey: .awsvpcConfiguration)
        awsvpcConfiguration = awsvpcConfigurationDecoded
    }
}

extension SchedulerClientTypes {
    /// Specifies the network configuration for an ECS task.
    public struct NetworkConfiguration: Swift.Equatable {
        /// Specifies the Amazon VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.
        public var awsvpcConfiguration: SchedulerClientTypes.AwsVpcConfiguration?

        public init (
            awsvpcConfiguration: SchedulerClientTypes.AwsVpcConfiguration? = nil
        )
        {
            self.awsvpcConfiguration = awsvpcConfiguration
        }
    }

}

extension SchedulerClientTypes.PlacementConstraint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.PlacementConstraintType.self, forKey: .type)
        type = typeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension SchedulerClientTypes {
    /// An object representing a constraint on task placement.
    public struct PlacementConstraint: Swift.Equatable {
        /// A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. For more information, see [Cluster query language](https://docs.aws.amazon.com/latest/developerguide/cluster-query-language.html) in the Amazon ECS Developer Guide.
        public var expression: Swift.String?
        /// The type of constraint. Use distinctInstance to ensure that each task in a particular group is running on a different container instance. Use memberOf to restrict the selection to a group of valid candidates.
        public var type: SchedulerClientTypes.PlacementConstraintType?

        public init (
            expression: Swift.String? = nil,
            type: SchedulerClientTypes.PlacementConstraintType? = nil
        )
        {
            self.expression = expression
            self.type = type
        }
    }

}

extension SchedulerClientTypes {
    public enum PlacementConstraintType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case distinctInstance
        case memberOf
        case sdkUnknown(Swift.String)

        public static var allCases: [PlacementConstraintType] {
            return [
                .distinctInstance,
                .memberOf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .distinctInstance: return "distinctInstance"
            case .memberOf: return "memberOf"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlacementConstraintType(rawValue: rawValue) ?? PlacementConstraintType.sdkUnknown(rawValue)
        }
    }
}

extension SchedulerClientTypes.PlacementStrategy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.PlacementStrategyType.self, forKey: .type)
        type = typeDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
    }
}

extension SchedulerClientTypes {
    /// The task placement strategy for a task or service.
    public struct PlacementStrategy: Swift.Equatable {
        /// The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or instanceId, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this field is not used.
        public var field: Swift.String?
        /// The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).
        public var type: SchedulerClientTypes.PlacementStrategyType?

        public init (
            field: Swift.String? = nil,
            type: SchedulerClientTypes.PlacementStrategyType? = nil
        )
        {
            self.field = field
            self.type = type
        }
    }

}

extension SchedulerClientTypes {
    public enum PlacementStrategyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binpack
        case random
        case spread
        case sdkUnknown(Swift.String)

        public static var allCases: [PlacementStrategyType] {
            return [
                .binpack,
                .random,
                .spread,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binpack: return "binpack"
            case .random: return "random"
            case .spread: return "spread"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlacementStrategyType(rawValue: rawValue) ?? PlacementStrategyType.sdkUnknown(rawValue)
        }
    }
}

extension SchedulerClientTypes {
    public enum PropagateTags: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case taskDefinition
        case sdkUnknown(Swift.String)

        public static var allCases: [PropagateTags] {
            return [
                .taskDefinition,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .taskDefinition: return "TASK_DEFINITION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropagateTags(rawValue: rawValue) ?? PropagateTags.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request references a resource which does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchedulerClientTypes.RetryPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumEventAgeInSeconds = self.maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = self.maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
    }
}

extension SchedulerClientTypes {
    /// A RetryPolicy object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.
    public struct RetryPolicy: Swift.Equatable {
        /// The maximum amount of time, in seconds, to continue to make retry attempts.
        public var maximumEventAgeInSeconds: Swift.Int?
        /// The maximum number of retry attempts to make before the request fails. Retry attempts with exponential backoff continue until either the maximum number of attempts is made or until the duration of the MaximumEventAgeInSeconds is reached.
        public var maximumRetryAttempts: Swift.Int?

        public init (
            maximumEventAgeInSeconds: Swift.Int? = nil,
            maximumRetryAttempts: Swift.Int? = nil
        )
        {
            self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
            self.maximumRetryAttempts = maximumRetryAttempts
        }
    }

}

extension SchedulerClientTypes.SageMakerPipelineParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SchedulerClientTypes {
    /// The name and value pair of a parameter to use to start execution of a SageMaker Model Building Pipeline.
    public struct SageMakerPipelineParameter: Swift.Equatable {
        /// Name of parameter to start execution of a SageMaker Model Building Pipeline.
        /// This member is required.
        public var name: Swift.String?
        /// Value of parameter to start execution of a SageMaker Model Building Pipeline.
        /// This member is required.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SchedulerClientTypes.SageMakerPipelineParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineParameterList = "PipelineParameterList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineParameterList = pipelineParameterList {
            var pipelineParameterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineParameterList)
            for sagemakerpipelineparameter0 in pipelineParameterList {
                try pipelineParameterListContainer.encode(sagemakerpipelineparameter0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineParameterListContainer = try containerValues.decodeIfPresent([SchedulerClientTypes.SageMakerPipelineParameter?].self, forKey: .pipelineParameterList)
        var pipelineParameterListDecoded0:[SchedulerClientTypes.SageMakerPipelineParameter]? = nil
        if let pipelineParameterListContainer = pipelineParameterListContainer {
            pipelineParameterListDecoded0 = [SchedulerClientTypes.SageMakerPipelineParameter]()
            for structure0 in pipelineParameterListContainer {
                if let structure0 = structure0 {
                    pipelineParameterListDecoded0?.append(structure0)
                }
            }
        }
        pipelineParameterList = pipelineParameterListDecoded0
    }
}

extension SchedulerClientTypes {
    /// The templated target type for the Amazon SageMaker [StartPipelineExecution](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html) API operation.
    public struct SageMakerPipelineParameters: Swift.Equatable {
        /// List of parameter names and values to use when executing the SageMaker Model Building Pipeline.
        public var pipelineParameterList: [SchedulerClientTypes.SageMakerPipelineParameter]?

        public init (
            pipelineParameterList: [SchedulerClientTypes.SageMakerPipelineParameter]? = nil
        )
        {
            self.pipelineParameterList = pipelineParameterList
        }
    }

}

extension SchedulerClientTypes {
    public enum ScheduleGroupState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduleGroupState] {
            return [
                .active,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduleGroupState(rawValue: rawValue) ?? ScheduleGroupState.sdkUnknown(rawValue)
        }
    }
}

extension SchedulerClientTypes.ScheduleGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationDate = "CreationDate"
        case lastModificationDate = "LastModificationDate"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let lastModificationDate = self.lastModificationDate {
            try encodeContainer.encodeTimestamp(lastModificationDate, format: .epochSeconds, forKey: .lastModificationDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.ScheduleGroupState.self, forKey: .state)
        state = stateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModificationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationDate)
        lastModificationDate = lastModificationDateDecoded
    }
}

extension SchedulerClientTypes {
    /// The details of a schedule group.
    public struct ScheduleGroupSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the schedule group.
        public var arn: Swift.String?
        /// The time at which the schedule group was created.
        public var creationDate: ClientRuntime.Date?
        /// The time at which the schedule group was last modified.
        public var lastModificationDate: ClientRuntime.Date?
        /// The name of the schedule group.
        public var name: Swift.String?
        /// Specifies the state of the schedule group.
        public var state: SchedulerClientTypes.ScheduleGroupState?

        public init (
            arn: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            lastModificationDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            state: SchedulerClientTypes.ScheduleGroupState? = nil
        )
        {
            self.arn = arn
            self.creationDate = creationDate
            self.lastModificationDate = lastModificationDate
            self.name = name
            self.state = state
        }
    }

}

extension SchedulerClientTypes {
    public enum ScheduleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduleState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduleState(rawValue: rawValue) ?? ScheduleState.sdkUnknown(rawValue)
        }
    }
}

extension SchedulerClientTypes.ScheduleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationDate = "CreationDate"
        case groupName = "GroupName"
        case lastModificationDate = "LastModificationDate"
        case name = "Name"
        case state = "State"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let lastModificationDate = self.lastModificationDate {
            try encodeContainer.encodeTimestamp(lastModificationDate, format: .epochSeconds, forKey: .lastModificationDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.ScheduleState.self, forKey: .state)
        state = stateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModificationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationDate)
        lastModificationDate = lastModificationDateDecoded
        let targetDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.TargetSummary.self, forKey: .target)
        target = targetDecoded
    }
}

extension SchedulerClientTypes {
    /// The details of a schedule.
    public struct ScheduleSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the schedule.
        public var arn: Swift.String?
        /// The time at which the schedule was created.
        public var creationDate: ClientRuntime.Date?
        /// The name of the schedule group associated with this schedule.
        public var groupName: Swift.String?
        /// The time at which the schedule was last modified.
        public var lastModificationDate: ClientRuntime.Date?
        /// The name of the schedule.
        public var name: Swift.String?
        /// Specifies whether the schedule is enabled or disabled.
        public var state: SchedulerClientTypes.ScheduleState?
        /// The schedule's target details.
        public var target: SchedulerClientTypes.TargetSummary?

        public init (
            arn: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            groupName: Swift.String? = nil,
            lastModificationDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            state: SchedulerClientTypes.ScheduleState? = nil,
            target: SchedulerClientTypes.TargetSummary? = nil
        )
        {
            self.arn = arn
            self.creationDate = creationDate
            self.groupName = groupName
            self.lastModificationDate = lastModificationDate
            self.name = name
            self.state = state
            self.target = target
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds a service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchedulerClientTypes.SqsParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageGroupId = "MessageGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageGroupId = self.messageGroupId {
            try encodeContainer.encode(messageGroupId, forKey: .messageGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageGroupId)
        messageGroupId = messageGroupIdDecoded
    }
}

extension SchedulerClientTypes {
    /// The templated target type for the Amazon SQS [SendMessage](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html) API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see [Using the Amazon SQS message deduplication ID](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html) in the Amazon SQS Developer Guide.
    public struct SqsParameters: Swift.Equatable {
        /// The FIFO message group ID to use as the target.
        public var messageGroupId: Swift.String?

        public init (
            messageGroupId: Swift.String? = nil
        )
        {
            self.messageGroupId = messageGroupId
        }
    }

}

extension SchedulerClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SchedulerClientTypes {
    /// Tag to associate with a schedule group.
    public struct Tag: Swift.Equatable {
        /// The key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value for the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schedule group that you are adding tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags to associate with the schedule group.
    /// This member is required.
    public var tags: [SchedulerClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [SchedulerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [SchedulerClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([SchedulerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SchedulerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SchedulerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension SchedulerClientTypes.Target: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case deadLetterConfig = "DeadLetterConfig"
        case ecsParameters = "EcsParameters"
        case eventBridgeParameters = "EventBridgeParameters"
        case input = "Input"
        case kinesisParameters = "KinesisParameters"
        case retryPolicy = "RetryPolicy"
        case roleArn = "RoleArn"
        case sageMakerPipelineParameters = "SageMakerPipelineParameters"
        case sqsParameters = "SqsParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let deadLetterConfig = self.deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let ecsParameters = self.ecsParameters {
            try encodeContainer.encode(ecsParameters, forKey: .ecsParameters)
        }
        if let eventBridgeParameters = self.eventBridgeParameters {
            try encodeContainer.encode(eventBridgeParameters, forKey: .eventBridgeParameters)
        }
        if let input = self.input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let kinesisParameters = self.kinesisParameters {
            try encodeContainer.encode(kinesisParameters, forKey: .kinesisParameters)
        }
        if let retryPolicy = self.retryPolicy {
            try encodeContainer.encode(retryPolicy, forKey: .retryPolicy)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sageMakerPipelineParameters = self.sageMakerPipelineParameters {
            try encodeContainer.encode(sageMakerPipelineParameters, forKey: .sageMakerPipelineParameters)
        }
        if let sqsParameters = self.sqsParameters {
            try encodeContainer.encode(sqsParameters, forKey: .sqsParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let retryPolicyDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.RetryPolicy.self, forKey: .retryPolicy)
        retryPolicy = retryPolicyDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .input)
        input = inputDecoded
        let ecsParametersDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.EcsParameters.self, forKey: .ecsParameters)
        ecsParameters = ecsParametersDecoded
        let eventBridgeParametersDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.EventBridgeParameters.self, forKey: .eventBridgeParameters)
        eventBridgeParameters = eventBridgeParametersDecoded
        let kinesisParametersDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.KinesisParameters.self, forKey: .kinesisParameters)
        kinesisParameters = kinesisParametersDecoded
        let sageMakerPipelineParametersDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.SageMakerPipelineParameters.self, forKey: .sageMakerPipelineParameters)
        sageMakerPipelineParameters = sageMakerPipelineParametersDecoded
        let sqsParametersDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.SqsParameters.self, forKey: .sqsParameters)
        sqsParameters = sqsParametersDecoded
    }
}

extension SchedulerClientTypes {
    /// The schedule's target. EventBridge Scheduler supports templated target that invoke common API operations, as well as universal targets that you can customize to invoke over 6,000 API operations across more than 270 services. You can only specify one templated or universal target for a schedule.
    public struct Target: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the target.
        /// This member is required.
        public var arn: Swift.String?
        /// An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.
        public var deadLetterConfig: SchedulerClientTypes.DeadLetterConfig?
        /// The templated target type for the Amazon ECS [RunTask](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) API operation.
        public var ecsParameters: SchedulerClientTypes.EcsParameters?
        /// The templated target type for the EventBridge [PutEvents](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html) API operation.
        public var eventBridgeParameters: SchedulerClientTypes.EventBridgeParameters?
        /// The text, or well-formed JSON, passed to the target. If you are configuring a templated Lambda, AWS Step Functions, or Amazon EventBridge target, the input must be a well-formed JSON. For all other target types, a JSON is not required. If you do not specify anything for this field, EventBridge Scheduler delivers a default notification to the target.
        public var input: Swift.String?
        /// The templated target type for the Amazon Kinesis [PutRecord] API operation.
        public var kinesisParameters: SchedulerClientTypes.KinesisParameters?
        /// A RetryPolicy object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.
        public var retryPolicy: SchedulerClientTypes.RetryPolicy?
        /// The Amazon Resource Name (ARN) of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The templated target type for the Amazon SageMaker [StartPipelineExecution](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html) API operation.
        public var sageMakerPipelineParameters: SchedulerClientTypes.SageMakerPipelineParameters?
        /// The templated target type for the Amazon SQS [SendMessage](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html) API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see [Using the Amazon SQS message deduplication ID](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html) in the Amazon SQS Developer Guide.
        public var sqsParameters: SchedulerClientTypes.SqsParameters?

        public init (
            arn: Swift.String? = nil,
            deadLetterConfig: SchedulerClientTypes.DeadLetterConfig? = nil,
            ecsParameters: SchedulerClientTypes.EcsParameters? = nil,
            eventBridgeParameters: SchedulerClientTypes.EventBridgeParameters? = nil,
            input: Swift.String? = nil,
            kinesisParameters: SchedulerClientTypes.KinesisParameters? = nil,
            retryPolicy: SchedulerClientTypes.RetryPolicy? = nil,
            roleArn: Swift.String? = nil,
            sageMakerPipelineParameters: SchedulerClientTypes.SageMakerPipelineParameters? = nil,
            sqsParameters: SchedulerClientTypes.SqsParameters? = nil
        )
        {
            self.arn = arn
            self.deadLetterConfig = deadLetterConfig
            self.ecsParameters = ecsParameters
            self.eventBridgeParameters = eventBridgeParameters
            self.input = input
            self.kinesisParameters = kinesisParameters
            self.retryPolicy = retryPolicy
            self.roleArn = roleArn
            self.sageMakerPipelineParameters = sageMakerPipelineParameters
            self.sqsParameters = sqsParameters
        }
    }

}

extension SchedulerClientTypes.TargetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SchedulerClientTypes {
    /// The details of a target.
    public struct TargetSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the target.
        /// This member is required.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "TagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schedule group from which you are removing tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case endDate = "EndDate"
        case flexibleTimeWindow = "FlexibleTimeWindow"
        case groupName = "GroupName"
        case kmsKeyArn = "KmsKeyArn"
        case scheduleExpression = "ScheduleExpression"
        case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
        case startDate = "StartDate"
        case state = "State"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endDate = self.endDate {
            try encodeContainer.encodeTimestamp(endDate, format: .epochSeconds, forKey: .endDate)
        }
        if let flexibleTimeWindow = self.flexibleTimeWindow {
            try encodeContainer.encode(flexibleTimeWindow, forKey: .flexibleTimeWindow)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let scheduleExpressionTimezone = self.scheduleExpressionTimezone {
            try encodeContainer.encode(scheduleExpressionTimezone, forKey: .scheduleExpressionTimezone)
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .epochSeconds, forKey: .startDate)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension UpdateScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/schedules/\(name.urlPercentEncoding())"
    }
}

public struct UpdateScheduleInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The description you specify for the schedule.
    public var description: Swift.String?
    /// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the EndDate you specify. EventBridge Scheduler ignores EndDate for one-time schedules.
    public var endDate: ClientRuntime.Date?
    /// Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.
    /// This member is required.
    public var flexibleTimeWindow: SchedulerClientTypes.FlexibleTimeWindow?
    /// The name of the schedule group with which the schedule is associated. You must provide this value in order for EventBridge Scheduler to find the schedule you want to update. If you omit this value, EventBridge Scheduler assumes the group is associated to the default group.
    public var groupName: Swift.String?
    /// The ARN for the customer managed KMS key that that you want EventBridge Scheduler to use to encrypt and decrypt your data.
    public var kmsKeyArn: Swift.String?
    /// The name of the schedule that you are updating.
    /// This member is required.
    public var name: Swift.String?
    /// The expression that defines when the schedule runs. The following formats are supported.
    ///
    /// * at expression - at(yyyy-mm-ddThh:mm:ss)
    ///
    /// * rate expression - rate(unit value)
    ///
    /// * cron expression - cron(fields)
    ///
    ///
    /// You can use at expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use rate and cron expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. A cron expression consists of six fields separated by white spaces: (minutes hours day_of_month month day_of_week year). A rate expression consists of a value as a positive integer, and a unit with the following options: minute | minutes | hour | hours | day | days For more information and examples, see [Schedule types on EventBridge Scheduler](https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html) in the EventBridge Scheduler User Guide.
    /// This member is required.
    public var scheduleExpression: Swift.String?
    /// The timezone in which the scheduling expression is evaluated.
    public var scheduleExpressionTimezone: Swift.String?
    /// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the StartDate you specify. EventBridge Scheduler ignores StartDate for one-time schedules.
    public var startDate: ClientRuntime.Date?
    /// Specifies whether the schedule is enabled or disabled.
    public var state: SchedulerClientTypes.ScheduleState?
    /// The schedule target. You can use this operation to change the target that your schedule invokes.
    /// This member is required.
    public var target: SchedulerClientTypes.Target?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        endDate: ClientRuntime.Date? = nil,
        flexibleTimeWindow: SchedulerClientTypes.FlexibleTimeWindow? = nil,
        groupName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        scheduleExpression: Swift.String? = nil,
        scheduleExpressionTimezone: Swift.String? = nil,
        startDate: ClientRuntime.Date? = nil,
        state: SchedulerClientTypes.ScheduleState? = nil,
        target: SchedulerClientTypes.Target? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.endDate = endDate
        self.flexibleTimeWindow = flexibleTimeWindow
        self.groupName = groupName
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.scheduleExpression = scheduleExpression
        self.scheduleExpressionTimezone = scheduleExpressionTimezone
        self.startDate = startDate
        self.state = state
        self.target = target
    }
}

struct UpdateScheduleInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let scheduleExpression: Swift.String?
    let startDate: ClientRuntime.Date?
    let endDate: ClientRuntime.Date?
    let description: Swift.String?
    let scheduleExpressionTimezone: Swift.String?
    let state: SchedulerClientTypes.ScheduleState?
    let kmsKeyArn: Swift.String?
    let target: SchedulerClientTypes.Target?
    let flexibleTimeWindow: SchedulerClientTypes.FlexibleTimeWindow?
    let clientToken: Swift.String?
}

extension UpdateScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case endDate = "EndDate"
        case flexibleTimeWindow = "FlexibleTimeWindow"
        case groupName = "GroupName"
        case kmsKeyArn = "KmsKeyArn"
        case scheduleExpression = "ScheduleExpression"
        case scheduleExpressionTimezone = "ScheduleExpressionTimezone"
        case startDate = "StartDate"
        case state = "State"
        case target = "Target"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDate)
        endDate = endDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scheduleExpressionTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpressionTimezone)
        scheduleExpressionTimezone = scheduleExpressionTimezoneDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.ScheduleState.self, forKey: .state)
        state = stateDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let targetDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.Target.self, forKey: .target)
        target = targetDecoded
        let flexibleTimeWindowDecoded = try containerValues.decodeIfPresent(SchedulerClientTypes.FlexibleTimeWindow.self, forKey: .flexibleTimeWindow)
        flexibleTimeWindow = flexibleTimeWindowDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateScheduleOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.scheduleArn = output.scheduleArn
        } else {
            self.scheduleArn = nil
        }
    }
}

public struct UpdateScheduleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schedule that you updated.
    /// This member is required.
    public var scheduleArn: Swift.String?

    public init (
        scheduleArn: Swift.String? = nil
    )
    {
        self.scheduleArn = scheduleArn
    }
}

struct UpdateScheduleOutputResponseBody: Swift.Equatable {
    let scheduleArn: Swift.String?
}

extension UpdateScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduleArn = "ScheduleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
