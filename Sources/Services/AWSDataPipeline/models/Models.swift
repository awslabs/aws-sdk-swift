// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActivatePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterValues
        case pipelineId
        case startTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterValues = parameterValues {
            var parameterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterValues)
            for parametervalue0 in parameterValues {
                try parameterValuesContainer.encode(parametervalue0)
            }
        }
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let startTimestamp = self.startTimestamp {
            try encodeContainer.encodeTimestamp(startTimestamp, format: .epochSeconds, forKey: .startTimestamp)
        }
    }
}

extension ActivatePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for ActivatePipeline.
public struct ActivatePipelineInput: Swift.Equatable {
    /// A list of parameter values to pass to the pipeline at activation.
    public var parameterValues: [DataPipelineClientTypes.ParameterValue]?
    /// The ID of the pipeline.
    /// This member is required.
    public var pipelineId: Swift.String?
    /// The date and time to resume the pipeline. By default, the pipeline resumes from the last completed execution.
    public var startTimestamp: ClientRuntime.Date?

    public init(
        parameterValues: [DataPipelineClientTypes.ParameterValue]? = nil,
        pipelineId: Swift.String? = nil,
        startTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.parameterValues = parameterValues
        self.pipelineId = pipelineId
        self.startTimestamp = startTimestamp
    }
}

struct ActivatePipelineInputBody: Swift.Equatable {
    let pipelineId: Swift.String?
    let parameterValues: [DataPipelineClientTypes.ParameterValue]?
    let startTimestamp: ClientRuntime.Date?
}

extension ActivatePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterValues
        case pipelineId
        case startTimestamp
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let parameterValuesContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.ParameterValue?].self, forKey: .parameterValues)
        var parameterValuesDecoded0:[DataPipelineClientTypes.ParameterValue]? = nil
        if let parameterValuesContainer = parameterValuesContainer {
            parameterValuesDecoded0 = [DataPipelineClientTypes.ParameterValue]()
            for structure0 in parameterValuesContainer {
                if let structure0 = structure0 {
                    parameterValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterValues = parameterValuesDecoded0
        let startTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
    }
}

extension ActivatePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Contains the output of ActivatePipeline.
public struct ActivatePipelineOutput: Swift.Equatable {

    public init() { }
}

enum ActivatePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AddTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension AddTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for AddTags.
public struct AddTagsInput: Swift.Equatable {
    /// The ID of the pipeline.
    /// This member is required.
    public var pipelineId: Swift.String?
    /// The tags to add, as key/value pairs.
    /// This member is required.
    public var tags: [DataPipelineClientTypes.Tag]?

    public init(
        pipelineId: Swift.String? = nil,
        tags: [DataPipelineClientTypes.Tag]? = nil
    )
    {
        self.pipelineId = pipelineId
        self.tags = tags
    }
}

struct AddTagsInputBody: Swift.Equatable {
    let pipelineId: Swift.String?
    let tags: [DataPipelineClientTypes.Tag]?
}

extension AddTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DataPipelineClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DataPipelineClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Contains the output of AddTags.
public struct AddTagsOutput: Swift.Equatable {

    public init() { }
}

enum AddTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
        case uniqueId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let uniqueId = self.uniqueId {
            try encodeContainer.encode(uniqueId, forKey: .uniqueId)
        }
    }
}

extension CreatePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for CreatePipeline.
public struct CreatePipelineInput: Swift.Equatable {
    /// The description for the pipeline.
    public var description: Swift.String?
    /// The name for the pipeline. You can use the same name for multiple pipelines associated with your AWS account, because AWS Data Pipeline assigns each pipeline a unique pipeline identifier.
    /// This member is required.
    public var name: Swift.String?
    /// A list of tags to associate with the pipeline at creation. Tags let you control access to pipelines. For more information, see [Controlling User Access to Pipelines](http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-control-access.html) in the AWS Data Pipeline Developer Guide.
    public var tags: [DataPipelineClientTypes.Tag]?
    /// A unique identifier. This identifier is not the same as the pipeline identifier assigned by AWS Data Pipeline. You are responsible for defining the format and ensuring the uniqueness of this identifier. You use this parameter to ensure idempotency during repeated calls to CreatePipeline. For example, if the first call to CreatePipeline does not succeed, you can pass in the same unique identifier and pipeline name combination on a subsequent call to CreatePipeline. CreatePipeline ensures that if a pipeline already exists with the same name and unique identifier, a new pipeline is not created. Instead, you'll receive the pipeline identifier from the previous attempt. The uniqueness of the name and unique identifier combination is scoped to the AWS account or IAM user credentials.
    /// This member is required.
    public var uniqueId: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [DataPipelineClientTypes.Tag]? = nil,
        uniqueId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.uniqueId = uniqueId
    }
}

struct CreatePipelineInputBody: Swift.Equatable {
    let name: Swift.String?
    let uniqueId: Swift.String?
    let description: Swift.String?
    let tags: [DataPipelineClientTypes.Tag]?
}

extension CreatePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
        case uniqueId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let uniqueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uniqueId)
        uniqueId = uniqueIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DataPipelineClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DataPipelineClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.pipelineId = output.pipelineId
        } else {
            self.pipelineId = nil
        }
    }
}

/// Contains the output of CreatePipeline.
public struct CreatePipelineOutput: Swift.Equatable {
    /// The ID that AWS Data Pipeline assigns the newly created pipeline. For example, df-06372391ZG65EXAMPLE.
    /// This member is required.
    public var pipelineId: Swift.String?

    public init(
        pipelineId: Swift.String? = nil
    )
    {
        self.pipelineId = pipelineId
    }
}

struct CreatePipelineOutputBody: Swift.Equatable {
    let pipelineId: Swift.String?
}

extension CreatePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
    }
}

enum CreatePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeactivatePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancelActive
        case pipelineId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cancelActive = self.cancelActive {
            try encodeContainer.encode(cancelActive, forKey: .cancelActive)
        }
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
    }
}

extension DeactivatePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DeactivatePipeline.
public struct DeactivatePipelineInput: Swift.Equatable {
    /// Indicates whether to cancel any running objects. The default is true, which sets the state of any running objects to CANCELED. If this value is false, the pipeline is deactivated after all running objects finish.
    public var cancelActive: Swift.Bool?
    /// The ID of the pipeline.
    /// This member is required.
    public var pipelineId: Swift.String?

    public init(
        cancelActive: Swift.Bool? = nil,
        pipelineId: Swift.String? = nil
    )
    {
        self.cancelActive = cancelActive
        self.pipelineId = pipelineId
    }
}

struct DeactivatePipelineInputBody: Swift.Equatable {
    let pipelineId: Swift.String?
    let cancelActive: Swift.Bool?
}

extension DeactivatePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancelActive
        case pipelineId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let cancelActiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cancelActive)
        cancelActive = cancelActiveDecoded
    }
}

extension DeactivatePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Contains the output of DeactivatePipeline.
public struct DeactivatePipelineOutput: Swift.Equatable {

    public init() { }
}

enum DeactivatePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
    }
}

extension DeletePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DeletePipeline.
public struct DeletePipelineInput: Swift.Equatable {
    /// The ID of the pipeline.
    /// This member is required.
    public var pipelineId: Swift.String?

    public init(
        pipelineId: Swift.String? = nil
    )
    {
        self.pipelineId = pipelineId
    }
}

struct DeletePipelineInputBody: Swift.Equatable {
    let pipelineId: Swift.String?
}

extension DeletePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
    }
}

extension DeletePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePipelineOutput: Swift.Equatable {

    public init() { }
}

enum DeletePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeObjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluateExpressions
        case marker
        case objectIds
        case pipelineId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluateExpressions = self.evaluateExpressions {
            try encodeContainer.encode(evaluateExpressions, forKey: .evaluateExpressions)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let objectIds = objectIds {
            var objectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectIds)
            for id0 in objectIds {
                try objectIdsContainer.encode(id0)
            }
        }
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
    }
}

extension DescribeObjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeObjects.
public struct DescribeObjectsInput: Swift.Equatable {
    /// Indicates whether any expressions in the object should be evaluated when the object descriptions are returned.
    public var evaluateExpressions: Swift.Bool?
    /// The starting point for the results to be returned. For the first call, this value should be empty. As long as there are more results, continue to call DescribeObjects with the marker value from the previous call to retrieve the next set of results.
    public var marker: Swift.String?
    /// The IDs of the pipeline objects that contain the definitions to be described. You can pass as many as 25 identifiers in a single call to DescribeObjects.
    /// This member is required.
    public var objectIds: [Swift.String]?
    /// The ID of the pipeline that contains the object definitions.
    /// This member is required.
    public var pipelineId: Swift.String?

    public init(
        evaluateExpressions: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        objectIds: [Swift.String]? = nil,
        pipelineId: Swift.String? = nil
    )
    {
        self.evaluateExpressions = evaluateExpressions
        self.marker = marker
        self.objectIds = objectIds
        self.pipelineId = pipelineId
    }
}

struct DescribeObjectsInputBody: Swift.Equatable {
    let pipelineId: Swift.String?
    let objectIds: [Swift.String]?
    let evaluateExpressions: Swift.Bool?
    let marker: Swift.String?
}

extension DescribeObjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluateExpressions
        case marker
        case objectIds
        case pipelineId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let objectIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .objectIds)
        var objectIdsDecoded0:[Swift.String]? = nil
        if let objectIdsContainer = objectIdsContainer {
            objectIdsDecoded0 = [Swift.String]()
            for string0 in objectIdsContainer {
                if let string0 = string0 {
                    objectIdsDecoded0?.append(string0)
                }
            }
        }
        objectIds = objectIdsDecoded0
        let evaluateExpressionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .evaluateExpressions)
        evaluateExpressions = evaluateExpressionsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeObjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeObjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.hasMoreResults = output.hasMoreResults
            self.marker = output.marker
            self.pipelineObjects = output.pipelineObjects
        } else {
            self.hasMoreResults = false
            self.marker = nil
            self.pipelineObjects = nil
        }
    }
}

/// Contains the output of DescribeObjects.
public struct DescribeObjectsOutput: Swift.Equatable {
    /// Indicates whether there are more results to return.
    public var hasMoreResults: Swift.Bool
    /// The starting point for the next page of results. To view the next page of results, call DescribeObjects again with this marker value. If the value is null, there are no more results.
    public var marker: Swift.String?
    /// An array of object definitions.
    /// This member is required.
    public var pipelineObjects: [DataPipelineClientTypes.PipelineObject]?

    public init(
        hasMoreResults: Swift.Bool = false,
        marker: Swift.String? = nil,
        pipelineObjects: [DataPipelineClientTypes.PipelineObject]? = nil
    )
    {
        self.hasMoreResults = hasMoreResults
        self.marker = marker
        self.pipelineObjects = pipelineObjects
    }
}

struct DescribeObjectsOutputBody: Swift.Equatable {
    let pipelineObjects: [DataPipelineClientTypes.PipelineObject]?
    let marker: Swift.String?
    let hasMoreResults: Swift.Bool
}

extension DescribeObjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hasMoreResults
        case marker
        case pipelineObjects
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineObjectsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.PipelineObject?].self, forKey: .pipelineObjects)
        var pipelineObjectsDecoded0:[DataPipelineClientTypes.PipelineObject]? = nil
        if let pipelineObjectsContainer = pipelineObjectsContainer {
            pipelineObjectsDecoded0 = [DataPipelineClientTypes.PipelineObject]()
            for structure0 in pipelineObjectsContainer {
                if let structure0 = structure0 {
                    pipelineObjectsDecoded0?.append(structure0)
                }
            }
        }
        pipelineObjects = pipelineObjectsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let hasMoreResultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasMoreResults) ?? false
        hasMoreResults = hasMoreResultsDecoded
    }
}

enum DescribeObjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePipelinesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineIds = pipelineIds {
            var pipelineIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineIds)
            for id0 in pipelineIds {
                try pipelineIdsContainer.encode(id0)
            }
        }
    }
}

extension DescribePipelinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribePipelines.
public struct DescribePipelinesInput: Swift.Equatable {
    /// The IDs of the pipelines to describe. You can pass as many as 25 identifiers in a single call. To obtain pipeline IDs, call [ListPipelines].
    /// This member is required.
    public var pipelineIds: [Swift.String]?

    public init(
        pipelineIds: [Swift.String]? = nil
    )
    {
        self.pipelineIds = pipelineIds
    }
}

struct DescribePipelinesInputBody: Swift.Equatable {
    let pipelineIds: [Swift.String]?
}

extension DescribePipelinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pipelineIds)
        var pipelineIdsDecoded0:[Swift.String]? = nil
        if let pipelineIdsContainer = pipelineIdsContainer {
            pipelineIdsDecoded0 = [Swift.String]()
            for string0 in pipelineIdsContainer {
                if let string0 = string0 {
                    pipelineIdsDecoded0?.append(string0)
                }
            }
        }
        pipelineIds = pipelineIdsDecoded0
    }
}

extension DescribePipelinesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePipelinesOutputBody = try responseDecoder.decode(responseBody: data)
            self.pipelineDescriptionList = output.pipelineDescriptionList
        } else {
            self.pipelineDescriptionList = nil
        }
    }
}

/// Contains the output of DescribePipelines.
public struct DescribePipelinesOutput: Swift.Equatable {
    /// An array of descriptions for the specified pipelines.
    /// This member is required.
    public var pipelineDescriptionList: [DataPipelineClientTypes.PipelineDescription]?

    public init(
        pipelineDescriptionList: [DataPipelineClientTypes.PipelineDescription]? = nil
    )
    {
        self.pipelineDescriptionList = pipelineDescriptionList
    }
}

struct DescribePipelinesOutputBody: Swift.Equatable {
    let pipelineDescriptionList: [DataPipelineClientTypes.PipelineDescription]?
}

extension DescribePipelinesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineDescriptionList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDescriptionListContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.PipelineDescription?].self, forKey: .pipelineDescriptionList)
        var pipelineDescriptionListDecoded0:[DataPipelineClientTypes.PipelineDescription]? = nil
        if let pipelineDescriptionListContainer = pipelineDescriptionListContainer {
            pipelineDescriptionListDecoded0 = [DataPipelineClientTypes.PipelineDescription]()
            for structure0 in pipelineDescriptionListContainer {
                if let structure0 = structure0 {
                    pipelineDescriptionListDecoded0?.append(structure0)
                }
            }
        }
        pipelineDescriptionList = pipelineDescriptionListDecoded0
    }
}

enum DescribePipelinesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EvaluateExpressionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
        case objectId
        case pipelineId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let objectId = self.objectId {
            try encodeContainer.encode(objectId, forKey: .objectId)
        }
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
    }
}

extension EvaluateExpressionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for EvaluateExpression.
public struct EvaluateExpressionInput: Swift.Equatable {
    /// The expression to evaluate.
    /// This member is required.
    public var expression: Swift.String?
    /// The ID of the object.
    /// This member is required.
    public var objectId: Swift.String?
    /// The ID of the pipeline.
    /// This member is required.
    public var pipelineId: Swift.String?

    public init(
        expression: Swift.String? = nil,
        objectId: Swift.String? = nil,
        pipelineId: Swift.String? = nil
    )
    {
        self.expression = expression
        self.objectId = objectId
        self.pipelineId = pipelineId
    }
}

struct EvaluateExpressionInputBody: Swift.Equatable {
    let pipelineId: Swift.String?
    let objectId: Swift.String?
    let expression: Swift.String?
}

extension EvaluateExpressionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
        case objectId
        case pipelineId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let objectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectId)
        objectId = objectIdDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension EvaluateExpressionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EvaluateExpressionOutputBody = try responseDecoder.decode(responseBody: data)
            self.evaluatedExpression = output.evaluatedExpression
        } else {
            self.evaluatedExpression = nil
        }
    }
}

/// Contains the output of EvaluateExpression.
public struct EvaluateExpressionOutput: Swift.Equatable {
    /// The evaluated expression.
    /// This member is required.
    public var evaluatedExpression: Swift.String?

    public init(
        evaluatedExpression: Swift.String? = nil
    )
    {
        self.evaluatedExpression = evaluatedExpression
    }
}

struct EvaluateExpressionOutputBody: Swift.Equatable {
    let evaluatedExpression: Swift.String?
}

extension EvaluateExpressionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluatedExpression
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluatedExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluatedExpression)
        evaluatedExpression = evaluatedExpressionDecoded
    }
}

enum EvaluateExpressionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TaskNotFoundException": return try await TaskNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataPipelineClientTypes.Field: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case refValue
        case stringValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let refValue = self.refValue {
            try encodeContainer.encode(refValue, forKey: .refValue)
        }
        if let stringValue = self.stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let refValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refValue)
        refValue = refValueDecoded
    }
}

extension DataPipelineClientTypes {
    /// A key-value pair that describes a property of a pipeline object. The value is specified as either a string value (StringValue) or a reference to another object (RefValue) but not as both.
    public struct Field: Swift.Equatable {
        /// The field identifier.
        /// This member is required.
        public var key: Swift.String?
        /// The field value, expressed as the identifier of another object.
        public var refValue: Swift.String?
        /// The field value, expressed as a String.
        public var stringValue: Swift.String?

        public init(
            key: Swift.String? = nil,
            refValue: Swift.String? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.key = key
            self.refValue = refValue
            self.stringValue = stringValue
        }
    }

}

extension GetPipelineDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineId
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension GetPipelineDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for GetPipelineDefinition.
public struct GetPipelineDefinitionInput: Swift.Equatable {
    /// The ID of the pipeline.
    /// This member is required.
    public var pipelineId: Swift.String?
    /// The version of the pipeline definition to retrieve. Set this parameter to latest (default) to use the last definition saved to the pipeline or active to use the last definition that was activated.
    public var version: Swift.String?

    public init(
        pipelineId: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.pipelineId = pipelineId
        self.version = version
    }
}

struct GetPipelineDefinitionInputBody: Swift.Equatable {
    let pipelineId: Swift.String?
    let version: Swift.String?
}

extension GetPipelineDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineId
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetPipelineDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPipelineDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.parameterObjects = output.parameterObjects
            self.parameterValues = output.parameterValues
            self.pipelineObjects = output.pipelineObjects
        } else {
            self.parameterObjects = nil
            self.parameterValues = nil
            self.pipelineObjects = nil
        }
    }
}

/// Contains the output of GetPipelineDefinition.
public struct GetPipelineDefinitionOutput: Swift.Equatable {
    /// The parameter objects used in the pipeline definition.
    public var parameterObjects: [DataPipelineClientTypes.ParameterObject]?
    /// The parameter values used in the pipeline definition.
    public var parameterValues: [DataPipelineClientTypes.ParameterValue]?
    /// The objects defined in the pipeline.
    public var pipelineObjects: [DataPipelineClientTypes.PipelineObject]?

    public init(
        parameterObjects: [DataPipelineClientTypes.ParameterObject]? = nil,
        parameterValues: [DataPipelineClientTypes.ParameterValue]? = nil,
        pipelineObjects: [DataPipelineClientTypes.PipelineObject]? = nil
    )
    {
        self.parameterObjects = parameterObjects
        self.parameterValues = parameterValues
        self.pipelineObjects = pipelineObjects
    }
}

struct GetPipelineDefinitionOutputBody: Swift.Equatable {
    let pipelineObjects: [DataPipelineClientTypes.PipelineObject]?
    let parameterObjects: [DataPipelineClientTypes.ParameterObject]?
    let parameterValues: [DataPipelineClientTypes.ParameterValue]?
}

extension GetPipelineDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterObjects
        case parameterValues
        case pipelineObjects
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineObjectsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.PipelineObject?].self, forKey: .pipelineObjects)
        var pipelineObjectsDecoded0:[DataPipelineClientTypes.PipelineObject]? = nil
        if let pipelineObjectsContainer = pipelineObjectsContainer {
            pipelineObjectsDecoded0 = [DataPipelineClientTypes.PipelineObject]()
            for structure0 in pipelineObjectsContainer {
                if let structure0 = structure0 {
                    pipelineObjectsDecoded0?.append(structure0)
                }
            }
        }
        pipelineObjects = pipelineObjectsDecoded0
        let parameterObjectsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.ParameterObject?].self, forKey: .parameterObjects)
        var parameterObjectsDecoded0:[DataPipelineClientTypes.ParameterObject]? = nil
        if let parameterObjectsContainer = parameterObjectsContainer {
            parameterObjectsDecoded0 = [DataPipelineClientTypes.ParameterObject]()
            for structure0 in parameterObjectsContainer {
                if let structure0 = structure0 {
                    parameterObjectsDecoded0?.append(structure0)
                }
            }
        }
        parameterObjects = parameterObjectsDecoded0
        let parameterValuesContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.ParameterValue?].self, forKey: .parameterValues)
        var parameterValuesDecoded0:[DataPipelineClientTypes.ParameterValue]? = nil
        if let parameterValuesContainer = parameterValuesContainer {
            parameterValuesDecoded0 = [DataPipelineClientTypes.ParameterValue]()
            for structure0 in parameterValuesContainer {
                if let structure0 = structure0 {
                    parameterValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterValues = parameterValuesDecoded0
    }
}

enum GetPipelineDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataPipelineClientTypes.InstanceIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document
        case signature
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let signature = self.signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signature)
        signature = signatureDecoded
    }
}

extension DataPipelineClientTypes {
    /// Identity information for the EC2 instance that is hosting the task runner. You can get this value by calling a metadata URI from the EC2 instance. For more information, see [Instance Metadata](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AESDG-chapter-instancedata.html) in the Amazon Elastic Compute Cloud User Guide. Passing in this value proves that your task runner is running on an EC2 instance, and ensures the proper AWS Data Pipeline service charges are applied to your pipeline.
    public struct InstanceIdentity: Swift.Equatable {
        /// A description of an EC2 instance that is generated when the instance is launched and exposed to the instance via the instance metadata service in the form of a JSON representation of an object.
        public var document: Swift.String?
        /// A signature which can be used to verify the accuracy and authenticity of the information provided in the instance identity document.
        public var signature: Swift.String?

        public init(
            document: Swift.String? = nil,
            signature: Swift.String? = nil
        )
        {
            self.document = document
            self.signature = signature
        }
    }

}

extension InternalServiceError {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal service error occurred.
public struct InternalServiceError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was not valid. Verify that your request was properly formatted, that the signature was generated with the correct credentials, and that you haven't exceeded any of the service limits for your account.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListPipelinesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

extension ListPipelinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for ListPipelines.
public struct ListPipelinesInput: Swift.Equatable {
    /// The starting point for the results to be returned. For the first call, this value should be empty. As long as there are more results, continue to call ListPipelines with the marker value from the previous call to retrieve the next set of results.
    public var marker: Swift.String?

    public init(
        marker: Swift.String? = nil
    )
    {
        self.marker = marker
    }
}

struct ListPipelinesInputBody: Swift.Equatable {
    let marker: Swift.String?
}

extension ListPipelinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListPipelinesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPipelinesOutputBody = try responseDecoder.decode(responseBody: data)
            self.hasMoreResults = output.hasMoreResults
            self.marker = output.marker
            self.pipelineIdList = output.pipelineIdList
        } else {
            self.hasMoreResults = false
            self.marker = nil
            self.pipelineIdList = nil
        }
    }
}

/// Contains the output of ListPipelines.
public struct ListPipelinesOutput: Swift.Equatable {
    /// Indicates whether there are more results that can be obtained by a subsequent call.
    public var hasMoreResults: Swift.Bool
    /// The starting point for the next page of results. To view the next page of results, call ListPipelinesOutput again with this marker value. If the value is null, there are no more results.
    public var marker: Swift.String?
    /// The pipeline identifiers. If you require additional information about the pipelines, you can use these identifiers to call [DescribePipelines] and [GetPipelineDefinition].
    /// This member is required.
    public var pipelineIdList: [DataPipelineClientTypes.PipelineIdName]?

    public init(
        hasMoreResults: Swift.Bool = false,
        marker: Swift.String? = nil,
        pipelineIdList: [DataPipelineClientTypes.PipelineIdName]? = nil
    )
    {
        self.hasMoreResults = hasMoreResults
        self.marker = marker
        self.pipelineIdList = pipelineIdList
    }
}

struct ListPipelinesOutputBody: Swift.Equatable {
    let pipelineIdList: [DataPipelineClientTypes.PipelineIdName]?
    let marker: Swift.String?
    let hasMoreResults: Swift.Bool
}

extension ListPipelinesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hasMoreResults
        case marker
        case pipelineIdList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdListContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.PipelineIdName?].self, forKey: .pipelineIdList)
        var pipelineIdListDecoded0:[DataPipelineClientTypes.PipelineIdName]? = nil
        if let pipelineIdListContainer = pipelineIdListContainer {
            pipelineIdListDecoded0 = [DataPipelineClientTypes.PipelineIdName]()
            for structure0 in pipelineIdListContainer {
                if let structure0 = structure0 {
                    pipelineIdListDecoded0?.append(structure0)
                }
            }
        }
        pipelineIdList = pipelineIdListDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let hasMoreResultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasMoreResults) ?? false
        hasMoreResults = hasMoreResultsDecoded
    }
}

enum ListPipelinesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataPipelineClientTypes.Operator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DataPipelineClientTypes.OperatorType.self, forKey: .type)
        type = typeDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DataPipelineClientTypes {
    /// Contains a logical operation for comparing the value of a field with a specified value.
    public struct Operator: Swift.Equatable {
        /// The logical operation to be performed: equal (EQ), equal reference (REF_EQ), less than or equal (LE), greater than or equal (GE), or between (BETWEEN). Equal reference (REF_EQ) can be used only with reference fields. The other comparison types can be used only with String fields. The comparison types you can use apply only to certain object fields, as detailed below. The comparison operators EQ and REF_EQ act on the following fields:
        ///
        /// * name
        ///
        /// * @sphere
        ///
        /// * parent
        ///
        /// * @componentParent
        ///
        /// * @instanceParent
        ///
        /// * @status
        ///
        /// * @scheduledStartTime
        ///
        /// * @scheduledEndTime
        ///
        /// * @actualStartTime
        ///
        /// * @actualEndTime
        ///
        ///
        /// The comparison operators GE, LE, and BETWEEN act on the following fields:
        ///
        /// * @scheduledStartTime
        ///
        /// * @scheduledEndTime
        ///
        /// * @actualStartTime
        ///
        /// * @actualEndTime
        ///
        ///
        /// Note that fields beginning with the at sign (@) are read-only and set by the web service. When you name fields, you should choose names containing only alpha-numeric values, as symbols may be reserved by AWS Data Pipeline. User-defined fields that you add to a pipeline should prefix their name with the string "my".
        public var type: DataPipelineClientTypes.OperatorType?
        /// The value that the actual field value will be compared with.
        public var values: [Swift.String]?

        public init(
            type: DataPipelineClientTypes.OperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.type = type
            self.values = values
        }
    }

}

extension DataPipelineClientTypes {
    public enum OperatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case equal
        case greaterthanorequal
        case lessthanorequal
        case referenceequal
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatorType] {
            return [
                .between,
                .equal,
                .greaterthanorequal,
                .lessthanorequal,
                .referenceequal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .equal: return "EQ"
            case .greaterthanorequal: return "GE"
            case .lessthanorequal: return "LE"
            case .referenceequal: return "REF_EQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperatorType(rawValue: rawValue) ?? OperatorType.sdkUnknown(rawValue)
        }
    }
}

extension DataPipelineClientTypes.ParameterAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case stringValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let stringValue = self.stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
    }
}

extension DataPipelineClientTypes {
    /// The attributes allowed or specified with a parameter object.
    public struct ParameterAttribute: Swift.Equatable {
        /// The field identifier.
        /// This member is required.
        public var key: Swift.String?
        /// The field value, expressed as a String.
        /// This member is required.
        public var stringValue: Swift.String?

        public init(
            key: Swift.String? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.key = key
            self.stringValue = stringValue
        }
    }

}

extension DataPipelineClientTypes.ParameterObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for parameterattribute0 in attributes {
                try attributesContainer.encode(parameterattribute0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let attributesContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.ParameterAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[DataPipelineClientTypes.ParameterAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [DataPipelineClientTypes.ParameterAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension DataPipelineClientTypes {
    /// Contains information about a parameter object.
    public struct ParameterObject: Swift.Equatable {
        /// The attributes of the parameter object.
        /// This member is required.
        public var attributes: [DataPipelineClientTypes.ParameterAttribute]?
        /// The ID of the parameter object.
        /// This member is required.
        public var id: Swift.String?

        public init(
            attributes: [DataPipelineClientTypes.ParameterAttribute]? = nil,
            id: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.id = id
        }
    }

}

extension DataPipelineClientTypes.ParameterValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case stringValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let stringValue = self.stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
    }
}

extension DataPipelineClientTypes {
    /// A value or list of parameter values.
    public struct ParameterValue: Swift.Equatable {
        /// The ID of the parameter value.
        /// This member is required.
        public var id: Swift.String?
        /// The field value, expressed as a String.
        /// This member is required.
        public var stringValue: Swift.String?

        public init(
            id: Swift.String? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.id = id
            self.stringValue = stringValue
        }
    }

}

extension PipelineDeletedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PipelineDeletedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified pipeline has been deleted.
public struct PipelineDeletedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PipelineDeletedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PipelineDeletedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PipelineDeletedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataPipelineClientTypes.PipelineDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case fields
        case name
        case pipelineId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for field0 in fields {
                try fieldsContainer.encode(field0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.Field?].self, forKey: .fields)
        var fieldsDecoded0:[DataPipelineClientTypes.Field]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [DataPipelineClientTypes.Field]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DataPipelineClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DataPipelineClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DataPipelineClientTypes {
    /// Contains pipeline metadata.
    public struct PipelineDescription: Swift.Equatable {
        /// Description of the pipeline.
        public var description: Swift.String?
        /// A list of read-only fields that contain metadata about the pipeline: @userId, @accountId, and @pipelineState.
        /// This member is required.
        public var fields: [DataPipelineClientTypes.Field]?
        /// The name of the pipeline.
        /// This member is required.
        public var name: Swift.String?
        /// The pipeline identifier that was assigned by AWS Data Pipeline. This is a string of the form df-297EG78HU43EEXAMPLE.
        /// This member is required.
        public var pipelineId: Swift.String?
        /// A list of tags to associated with a pipeline. Tags let you control access to pipelines. For more information, see [Controlling User Access to Pipelines](http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-control-access.html) in the AWS Data Pipeline Developer Guide.
        public var tags: [DataPipelineClientTypes.Tag]?

        public init(
            description: Swift.String? = nil,
            fields: [DataPipelineClientTypes.Field]? = nil,
            name: Swift.String? = nil,
            pipelineId: Swift.String? = nil,
            tags: [DataPipelineClientTypes.Tag]? = nil
        )
        {
            self.description = description
            self.fields = fields
            self.name = name
            self.pipelineId = pipelineId
            self.tags = tags
        }
    }

}

extension DataPipelineClientTypes.PipelineIdName: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DataPipelineClientTypes {
    /// Contains the name and identifier of a pipeline.
    public struct PipelineIdName: Swift.Equatable {
        /// The ID of the pipeline that was assigned by AWS Data Pipeline. This is a string of the form df-297EG78HU43EEXAMPLE.
        public var id: Swift.String?
        /// The name of the pipeline.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension PipelineNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PipelineNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified pipeline was not found. Verify that you used the correct user and account identifiers.
public struct PipelineNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PipelineNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PipelineNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PipelineNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataPipelineClientTypes.PipelineObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for field0 in fields {
                try fieldsContainer.encode(field0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.Field?].self, forKey: .fields)
        var fieldsDecoded0:[DataPipelineClientTypes.Field]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [DataPipelineClientTypes.Field]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension DataPipelineClientTypes {
    /// Contains information about a pipeline object. This can be a logical, physical, or physical attempt pipeline object. The complete set of components of a pipeline defines the pipeline.
    public struct PipelineObject: Swift.Equatable {
        /// Key-value pairs that define the properties of the object.
        /// This member is required.
        public var fields: [DataPipelineClientTypes.Field]?
        /// The ID of the object.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the object.
        /// This member is required.
        public var name: Swift.String?

        public init(
            fields: [DataPipelineClientTypes.Field]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.fields = fields
            self.id = id
            self.name = name
        }
    }

}

extension PollForTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname
        case instanceIdentity
        case workerGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let instanceIdentity = self.instanceIdentity {
            try encodeContainer.encode(instanceIdentity, forKey: .instanceIdentity)
        }
        if let workerGroup = self.workerGroup {
            try encodeContainer.encode(workerGroup, forKey: .workerGroup)
        }
    }
}

extension PollForTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for PollForTask.
public struct PollForTaskInput: Swift.Equatable {
    /// The public DNS name of the calling task runner.
    public var hostname: Swift.String?
    /// Identity information for the EC2 instance that is hosting the task runner. You can get this value from the instance using http://169.254.169.254/latest/meta-data/instance-id. For more information, see [Instance Metadata](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AESDG-chapter-instancedata.html) in the Amazon Elastic Compute Cloud User Guide. Passing in this value proves that your task runner is running on an EC2 instance, and ensures the proper AWS Data Pipeline service charges are applied to your pipeline.
    public var instanceIdentity: DataPipelineClientTypes.InstanceIdentity?
    /// The type of task the task runner is configured to accept and process. The worker group is set as a field on objects in the pipeline when they are created. You can only specify a single value for workerGroup in the call to PollForTask. There are no wildcard values permitted in workerGroup; the string must be an exact, case-sensitive, match.
    /// This member is required.
    public var workerGroup: Swift.String?

    public init(
        hostname: Swift.String? = nil,
        instanceIdentity: DataPipelineClientTypes.InstanceIdentity? = nil,
        workerGroup: Swift.String? = nil
    )
    {
        self.hostname = hostname
        self.instanceIdentity = instanceIdentity
        self.workerGroup = workerGroup
    }
}

struct PollForTaskInputBody: Swift.Equatable {
    let workerGroup: Swift.String?
    let hostname: Swift.String?
    let instanceIdentity: DataPipelineClientTypes.InstanceIdentity?
}

extension PollForTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname
        case instanceIdentity
        case workerGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerGroup)
        workerGroup = workerGroupDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let instanceIdentityDecoded = try containerValues.decodeIfPresent(DataPipelineClientTypes.InstanceIdentity.self, forKey: .instanceIdentity)
        instanceIdentity = instanceIdentityDecoded
    }
}

extension PollForTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PollForTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.taskObject = output.taskObject
        } else {
            self.taskObject = nil
        }
    }
}

/// Contains the output of PollForTask.
public struct PollForTaskOutput: Swift.Equatable {
    /// The information needed to complete the task that is being assigned to the task runner. One of the fields returned in this object is taskId, which contains an identifier for the task being assigned. The calling task runner uses taskId in subsequent calls to [ReportTaskProgress] and [SetTaskStatus].
    public var taskObject: DataPipelineClientTypes.TaskObject?

    public init(
        taskObject: DataPipelineClientTypes.TaskObject? = nil
    )
    {
        self.taskObject = taskObject
    }
}

struct PollForTaskOutputBody: Swift.Equatable {
    let taskObject: DataPipelineClientTypes.TaskObject?
}

extension PollForTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskObject
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskObjectDecoded = try containerValues.decodeIfPresent(DataPipelineClientTypes.TaskObject.self, forKey: .taskObject)
        taskObject = taskObjectDecoded
    }
}

enum PollForTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TaskNotFoundException": return try await TaskNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutPipelineDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterObjects
        case parameterValues
        case pipelineId
        case pipelineObjects
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterObjects = parameterObjects {
            var parameterObjectsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterObjects)
            for parameterobject0 in parameterObjects {
                try parameterObjectsContainer.encode(parameterobject0)
            }
        }
        if let parameterValues = parameterValues {
            var parameterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterValues)
            for parametervalue0 in parameterValues {
                try parameterValuesContainer.encode(parametervalue0)
            }
        }
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let pipelineObjects = pipelineObjects {
            var pipelineObjectsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineObjects)
            for pipelineobject0 in pipelineObjects {
                try pipelineObjectsContainer.encode(pipelineobject0)
            }
        }
    }
}

extension PutPipelineDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for PutPipelineDefinition.
public struct PutPipelineDefinitionInput: Swift.Equatable {
    /// The parameter objects used with the pipeline.
    public var parameterObjects: [DataPipelineClientTypes.ParameterObject]?
    /// The parameter values used with the pipeline.
    public var parameterValues: [DataPipelineClientTypes.ParameterValue]?
    /// The ID of the pipeline.
    /// This member is required.
    public var pipelineId: Swift.String?
    /// The objects that define the pipeline. These objects overwrite the existing pipeline definition.
    /// This member is required.
    public var pipelineObjects: [DataPipelineClientTypes.PipelineObject]?

    public init(
        parameterObjects: [DataPipelineClientTypes.ParameterObject]? = nil,
        parameterValues: [DataPipelineClientTypes.ParameterValue]? = nil,
        pipelineId: Swift.String? = nil,
        pipelineObjects: [DataPipelineClientTypes.PipelineObject]? = nil
    )
    {
        self.parameterObjects = parameterObjects
        self.parameterValues = parameterValues
        self.pipelineId = pipelineId
        self.pipelineObjects = pipelineObjects
    }
}

struct PutPipelineDefinitionInputBody: Swift.Equatable {
    let pipelineId: Swift.String?
    let pipelineObjects: [DataPipelineClientTypes.PipelineObject]?
    let parameterObjects: [DataPipelineClientTypes.ParameterObject]?
    let parameterValues: [DataPipelineClientTypes.ParameterValue]?
}

extension PutPipelineDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterObjects
        case parameterValues
        case pipelineId
        case pipelineObjects
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let pipelineObjectsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.PipelineObject?].self, forKey: .pipelineObjects)
        var pipelineObjectsDecoded0:[DataPipelineClientTypes.PipelineObject]? = nil
        if let pipelineObjectsContainer = pipelineObjectsContainer {
            pipelineObjectsDecoded0 = [DataPipelineClientTypes.PipelineObject]()
            for structure0 in pipelineObjectsContainer {
                if let structure0 = structure0 {
                    pipelineObjectsDecoded0?.append(structure0)
                }
            }
        }
        pipelineObjects = pipelineObjectsDecoded0
        let parameterObjectsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.ParameterObject?].self, forKey: .parameterObjects)
        var parameterObjectsDecoded0:[DataPipelineClientTypes.ParameterObject]? = nil
        if let parameterObjectsContainer = parameterObjectsContainer {
            parameterObjectsDecoded0 = [DataPipelineClientTypes.ParameterObject]()
            for structure0 in parameterObjectsContainer {
                if let structure0 = structure0 {
                    parameterObjectsDecoded0?.append(structure0)
                }
            }
        }
        parameterObjects = parameterObjectsDecoded0
        let parameterValuesContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.ParameterValue?].self, forKey: .parameterValues)
        var parameterValuesDecoded0:[DataPipelineClientTypes.ParameterValue]? = nil
        if let parameterValuesContainer = parameterValuesContainer {
            parameterValuesDecoded0 = [DataPipelineClientTypes.ParameterValue]()
            for structure0 in parameterValuesContainer {
                if let structure0 = structure0 {
                    parameterValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterValues = parameterValuesDecoded0
    }
}

extension PutPipelineDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutPipelineDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.errored = output.errored
            self.validationErrors = output.validationErrors
            self.validationWarnings = output.validationWarnings
        } else {
            self.errored = false
            self.validationErrors = nil
            self.validationWarnings = nil
        }
    }
}

/// Contains the output of PutPipelineDefinition.
public struct PutPipelineDefinitionOutput: Swift.Equatable {
    /// Indicates whether there were validation errors, and the pipeline definition is stored but cannot be activated until you correct the pipeline and call PutPipelineDefinition to commit the corrected pipeline.
    /// This member is required.
    public var errored: Swift.Bool
    /// The validation errors that are associated with the objects defined in pipelineObjects.
    public var validationErrors: [DataPipelineClientTypes.ValidationError]?
    /// The validation warnings that are associated with the objects defined in pipelineObjects.
    public var validationWarnings: [DataPipelineClientTypes.ValidationWarning]?

    public init(
        errored: Swift.Bool = false,
        validationErrors: [DataPipelineClientTypes.ValidationError]? = nil,
        validationWarnings: [DataPipelineClientTypes.ValidationWarning]? = nil
    )
    {
        self.errored = errored
        self.validationErrors = validationErrors
        self.validationWarnings = validationWarnings
    }
}

struct PutPipelineDefinitionOutputBody: Swift.Equatable {
    let validationErrors: [DataPipelineClientTypes.ValidationError]?
    let validationWarnings: [DataPipelineClientTypes.ValidationWarning]?
    let errored: Swift.Bool
}

extension PutPipelineDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errored
        case validationErrors
        case validationWarnings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationErrorsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.ValidationError?].self, forKey: .validationErrors)
        var validationErrorsDecoded0:[DataPipelineClientTypes.ValidationError]? = nil
        if let validationErrorsContainer = validationErrorsContainer {
            validationErrorsDecoded0 = [DataPipelineClientTypes.ValidationError]()
            for structure0 in validationErrorsContainer {
                if let structure0 = structure0 {
                    validationErrorsDecoded0?.append(structure0)
                }
            }
        }
        validationErrors = validationErrorsDecoded0
        let validationWarningsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.ValidationWarning?].self, forKey: .validationWarnings)
        var validationWarningsDecoded0:[DataPipelineClientTypes.ValidationWarning]? = nil
        if let validationWarningsContainer = validationWarningsContainer {
            validationWarningsDecoded0 = [DataPipelineClientTypes.ValidationWarning]()
            for structure0 in validationWarningsContainer {
                if let structure0 = structure0 {
                    validationWarningsDecoded0?.append(structure0)
                }
            }
        }
        validationWarnings = validationWarningsDecoded0
        let erroredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .errored) ?? false
        errored = erroredDecoded
    }
}

enum PutPipelineDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataPipelineClientTypes.Query: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectors = selectors {
            var selectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectors)
            for selector0 in selectors {
                try selectorsContainer.encode(selector0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectorsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.Selector?].self, forKey: .selectors)
        var selectorsDecoded0:[DataPipelineClientTypes.Selector]? = nil
        if let selectorsContainer = selectorsContainer {
            selectorsDecoded0 = [DataPipelineClientTypes.Selector]()
            for structure0 in selectorsContainer {
                if let structure0 = structure0 {
                    selectorsDecoded0?.append(structure0)
                }
            }
        }
        selectors = selectorsDecoded0
    }
}

extension DataPipelineClientTypes {
    /// Defines the query to run against an object.
    public struct Query: Swift.Equatable {
        /// List of selectors that define the query. An object must satisfy all of the selectors to match the query.
        public var selectors: [DataPipelineClientTypes.Selector]?

        public init(
            selectors: [DataPipelineClientTypes.Selector]? = nil
        )
        {
            self.selectors = selectors
        }
    }

}

extension QueryObjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case marker
        case pipelineId
        case query
        case sphere
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let query = self.query {
            try encodeContainer.encode(query, forKey: .query)
        }
        if let sphere = self.sphere {
            try encodeContainer.encode(sphere, forKey: .sphere)
        }
    }
}

extension QueryObjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for QueryObjects.
public struct QueryObjectsInput: Swift.Equatable {
    /// The maximum number of object names that QueryObjects will return in a single call. The default value is 100.
    public var limit: Swift.Int?
    /// The starting point for the results to be returned. For the first call, this value should be empty. As long as there are more results, continue to call QueryObjects with the marker value from the previous call to retrieve the next set of results.
    public var marker: Swift.String?
    /// The ID of the pipeline.
    /// This member is required.
    public var pipelineId: Swift.String?
    /// The query that defines the objects to be returned. The Query object can contain a maximum of ten selectors. The conditions in the query are limited to top-level String fields in the object. These filters can be applied to components, instances, and attempts.
    public var query: DataPipelineClientTypes.Query?
    /// Indicates whether the query applies to components or instances. The possible values are: COMPONENT, INSTANCE, and ATTEMPT.
    /// This member is required.
    public var sphere: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        pipelineId: Swift.String? = nil,
        query: DataPipelineClientTypes.Query? = nil,
        sphere: Swift.String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.pipelineId = pipelineId
        self.query = query
        self.sphere = sphere
    }
}

struct QueryObjectsInputBody: Swift.Equatable {
    let pipelineId: Swift.String?
    let query: DataPipelineClientTypes.Query?
    let sphere: Swift.String?
    let marker: Swift.String?
    let limit: Swift.Int?
}

extension QueryObjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case marker
        case pipelineId
        case query
        case sphere
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let queryDecoded = try containerValues.decodeIfPresent(DataPipelineClientTypes.Query.self, forKey: .query)
        query = queryDecoded
        let sphereDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sphere)
        sphere = sphereDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension QueryObjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: QueryObjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.hasMoreResults = output.hasMoreResults
            self.ids = output.ids
            self.marker = output.marker
        } else {
            self.hasMoreResults = false
            self.ids = nil
            self.marker = nil
        }
    }
}

/// Contains the output of QueryObjects.
public struct QueryObjectsOutput: Swift.Equatable {
    /// Indicates whether there are more results that can be obtained by a subsequent call.
    public var hasMoreResults: Swift.Bool
    /// The identifiers that match the query selectors.
    public var ids: [Swift.String]?
    /// The starting point for the next page of results. To view the next page of results, call QueryObjects again with this marker value. If the value is null, there are no more results.
    public var marker: Swift.String?

    public init(
        hasMoreResults: Swift.Bool = false,
        ids: [Swift.String]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.hasMoreResults = hasMoreResults
        self.ids = ids
        self.marker = marker
    }
}

struct QueryObjectsOutputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let marker: Swift.String?
    let hasMoreResults: Swift.Bool
}

extension QueryObjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hasMoreResults
        case ids
        case marker
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let hasMoreResultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasMoreResults) ?? false
        hasMoreResults = hasMoreResultsDecoded
    }
}

enum QueryObjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineId
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for string0 in tagKeys {
                try tagKeysContainer.encode(string0)
            }
        }
    }
}

extension RemoveTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for RemoveTags.
public struct RemoveTagsInput: Swift.Equatable {
    /// The ID of the pipeline.
    /// This member is required.
    public var pipelineId: Swift.String?
    /// The keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        pipelineId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.pipelineId = pipelineId
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsInputBody: Swift.Equatable {
    let pipelineId: Swift.String?
    let tagKeys: [Swift.String]?
}

extension RemoveTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineId
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Contains the output of RemoveTags.
public struct RemoveTagsOutput: Swift.Equatable {

    public init() { }
}

enum RemoveTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ReportTaskProgressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for field0 in fields {
                try fieldsContainer.encode(field0)
            }
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }
}

extension ReportTaskProgressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for ReportTaskProgress.
public struct ReportTaskProgressInput: Swift.Equatable {
    /// Key-value pairs that define the properties of the ReportTaskProgressInput object.
    public var fields: [DataPipelineClientTypes.Field]?
    /// The ID of the task assigned to the task runner. This value is provided in the response for [PollForTask].
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        fields: [DataPipelineClientTypes.Field]? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.fields = fields
        self.taskId = taskId
    }
}

struct ReportTaskProgressInputBody: Swift.Equatable {
    let taskId: Swift.String?
    let fields: [DataPipelineClientTypes.Field]?
}

extension ReportTaskProgressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.Field?].self, forKey: .fields)
        var fieldsDecoded0:[DataPipelineClientTypes.Field]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [DataPipelineClientTypes.Field]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ReportTaskProgressOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReportTaskProgressOutputBody = try responseDecoder.decode(responseBody: data)
            self.canceled = output.canceled
        } else {
            self.canceled = false
        }
    }
}

/// Contains the output of ReportTaskProgress.
public struct ReportTaskProgressOutput: Swift.Equatable {
    /// If true, the calling task runner should cancel processing of the task. The task runner does not need to call [SetTaskStatus] for canceled tasks.
    /// This member is required.
    public var canceled: Swift.Bool

    public init(
        canceled: Swift.Bool = false
    )
    {
        self.canceled = canceled
    }
}

struct ReportTaskProgressOutputBody: Swift.Equatable {
    let canceled: Swift.Bool
}

extension ReportTaskProgressOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canceled
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canceledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canceled) ?? false
        canceled = canceledDecoded
    }
}

enum ReportTaskProgressOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TaskNotFoundException": return try await TaskNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ReportTaskRunnerHeartbeatInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname
        case taskrunnerId
        case workerGroup
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let taskrunnerId = self.taskrunnerId {
            try encodeContainer.encode(taskrunnerId, forKey: .taskrunnerId)
        }
        if let workerGroup = self.workerGroup {
            try encodeContainer.encode(workerGroup, forKey: .workerGroup)
        }
    }
}

extension ReportTaskRunnerHeartbeatInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for ReportTaskRunnerHeartbeat.
public struct ReportTaskRunnerHeartbeatInput: Swift.Equatable {
    /// The public DNS name of the task runner.
    public var hostname: Swift.String?
    /// The ID of the task runner. This value should be unique across your AWS account. In the case of AWS Data Pipeline Task Runner launched on a resource managed by AWS Data Pipeline, the web service provides a unique identifier when it launches the application. If you have written a custom task runner, you should assign a unique identifier for the task runner.
    /// This member is required.
    public var taskrunnerId: Swift.String?
    /// The type of task the task runner is configured to accept and process. The worker group is set as a field on objects in the pipeline when they are created. You can only specify a single value for workerGroup. There are no wildcard values permitted in workerGroup; the string must be an exact, case-sensitive, match.
    public var workerGroup: Swift.String?

    public init(
        hostname: Swift.String? = nil,
        taskrunnerId: Swift.String? = nil,
        workerGroup: Swift.String? = nil
    )
    {
        self.hostname = hostname
        self.taskrunnerId = taskrunnerId
        self.workerGroup = workerGroup
    }
}

struct ReportTaskRunnerHeartbeatInputBody: Swift.Equatable {
    let taskrunnerId: Swift.String?
    let workerGroup: Swift.String?
    let hostname: Swift.String?
}

extension ReportTaskRunnerHeartbeatInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname
        case taskrunnerId
        case workerGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskrunnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskrunnerId)
        taskrunnerId = taskrunnerIdDecoded
        let workerGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workerGroup)
        workerGroup = workerGroupDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
    }
}

extension ReportTaskRunnerHeartbeatOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReportTaskRunnerHeartbeatOutputBody = try responseDecoder.decode(responseBody: data)
            self.terminate = output.terminate
        } else {
            self.terminate = false
        }
    }
}

/// Contains the output of ReportTaskRunnerHeartbeat.
public struct ReportTaskRunnerHeartbeatOutput: Swift.Equatable {
    /// Indicates whether the calling task runner should terminate.
    /// This member is required.
    public var terminate: Swift.Bool

    public init(
        terminate: Swift.Bool = false
    )
    {
        self.terminate = terminate
    }
}

struct ReportTaskRunnerHeartbeatOutputBody: Swift.Equatable {
    let terminate: Swift.Bool
}

extension ReportTaskRunnerHeartbeatOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminate) ?? false
        terminate = terminateDecoded
    }
}

enum ReportTaskRunnerHeartbeatOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataPipelineClientTypes.Selector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldName
        case `operator` = "operator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldName = self.fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`, forKey: .`operator`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(DataPipelineClientTypes.Operator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension DataPipelineClientTypes {
    /// A comparision that is used to determine whether a query should return this object.
    public struct Selector: Swift.Equatable {
        /// The name of the field that the operator will be applied to. The field name is the "key" portion of the field definition in the pipeline definition syntax that is used by the AWS Data Pipeline API. If the field is not set on the object, the condition fails.
        public var fieldName: Swift.String?
        /// Contains a logical operation for comparing the value of a field with a specified value.
        public var `operator`: DataPipelineClientTypes.Operator?

        public init(
            fieldName: Swift.String? = nil,
            `operator`: DataPipelineClientTypes.Operator? = nil
        )
        {
            self.fieldName = fieldName
            self.`operator` = `operator`
        }
    }

}

extension SetStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIds
        case pipelineId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIds = objectIds {
            var objectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectIds)
            for id0 in objectIds {
                try objectIdsContainer.encode(id0)
            }
        }
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }
}

extension SetStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for SetStatus.
public struct SetStatusInput: Swift.Equatable {
    /// The IDs of the objects. The corresponding objects can be either physical or components, but not a mix of both types.
    /// This member is required.
    public var objectIds: [Swift.String]?
    /// The ID of the pipeline that contains the objects.
    /// This member is required.
    public var pipelineId: Swift.String?
    /// The status to be set on all the objects specified in objectIds. For components, use PAUSE or RESUME. For instances, use TRY_CANCEL, RERUN, or MARK_FINISHED.
    /// This member is required.
    public var status: Swift.String?

    public init(
        objectIds: [Swift.String]? = nil,
        pipelineId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.objectIds = objectIds
        self.pipelineId = pipelineId
        self.status = status
    }
}

struct SetStatusInputBody: Swift.Equatable {
    let pipelineId: Swift.String?
    let objectIds: [Swift.String]?
    let status: Swift.String?
}

extension SetStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIds
        case pipelineId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let objectIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .objectIds)
        var objectIdsDecoded0:[Swift.String]? = nil
        if let objectIdsContainer = objectIdsContainer {
            objectIdsDecoded0 = [Swift.String]()
            for string0 in objectIdsContainer {
                if let string0 = string0 {
                    objectIdsDecoded0?.append(string0)
                }
            }
        }
        objectIds = objectIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SetStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetStatusOutput: Swift.Equatable {

    public init() { }
}

enum SetStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetTaskStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorId
        case errorMessage
        case errorStackTrace
        case taskId
        case taskStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorId = self.errorId {
            try encodeContainer.encode(errorId, forKey: .errorId)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorStackTrace = self.errorStackTrace {
            try encodeContainer.encode(errorStackTrace, forKey: .errorStackTrace)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStatus = self.taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
    }
}

extension SetTaskStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for SetTaskStatus.
public struct SetTaskStatusInput: Swift.Equatable {
    /// If an error occurred during the task, this value specifies the error code. This value is set on the physical attempt object. It is used to display error information to the user. It should not start with string "Service_" which is reserved by the system.
    public var errorId: Swift.String?
    /// If an error occurred during the task, this value specifies a text description of the error. This value is set on the physical attempt object. It is used to display error information to the user. The web service does not parse this value.
    public var errorMessage: Swift.String?
    /// If an error occurred during the task, this value specifies the stack trace associated with the error. This value is set on the physical attempt object. It is used to display error information to the user. The web service does not parse this value.
    public var errorStackTrace: Swift.String?
    /// The ID of the task assigned to the task runner. This value is provided in the response for [PollForTask].
    /// This member is required.
    public var taskId: Swift.String?
    /// If FINISHED, the task successfully completed. If FAILED, the task ended unsuccessfully. Preconditions use false.
    /// This member is required.
    public var taskStatus: DataPipelineClientTypes.TaskStatus?

    public init(
        errorId: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        errorStackTrace: Swift.String? = nil,
        taskId: Swift.String? = nil,
        taskStatus: DataPipelineClientTypes.TaskStatus? = nil
    )
    {
        self.errorId = errorId
        self.errorMessage = errorMessage
        self.errorStackTrace = errorStackTrace
        self.taskId = taskId
        self.taskStatus = taskStatus
    }
}

struct SetTaskStatusInputBody: Swift.Equatable {
    let taskId: Swift.String?
    let taskStatus: DataPipelineClientTypes.TaskStatus?
    let errorId: Swift.String?
    let errorMessage: Swift.String?
    let errorStackTrace: Swift.String?
}

extension SetTaskStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorId
        case errorMessage
        case errorStackTrace
        case taskId
        case taskStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(DataPipelineClientTypes.TaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let errorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorId)
        errorId = errorIdDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorStackTraceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorStackTrace)
        errorStackTrace = errorStackTraceDecoded
    }
}

extension SetTaskStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Contains the output of SetTaskStatus.
public struct SetTaskStatusOutput: Swift.Equatable {

    public init() { }
}

enum SetTaskStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TaskNotFoundException": return try await TaskNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataPipelineClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DataPipelineClientTypes {
    /// Tags are key/value pairs defined by a user and associated with a pipeline to control access. AWS Data Pipeline allows you to associate ten tags per pipeline. For more information, see [Controlling User Access to Pipelines](http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-control-access.html) in the AWS Data Pipeline Developer Guide.
    public struct Tag: Swift.Equatable {
        /// The key name of a tag defined by a user. For more information, see [Controlling User Access to Pipelines](http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-control-access.html) in the AWS Data Pipeline Developer Guide.
        /// This member is required.
        public var key: Swift.String?
        /// The optional value portion of a tag defined by a user. For more information, see [Controlling User Access to Pipelines](http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-control-access.html) in the AWS Data Pipeline Developer Guide.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TaskNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TaskNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified task was not found.
public struct TaskNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TaskNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TaskNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TaskNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataPipelineClientTypes.TaskObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attemptId
        case objects
        case pipelineId
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attemptId = self.attemptId {
            try encodeContainer.encode(attemptId, forKey: .attemptId)
        }
        if let objects = objects {
            var objectsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .objects)
            for (dictKey0, pipelineObjectMap0) in objects {
                try objectsContainer.encode(pipelineObjectMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let attemptIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attemptId)
        attemptId = attemptIdDecoded
        let objectsContainer = try containerValues.decodeIfPresent([Swift.String: DataPipelineClientTypes.PipelineObject?].self, forKey: .objects)
        var objectsDecoded0: [Swift.String:DataPipelineClientTypes.PipelineObject]? = nil
        if let objectsContainer = objectsContainer {
            objectsDecoded0 = [Swift.String:DataPipelineClientTypes.PipelineObject]()
            for (key0, pipelineobject0) in objectsContainer {
                if let pipelineobject0 = pipelineobject0 {
                    objectsDecoded0?[key0] = pipelineobject0
                }
            }
        }
        objects = objectsDecoded0
    }
}

extension DataPipelineClientTypes {
    /// Contains information about a pipeline task that is assigned to a task runner.
    public struct TaskObject: Swift.Equatable {
        /// The ID of the pipeline task attempt object. AWS Data Pipeline uses this value to track how many times a task is attempted.
        public var attemptId: Swift.String?
        /// Connection information for the location where the task runner will publish the output of the task.
        public var objects: [Swift.String:DataPipelineClientTypes.PipelineObject]?
        /// The ID of the pipeline that provided the task.
        public var pipelineId: Swift.String?
        /// An internal identifier for the task. This ID is passed to the [SetTaskStatus] and [ReportTaskProgress] actions.
        public var taskId: Swift.String?

        public init(
            attemptId: Swift.String? = nil,
            objects: [Swift.String:DataPipelineClientTypes.PipelineObject]? = nil,
            pipelineId: Swift.String? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.attemptId = attemptId
            self.objects = objects
            self.pipelineId = pipelineId
            self.taskId = taskId
        }
    }

}

extension DataPipelineClientTypes {
    public enum TaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case `false`
        case finished
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .failed,
                .false,
                .finished,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .false: return "FALSE"
            case .finished: return "FINISHED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskStatus(rawValue: rawValue) ?? TaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension ValidatePipelineDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterObjects
        case parameterValues
        case pipelineId
        case pipelineObjects
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterObjects = parameterObjects {
            var parameterObjectsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterObjects)
            for parameterobject0 in parameterObjects {
                try parameterObjectsContainer.encode(parameterobject0)
            }
        }
        if let parameterValues = parameterValues {
            var parameterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterValues)
            for parametervalue0 in parameterValues {
                try parameterValuesContainer.encode(parametervalue0)
            }
        }
        if let pipelineId = self.pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let pipelineObjects = pipelineObjects {
            var pipelineObjectsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineObjects)
            for pipelineobject0 in pipelineObjects {
                try pipelineObjectsContainer.encode(pipelineobject0)
            }
        }
    }
}

extension ValidatePipelineDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for ValidatePipelineDefinition.
public struct ValidatePipelineDefinitionInput: Swift.Equatable {
    /// The parameter objects used with the pipeline.
    public var parameterObjects: [DataPipelineClientTypes.ParameterObject]?
    /// The parameter values used with the pipeline.
    public var parameterValues: [DataPipelineClientTypes.ParameterValue]?
    /// The ID of the pipeline.
    /// This member is required.
    public var pipelineId: Swift.String?
    /// The objects that define the pipeline changes to validate against the pipeline.
    /// This member is required.
    public var pipelineObjects: [DataPipelineClientTypes.PipelineObject]?

    public init(
        parameterObjects: [DataPipelineClientTypes.ParameterObject]? = nil,
        parameterValues: [DataPipelineClientTypes.ParameterValue]? = nil,
        pipelineId: Swift.String? = nil,
        pipelineObjects: [DataPipelineClientTypes.PipelineObject]? = nil
    )
    {
        self.parameterObjects = parameterObjects
        self.parameterValues = parameterValues
        self.pipelineId = pipelineId
        self.pipelineObjects = pipelineObjects
    }
}

struct ValidatePipelineDefinitionInputBody: Swift.Equatable {
    let pipelineId: Swift.String?
    let pipelineObjects: [DataPipelineClientTypes.PipelineObject]?
    let parameterObjects: [DataPipelineClientTypes.ParameterObject]?
    let parameterValues: [DataPipelineClientTypes.ParameterValue]?
}

extension ValidatePipelineDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterObjects
        case parameterValues
        case pipelineId
        case pipelineObjects
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let pipelineObjectsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.PipelineObject?].self, forKey: .pipelineObjects)
        var pipelineObjectsDecoded0:[DataPipelineClientTypes.PipelineObject]? = nil
        if let pipelineObjectsContainer = pipelineObjectsContainer {
            pipelineObjectsDecoded0 = [DataPipelineClientTypes.PipelineObject]()
            for structure0 in pipelineObjectsContainer {
                if let structure0 = structure0 {
                    pipelineObjectsDecoded0?.append(structure0)
                }
            }
        }
        pipelineObjects = pipelineObjectsDecoded0
        let parameterObjectsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.ParameterObject?].self, forKey: .parameterObjects)
        var parameterObjectsDecoded0:[DataPipelineClientTypes.ParameterObject]? = nil
        if let parameterObjectsContainer = parameterObjectsContainer {
            parameterObjectsDecoded0 = [DataPipelineClientTypes.ParameterObject]()
            for structure0 in parameterObjectsContainer {
                if let structure0 = structure0 {
                    parameterObjectsDecoded0?.append(structure0)
                }
            }
        }
        parameterObjects = parameterObjectsDecoded0
        let parameterValuesContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.ParameterValue?].self, forKey: .parameterValues)
        var parameterValuesDecoded0:[DataPipelineClientTypes.ParameterValue]? = nil
        if let parameterValuesContainer = parameterValuesContainer {
            parameterValuesDecoded0 = [DataPipelineClientTypes.ParameterValue]()
            for structure0 in parameterValuesContainer {
                if let structure0 = structure0 {
                    parameterValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterValues = parameterValuesDecoded0
    }
}

extension ValidatePipelineDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidatePipelineDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.errored = output.errored
            self.validationErrors = output.validationErrors
            self.validationWarnings = output.validationWarnings
        } else {
            self.errored = false
            self.validationErrors = nil
            self.validationWarnings = nil
        }
    }
}

/// Contains the output of ValidatePipelineDefinition.
public struct ValidatePipelineDefinitionOutput: Swift.Equatable {
    /// Indicates whether there were validation errors.
    /// This member is required.
    public var errored: Swift.Bool
    /// Any validation errors that were found.
    public var validationErrors: [DataPipelineClientTypes.ValidationError]?
    /// Any validation warnings that were found.
    public var validationWarnings: [DataPipelineClientTypes.ValidationWarning]?

    public init(
        errored: Swift.Bool = false,
        validationErrors: [DataPipelineClientTypes.ValidationError]? = nil,
        validationWarnings: [DataPipelineClientTypes.ValidationWarning]? = nil
    )
    {
        self.errored = errored
        self.validationErrors = validationErrors
        self.validationWarnings = validationWarnings
    }
}

struct ValidatePipelineDefinitionOutputBody: Swift.Equatable {
    let validationErrors: [DataPipelineClientTypes.ValidationError]?
    let validationWarnings: [DataPipelineClientTypes.ValidationWarning]?
    let errored: Swift.Bool
}

extension ValidatePipelineDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errored
        case validationErrors
        case validationWarnings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationErrorsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.ValidationError?].self, forKey: .validationErrors)
        var validationErrorsDecoded0:[DataPipelineClientTypes.ValidationError]? = nil
        if let validationErrorsContainer = validationErrorsContainer {
            validationErrorsDecoded0 = [DataPipelineClientTypes.ValidationError]()
            for structure0 in validationErrorsContainer {
                if let structure0 = structure0 {
                    validationErrorsDecoded0?.append(structure0)
                }
            }
        }
        validationErrors = validationErrorsDecoded0
        let validationWarningsContainer = try containerValues.decodeIfPresent([DataPipelineClientTypes.ValidationWarning?].self, forKey: .validationWarnings)
        var validationWarningsDecoded0:[DataPipelineClientTypes.ValidationWarning]? = nil
        if let validationWarningsContainer = validationWarningsContainer {
            validationWarningsDecoded0 = [DataPipelineClientTypes.ValidationWarning]()
            for structure0 in validationWarningsContainer {
                if let structure0 = structure0 {
                    validationWarningsDecoded0?.append(structure0)
                }
            }
        }
        validationWarnings = validationWarningsDecoded0
        let erroredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .errored) ?? false
        errored = erroredDecoded
    }
}

enum ValidatePipelineDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceError": return try await InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineDeletedException": return try await PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PipelineNotFoundException": return try await PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataPipelineClientTypes.ValidationError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for validationmessage0 in errors {
                try errorsContainer.encode(validationmessage0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let errorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .errors)
        var errorsDecoded0:[Swift.String]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [Swift.String]()
            for string0 in errorsContainer {
                if let string0 = string0 {
                    errorsDecoded0?.append(string0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension DataPipelineClientTypes {
    /// Defines a validation error. Validation errors prevent pipeline activation. The set of validation errors that can be returned are defined by AWS Data Pipeline.
    public struct ValidationError: Swift.Equatable {
        /// A description of the validation error.
        public var errors: [Swift.String]?
        /// The identifier of the object that contains the validation error.
        public var id: Swift.String?

        public init(
            errors: [Swift.String]? = nil,
            id: Swift.String? = nil
        )
        {
            self.errors = errors
            self.id = id
        }
    }

}

extension DataPipelineClientTypes.ValidationWarning: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case warnings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let warnings = warnings {
            var warningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .warnings)
            for validationmessage0 in warnings {
                try warningsContainer.encode(validationmessage0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension DataPipelineClientTypes {
    /// Defines a validation warning. Validation warnings do not prevent pipeline activation. The set of validation warnings that can be returned are defined by AWS Data Pipeline.
    public struct ValidationWarning: Swift.Equatable {
        /// The identifier of the object that contains the validation warning.
        public var id: Swift.String?
        /// A description of the validation warning.
        public var warnings: [Swift.String]?

        public init(
            id: Swift.String? = nil,
            warnings: [Swift.String]? = nil
        )
        {
            self.id = id
            self.warnings = warnings
        }
    }

}
