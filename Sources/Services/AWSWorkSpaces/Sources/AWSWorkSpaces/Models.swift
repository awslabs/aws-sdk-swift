//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The user is not authorized to access a resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The TargetAccountId is already linked or invited.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Unexpected server error occured.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The resource could not be found.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that could not be found.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

/// You either haven't provided a TargetAccountId or are using the same value for TargetAccountId and SourceAccountId.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AcceptAccountLinkInvitationInput: Swift.Sendable {
    /// A string of up to 64 ASCII characters that Amazon EFS uses to ensure idempotent creation.
    public var clientToken: Swift.String?
    /// The identifier of the account link.
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.linkId = linkId
    }
}

extension WorkSpacesClientTypes {

    public enum AccountLinkStatusEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linked
        case linkingFailed
        case linkNotFound
        case pendingAcceptanceByTargetAccount
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountLinkStatusEnum] {
            return [
                .linked,
                .linkingFailed,
                .linkNotFound,
                .pendingAcceptanceByTargetAccount,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linked: return "LINKED"
            case .linkingFailed: return "LINKING_FAILED"
            case .linkNotFound: return "LINK_NOT_FOUND"
            case .pendingAcceptanceByTargetAccount: return "PENDING_ACCEPTANCE_BY_TARGET_ACCOUNT"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Information about about the account link.
    public struct AccountLink: Swift.Sendable {
        /// The identifier of the account link.
        public var accountLinkId: Swift.String?
        /// The status of the account link.
        public var accountLinkStatus: WorkSpacesClientTypes.AccountLinkStatusEnum?
        /// The identifier of the source account.
        public var sourceAccountId: Swift.String?
        /// The identifier of the target account.
        public var targetAccountId: Swift.String?

        public init(
            accountLinkId: Swift.String? = nil,
            accountLinkStatus: WorkSpacesClientTypes.AccountLinkStatusEnum? = nil,
            sourceAccountId: Swift.String? = nil,
            targetAccountId: Swift.String? = nil
        )
        {
            self.accountLinkId = accountLinkId
            self.accountLinkStatus = accountLinkStatus
            self.sourceAccountId = sourceAccountId
            self.targetAccountId = targetAccountId
        }
    }
}

public struct AcceptAccountLinkInvitationOutput: Swift.Sendable {
    /// Information about the account link.
    public var accountLink: WorkSpacesClientTypes.AccountLink?

    public init(
        accountLink: WorkSpacesClientTypes.AccountLink? = nil
    )
    {
        self.accountLink = accountLink
    }
}

extension WorkSpacesClientTypes {

    public enum AccessPropertyValue: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPropertyValue] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum DedicatedTenancySupportResultEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancySupportResultEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum DedicatedTenancyModificationStateEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancyModificationStateEnum] {
            return [
                .completed,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a modification to the configuration of Bring Your Own License (BYOL) for the specified account.
    public struct AccountModification: Swift.Sendable {
        /// The IP address range, specified as an IPv4 CIDR block, for the management network interface used for the account.
        public var dedicatedTenancyManagementCidrRange: Swift.String?
        /// The status of BYOL (whether BYOL is being enabled or disabled).
        public var dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum?
        /// The error code that is returned if the configuration of BYOL cannot be modified.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the configuration of BYOL cannot be modified.
        public var errorMessage: Swift.String?
        /// The state of the modification to the configuration of BYOL.
        public var modificationState: WorkSpacesClientTypes.DedicatedTenancyModificationStateEnum?
        /// The timestamp when the modification of the BYOL configuration was started.
        public var startTime: Foundation.Date?

        public init(
            dedicatedTenancyManagementCidrRange: Swift.String? = nil,
            dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            modificationState: WorkSpacesClientTypes.DedicatedTenancyModificationStateEnum? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
            self.dedicatedTenancySupport = dedicatedTenancySupport
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.modificationState = modificationState
            self.startTime = startTime
        }
    }
}

extension WorkSpacesClientTypes {

    /// Information about the Active Directory config.
    public struct ActiveDirectoryConfig: Swift.Sendable {
        /// The name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// Indicates the secret ARN on the service account.
        /// This member is required.
        public var serviceAccountSecretArn: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            serviceAccountSecretArn: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.serviceAccountSecretArn = serviceAccountSecretArn
        }
    }
}

extension WorkSpacesClientTypes {

    public enum Application: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case microsoftOffice2016
        case microsoftOffice2019
        case sdkUnknown(Swift.String)

        public static var allCases: [Application] {
            return [
                .microsoftOffice2016,
                .microsoftOffice2019
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .microsoftOffice2016: return "Microsoft_Office_2016"
            case .microsoftOffice2019: return "Microsoft_Office_2019"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum ApplicationAssociatedResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bundle
        case image
        case workspace
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationAssociatedResourceType] {
            return [
                .bundle,
                .image,
                .workspace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bundle: return "BUNDLE"
            case .image: return "IMAGE"
            case .workspace: return "WORKSPACE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The specified application is not supported.
public struct ApplicationNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "ApplicationNotSupportedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension WorkSpacesClientTypes {

    public enum AssociationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case error
        case installing
        case pendingInstall
        case pendingInstallDeployment
        case pendingUninstall
        case pendingUninstallDeployment
        case removed
        case uninstalling
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationState] {
            return [
                .completed,
                .error,
                .installing,
                .pendingInstall,
                .pendingInstallDeployment,
                .pendingUninstall,
                .pendingUninstallDeployment,
                .removed,
                .uninstalling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .error: return "ERROR"
            case .installing: return "INSTALLING"
            case .pendingInstall: return "PENDING_INSTALL"
            case .pendingInstallDeployment: return "PENDING_INSTALL_DEPLOYMENT"
            case .pendingUninstall: return "PENDING_UNINSTALL"
            case .pendingUninstallDeployment: return "PENDING_UNINSTALL_DEPLOYMENT"
            case .removed: return "REMOVED"
            case .uninstalling: return "UNINSTALLING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum AssociationErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case insufficientDiskspace
        case insufficientMemory
        case internalServerError
        case unsupportedOperatingSystem
        case workspaceUnreachable
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationErrorCode] {
            return [
                .insufficientDiskspace,
                .insufficientMemory,
                .internalServerError,
                .unsupportedOperatingSystem,
                .workspaceUnreachable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .insufficientDiskspace: return "ValidationError.InsufficientDiskSpace"
            case .insufficientMemory: return "ValidationError.InsufficientMemory"
            case .internalServerError: return "DeploymentError.InternalServerError"
            case .unsupportedOperatingSystem: return "ValidationError.UnsupportedOperatingSystem"
            case .workspaceUnreachable: return "DeploymentError.WorkspaceUnreachable"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Indicates the reason that the association deployment failed, including the error code and error message.
    public struct AssociationStateReason: Swift.Sendable {
        /// The error code of the association deployment failure.
        public var errorCode: WorkSpacesClientTypes.AssociationErrorCode?
        /// The error message of the association deployment failure.
        public var errorMessage: Swift.String?

        public init(
            errorCode: WorkSpacesClientTypes.AssociationErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the association between an application and an application resource.
    public struct ApplicationResourceAssociation: Swift.Sendable {
        /// The identifier of the application.
        public var applicationId: Swift.String?
        /// The identifier of the associated resource.
        public var associatedResourceId: Swift.String?
        /// The resource type of the associated resource.
        public var associatedResourceType: WorkSpacesClientTypes.ApplicationAssociatedResourceType?
        /// The time the association was created.
        public var created: Foundation.Date?
        /// The time the association status was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The status of the application resource association.
        public var state: WorkSpacesClientTypes.AssociationState?
        /// The reason the association deployment failed.
        public var stateReason: WorkSpacesClientTypes.AssociationStateReason?

        public init(
            applicationId: Swift.String? = nil,
            associatedResourceId: Swift.String? = nil,
            associatedResourceType: WorkSpacesClientTypes.ApplicationAssociatedResourceType? = nil,
            created: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            state: WorkSpacesClientTypes.AssociationState? = nil,
            stateReason: WorkSpacesClientTypes.AssociationStateReason? = nil
        )
        {
            self.applicationId = applicationId
            self.associatedResourceId = associatedResourceId
            self.associatedResourceType = associatedResourceType
            self.created = created
            self.lastUpdatedTime = lastUpdatedTime
            self.state = state
            self.stateReason = stateReason
        }
    }
}

extension WorkSpacesClientTypes {

    public enum ApplicationSettingsStatusEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationSettingsStatusEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// The persistent application settings for WorkSpaces Pools users.
    public struct ApplicationSettingsRequest: Swift.Sendable {
        /// The path prefix for the S3 bucket where users’ persistent application settings are stored. You can allow the same persistent application settings to be used across multiple pools by specifying the same settings group for each pool.
        public var settingsGroup: Swift.String?
        /// Enables or disables persistent application settings for users during their pool sessions.
        /// This member is required.
        public var status: WorkSpacesClientTypes.ApplicationSettingsStatusEnum?

        public init(
            settingsGroup: Swift.String? = nil,
            status: WorkSpacesClientTypes.ApplicationSettingsStatusEnum? = nil
        )
        {
            self.settingsGroup = settingsGroup
            self.status = status
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the persistent application settings for WorkSpaces Pools users.
    public struct ApplicationSettingsResponse: Swift.Sendable {
        /// The S3 bucket where users’ persistent application settings are stored. When persistent application settings are enabled for the first time for an account in an Amazon Web Services Region, an S3 bucket is created. The bucket is unique to the Amazon Web Services account and the Region.
        public var s3BucketName: Swift.String?
        /// The path prefix for the S3 bucket where users’ persistent application settings are stored.
        public var settingsGroup: Swift.String?
        /// Specifies whether persistent application settings are enabled for users during their pool sessions.
        /// This member is required.
        public var status: WorkSpacesClientTypes.ApplicationSettingsStatusEnum?

        public init(
            s3BucketName: Swift.String? = nil,
            settingsGroup: Swift.String? = nil,
            status: WorkSpacesClientTypes.ApplicationSettingsStatusEnum? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.settingsGroup = settingsGroup
            self.status = status
        }
    }
}

/// One or more parameter values are not valid.
public struct InvalidParameterValuesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValuesException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The state of the resource is not valid for this operation.
public struct InvalidResourceStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This operation is not supported.
public struct OperationNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception error message.
        public internal(set) var message: Swift.String? = nil
        /// The exception error reason.
        public internal(set) var reason: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotSupportedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// The resource is associated with a directory.
public struct ResourceAssociatedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAssociatedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateConnectionAliasInput: Swift.Sendable {
    /// The identifier of the connection alias.
    /// This member is required.
    public var aliasId: Swift.String?
    /// The identifier of the directory to associate the connection alias with.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        aliasId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
        self.resourceId = resourceId
    }
}

public struct AssociateConnectionAliasOutput: Swift.Sendable {
    /// The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when you're configuring your DNS routing policies.
    public var connectionIdentifier: Swift.String?

    public init(
        connectionIdentifier: Swift.String? = nil
    )
    {
        self.connectionIdentifier = connectionIdentifier
    }
}

/// Your resource limits have been exceeded.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateIpGroupsInput: Swift.Sendable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The identifiers of one or more IP access control groups.
    /// This member is required.
    public var groupIds: [Swift.String]?

    public init(
        directoryId: Swift.String? = nil,
        groupIds: [Swift.String]? = nil
    )
    {
        self.directoryId = directoryId
        self.groupIds = groupIds
    }
}

public struct AssociateIpGroupsOutput: Swift.Sendable {

    public init() { }
}

/// The compute type of the WorkSpace is not compatible with the application.
public struct ComputeNotCompatibleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "ComputeNotCompatibleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The specified application is not compatible with the resource.
public struct IncompatibleApplicationsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "IncompatibleApplicationsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The operating system of the WorkSpace is not compatible with the application.
public struct OperatingSystemNotCompatibleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "OperatingSystemNotCompatibleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource is currently in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that is in use.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

public struct AssociateWorkspaceApplicationInput: Swift.Sendable {
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.workspaceId = workspaceId
    }
}

extension WorkSpacesClientTypes {

    public enum WorkSpaceAssociatedResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkSpaceAssociatedResourceType] {
            return [
                .application
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the association between an application and a WorkSpace resource.
    public struct WorkspaceResourceAssociation: Swift.Sendable {
        /// The identifier of the associated resource.
        public var associatedResourceId: Swift.String?
        /// The resource types of the associated resource.
        public var associatedResourceType: WorkSpacesClientTypes.WorkSpaceAssociatedResourceType?
        /// The time the association is created.
        public var created: Foundation.Date?
        /// The time the association status was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The status of the WorkSpace resource association.
        public var state: WorkSpacesClientTypes.AssociationState?
        /// The reason the association deployment failed.
        public var stateReason: WorkSpacesClientTypes.AssociationStateReason?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            associatedResourceId: Swift.String? = nil,
            associatedResourceType: WorkSpacesClientTypes.WorkSpaceAssociatedResourceType? = nil,
            created: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            state: WorkSpacesClientTypes.AssociationState? = nil,
            stateReason: WorkSpacesClientTypes.AssociationStateReason? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.associatedResourceId = associatedResourceId
            self.associatedResourceType = associatedResourceType
            self.created = created
            self.lastUpdatedTime = lastUpdatedTime
            self.state = state
            self.stateReason = stateReason
            self.workspaceId = workspaceId
        }
    }
}

public struct AssociateWorkspaceApplicationOutput: Swift.Sendable {
    /// Information about the association between the specified WorkSpace and the specified application.
    public var association: WorkSpacesClientTypes.WorkspaceResourceAssociation?

    public init(
        association: WorkSpacesClientTypes.WorkspaceResourceAssociation? = nil
    )
    {
        self.association = association
    }
}

extension WorkSpacesClientTypes {

    public enum AssociationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associatedWithOwnerAccount
        case associatedWithSharedAccount
        case notAssociated
        case pendingAssociation
        case pendingDisassociation
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationStatus] {
            return [
                .associatedWithOwnerAccount,
                .associatedWithSharedAccount,
                .notAssociated,
                .pendingAssociation,
                .pendingDisassociation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associatedWithOwnerAccount: return "ASSOCIATED_WITH_OWNER_ACCOUNT"
            case .associatedWithSharedAccount: return "ASSOCIATED_WITH_SHARED_ACCOUNT"
            case .notAssociated: return "NOT_ASSOCIATED"
            case .pendingAssociation: return "PENDING_ASSOCIATION"
            case .pendingDisassociation: return "PENDING_DISASSOCIATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum AuthenticationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .saml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a rule for an IP access control group.
    public struct IpRuleItem: Swift.Sendable {
        /// The IP address range, in CIDR notation.
        public var ipRule: Swift.String?
        /// The description.
        public var ruleDesc: Swift.String?

        public init(
            ipRule: Swift.String? = nil,
            ruleDesc: Swift.String? = nil
        )
        {
            self.ipRule = ipRule
            self.ruleDesc = ruleDesc
        }
    }
}

public struct AuthorizeIpRulesInput: Swift.Sendable {
    /// The identifier of the group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The rules to add to the group.
    /// This member is required.
    public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

    public init(
        groupId: Swift.String? = nil,
        userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

public struct AuthorizeIpRulesOutput: Swift.Sendable {

    public init() { }
}

extension WorkSpacesClientTypes {

    public enum BundleAssociatedResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case sdkUnknown(Swift.String)

        public static var allCases: [BundleAssociatedResourceType] {
            return [
                .application
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum BundleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case regular
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [BundleType] {
            return [
                .regular,
                .standby
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .regular: return "REGULAR"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum Compute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case graphics
        case graphicspro
        case graphicsproG4dn
        case graphicsG4dn
        case performance
        case power
        case powerpro
        case standard
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [Compute] {
            return [
                .graphics,
                .graphicspro,
                .graphicsproG4dn,
                .graphicsG4dn,
                .performance,
                .power,
                .powerpro,
                .standard,
                .value
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .graphics: return "GRAPHICS"
            case .graphicspro: return "GRAPHICSPRO"
            case .graphicsproG4dn: return "GRAPHICSPRO_G4DN"
            case .graphicsG4dn: return "GRAPHICS_G4DN"
            case .performance: return "PERFORMANCE"
            case .power: return "POWER"
            case .powerpro: return "POWERPRO"
            case .standard: return "STANDARD"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the compute type of the bundle.
    public struct ComputeType: Swift.Sendable {
        /// The compute type.
        public var name: WorkSpacesClientTypes.Compute?

        public init(
            name: WorkSpacesClientTypes.Compute? = nil
        )
        {
            self.name = name
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the root volume for a WorkSpace bundle.
    public struct RootStorage: Swift.Sendable {
        /// The size of the root volume.
        /// This member is required.
        public var capacity: Swift.String?

        public init(
            capacity: Swift.String? = nil
        )
        {
            self.capacity = capacity
        }
    }
}

extension WorkSpacesClientTypes {

    public enum WorkspaceBundleState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case error
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceBundleState] {
            return [
                .available,
                .error,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the user volume for a WorkSpace bundle.
    public struct UserStorage: Swift.Sendable {
        /// The size of the user volume.
        /// This member is required.
        public var capacity: Swift.String?

        public init(
            capacity: Swift.String? = nil
        )
        {
            self.capacity = capacity
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a WorkSpace bundle.
    public struct WorkspaceBundle: Swift.Sendable {
        /// The identifier of the bundle.
        public var bundleId: Swift.String?
        /// The type of WorkSpace bundle.
        public var bundleType: WorkSpacesClientTypes.BundleType?
        /// The compute type of the bundle. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles).
        public var computeType: WorkSpacesClientTypes.ComputeType?
        /// The time when the bundle was created.
        public var creationTime: Foundation.Date?
        /// The description of the bundle.
        public var description: Swift.String?
        /// The identifier of the image that was used to create the bundle.
        public var imageId: Swift.String?
        /// The last time that the bundle was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The name of the bundle.
        public var name: Swift.String?
        /// The owner of the bundle. This is the account identifier of the owner, or AMAZON if the bundle is provided by Amazon Web Services.
        public var owner: Swift.String?
        /// The size of the root volume.
        public var rootStorage: WorkSpacesClientTypes.RootStorage?
        /// The state of the WorkSpace bundle.
        public var state: WorkSpacesClientTypes.WorkspaceBundleState?
        /// The size of the user volume.
        public var userStorage: WorkSpacesClientTypes.UserStorage?

        public init(
            bundleId: Swift.String? = nil,
            bundleType: WorkSpacesClientTypes.BundleType? = nil,
            computeType: WorkSpacesClientTypes.ComputeType? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            imageId: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            rootStorage: WorkSpacesClientTypes.RootStorage? = nil,
            state: WorkSpacesClientTypes.WorkspaceBundleState? = nil,
            userStorage: WorkSpacesClientTypes.UserStorage? = nil
        )
        {
            self.bundleId = bundleId
            self.bundleType = bundleType
            self.computeType = computeType
            self.creationTime = creationTime
            self.description = description
            self.imageId = imageId
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.owner = owner
            self.rootStorage = rootStorage
            self.state = state
            self.userStorage = userStorage
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the association between an application and a bundle resource.
    public struct BundleResourceAssociation: Swift.Sendable {
        /// The identifier of the associated resource.
        public var associatedResourceId: Swift.String?
        /// The resource type of the associated resources.
        public var associatedResourceType: WorkSpacesClientTypes.BundleAssociatedResourceType?
        /// The identifier of the bundle.
        public var bundleId: Swift.String?
        /// The time the association is created.
        public var created: Foundation.Date?
        /// The time the association status was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The status of the bundle resource association.
        public var state: WorkSpacesClientTypes.AssociationState?
        /// The reason the association deployment failed.
        public var stateReason: WorkSpacesClientTypes.AssociationStateReason?

        public init(
            associatedResourceId: Swift.String? = nil,
            associatedResourceType: WorkSpacesClientTypes.BundleAssociatedResourceType? = nil,
            bundleId: Swift.String? = nil,
            created: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            state: WorkSpacesClientTypes.AssociationState? = nil,
            stateReason: WorkSpacesClientTypes.AssociationStateReason? = nil
        )
        {
            self.associatedResourceId = associatedResourceId
            self.associatedResourceType = associatedResourceType
            self.bundleId = bundleId
            self.created = created
            self.lastUpdatedTime = lastUpdatedTime
            self.state = state
            self.stateReason = stateReason
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the user capacity for a pool of WorkSpaces.
    public struct Capacity: Swift.Sendable {
        /// The desired number of user sessions for the WorkSpaces in the pool.
        /// This member is required.
        public var desiredUserSessions: Swift.Int?

        public init(
            desiredUserSessions: Swift.Int? = nil
        )
        {
            self.desiredUserSessions = desiredUserSessions
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the capacity status for a pool of WorkSpaces.
    public struct CapacityStatus: Swift.Sendable {
        /// The number of user sessions currently being used for your pool.
        /// This member is required.
        public var activeUserSessions: Swift.Int?
        /// The total number of user sessions that are available for streaming or are currently streaming in your pool. ActualUserSessions = AvailableUserSessions + ActiveUserSessions
        /// This member is required.
        public var actualUserSessions: Swift.Int?
        /// The number of user sessions currently available for streaming from your pool. AvailableUserSessions = ActualUserSessions - ActiveUserSessions
        /// This member is required.
        public var availableUserSessions: Swift.Int?
        /// The total number of sessions slots that are either running or pending. This represents the total number of concurrent streaming sessions your pool can support in a steady state.
        /// This member is required.
        public var desiredUserSessions: Swift.Int?

        public init(
            activeUserSessions: Swift.Int? = nil,
            actualUserSessions: Swift.Int? = nil,
            availableUserSessions: Swift.Int? = nil,
            desiredUserSessions: Swift.Int? = nil
        )
        {
            self.activeUserSessions = activeUserSessions
            self.actualUserSessions = actualUserSessions
            self.availableUserSessions = availableUserSessions
            self.desiredUserSessions = desiredUserSessions
        }
    }
}

extension WorkSpacesClientTypes {

    public enum CertificateBasedAuthStatusEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateBasedAuthStatusEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the properties of the certificate-based authentication you want to use with your WorkSpaces.
    public struct CertificateBasedAuthProperties: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Certificate Manager Private CA resource.
        public var certificateAuthorityArn: Swift.String?
        /// The status of the certificate-based authentication properties.
        public var status: WorkSpacesClientTypes.CertificateBasedAuthStatusEnum?

        public init(
            certificateAuthorityArn: Swift.String? = nil,
            status: WorkSpacesClientTypes.CertificateBasedAuthStatusEnum? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.status = status
        }
    }
}

extension WorkSpacesClientTypes {

    public enum ClientDeviceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deviceTypeAndroid
        case deviceTypeIos
        case deviceTypeLinux
        case deviceTypeOsx
        case deviceTypeWeb
        case deviceTypeWindows
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientDeviceType] {
            return [
                .deviceTypeAndroid,
                .deviceTypeIos,
                .deviceTypeLinux,
                .deviceTypeOsx,
                .deviceTypeWeb,
                .deviceTypeWindows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deviceTypeAndroid: return "DeviceTypeAndroid"
            case .deviceTypeIos: return "DeviceTypeIos"
            case .deviceTypeLinux: return "DeviceTypeLinux"
            case .deviceTypeOsx: return "DeviceTypeOsx"
            case .deviceTypeWeb: return "DeviceTypeWeb"
            case .deviceTypeWindows: return "DeviceTypeWindows"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum LogUploadEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LogUploadEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum ReconnectEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReconnectEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes an Amazon WorkSpaces client.
    public struct ClientProperties: Swift.Sendable {
        /// Specifies whether users can upload diagnostic log files of Amazon WorkSpaces client directly to WorkSpaces to troubleshoot issues when using the WorkSpaces client. When enabled, the log files will be sent to WorkSpaces automatically and will be applied to all users in the specified directory.
        public var logUploadEnabled: WorkSpacesClientTypes.LogUploadEnum?
        /// Specifies whether users can cache their credentials on the Amazon WorkSpaces client. When enabled, users can choose to reconnect to their WorkSpaces without re-entering their credentials.
        public var reconnectEnabled: WorkSpacesClientTypes.ReconnectEnum?

        public init(
            logUploadEnabled: WorkSpacesClientTypes.LogUploadEnum? = nil,
            reconnectEnabled: WorkSpacesClientTypes.ReconnectEnum? = nil
        )
        {
            self.logUploadEnabled = logUploadEnabled
            self.reconnectEnabled = reconnectEnabled
        }
    }
}

extension WorkSpacesClientTypes {

    /// Information about the Amazon WorkSpaces client.
    public struct ClientPropertiesResult: Swift.Sendable {
        /// Information about the Amazon WorkSpaces client.
        public var clientProperties: WorkSpacesClientTypes.ClientProperties?
        /// The resource identifier, in the form of a directory ID.
        public var resourceId: Swift.String?

        public init(
            clientProperties: WorkSpacesClientTypes.ClientProperties? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.clientProperties = clientProperties
            self.resourceId = resourceId
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes an Amazon Connect client add-in.
    public struct ConnectClientAddIn: Swift.Sendable {
        /// The client add-in identifier.
        public var addInId: Swift.String?
        /// The name of the client add in.
        public var name: Swift.String?
        /// The directory identifier for which the client add-in is configured.
        public var resourceId: Swift.String?
        /// The endpoint URL of the client add-in.
        public var url: Swift.String?

        public init(
            addInId: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.addInId = addInId
            self.name = name
            self.resourceId = resourceId
            self.url = url
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a connection alias association that is used for cross-Region redirection. For more information, see [ Cross-Region Redirection for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html).
    public struct ConnectionAliasAssociation: Swift.Sendable {
        /// The identifier of the Amazon Web Services account that associated the connection alias with a directory.
        public var associatedAccountId: Swift.String?
        /// The association status of the connection alias.
        public var associationStatus: WorkSpacesClientTypes.AssociationStatus?
        /// The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when you're configuring your DNS routing policies.
        public var connectionIdentifier: Swift.String?
        /// The identifier of the directory associated with a connection alias.
        public var resourceId: Swift.String?

        public init(
            associatedAccountId: Swift.String? = nil,
            associationStatus: WorkSpacesClientTypes.AssociationStatus? = nil,
            connectionIdentifier: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.associatedAccountId = associatedAccountId
            self.associationStatus = associationStatus
            self.connectionIdentifier = connectionIdentifier
            self.resourceId = resourceId
        }
    }
}

extension WorkSpacesClientTypes {

    public enum ConnectionAliasState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionAliasState] {
            return [
                .created,
                .creating,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a connection alias. Connection aliases are used for cross-Region redirection. For more information, see [ Cross-Region Redirection for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html).
    public struct ConnectionAlias: Swift.Sendable {
        /// The identifier of the connection alias.
        public var aliasId: Swift.String?
        /// The association status of the connection alias.
        public var associations: [WorkSpacesClientTypes.ConnectionAliasAssociation]?
        /// The connection string specified for the connection alias. The connection string must be in the form of a fully qualified domain name (FQDN), such as www.example.com.
        public var connectionString: Swift.String?
        /// The identifier of the Amazon Web Services account that owns the connection alias.
        public var ownerAccountId: Swift.String?
        /// The current state of the connection alias.
        public var state: WorkSpacesClientTypes.ConnectionAliasState?

        public init(
            aliasId: Swift.String? = nil,
            associations: [WorkSpacesClientTypes.ConnectionAliasAssociation]? = nil,
            connectionString: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            state: WorkSpacesClientTypes.ConnectionAliasState? = nil
        )
        {
            self.aliasId = aliasId
            self.associations = associations
            self.connectionString = connectionString
            self.ownerAccountId = ownerAccountId
            self.state = state
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the permissions for a connection alias. Connection aliases are used for cross-Region redirection. For more information, see [ Cross-Region Redirection for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html).
    public struct ConnectionAliasPermission: Swift.Sendable {
        /// Indicates whether the specified Amazon Web Services account is allowed to associate the connection alias with a directory.
        /// This member is required.
        public var allowAssociation: Swift.Bool?
        /// The identifier of the Amazon Web Services account that the connection alias is shared with.
        /// This member is required.
        public var sharedAccountId: Swift.String?

        public init(
            allowAssociation: Swift.Bool? = nil,
            sharedAccountId: Swift.String? = nil
        )
        {
            self.allowAssociation = allowAssociation
            self.sharedAccountId = sharedAccountId
        }
    }
}

extension WorkSpacesClientTypes {

    public enum ConnectionState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case disconnected
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionState] {
            return [
                .connected,
                .disconnected,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The specified resource is not available.
public struct ResourceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception error message.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that is not available.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

extension WorkSpacesClientTypes {

    /// Describes a tag.
    public struct Tag: Swift.Sendable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CopyWorkspaceImageInput: Swift.Sendable {
    /// A description of the image.
    public var description: Swift.String?
    /// The name of the image.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the source image.
    /// This member is required.
    public var sourceImageId: Swift.String?
    /// The identifier of the source Region.
    /// This member is required.
    public var sourceRegion: Swift.String?
    /// The tags for the image.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceImageId: Swift.String? = nil,
        sourceRegion: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.sourceImageId = sourceImageId
        self.sourceRegion = sourceRegion
        self.tags = tags
    }
}

public struct CopyWorkspaceImageOutput: Swift.Sendable {
    /// The identifier of the image.
    public var imageId: Swift.String?

    public init(
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

public struct CreateAccountLinkInvitationInput: Swift.Sendable {
    /// A string of up to 64 ASCII characters that Amazon EFS uses to ensure idempotent creation.
    public var clientToken: Swift.String?
    /// The identifier of the target account.
    /// This member is required.
    public var targetAccountId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        targetAccountId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.targetAccountId = targetAccountId
    }
}

public struct CreateAccountLinkInvitationOutput: Swift.Sendable {
    /// Information about the account link.
    public var accountLink: WorkSpacesClientTypes.AccountLink?

    public init(
        accountLink: WorkSpacesClientTypes.AccountLink? = nil
    )
    {
        self.accountLink = accountLink
    }
}

/// The resource could not be created.
public struct ResourceCreationFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceCreationFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateConnectClientAddInInput: Swift.Sendable {
    /// The name of the client add-in.
    /// This member is required.
    public var name: Swift.String?
    /// The directory identifier for which to configure the client add-in.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The endpoint URL of the Amazon Connect client add-in.
    /// This member is required.
    public var url: Swift.String?

    public init(
        name: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        url: Swift.String? = nil
    )
    {
        self.name = name
        self.resourceId = resourceId
        self.url = url
    }
}

public struct CreateConnectClientAddInOutput: Swift.Sendable {
    /// The client add-in identifier.
    public var addInId: Swift.String?

    public init(
        addInId: Swift.String? = nil
    )
    {
        self.addInId = addInId
    }
}

public struct CreateConnectionAliasInput: Swift.Sendable {
    /// A connection string in the form of a fully qualified domain name (FQDN), such as www.example.com. After you create a connection string, it is always associated to your Amazon Web Services account. You cannot recreate the same connection string with a different account, even if you delete all instances of it from the original account. The connection string is globally reserved for your account.
    /// This member is required.
    public var connectionString: Swift.String?
    /// The tags to associate with the connection alias.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init(
        connectionString: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.connectionString = connectionString
        self.tags = tags
    }
}

public struct CreateConnectionAliasOutput: Swift.Sendable {
    /// The identifier of the connection alias.
    public var aliasId: Swift.String?

    public init(
        aliasId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

public struct CreateIpGroupInput: Swift.Sendable {
    /// The description of the group.
    public var groupDesc: Swift.String?
    /// The name of the group.
    /// This member is required.
    public var groupName: Swift.String?
    /// The tags. Each WorkSpaces resource can have a maximum of 50 tags.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// The rules to add to the group.
    public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

    public init(
        groupDesc: Swift.String? = nil,
        groupName: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
    )
    {
        self.groupDesc = groupDesc
        self.groupName = groupName
        self.tags = tags
        self.userRules = userRules
    }
}

public struct CreateIpGroupOutput: Swift.Sendable {
    /// The identifier of the group.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

extension WorkSpacesClientTypes {

    public enum DataReplication: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case noReplication
        case primaryAsSource
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplication] {
            return [
                .noReplication,
                .primaryAsSource
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .noReplication: return "NO_REPLICATION"
            case .primaryAsSource: return "PRIMARY_AS_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a standby WorkSpace.
    public struct StandbyWorkspace: Swift.Sendable {
        /// Indicates whether data replication is enabled, and if enabled, the type of data replication.
        public var dataReplication: WorkSpacesClientTypes.DataReplication?
        /// The identifier of the directory for the standby WorkSpace.
        /// This member is required.
        public var directoryId: Swift.String?
        /// The identifier of the standby WorkSpace.
        /// This member is required.
        public var primaryWorkspaceId: Swift.String?
        /// The tags associated with the standby WorkSpace.
        public var tags: [WorkSpacesClientTypes.Tag]?
        /// The volume encryption key of the standby WorkSpace.
        public var volumeEncryptionKey: Swift.String?

        public init(
            dataReplication: WorkSpacesClientTypes.DataReplication? = nil,
            directoryId: Swift.String? = nil,
            primaryWorkspaceId: Swift.String? = nil,
            tags: [WorkSpacesClientTypes.Tag]? = nil,
            volumeEncryptionKey: Swift.String? = nil
        )
        {
            self.dataReplication = dataReplication
            self.directoryId = directoryId
            self.primaryWorkspaceId = primaryWorkspaceId
            self.tags = tags
            self.volumeEncryptionKey = volumeEncryptionKey
        }
    }
}

public struct CreateStandbyWorkspacesInput: Swift.Sendable {
    /// The Region of the primary WorkSpace.
    /// This member is required.
    public var primaryRegion: Swift.String?
    /// Information about the standby WorkSpace to be created.
    /// This member is required.
    public var standbyWorkspaces: [WorkSpacesClientTypes.StandbyWorkspace]?

    public init(
        primaryRegion: Swift.String? = nil,
        standbyWorkspaces: [WorkSpacesClientTypes.StandbyWorkspace]? = nil
    )
    {
        self.primaryRegion = primaryRegion
        self.standbyWorkspaces = standbyWorkspaces
    }
}

extension WorkSpacesClientTypes {

    /// Describes the standby WorkSpace that could not be created.
    public struct FailedCreateStandbyWorkspacesRequest: Swift.Sendable {
        /// The error code that is returned if the standby WorkSpace could not be created.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the standby WorkSpace could not be created.
        public var errorMessage: Swift.String?
        /// Information about the standby WorkSpace that could not be created.
        public var standbyWorkspaceRequest: WorkSpacesClientTypes.StandbyWorkspace?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            standbyWorkspaceRequest: WorkSpacesClientTypes.StandbyWorkspace? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.standbyWorkspaceRequest = standbyWorkspaceRequest
        }
    }
}

extension WorkSpacesClientTypes {

    public enum WorkspaceState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case adminMaintenance
        case available
        case error
        case impaired
        case maintenance
        case pending
        case rebooting
        case rebuilding
        case restoring
        case starting
        case stopped
        case stopping
        case suspended
        case terminated
        case terminating
        case unhealthy
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceState] {
            return [
                .adminMaintenance,
                .available,
                .error,
                .impaired,
                .maintenance,
                .pending,
                .rebooting,
                .rebuilding,
                .restoring,
                .starting,
                .stopped,
                .stopping,
                .suspended,
                .terminated,
                .terminating,
                .unhealthy,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .adminMaintenance: return "ADMIN_MAINTENANCE"
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .impaired: return "IMPAIRED"
            case .maintenance: return "MAINTENANCE"
            case .pending: return "PENDING"
            case .rebooting: return "REBOOTING"
            case .rebuilding: return "REBUILDING"
            case .restoring: return "RESTORING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .suspended: return "SUSPENDED"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case .unhealthy: return "UNHEALTHY"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Information about the standby WorkSpace.
    public struct PendingCreateStandbyWorkspacesRequest: Swift.Sendable {
        /// The identifier of the directory for the standby WorkSpace.
        public var directoryId: Swift.String?
        /// The operational state of the standby WorkSpace.
        public var state: WorkSpacesClientTypes.WorkspaceState?
        /// Describes the standby WorkSpace that was created. Because this operation is asynchronous, the identifier returned is not immediately available for use with other operations. For example, if you call [ DescribeWorkspaces](https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html) before the WorkSpace is created, the information returned can be incomplete.
        public var userName: Swift.String?
        /// The identifier of the standby WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            directoryId: Swift.String? = nil,
            state: WorkSpacesClientTypes.WorkspaceState? = nil,
            userName: Swift.String? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
            self.state = state
            self.userName = userName
            self.workspaceId = workspaceId
        }
    }
}

public struct CreateStandbyWorkspacesOutput: Swift.Sendable {
    /// Information about the standby WorkSpace that could not be created.
    public var failedStandbyRequests: [WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest]?
    /// Information about the standby WorkSpace that was created.
    public var pendingStandbyRequests: [WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest]?

    public init(
        failedStandbyRequests: [WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest]? = nil,
        pendingStandbyRequests: [WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest]? = nil
    )
    {
        self.failedStandbyRequests = failedStandbyRequests
        self.pendingStandbyRequests = pendingStandbyRequests
    }
}

public struct CreateTagsInput: Swift.Sendable {
    /// The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces, registered directories, images, custom bundles, IP access control groups, and connection aliases.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The tags. Each WorkSpaces resource can have a maximum of 50 tags.
    /// This member is required.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init(
        resourceId: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tags = tags
    }
}

public struct CreateTagsOutput: Swift.Sendable {

    public init() { }
}

public struct CreateUpdatedWorkspaceImageInput: Swift.Sendable {
    /// A description of whether updates for the WorkSpace image are available.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the new updated WorkSpace image.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the source WorkSpace image.
    /// This member is required.
    public var sourceImageId: Swift.String?
    /// The tags that you want to add to the new updated WorkSpace image. To add tags at the same time when you're creating the updated image, you must create an IAM policy that grants your IAM user permissions to use workspaces:CreateTags.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceImageId: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.sourceImageId = sourceImageId
        self.tags = tags
    }
}

public struct CreateUpdatedWorkspaceImageOutput: Swift.Sendable {
    /// The identifier of the new updated WorkSpace image.
    public var imageId: Swift.String?

    public init(
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

public struct CreateWorkspaceBundleInput: Swift.Sendable {
    /// The description of the bundle.
    /// This member is required.
    public var bundleDescription: Swift.String?
    /// The name of the bundle.
    /// This member is required.
    public var bundleName: Swift.String?
    /// Describes the compute type of the bundle.
    /// This member is required.
    public var computeType: WorkSpacesClientTypes.ComputeType?
    /// The identifier of the image that is used to create the bundle.
    /// This member is required.
    public var imageId: Swift.String?
    /// Describes the root volume for a WorkSpace bundle.
    public var rootStorage: WorkSpacesClientTypes.RootStorage?
    /// The tags associated with the bundle. To add tags at the same time when you're creating the bundle, you must create an IAM policy that grants your IAM user permissions to use workspaces:CreateTags.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// Describes the user volume for a WorkSpace bundle.
    /// This member is required.
    public var userStorage: WorkSpacesClientTypes.UserStorage?

    public init(
        bundleDescription: Swift.String? = nil,
        bundleName: Swift.String? = nil,
        computeType: WorkSpacesClientTypes.ComputeType? = nil,
        imageId: Swift.String? = nil,
        rootStorage: WorkSpacesClientTypes.RootStorage? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        userStorage: WorkSpacesClientTypes.UserStorage? = nil
    )
    {
        self.bundleDescription = bundleDescription
        self.bundleName = bundleName
        self.computeType = computeType
        self.imageId = imageId
        self.rootStorage = rootStorage
        self.tags = tags
        self.userStorage = userStorage
    }
}

public struct CreateWorkspaceBundleOutput: Swift.Sendable {
    /// Describes a WorkSpace bundle.
    public var workspaceBundle: WorkSpacesClientTypes.WorkspaceBundle?

    public init(
        workspaceBundle: WorkSpacesClientTypes.WorkspaceBundle? = nil
    )
    {
        self.workspaceBundle = workspaceBundle
    }
}

public struct CreateWorkspaceImageInput: Swift.Sendable {
    /// The description of the new WorkSpace image.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the new WorkSpace image.
    /// This member is required.
    public var name: Swift.String?
    /// The tags that you want to add to the new WorkSpace image. To add tags when you're creating the image, you must create an IAM policy that grants your IAM user permission to use workspaces:CreateTags.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// The identifier of the source WorkSpace
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

extension WorkSpacesClientTypes {

    public enum OperatingSystemType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatingSystemType] {
            return [
                .linux,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// The operating system that the image is running.
    public struct OperatingSystem: Swift.Sendable {
        /// The operating system.
        public var type: WorkSpacesClientTypes.OperatingSystemType?

        public init(
            type: WorkSpacesClientTypes.OperatingSystemType? = nil
        )
        {
            self.type = type
        }
    }
}

extension WorkSpacesClientTypes {

    public enum WorkspaceImageRequiredTenancy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dedicated
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageRequiredTenancy] {
            return [
                .dedicated,
                .default
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "DEDICATED"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum WorkspaceImageState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case error
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageState] {
            return [
                .available,
                .error,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateWorkspaceImageOutput: Swift.Sendable {
    /// The date when the image was created.
    public var created: Foundation.Date?
    /// The description of the image.
    public var description: Swift.String?
    /// The identifier of the new WorkSpace image.
    public var imageId: Swift.String?
    /// The name of the image.
    public var name: Swift.String?
    /// The operating system that the image is running.
    public var operatingSystem: WorkSpacesClientTypes.OperatingSystem?
    /// The identifier of the Amazon Web Services account that owns the image.
    public var ownerAccountId: Swift.String?
    /// Specifies whether the image is running on dedicated hardware. When Bring Your Own License (BYOL) is enabled, this value is set to DEDICATED. For more information, see [ Bring Your Own Windows Desktop Images.](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.htm).
    public var requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy?
    /// The availability status of the image.
    public var state: WorkSpacesClientTypes.WorkspaceImageState?

    public init(
        created: Foundation.Date? = nil,
        description: Swift.String? = nil,
        imageId: Swift.String? = nil,
        name: Swift.String? = nil,
        operatingSystem: WorkSpacesClientTypes.OperatingSystem? = nil,
        ownerAccountId: Swift.String? = nil,
        requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy? = nil,
        state: WorkSpacesClientTypes.WorkspaceImageState? = nil
    )
    {
        self.created = created
        self.description = description
        self.imageId = imageId
        self.name = name
        self.operatingSystem = operatingSystem
        self.ownerAccountId = ownerAccountId
        self.requiredTenancy = requiredTenancy
        self.state = state
    }
}

extension WorkSpacesClientTypes {

    public enum OperatingSystemName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonLinux2
        case rhel8
        case ubuntu1804
        case ubuntu2004
        case ubuntu2204
        case unknown
        case windows10
        case windows11
        case windows7
        case windowsServer2016
        case windowsServer2019
        case windowsServer2022
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatingSystemName] {
            return [
                .amazonLinux2,
                .rhel8,
                .ubuntu1804,
                .ubuntu2004,
                .ubuntu2204,
                .unknown,
                .windows10,
                .windows11,
                .windows7,
                .windowsServer2016,
                .windowsServer2019,
                .windowsServer2022
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonLinux2: return "AMAZON_LINUX_2"
            case .rhel8: return "RHEL_8"
            case .ubuntu1804: return "UBUNTU_18_04"
            case .ubuntu2004: return "UBUNTU_20_04"
            case .ubuntu2204: return "UBUNTU_22_04"
            case .unknown: return "UNKNOWN"
            case .windows10: return "WINDOWS_10"
            case .windows11: return "WINDOWS_11"
            case .windows7: return "WINDOWS_7"
            case .windowsServer2016: return "WINDOWS_SERVER_2016"
            case .windowsServer2019: return "WINDOWS_SERVER_2019"
            case .windowsServer2022: return "WINDOWS_SERVER_2022"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum ModelProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pcoip
        case wsp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .pcoip,
                .wsp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pcoip: return "PCOIP"
            case .wsp: return "WSP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum RunningMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alwaysOn
        case autoStop
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [RunningMode] {
            return [
                .alwaysOn,
                .autoStop,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alwaysOn: return "ALWAYS_ON"
            case .autoStop: return "AUTO_STOP"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a WorkSpace.
    public struct WorkspaceProperties: Swift.Sendable {
        /// The compute type. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles).
        public var computeTypeName: WorkSpacesClientTypes.Compute?
        /// The name of the operating system.
        public var operatingSystemName: WorkSpacesClientTypes.OperatingSystemName?
        /// The protocol. For more information, see [ Protocols for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-protocols.html).
        ///
        /// * Only available for WorkSpaces created with PCoIP bundles.
        ///
        /// * The Protocols property is case sensitive. Ensure you use PCOIP or DCV (formerly WSP).
        ///
        /// * Unavailable for Windows 7 WorkSpaces and WorkSpaces using GPU-based bundles (Graphics, GraphicsPro, Graphics.g4dn, and GraphicsPro.g4dn).
        public var protocols: [WorkSpacesClientTypes.ModelProtocol]?
        /// The size of the root volume. For important information about how to modify the size of the root and user volumes, see [Modify a WorkSpace](https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html).
        public var rootVolumeSizeGib: Swift.Int?
        /// The running mode. For more information, see [Manage the WorkSpace Running Mode](https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html). The MANUAL value is only supported by Amazon WorkSpaces Core. Contact your account team to be allow-listed to use this value. For more information, see [Amazon WorkSpaces Core](http://aws.amazon.com/workspaces/core/). Review your running mode to ensure you are using one that is optimal for your needs and budget. For more information on switching running modes, see [ Can I switch between hourly and monthly billing?](http://aws.amazon.com/workspaces-family/workspaces/faqs/#:~:text=Can%20I%20switch%20between%20hourly%20and%20monthly%20billing%20on%20WorkSpaces%20Personal%3F)
        public var runningMode: WorkSpacesClientTypes.RunningMode?
        /// The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.
        public var runningModeAutoStopTimeoutInMinutes: Swift.Int?
        /// The size of the user storage. For important information about how to modify the size of the root and user volumes, see [Modify a WorkSpace](https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html).
        public var userVolumeSizeGib: Swift.Int?

        public init(
            computeTypeName: WorkSpacesClientTypes.Compute? = nil,
            operatingSystemName: WorkSpacesClientTypes.OperatingSystemName? = nil,
            protocols: [WorkSpacesClientTypes.ModelProtocol]? = nil,
            rootVolumeSizeGib: Swift.Int? = nil,
            runningMode: WorkSpacesClientTypes.RunningMode? = nil,
            runningModeAutoStopTimeoutInMinutes: Swift.Int? = nil,
            userVolumeSizeGib: Swift.Int? = nil
        )
        {
            self.computeTypeName = computeTypeName
            self.operatingSystemName = operatingSystemName
            self.protocols = protocols
            self.rootVolumeSizeGib = rootVolumeSizeGib
            self.runningMode = runningMode
            self.runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutes
            self.userVolumeSizeGib = userVolumeSizeGib
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the information used to create a WorkSpace.
    public struct WorkspaceRequest: Swift.Sendable {
        /// The identifier of the bundle for the WorkSpace. You can use [DescribeWorkspaceBundles] to list the available bundles.
        /// This member is required.
        public var bundleId: Swift.String?
        /// The identifier of the Directory Service directory for the WorkSpace. You can use [DescribeWorkspaceDirectories] to list the available directories.
        /// This member is required.
        public var directoryId: Swift.String?
        /// Indicates whether the data stored on the root volume is encrypted.
        public var rootVolumeEncryptionEnabled: Swift.Bool?
        /// The tags for the WorkSpace.
        public var tags: [WorkSpacesClientTypes.Tag]?
        /// The user name of the user for the WorkSpace. This user name must exist in the Directory Service directory for the WorkSpace. The reserved keyword, [UNDEFINED], is used when creating user-decoupled WorkSpaces.
        /// This member is required.
        public var userName: Swift.String?
        /// Indicates whether the data stored on the user volume is encrypted.
        public var userVolumeEncryptionEnabled: Swift.Bool?
        /// The ARN of the symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.
        public var volumeEncryptionKey: Swift.String?
        /// The name of the user-decoupled WorkSpace. WorkspaceName is required if UserName is [UNDEFINED] for user-decoupled WorkSpaces. WorkspaceName is not applicable if UserName is specified for user-assigned WorkSpaces.
        public var workspaceName: Swift.String?
        /// The WorkSpace properties.
        public var workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?

        public init(
            bundleId: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            rootVolumeEncryptionEnabled: Swift.Bool? = nil,
            tags: [WorkSpacesClientTypes.Tag]? = nil,
            userName: Swift.String? = nil,
            userVolumeEncryptionEnabled: Swift.Bool? = nil,
            volumeEncryptionKey: Swift.String? = nil,
            workspaceName: Swift.String? = nil,
            workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties? = nil
        )
        {
            self.bundleId = bundleId
            self.directoryId = directoryId
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.tags = tags
            self.userName = userName
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.volumeEncryptionKey = volumeEncryptionKey
            self.workspaceName = workspaceName
            self.workspaceProperties = workspaceProperties
        }
    }
}

public struct CreateWorkspacesInput: Swift.Sendable {
    /// The WorkSpaces to create. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var workspaces: [WorkSpacesClientTypes.WorkspaceRequest]?

    public init(
        workspaces: [WorkSpacesClientTypes.WorkspaceRequest]? = nil
    )
    {
        self.workspaces = workspaces
    }
}

extension WorkSpacesClientTypes {

    /// Describes a WorkSpace that cannot be created.
    public struct FailedCreateWorkspaceRequest: Swift.Sendable {
        /// The error code that is returned if the WorkSpace cannot be created.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the WorkSpace cannot be created.
        public var errorMessage: Swift.String?
        /// Information about the WorkSpace.
        public var workspaceRequest: WorkSpacesClientTypes.WorkspaceRequest?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            workspaceRequest: WorkSpacesClientTypes.WorkspaceRequest? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.workspaceRequest = workspaceRequest
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the data replication settings.
    public struct DataReplicationSettings: Swift.Sendable {
        /// Indicates whether data replication is enabled, and if enabled, the type of data replication.
        public var dataReplication: WorkSpacesClientTypes.DataReplication?
        /// The date and time at which the last successful snapshot was taken of the primary WorkSpace used for replicating data.
        public var recoverySnapshotTime: Foundation.Date?

        public init(
            dataReplication: WorkSpacesClientTypes.DataReplication? = nil,
            recoverySnapshotTime: Foundation.Date? = nil
        )
        {
            self.dataReplication = dataReplication
            self.recoverySnapshotTime = recoverySnapshotTime
        }
    }
}

extension WorkSpacesClientTypes {

    public enum ModificationResourceEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case computeType
        case rootVolume
        case userVolume
        case sdkUnknown(Swift.String)

        public static var allCases: [ModificationResourceEnum] {
            return [
                .computeType,
                .rootVolume,
                .userVolume
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .computeType: return "COMPUTE_TYPE"
            case .rootVolume: return "ROOT_VOLUME"
            case .userVolume: return "USER_VOLUME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum ModificationStateEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case updateInitiated
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ModificationStateEnum] {
            return [
                .updateInitiated,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .updateInitiated: return "UPDATE_INITIATED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a WorkSpace modification.
    public struct ModificationState: Swift.Sendable {
        /// The resource.
        public var resource: WorkSpacesClientTypes.ModificationResourceEnum?
        /// The modification state.
        public var state: WorkSpacesClientTypes.ModificationStateEnum?

        public init(
            resource: WorkSpacesClientTypes.ModificationResourceEnum? = nil,
            state: WorkSpacesClientTypes.ModificationStateEnum? = nil
        )
        {
            self.resource = resource
            self.state = state
        }
    }
}

extension WorkSpacesClientTypes {

    public enum StandbyWorkspaceRelationshipType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case primary
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [StandbyWorkspaceRelationshipType] {
            return [
                .primary,
                .standby
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .primary: return "PRIMARY"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the related WorkSpace. The related WorkSpace could be a standby WorkSpace or primary WorkSpace related to the specified WorkSpace.
    public struct RelatedWorkspaceProperties: Swift.Sendable {
        /// The Region of the related WorkSpace.
        public var region: Swift.String?
        /// Indicates the state of the WorkSpace.
        public var state: WorkSpacesClientTypes.WorkspaceState?
        /// Indicates the type of WorkSpace.
        public var type: WorkSpacesClientTypes.StandbyWorkspaceRelationshipType?
        /// The identifier of the related WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            region: Swift.String? = nil,
            state: WorkSpacesClientTypes.WorkspaceState? = nil,
            type: WorkSpacesClientTypes.StandbyWorkspaceRelationshipType? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.region = region
            self.state = state
            self.type = type
            self.workspaceId = workspaceId
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the properties of the related standby WorkSpaces.
    public struct StandbyWorkspacesProperties: Swift.Sendable {
        /// Indicates whether data replication is enabled, and if enabled, the type of data replication.
        public var dataReplication: WorkSpacesClientTypes.DataReplication?
        /// The date and time at which the last successful snapshot was taken of the primary WorkSpace used for replicating data.
        public var recoverySnapshotTime: Foundation.Date?
        /// The identifier of the standby WorkSpace
        public var standbyWorkspaceId: Swift.String?

        public init(
            dataReplication: WorkSpacesClientTypes.DataReplication? = nil,
            recoverySnapshotTime: Foundation.Date? = nil,
            standbyWorkspaceId: Swift.String? = nil
        )
        {
            self.dataReplication = dataReplication
            self.recoverySnapshotTime = recoverySnapshotTime
            self.standbyWorkspaceId = standbyWorkspaceId
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a WorkSpace.
    public struct Workspace: Swift.Sendable {
        /// The identifier of the bundle used to create the WorkSpace.
        public var bundleId: Swift.String?
        /// The name of the WorkSpace, as seen by the operating system. The format of this name varies. For more information, see [ Launch a WorkSpace](https://docs.aws.amazon.com/workspaces/latest/adminguide/launch-workspaces-tutorials.html).
        public var computerName: Swift.String?
        /// Indicates the settings of the data replication.
        public var dataReplicationSettings: WorkSpacesClientTypes.DataReplicationSettings?
        /// The identifier of the Directory Service directory for the WorkSpace.
        public var directoryId: Swift.String?
        /// The error code that is returned if the WorkSpace cannot be created.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the WorkSpace cannot be created.
        public var errorMessage: Swift.String?
        /// The IP address of the WorkSpace.
        public var ipAddress: Swift.String?
        /// The modification states of the WorkSpace.
        public var modificationStates: [WorkSpacesClientTypes.ModificationState]?
        /// The standby WorkSpace or primary WorkSpace related to the specified WorkSpace.
        public var relatedWorkspaces: [WorkSpacesClientTypes.RelatedWorkspaceProperties]?
        /// Indicates whether the data stored on the root volume is encrypted.
        public var rootVolumeEncryptionEnabled: Swift.Bool?
        /// The properties of the standby WorkSpace
        public var standbyWorkspacesProperties: [WorkSpacesClientTypes.StandbyWorkspacesProperties]?
        /// The operational state of the WorkSpace.
        ///
        /// * PENDING – The WorkSpace is in a waiting state (for example, the WorkSpace is being created).
        ///
        /// * AVAILABLE – The WorkSpace is running and has passed the health checks.
        ///
        /// * IMPAIRED – Refer to UNHEALTHY state.
        ///
        /// * UNHEALTHY – The WorkSpace is not responding to health checks.
        ///
        /// * REBOOTING – The WorkSpace is being rebooted (restarted).
        ///
        /// * STARTING – The WorkSpace is starting up and health checks are being run.
        ///
        /// * REBUILDING – The WorkSpace is being rebuilt.
        ///
        /// * RESTORING – The WorkSpace is being restored.
        ///
        /// * MAINTENANCE – The WorkSpace is undergoing scheduled maintenance by Amazon Web Services.
        ///
        /// * ADMIN_MAINTENANCE – The WorkSpace is undergoing maintenance by the WorkSpaces administrator.
        ///
        /// * TERMINATING – The WorkSpace is being deleted.
        ///
        /// * TERMINATED – The WorkSpace has been deleted.
        ///
        /// * SUSPENDED – The WorkSpace has been suspended for image creation.
        ///
        /// * UPDATING – The WorkSpace is undergoing an update.
        ///
        /// * STOPPING – The WorkSpace is being stopped.
        ///
        /// * STOPPED – The WorkSpace has been stopped.
        ///
        /// * ERROR  – The WorkSpace is an error state (for example, an error occurred during startup).
        ///
        ///
        /// After a WorkSpace is terminated, the TERMINATED state is returned only briefly before the WorkSpace directory metadata is cleaned up, so this state is rarely returned. To confirm that a WorkSpace is terminated, check for the WorkSpace ID by using [ DescribeWorkSpaces](https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html). If the WorkSpace ID isn't returned, then the WorkSpace has been successfully terminated.
        public var state: WorkSpacesClientTypes.WorkspaceState?
        /// The identifier of the subnet for the WorkSpace.
        public var subnetId: Swift.String?
        /// The user for the WorkSpace.
        public var userName: Swift.String?
        /// Indicates whether the data stored on the user volume is encrypted.
        public var userVolumeEncryptionEnabled: Swift.Bool?
        /// The ARN of the symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.
        public var volumeEncryptionKey: Swift.String?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?
        /// The name of the user-decoupled WorkSpace.
        public var workspaceName: Swift.String?
        /// The properties of the WorkSpace.
        public var workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?

        public init(
            bundleId: Swift.String? = nil,
            computerName: Swift.String? = nil,
            dataReplicationSettings: WorkSpacesClientTypes.DataReplicationSettings? = nil,
            directoryId: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            modificationStates: [WorkSpacesClientTypes.ModificationState]? = nil,
            relatedWorkspaces: [WorkSpacesClientTypes.RelatedWorkspaceProperties]? = nil,
            rootVolumeEncryptionEnabled: Swift.Bool? = nil,
            standbyWorkspacesProperties: [WorkSpacesClientTypes.StandbyWorkspacesProperties]? = nil,
            state: WorkSpacesClientTypes.WorkspaceState? = nil,
            subnetId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userVolumeEncryptionEnabled: Swift.Bool? = nil,
            volumeEncryptionKey: Swift.String? = nil,
            workspaceId: Swift.String? = nil,
            workspaceName: Swift.String? = nil,
            workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties? = nil
        )
        {
            self.bundleId = bundleId
            self.computerName = computerName
            self.dataReplicationSettings = dataReplicationSettings
            self.directoryId = directoryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.ipAddress = ipAddress
            self.modificationStates = modificationStates
            self.relatedWorkspaces = relatedWorkspaces
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.standbyWorkspacesProperties = standbyWorkspacesProperties
            self.state = state
            self.subnetId = subnetId
            self.userName = userName
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.volumeEncryptionKey = volumeEncryptionKey
            self.workspaceId = workspaceId
            self.workspaceName = workspaceName
            self.workspaceProperties = workspaceProperties
        }
    }
}

public struct CreateWorkspacesOutput: Swift.Sendable {
    /// Information about the WorkSpaces that could not be created.
    public var failedRequests: [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]?
    /// Information about the WorkSpaces that were created. Because this operation is asynchronous, the identifier returned is not immediately available for use with other operations. For example, if you call [DescribeWorkspaces] before the WorkSpace is created, the information returned can be incomplete.
    public var pendingRequests: [WorkSpacesClientTypes.Workspace]?

    public init(
        failedRequests: [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]? = nil,
        pendingRequests: [WorkSpacesClientTypes.Workspace]? = nil
    )
    {
        self.failedRequests = failedRequests
        self.pendingRequests = pendingRequests
    }
}

extension WorkSpacesClientTypes {

    /// Describes the timeout settings for a pool of WorkSpaces.
    public struct TimeoutSettings: Swift.Sendable {
        /// Specifies the amount of time, in seconds, that a streaming session remains active after users disconnect. If users try to reconnect to the streaming session after a disconnection or network interruption within the time set, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance.
        public var disconnectTimeoutInSeconds: Swift.Int?
        /// The amount of time in seconds a connection will stay active while idle.
        public var idleDisconnectTimeoutInSeconds: Swift.Int?
        /// Specifies the maximum amount of time, in seconds, that a streaming session can remain active. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance.
        public var maxUserDurationInSeconds: Swift.Int?

        public init(
            disconnectTimeoutInSeconds: Swift.Int? = nil,
            idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
            maxUserDurationInSeconds: Swift.Int? = nil
        )
        {
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
        }
    }
}

public struct CreateWorkspacesPoolInput: Swift.Sendable {
    /// Indicates the application settings of the pool.
    public var applicationSettings: WorkSpacesClientTypes.ApplicationSettingsRequest?
    /// The identifier of the bundle for the pool.
    /// This member is required.
    public var bundleId: Swift.String?
    /// The user capacity of the pool.
    /// This member is required.
    public var capacity: WorkSpacesClientTypes.Capacity?
    /// The pool description.
    /// This member is required.
    public var description: Swift.String?
    /// The identifier of the directory for the pool.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The name of the pool.
    /// This member is required.
    public var poolName: Swift.String?
    /// The tags for the pool.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// Indicates the timeout settings of the pool.
    public var timeoutSettings: WorkSpacesClientTypes.TimeoutSettings?

    public init(
        applicationSettings: WorkSpacesClientTypes.ApplicationSettingsRequest? = nil,
        bundleId: Swift.String? = nil,
        capacity: WorkSpacesClientTypes.Capacity? = nil,
        description: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        poolName: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        timeoutSettings: WorkSpacesClientTypes.TimeoutSettings? = nil
    )
    {
        self.applicationSettings = applicationSettings
        self.bundleId = bundleId
        self.capacity = capacity
        self.description = description
        self.directoryId = directoryId
        self.poolName = poolName
        self.tags = tags
        self.timeoutSettings = timeoutSettings
    }
}

extension WorkSpacesClientTypes {

    public enum WorkspacesPoolErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bundleNotFound
        case defaultOuIsMissing
        case directoryNotFound
        case domainJoinErrorAccessDenied
        case domainJoinErrorDsMachineAccountQuotaExceeded
        case domainJoinErrorFileNotFound
        case domainJoinErrorInvalidParameter
        case domainJoinErrorLogonFailure
        case domainJoinErrorMoreData
        case domainJoinErrorNotSupported
        case domainJoinErrorNoSuchDomain
        case domainJoinErrorSecretActionPermissionIsMissing
        case domainJoinErrorSecretDecryptionFailure
        case domainJoinErrorSecretInvalid
        case domainJoinErrorSecretNotFound
        case domainJoinErrorSecretStateInvalid
        case domainJoinErrorSecretValueKeyNotFound
        case domainJoinInternalServiceError
        case domainJoinNerrInvalidWorkgroupName
        case domainJoinNerrPasswordExpired
        case domainJoinNerrWorkstationNotStarted
        case iamServiceRoleIsMissing
        case iamServiceRoleMissingDescribeSecurityGroupsAction
        case iamServiceRoleMissingDescribeSubnetAction
        case iamServiceRoleMissingEniCreateAction
        case iamServiceRoleMissingEniDeleteAction
        case iamServiceRoleMissingEniDescribeAction
        case igwNotAttached
        case imageNotFound
        case insufficientPermissionsError
        case internalServiceError
        case invalidSubnetConfiguration
        case machineRoleIsMissing
        case networkInterfaceLimitExceeded
        case securityGroupsNotFound
        case stsDisabledInRegion
        case subnetHasInsufficientIpAddresses
        case subnetNotFound
        case workspacesPoolInstanceProvisioningFailure
        case workspacesPoolStopped
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspacesPoolErrorCode] {
            return [
                .bundleNotFound,
                .defaultOuIsMissing,
                .directoryNotFound,
                .domainJoinErrorAccessDenied,
                .domainJoinErrorDsMachineAccountQuotaExceeded,
                .domainJoinErrorFileNotFound,
                .domainJoinErrorInvalidParameter,
                .domainJoinErrorLogonFailure,
                .domainJoinErrorMoreData,
                .domainJoinErrorNotSupported,
                .domainJoinErrorNoSuchDomain,
                .domainJoinErrorSecretActionPermissionIsMissing,
                .domainJoinErrorSecretDecryptionFailure,
                .domainJoinErrorSecretInvalid,
                .domainJoinErrorSecretNotFound,
                .domainJoinErrorSecretStateInvalid,
                .domainJoinErrorSecretValueKeyNotFound,
                .domainJoinInternalServiceError,
                .domainJoinNerrInvalidWorkgroupName,
                .domainJoinNerrPasswordExpired,
                .domainJoinNerrWorkstationNotStarted,
                .iamServiceRoleIsMissing,
                .iamServiceRoleMissingDescribeSecurityGroupsAction,
                .iamServiceRoleMissingDescribeSubnetAction,
                .iamServiceRoleMissingEniCreateAction,
                .iamServiceRoleMissingEniDeleteAction,
                .iamServiceRoleMissingEniDescribeAction,
                .igwNotAttached,
                .imageNotFound,
                .insufficientPermissionsError,
                .internalServiceError,
                .invalidSubnetConfiguration,
                .machineRoleIsMissing,
                .networkInterfaceLimitExceeded,
                .securityGroupsNotFound,
                .stsDisabledInRegion,
                .subnetHasInsufficientIpAddresses,
                .subnetNotFound,
                .workspacesPoolInstanceProvisioningFailure,
                .workspacesPoolStopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bundleNotFound: return "BUNDLE_NOT_FOUND"
            case .defaultOuIsMissing: return "DEFAULT_OU_IS_MISSING"
            case .directoryNotFound: return "DIRECTORY_NOT_FOUND"
            case .domainJoinErrorAccessDenied: return "DOMAIN_JOIN_ERROR_ACCESS_DENIED"
            case .domainJoinErrorDsMachineAccountQuotaExceeded: return "DOMAIN_JOIN_ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED"
            case .domainJoinErrorFileNotFound: return "DOMAIN_JOIN_ERROR_FILE_NOT_FOUND"
            case .domainJoinErrorInvalidParameter: return "DOMAIN_JOIN_ERROR_INVALID_PARAMETER"
            case .domainJoinErrorLogonFailure: return "DOMAIN_JOIN_ERROR_LOGON_FAILURE"
            case .domainJoinErrorMoreData: return "DOMAIN_JOIN_ERROR_MORE_DATA"
            case .domainJoinErrorNotSupported: return "DOMAIN_JOIN_ERROR_NOT_SUPPORTED"
            case .domainJoinErrorNoSuchDomain: return "DOMAIN_JOIN_ERROR_NO_SUCH_DOMAIN"
            case .domainJoinErrorSecretActionPermissionIsMissing: return "DOMAIN_JOIN_ERROR_SECRET_ACTION_PERMISSION_IS_MISSING"
            case .domainJoinErrorSecretDecryptionFailure: return "DOMAIN_JOIN_ERROR_SECRET_DECRYPTION_FAILURE"
            case .domainJoinErrorSecretInvalid: return "DOMAIN_JOIN_ERROR_SECRET_INVALID"
            case .domainJoinErrorSecretNotFound: return "DOMAIN_JOIN_ERROR_SECRET_NOT_FOUND"
            case .domainJoinErrorSecretStateInvalid: return "DOMAIN_JOIN_ERROR_SECRET_STATE_INVALID"
            case .domainJoinErrorSecretValueKeyNotFound: return "DOMAIN_JOIN_ERROR_SECRET_VALUE_KEY_NOT_FOUND"
            case .domainJoinInternalServiceError: return "DOMAIN_JOIN_INTERNAL_SERVICE_ERROR"
            case .domainJoinNerrInvalidWorkgroupName: return "DOMAIN_JOIN_NERR_INVALID_WORKGROUP_NAME"
            case .domainJoinNerrPasswordExpired: return "DOMAIN_JOIN_NERR_PASSWORD_EXPIRED"
            case .domainJoinNerrWorkstationNotStarted: return "DOMAIN_JOIN_NERR_WORKSTATION_NOT_STARTED"
            case .iamServiceRoleIsMissing: return "IAM_SERVICE_ROLE_IS_MISSING"
            case .iamServiceRoleMissingDescribeSecurityGroupsAction: return "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SECURITY_GROUPS_ACTION"
            case .iamServiceRoleMissingDescribeSubnetAction: return "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION"
            case .iamServiceRoleMissingEniCreateAction: return "IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION"
            case .iamServiceRoleMissingEniDeleteAction: return "IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION"
            case .iamServiceRoleMissingEniDescribeAction: return "IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION"
            case .igwNotAttached: return "IGW_NOT_ATTACHED"
            case .imageNotFound: return "IMAGE_NOT_FOUND"
            case .insufficientPermissionsError: return "INSUFFICIENT_PERMISSIONS_ERROR"
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .invalidSubnetConfiguration: return "INVALID_SUBNET_CONFIGURATION"
            case .machineRoleIsMissing: return "MACHINE_ROLE_IS_MISSING"
            case .networkInterfaceLimitExceeded: return "NETWORK_INTERFACE_LIMIT_EXCEEDED"
            case .securityGroupsNotFound: return "SECURITY_GROUPS_NOT_FOUND"
            case .stsDisabledInRegion: return "STS_DISABLED_IN_REGION"
            case .subnetHasInsufficientIpAddresses: return "SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES"
            case .subnetNotFound: return "SUBNET_NOT_FOUND"
            case .workspacesPoolInstanceProvisioningFailure: return "WORKSPACES_POOL_INSTANCE_PROVISIONING_FAILURE"
            case .workspacesPoolStopped: return "WORKSPACES_POOL_STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a pool error.
    public struct WorkspacesPoolError: Swift.Sendable {
        /// The error code.
        public var errorCode: WorkSpacesClientTypes.WorkspacesPoolErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init(
            errorCode: WorkSpacesClientTypes.WorkspacesPoolErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

extension WorkSpacesClientTypes {

    public enum WorkspacesPoolState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case running
        case starting
        case stopped
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspacesPoolState] {
            return [
                .creating,
                .deleting,
                .running,
                .starting,
                .stopped,
                .stopping,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a pool of WorkSpaces.
    public struct WorkspacesPool: Swift.Sendable {
        /// The persistent application settings for users of the pool.
        public var applicationSettings: WorkSpacesClientTypes.ApplicationSettingsResponse?
        /// The identifier of the bundle used by the pool.
        /// This member is required.
        public var bundleId: Swift.String?
        /// The capacity status for the pool
        /// This member is required.
        public var capacityStatus: WorkSpacesClientTypes.CapacityStatus?
        /// The time the pool was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the pool.
        public var description: Swift.String?
        /// The identifier of the directory used by the pool.
        /// This member is required.
        public var directoryId: Swift.String?
        /// The pool errors.
        public var errors: [WorkSpacesClientTypes.WorkspacesPoolError]?
        /// The Amazon Resource Name (ARN) for the pool.
        /// This member is required.
        public var poolArn: Swift.String?
        /// The identifier of a pool.
        /// This member is required.
        public var poolId: Swift.String?
        /// The name of the pool,
        /// This member is required.
        public var poolName: Swift.String?
        /// The current state of the pool.
        /// This member is required.
        public var state: WorkSpacesClientTypes.WorkspacesPoolState?
        /// The amount of time that a pool session remains active after users disconnect. If they try to reconnect to the pool session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new pool instance.
        public var timeoutSettings: WorkSpacesClientTypes.TimeoutSettings?

        public init(
            applicationSettings: WorkSpacesClientTypes.ApplicationSettingsResponse? = nil,
            bundleId: Swift.String? = nil,
            capacityStatus: WorkSpacesClientTypes.CapacityStatus? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            errors: [WorkSpacesClientTypes.WorkspacesPoolError]? = nil,
            poolArn: Swift.String? = nil,
            poolId: Swift.String? = nil,
            poolName: Swift.String? = nil,
            state: WorkSpacesClientTypes.WorkspacesPoolState? = nil,
            timeoutSettings: WorkSpacesClientTypes.TimeoutSettings? = nil
        )
        {
            self.applicationSettings = applicationSettings
            self.bundleId = bundleId
            self.capacityStatus = capacityStatus
            self.createdAt = createdAt
            self.description = description
            self.directoryId = directoryId
            self.errors = errors
            self.poolArn = poolArn
            self.poolId = poolId
            self.poolName = poolName
            self.state = state
            self.timeoutSettings = timeoutSettings
        }
    }
}

public struct CreateWorkspacesPoolOutput: Swift.Sendable {
    /// Indicates the pool to create.
    public var workspacesPool: WorkSpacesClientTypes.WorkspacesPool?

    public init(
        workspacesPool: WorkSpacesClientTypes.WorkspacesPool? = nil
    )
    {
        self.workspacesPool = workspacesPool
    }
}

extension WorkSpacesClientTypes {

    public enum DedicatedTenancyAccountType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sourceAccount
        case targetAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancyAccountType] {
            return [
                .sourceAccount,
                .targetAccount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sourceAccount: return "SOURCE_ACCOUNT"
            case .targetAccount: return "TARGET_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum DedicatedTenancySupportEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancySupportEnum] {
            return [
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Returns default client branding attributes that were imported. These attributes display on the client login screen. Client branding attributes are public facing. Ensure that you don't include sensitive information.
    public struct DefaultClientBrandingAttributes: Swift.Sendable {
        /// The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.
        public var forgotPasswordLink: Swift.String?
        /// The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is en_US. The HTML tags supported include the following: a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul.
        public var loginMessage: [Swift.String: Swift.String]?
        /// The logo. The only image format accepted is a binary data object that is converted from a .png file.
        public var logoUrl: Swift.String?
        /// The support email. The company's customer support email address.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default email is workspaces-feedback@amazon.com.
        public var supportEmail: Swift.String?
        /// The support link. The link for the company's customer support page for their WorkSpace.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive.You can specify one parameter for each platform type, but not both.
        ///
        /// * The default support link is workspaces-feedback@amazon.com.
        public var supportLink: Swift.String?

        public init(
            forgotPasswordLink: Swift.String? = nil,
            loginMessage: [Swift.String: Swift.String]? = nil,
            logoUrl: Swift.String? = nil,
            supportEmail: Swift.String? = nil,
            supportLink: Swift.String? = nil
        )
        {
            self.forgotPasswordLink = forgotPasswordLink
            self.loginMessage = loginMessage
            self.logoUrl = logoUrl
            self.supportEmail = supportEmail
            self.supportLink = supportLink
        }
    }
}

extension WorkSpacesClientTypes {

    /// The default client branding attributes to be imported. These attributes display on the client login screen. Client branding attributes are public facing. Ensure that you do not include sensitive information.
    public struct DefaultImportClientBrandingAttributes: Swift.Sendable {
        /// The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.
        public var forgotPasswordLink: Swift.String?
        /// The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is en_US. The HTML tags supported include the following: a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul.
        public var loginMessage: [Swift.String: Swift.String]?
        /// The logo. The only image format accepted is a binary data object that is converted from a .png file.
        public var logo: Foundation.Data?
        /// The support email. The company's customer support email address.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default email is workspaces-feedback@amazon.com.
        public var supportEmail: Swift.String?
        /// The support link. The link for the company's customer support page for their WorkSpace.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default support link is workspaces-feedback@amazon.com.
        public var supportLink: Swift.String?

        public init(
            forgotPasswordLink: Swift.String? = nil,
            loginMessage: [Swift.String: Swift.String]? = nil,
            logo: Foundation.Data? = nil,
            supportEmail: Swift.String? = nil,
            supportLink: Swift.String? = nil
        )
        {
            self.forgotPasswordLink = forgotPasswordLink
            self.loginMessage = loginMessage
            self.logo = logo
            self.supportEmail = supportEmail
            self.supportLink = supportLink
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the default values that are used to create WorkSpaces. For more information, see [Update Directory Details for Your WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html).
    public struct DefaultWorkspaceCreationProperties: Swift.Sendable {
        /// The identifier of the default security group to apply to WorkSpaces when they are created. For more information, see [ Security Groups for Your WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-security-groups.html).
        public var customSecurityGroupId: Swift.String?
        /// The organizational unit (OU) in the directory for the WorkSpace machine accounts.
        public var defaultOu: Swift.String?
        /// Specifies whether to automatically assign an Elastic public IP address to WorkSpaces in this directory by default. If enabled, the Elastic public IP address allows outbound internet access from your WorkSpaces when you’re using an internet gateway in the Amazon VPC in which your WorkSpaces are located. If you're using a Network Address Translation (NAT) gateway for outbound internet access from your VPC, or if your WorkSpaces are in public subnets and you manually assign them Elastic IP addresses, you should disable this setting. This setting applies to new WorkSpaces that you launch or to existing WorkSpaces that you rebuild. For more information, see [ Configure a VPC for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html).
        public var enableInternetAccess: Swift.Bool?
        /// Specifies whether maintenance mode is enabled for WorkSpaces. For more information, see [WorkSpace Maintenance](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html).
        public var enableMaintenanceMode: Swift.Bool?
        /// Specifies whether the directory is enabled for Amazon WorkDocs.
        public var enableWorkDocs: Swift.Bool?
        /// Indicates the IAM role ARN of the instance.
        public var instanceIamRoleArn: Swift.String?
        /// Specifies whether WorkSpace users are local administrators on their WorkSpaces.
        public var userEnabledAsLocalAdministrator: Swift.Bool?

        public init(
            customSecurityGroupId: Swift.String? = nil,
            defaultOu: Swift.String? = nil,
            enableInternetAccess: Swift.Bool? = nil,
            enableMaintenanceMode: Swift.Bool? = nil,
            enableWorkDocs: Swift.Bool? = nil,
            instanceIamRoleArn: Swift.String? = nil,
            userEnabledAsLocalAdministrator: Swift.Bool? = nil
        )
        {
            self.customSecurityGroupId = customSecurityGroupId
            self.defaultOu = defaultOu
            self.enableInternetAccess = enableInternetAccess
            self.enableMaintenanceMode = enableMaintenanceMode
            self.enableWorkDocs = enableWorkDocs
            self.instanceIamRoleArn = instanceIamRoleArn
            self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
        }
    }
}

extension WorkSpacesClientTypes {

    public enum DeletableCertificateBasedAuthProperty: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case certificateBasedAuthPropertiesCertificateAuthorityArn
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletableCertificateBasedAuthProperty] {
            return [
                .certificateBasedAuthPropertiesCertificateAuthorityArn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .certificateBasedAuthPropertiesCertificateAuthorityArn: return "CERTIFICATE_BASED_AUTH_PROPERTIES_CERTIFICATE_AUTHORITY_ARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum DeletableSamlProperty: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case samlPropertiesRelayStateParameterName
        case samlPropertiesUserAccessUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletableSamlProperty] {
            return [
                .samlPropertiesRelayStateParameterName,
                .samlPropertiesUserAccessUrl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .samlPropertiesRelayStateParameterName: return "SAML_PROPERTIES_RELAY_STATE_PARAMETER_NAME"
            case .samlPropertiesUserAccessUrl: return "SAML_PROPERTIES_USER_ACCESS_URL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteAccountLinkInvitationInput: Swift.Sendable {
    /// A string of up to 64 ASCII characters that Amazon EFS uses to ensure idempotent creation.
    public var clientToken: Swift.String?
    /// The identifier of the account link.
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.linkId = linkId
    }
}

public struct DeleteAccountLinkInvitationOutput: Swift.Sendable {
    /// Information about the account link.
    public var accountLink: WorkSpacesClientTypes.AccountLink?

    public init(
        accountLink: WorkSpacesClientTypes.AccountLink? = nil
    )
    {
        self.accountLink = accountLink
    }
}

public struct DeleteClientBrandingInput: Swift.Sendable {
    /// The device type for which you want to delete client branding.
    /// This member is required.
    public var platforms: [WorkSpacesClientTypes.ClientDeviceType]?
    /// The directory identifier of the WorkSpace for which you want to delete client branding.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        platforms: [WorkSpacesClientTypes.ClientDeviceType]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.platforms = platforms
        self.resourceId = resourceId
    }
}

public struct DeleteClientBrandingOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteConnectClientAddInInput: Swift.Sendable {
    /// The identifier of the client add-in to delete.
    /// This member is required.
    public var addInId: Swift.String?
    /// The directory identifier for which the client add-in is configured.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        addInId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.addInId = addInId
        self.resourceId = resourceId
    }
}

public struct DeleteConnectClientAddInOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteConnectionAliasInput: Swift.Sendable {
    /// The identifier of the connection alias to delete.
    /// This member is required.
    public var aliasId: Swift.String?

    public init(
        aliasId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

public struct DeleteConnectionAliasOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteIpGroupInput: Swift.Sendable {
    /// The identifier of the IP access control group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

public struct DeleteIpGroupOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTagsInput: Swift.Sendable {
    /// The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces, registered directories, images, custom bundles, IP access control groups, and connection aliases.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeys = tagKeys
    }
}

public struct DeleteTagsOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWorkspaceBundleInput: Swift.Sendable {
    /// The identifier of the bundle.
    public var bundleId: Swift.String?

    public init(
        bundleId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
    }
}

public struct DeleteWorkspaceBundleOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWorkspaceImageInput: Swift.Sendable {
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?

    public init(
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

public struct DeleteWorkspaceImageOutput: Swift.Sendable {

    public init() { }
}

public struct DeployWorkspaceApplicationsInput: Swift.Sendable {
    /// Indicates whether the force flag is applied for the specified WorkSpace. When the force flag is enabled, it allows previously failed deployments to be retried.
    public var force: Swift.Bool?
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.force = force
        self.workspaceId = workspaceId
    }
}

extension WorkSpacesClientTypes {

    /// Describes the WorkSpace application deployment.
    public struct WorkSpaceApplicationDeployment: Swift.Sendable {
        /// The associations between the applications and the associated resources.
        public var associations: [WorkSpacesClientTypes.WorkspaceResourceAssociation]?

        public init(
            associations: [WorkSpacesClientTypes.WorkspaceResourceAssociation]? = nil
        )
        {
            self.associations = associations
        }
    }
}

public struct DeployWorkspaceApplicationsOutput: Swift.Sendable {
    /// The list of deployed associations and information about them.
    public var deployment: WorkSpacesClientTypes.WorkSpaceApplicationDeployment?

    public init(
        deployment: WorkSpacesClientTypes.WorkSpaceApplicationDeployment? = nil
    )
    {
        self.deployment = deployment
    }
}

public struct DeregisterWorkspaceDirectoryInput: Swift.Sendable {
    /// The identifier of the directory. If any WorkSpaces are registered to this directory, you must remove them before you deregister the directory, or you will receive an OperationNotSupportedException error.
    /// This member is required.
    public var directoryId: Swift.String?

    public init(
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

public struct DeregisterWorkspaceDirectoryOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeAccountInput: Swift.Sendable {

    public init() { }
}

public struct DescribeAccountOutput: Swift.Sendable {
    /// The type of linked account.
    public var dedicatedTenancyAccountType: WorkSpacesClientTypes.DedicatedTenancyAccountType?
    /// The IP address range, specified as an IPv4 CIDR block, used for the management network interface. The management network interface is connected to a secure Amazon WorkSpaces management network. It is used for interactive streaming of the WorkSpace desktop to Amazon WorkSpaces clients, and to allow Amazon WorkSpaces to manage the WorkSpace.
    public var dedicatedTenancyManagementCidrRange: Swift.String?
    /// The status of BYOL (whether BYOL is enabled or disabled).
    public var dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum?

    public init(
        dedicatedTenancyAccountType: WorkSpacesClientTypes.DedicatedTenancyAccountType? = nil,
        dedicatedTenancyManagementCidrRange: Swift.String? = nil,
        dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum? = nil
    )
    {
        self.dedicatedTenancyAccountType = dedicatedTenancyAccountType
        self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
        self.dedicatedTenancySupport = dedicatedTenancySupport
    }
}

public struct DescribeAccountModificationsInput: Swift.Sendable {
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

public struct DescribeAccountModificationsOutput: Swift.Sendable {
    /// The list of modifications to the configuration of BYOL.
    public var accountModifications: [WorkSpacesClientTypes.AccountModification]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        accountModifications: [WorkSpacesClientTypes.AccountModification]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountModifications = accountModifications
        self.nextToken = nextToken
    }
}

public struct DescribeApplicationAssociationsInput: Swift.Sendable {
    /// The identifier of the specified application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The resource type of the associated resources.
    /// This member is required.
    public var associatedResourceTypes: [WorkSpacesClientTypes.ApplicationAssociatedResourceType]?
    /// The maximum number of associations to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        associatedResourceTypes: [WorkSpacesClientTypes.ApplicationAssociatedResourceType]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.associatedResourceTypes = associatedResourceTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeApplicationAssociationsOutput: Swift.Sendable {
    /// List of associations and information about them.
    public var associations: [WorkSpacesClientTypes.ApplicationResourceAssociation]?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        associations: [WorkSpacesClientTypes.ApplicationResourceAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associations = associations
        self.nextToken = nextToken
    }
}

extension WorkSpacesClientTypes {

    public enum WorkSpaceApplicationLicenseType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case licensed
        case unlicensed
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkSpaceApplicationLicenseType] {
            return [
                .licensed,
                .unlicensed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .licensed: return "LICENSED"
            case .unlicensed: return "UNLICENSED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeApplicationsInput: Swift.Sendable {
    /// The identifiers of one or more applications.
    public var applicationIds: [Swift.String]?
    /// The compute types supported by the applications.
    public var computeTypeNames: [WorkSpacesClientTypes.Compute]?
    /// The license availability for the applications.
    public var licenseType: WorkSpacesClientTypes.WorkSpaceApplicationLicenseType?
    /// The maximum number of applications to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The operating systems supported by the applications.
    public var operatingSystemNames: [WorkSpacesClientTypes.OperatingSystemName]?
    /// The owner of the applications.
    public var owner: Swift.String?

    public init(
        applicationIds: [Swift.String]? = nil,
        computeTypeNames: [WorkSpacesClientTypes.Compute]? = nil,
        licenseType: WorkSpacesClientTypes.WorkSpaceApplicationLicenseType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        operatingSystemNames: [WorkSpacesClientTypes.OperatingSystemName]? = nil,
        owner: Swift.String? = nil
    )
    {
        self.applicationIds = applicationIds
        self.computeTypeNames = computeTypeNames
        self.licenseType = licenseType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operatingSystemNames = operatingSystemNames
        self.owner = owner
    }
}

extension WorkSpacesClientTypes {

    public enum WorkSpaceApplicationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case error
        case pending
        case uninstallOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkSpaceApplicationState] {
            return [
                .available,
                .error,
                .pending,
                .uninstallOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .pending: return "PENDING"
            case .uninstallOnly: return "UNINSTALL_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the WorkSpace application.
    public struct WorkSpaceApplication: Swift.Sendable {
        /// The identifier of the application.
        public var applicationId: Swift.String?
        /// The time the application is created.
        public var created: Foundation.Date?
        /// The description of the WorkSpace application.
        public var description: Swift.String?
        /// The license availability for the applications.
        public var licenseType: WorkSpacesClientTypes.WorkSpaceApplicationLicenseType?
        /// The name of the WorkSpace application.
        public var name: Swift.String?
        /// The owner of the WorkSpace application.
        public var owner: Swift.String?
        /// The status of WorkSpace application.
        public var state: WorkSpacesClientTypes.WorkSpaceApplicationState?
        /// The supported compute types of the WorkSpace application.
        public var supportedComputeTypeNames: [WorkSpacesClientTypes.Compute]?
        /// The supported operating systems of the WorkSpace application.
        public var supportedOperatingSystemNames: [WorkSpacesClientTypes.OperatingSystemName]?

        public init(
            applicationId: Swift.String? = nil,
            created: Foundation.Date? = nil,
            description: Swift.String? = nil,
            licenseType: WorkSpacesClientTypes.WorkSpaceApplicationLicenseType? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            state: WorkSpacesClientTypes.WorkSpaceApplicationState? = nil,
            supportedComputeTypeNames: [WorkSpacesClientTypes.Compute]? = nil,
            supportedOperatingSystemNames: [WorkSpacesClientTypes.OperatingSystemName]? = nil
        )
        {
            self.applicationId = applicationId
            self.created = created
            self.description = description
            self.licenseType = licenseType
            self.name = name
            self.owner = owner
            self.state = state
            self.supportedComputeTypeNames = supportedComputeTypeNames
            self.supportedOperatingSystemNames = supportedOperatingSystemNames
        }
    }
}

public struct DescribeApplicationsOutput: Swift.Sendable {
    /// List of information about the specified applications.
    public var applications: [WorkSpacesClientTypes.WorkSpaceApplication]?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        applications: [WorkSpacesClientTypes.WorkSpaceApplication]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

public struct DescribeBundleAssociationsInput: Swift.Sendable {
    /// The resource types of the associated resource.
    /// This member is required.
    public var associatedResourceTypes: [WorkSpacesClientTypes.BundleAssociatedResourceType]?
    /// The identifier of the bundle.
    /// This member is required.
    public var bundleId: Swift.String?

    public init(
        associatedResourceTypes: [WorkSpacesClientTypes.BundleAssociatedResourceType]? = nil,
        bundleId: Swift.String? = nil
    )
    {
        self.associatedResourceTypes = associatedResourceTypes
        self.bundleId = bundleId
    }
}

public struct DescribeBundleAssociationsOutput: Swift.Sendable {
    /// List of information about the specified associations.
    public var associations: [WorkSpacesClientTypes.BundleResourceAssociation]?

    public init(
        associations: [WorkSpacesClientTypes.BundleResourceAssociation]? = nil
    )
    {
        self.associations = associations
    }
}

public struct DescribeClientBrandingInput: Swift.Sendable {
    /// The directory identifier of the WorkSpace for which you want to view client branding information.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

extension WorkSpacesClientTypes {

    /// The client branding attributes for iOS device types. These attributes are displayed on the iOS client login screen only. Client branding attributes are public facing. Ensure you do not include sensitive information.
    public struct IosClientBrandingAttributes: Swift.Sendable {
        /// The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.
        public var forgotPasswordLink: Swift.String?
        /// The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is en_US. The HTML tags supported include the following: a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul.
        public var loginMessage: [Swift.String: Swift.String]?
        /// The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a .png file. For more information about iOS image size and resolution, see [Image Size and Resolution ](https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/) in the Apple Human Interface Guidelines.
        public var logo2xUrl: Swift.String?
        /// The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x).The only image format accepted is a binary data object that is converted from a .png file. For more information about iOS image size and resolution, see [Image Size and Resolution ](https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/) in the Apple Human Interface Guidelines.
        public var logo3xUrl: Swift.String?
        /// The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a .png file.
        public var logoUrl: Swift.String?
        /// The support email. The company's customer support email address.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default email is workspaces-feedback@amazon.com.
        public var supportEmail: Swift.String?
        /// The support link. The link for the company's customer support page for their WorkSpace.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default support link is workspaces-feedback@amazon.com.
        public var supportLink: Swift.String?

        public init(
            forgotPasswordLink: Swift.String? = nil,
            loginMessage: [Swift.String: Swift.String]? = nil,
            logo2xUrl: Swift.String? = nil,
            logo3xUrl: Swift.String? = nil,
            logoUrl: Swift.String? = nil,
            supportEmail: Swift.String? = nil,
            supportLink: Swift.String? = nil
        )
        {
            self.forgotPasswordLink = forgotPasswordLink
            self.loginMessage = loginMessage
            self.logo2xUrl = logo2xUrl
            self.logo3xUrl = logo3xUrl
            self.logoUrl = logoUrl
            self.supportEmail = supportEmail
            self.supportLink = supportLink
        }
    }
}

public struct DescribeClientBrandingOutput: Swift.Sendable {
    /// The branding information for Android devices.
    public var deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information for iOS devices.
    public var deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes?
    /// The branding information for Linux devices.
    public var deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information for macOS devices.
    public var deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information for Web access.
    public var deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information for Windows devices.
    public var deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes?

    public init(
        deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes? = nil,
        deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil
    )
    {
        self.deviceTypeAndroid = deviceTypeAndroid
        self.deviceTypeIos = deviceTypeIos
        self.deviceTypeLinux = deviceTypeLinux
        self.deviceTypeOsx = deviceTypeOsx
        self.deviceTypeWeb = deviceTypeWeb
        self.deviceTypeWindows = deviceTypeWindows
    }
}

public struct DescribeClientPropertiesInput: Swift.Sendable {
    /// The resource identifier, in the form of directory IDs.
    /// This member is required.
    public var resourceIds: [Swift.String]?

    public init(
        resourceIds: [Swift.String]? = nil
    )
    {
        self.resourceIds = resourceIds
    }
}

public struct DescribeClientPropertiesOutput: Swift.Sendable {
    /// Information about the specified Amazon WorkSpaces clients.
    public var clientPropertiesList: [WorkSpacesClientTypes.ClientPropertiesResult]?

    public init(
        clientPropertiesList: [WorkSpacesClientTypes.ClientPropertiesResult]? = nil
    )
    {
        self.clientPropertiesList = clientPropertiesList
    }
}

public struct DescribeConnectClientAddInsInput: Swift.Sendable {
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The directory identifier for which the client add-in is configured.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

public struct DescribeConnectClientAddInsOutput: Swift.Sendable {
    /// Information about client add-ins.
    public var addIns: [WorkSpacesClientTypes.ConnectClientAddIn]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        addIns: [WorkSpacesClientTypes.ConnectClientAddIn]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.addIns = addIns
        self.nextToken = nextToken
    }
}

public struct DescribeConnectionAliasesInput: Swift.Sendable {
    /// The identifiers of the connection aliases to describe.
    public var aliasIds: [Swift.String]?
    /// The maximum number of connection aliases to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the directory associated with the connection alias.
    public var resourceId: Swift.String?

    public init(
        aliasIds: [Swift.String]? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.aliasIds = aliasIds
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

public struct DescribeConnectionAliasesOutput: Swift.Sendable {
    /// Information about the specified connection aliases.
    public var connectionAliases: [WorkSpacesClientTypes.ConnectionAlias]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        connectionAliases: [WorkSpacesClientTypes.ConnectionAlias]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionAliases = connectionAliases
        self.nextToken = nextToken
    }
}

public struct DescribeConnectionAliasPermissionsInput: Swift.Sendable {
    /// The identifier of the connection alias.
    /// This member is required.
    public var aliasId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        aliasId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeConnectionAliasPermissionsOutput: Swift.Sendable {
    /// The identifier of the connection alias.
    public var aliasId: Swift.String?
    /// The permissions associated with a connection alias.
    public var connectionAliasPermissions: [WorkSpacesClientTypes.ConnectionAliasPermission]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        aliasId: Swift.String? = nil,
        connectionAliasPermissions: [WorkSpacesClientTypes.ConnectionAliasPermission]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
        self.connectionAliasPermissions = connectionAliasPermissions
        self.nextToken = nextToken
    }
}

extension WorkSpacesClientTypes {

    public enum ImageAssociatedResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageAssociatedResourceType] {
            return [
                .application
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeImageAssociationsInput: Swift.Sendable {
    /// The resource types of the associated resource.
    /// This member is required.
    public var associatedResourceTypes: [WorkSpacesClientTypes.ImageAssociatedResourceType]?
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?

    public init(
        associatedResourceTypes: [WorkSpacesClientTypes.ImageAssociatedResourceType]? = nil,
        imageId: Swift.String? = nil
    )
    {
        self.associatedResourceTypes = associatedResourceTypes
        self.imageId = imageId
    }
}

extension WorkSpacesClientTypes {

    /// Describes the association between an application and an image resource.
    public struct ImageResourceAssociation: Swift.Sendable {
        /// The identifier of the associated resource.
        public var associatedResourceId: Swift.String?
        /// The resource type of the associated resources.
        public var associatedResourceType: WorkSpacesClientTypes.ImageAssociatedResourceType?
        /// The time the association is created.
        public var created: Foundation.Date?
        /// The identifier of the image.
        public var imageId: Swift.String?
        /// The time the association status was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The status of the image resource association.
        public var state: WorkSpacesClientTypes.AssociationState?
        /// The reason the association deployment failed.
        public var stateReason: WorkSpacesClientTypes.AssociationStateReason?

        public init(
            associatedResourceId: Swift.String? = nil,
            associatedResourceType: WorkSpacesClientTypes.ImageAssociatedResourceType? = nil,
            created: Foundation.Date? = nil,
            imageId: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            state: WorkSpacesClientTypes.AssociationState? = nil,
            stateReason: WorkSpacesClientTypes.AssociationStateReason? = nil
        )
        {
            self.associatedResourceId = associatedResourceId
            self.associatedResourceType = associatedResourceType
            self.created = created
            self.imageId = imageId
            self.lastUpdatedTime = lastUpdatedTime
            self.state = state
            self.stateReason = stateReason
        }
    }
}

public struct DescribeImageAssociationsOutput: Swift.Sendable {
    /// List of information about the specified associations.
    public var associations: [WorkSpacesClientTypes.ImageResourceAssociation]?

    public init(
        associations: [WorkSpacesClientTypes.ImageResourceAssociation]? = nil
    )
    {
        self.associations = associations
    }
}

public struct DescribeIpGroupsInput: Swift.Sendable {
    /// The identifiers of one or more IP access control groups.
    public var groupIds: [Swift.String]?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        groupIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupIds = groupIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WorkSpacesClientTypes {

    /// Describes an IP access control group.
    public struct WorkspacesIpGroup: Swift.Sendable {
        /// The description of the group.
        public var groupDesc: Swift.String?
        /// The identifier of the group.
        public var groupId: Swift.String?
        /// The name of the group.
        public var groupName: Swift.String?
        /// The rules.
        public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

        public init(
            groupDesc: Swift.String? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
        )
        {
            self.groupDesc = groupDesc
            self.groupId = groupId
            self.groupName = groupName
            self.userRules = userRules
        }
    }
}

public struct DescribeIpGroupsOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the IP access control groups.
    public var result: [WorkSpacesClientTypes.WorkspacesIpGroup]?

    public init(
        nextToken: Swift.String? = nil,
        result: [WorkSpacesClientTypes.WorkspacesIpGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.result = result
    }
}

public struct DescribeTagsInput: Swift.Sendable {
    /// The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces, registered directories, images, custom bundles, IP access control groups, and connection aliases.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

public struct DescribeTagsOutput: Swift.Sendable {
    /// The tags.
    public var tagList: [WorkSpacesClientTypes.Tag]?

    public init(
        tagList: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

public struct DescribeWorkspaceAssociationsInput: Swift.Sendable {
    /// The resource types of the associated resources.
    /// This member is required.
    public var associatedResourceTypes: [WorkSpacesClientTypes.WorkSpaceAssociatedResourceType]?
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        associatedResourceTypes: [WorkSpacesClientTypes.WorkSpaceAssociatedResourceType]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.associatedResourceTypes = associatedResourceTypes
        self.workspaceId = workspaceId
    }
}

public struct DescribeWorkspaceAssociationsOutput: Swift.Sendable {
    /// List of information about the specified associations.
    public var associations: [WorkSpacesClientTypes.WorkspaceResourceAssociation]?

    public init(
        associations: [WorkSpacesClientTypes.WorkspaceResourceAssociation]? = nil
    )
    {
        self.associations = associations
    }
}

public struct DescribeWorkspaceBundlesInput: Swift.Sendable {
    /// The identifiers of the bundles. You cannot combine this parameter with any other filter.
    public var bundleIds: [Swift.String]?
    /// The token for the next set of results. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The owner of the bundles. You cannot combine this parameter with any other filter. To describe the bundles provided by Amazon Web Services, specify AMAZON. To describe the bundles that belong to your account, don't specify a value.
    public var owner: Swift.String?

    public init(
        bundleIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        owner: Swift.String? = nil
    )
    {
        self.bundleIds = bundleIds
        self.nextToken = nextToken
        self.owner = owner
    }
}

public struct DescribeWorkspaceBundlesOutput: Swift.Sendable {
    /// Information about the bundles.
    public var bundles: [WorkSpacesClientTypes.WorkspaceBundle]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return. This token is valid for one day and must be used within that time frame.
    public var nextToken: Swift.String?

    public init(
        bundles: [WorkSpacesClientTypes.WorkspaceBundle]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bundles = bundles
        self.nextToken = nextToken
    }
}

extension WorkSpacesClientTypes {

    public enum DescribeWorkspaceDirectoriesFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case userIdentityType
        case workspaceType
        case sdkUnknown(Swift.String)

        public static var allCases: [DescribeWorkspaceDirectoriesFilterName] {
            return [
                .userIdentityType,
                .workspaceType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .userIdentityType: return "USER_IDENTITY_TYPE"
            case .workspaceType: return "WORKSPACE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the filter conditions for the WorkSpaces to return.
    public struct DescribeWorkspaceDirectoriesFilter: Swift.Sendable {
        /// The name of the WorkSpaces to filter.
        /// This member is required.
        public var name: WorkSpacesClientTypes.DescribeWorkspaceDirectoriesFilterName?
        /// The values for filtering WorkSpaces
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: WorkSpacesClientTypes.DescribeWorkspaceDirectoriesFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeWorkspaceDirectoriesInput: Swift.Sendable {
    /// The identifiers of the directories. If the value is null, all directories are retrieved.
    public var directoryIds: [Swift.String]?
    /// The filter condition for the WorkSpaces.
    public var filters: [WorkSpacesClientTypes.DescribeWorkspaceDirectoriesFilter]?
    /// The maximum number of directories to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The names of the WorkSpace directories.
    public var workspaceDirectoryNames: [Swift.String]?

    public init(
        directoryIds: [Swift.String]? = nil,
        filters: [WorkSpacesClientTypes.DescribeWorkspaceDirectoriesFilter]? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceDirectoryNames: [Swift.String]? = nil
    )
    {
        self.directoryIds = directoryIds
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.workspaceDirectoryNames = workspaceDirectoryNames
    }
}

extension WorkSpacesClientTypes {

    public enum WorkspaceDirectoryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case adConnector
        case awsIamIdentityCenter
        case customerManaged
        case simpleAd
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceDirectoryType] {
            return [
                .adConnector,
                .awsIamIdentityCenter,
                .customerManaged,
                .simpleAd
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .adConnector: return "AD_CONNECTOR"
            case .awsIamIdentityCenter: return "AWS_IAM_IDENTITY_CENTER"
            case .customerManaged: return "CUSTOMER_MANAGED"
            case .simpleAd: return "SIMPLE_AD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Specifies the configurations of the identity center.
    public struct IDCConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the application.
        public var applicationArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the identity center instance.
        public var instanceArn: Swift.String?

        public init(
            applicationArn: Swift.String? = nil,
            instanceArn: Swift.String? = nil
        )
        {
            self.applicationArn = applicationArn
            self.instanceArn = instanceArn
        }
    }
}

extension WorkSpacesClientTypes {

    /// Specifies the configurations of the Microsoft Entra.
    public struct MicrosoftEntraConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the application config.
        public var applicationConfigSecretArn: Swift.String?
        /// The identifier of the tenant.
        public var tenantId: Swift.String?

        public init(
            applicationConfigSecretArn: Swift.String? = nil,
            tenantId: Swift.String? = nil
        )
        {
            self.applicationConfigSecretArn = applicationConfigSecretArn
            self.tenantId = tenantId
        }
    }
}

extension WorkSpacesClientTypes {

    public enum SamlStatusEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case enabledWithDirectoryLoginFallback
        case sdkUnknown(Swift.String)

        public static var allCases: [SamlStatusEnum] {
            return [
                .disabled,
                .enabled,
                .enabledWithDirectoryLoginFallback
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .enabledWithDirectoryLoginFallback: return "ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the enablement status, user access URL, and relay state parameter name that are used for configuring federation with an SAML 2.0 identity provider.
    public struct SamlProperties: Swift.Sendable {
        /// The relay state parameter name supported by the SAML 2.0 identity provider (IdP). When the end user is redirected to the user access URL from the WorkSpaces client application, this relay state parameter name is appended as a query parameter to the URL along with the relay state endpoint to return the user to the client application session. To use SAML 2.0 authentication with WorkSpaces, the IdP must support IdP-initiated deep linking for the relay state URL. Consult your IdP documentation for more information.
        public var relayStateParameterName: Swift.String?
        /// Indicates the status of SAML 2.0 authentication. These statuses include the following.
        ///
        /// * If the setting is DISABLED, end users will be directed to login with their directory credentials.
        ///
        /// * If the setting is ENABLED, end users will be directed to login via the user access URL. Users attempting to connect to WorkSpaces from a client application that does not support SAML 2.0 authentication will not be able to connect.
        ///
        /// * If the setting is ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK, end users will be directed to login via the user access URL on supported client applications, but will not prevent clients that do not support SAML 2.0 authentication from connecting as if SAML 2.0 authentication was disabled.
        public var status: WorkSpacesClientTypes.SamlStatusEnum?
        /// The SAML 2.0 identity provider (IdP) user access URL is the URL a user would navigate to in their web browser in order to federate from the IdP and directly access the application, without any SAML 2.0 service provider (SP) bindings.
        public var userAccessUrl: Swift.String?

        public init(
            relayStateParameterName: Swift.String? = nil,
            status: WorkSpacesClientTypes.SamlStatusEnum? = nil,
            userAccessUrl: Swift.String? = nil
        )
        {
            self.relayStateParameterName = relayStateParameterName
            self.status = status
            self.userAccessUrl = userAccessUrl
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the self-service permissions for a directory. For more information, see [Enable Self-Service WorkSpace Management Capabilities for Your Users](https://docs.aws.amazon.com/workspaces/latest/adminguide/enable-user-self-service-workspace-management.html).
    public struct SelfservicePermissions: Swift.Sendable {
        /// Specifies whether users can change the compute type (bundle) for their WorkSpace.
        public var changeComputeType: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can increase the volume size of the drives on their WorkSpace.
        public var increaseVolumeSize: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can rebuild the operating system of a WorkSpace to its original state.
        public var rebuildWorkspace: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can restart their WorkSpace.
        public var restartWorkspace: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can switch the running mode of their WorkSpace.
        public var switchRunningMode: WorkSpacesClientTypes.ReconnectEnum?

        public init(
            changeComputeType: WorkSpacesClientTypes.ReconnectEnum? = nil,
            increaseVolumeSize: WorkSpacesClientTypes.ReconnectEnum? = nil,
            rebuildWorkspace: WorkSpacesClientTypes.ReconnectEnum? = nil,
            restartWorkspace: WorkSpacesClientTypes.ReconnectEnum? = nil,
            switchRunningMode: WorkSpacesClientTypes.ReconnectEnum? = nil
        )
        {
            self.changeComputeType = changeComputeType
            self.increaseVolumeSize = increaseVolumeSize
            self.rebuildWorkspace = rebuildWorkspace
            self.restartWorkspace = restartWorkspace
            self.switchRunningMode = switchRunningMode
        }
    }
}

extension WorkSpacesClientTypes {

    public enum WorkspaceDirectoryState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deregistered
        case deregistering
        case error
        case registered
        case registering
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceDirectoryState] {
            return [
                .deregistered,
                .deregistering,
                .error,
                .registered,
                .registering
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deregistered: return "DEREGISTERED"
            case .deregistering: return "DEREGISTERING"
            case .error: return "ERROR"
            case .registered: return "REGISTERED"
            case .registering: return "REGISTERING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum StorageConnectorTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case homeFolder
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageConnectorTypeEnum] {
            return [
                .homeFolder
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .homeFolder: return "HOME_FOLDER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum StorageConnectorStatusEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageConnectorStatusEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the storage connector.
    public struct StorageConnector: Swift.Sendable {
        /// The type of connector used to save user files.
        /// This member is required.
        public var connectorType: WorkSpacesClientTypes.StorageConnectorTypeEnum?
        /// Indicates if the storage connetor is enabled or disabled.
        /// This member is required.
        public var status: WorkSpacesClientTypes.StorageConnectorStatusEnum?

        public init(
            connectorType: WorkSpacesClientTypes.StorageConnectorTypeEnum? = nil,
            status: WorkSpacesClientTypes.StorageConnectorStatusEnum? = nil
        )
        {
            self.connectorType = connectorType
            self.status = status
        }
    }
}

extension WorkSpacesClientTypes {

    public enum StreamingExperiencePreferredProtocolEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingExperiencePreferredProtocolEnum] {
            return [
                .tcp,
                .udp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum UserSettingActionEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case clipboardCopyFromLocalDevice
        case clipboardCopyToLocalDevice
        case printingToLocalDevice
        case smartCard
        case sdkUnknown(Swift.String)

        public static var allCases: [UserSettingActionEnum] {
            return [
                .clipboardCopyFromLocalDevice,
                .clipboardCopyToLocalDevice,
                .printingToLocalDevice,
                .smartCard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .clipboardCopyFromLocalDevice: return "CLIPBOARD_COPY_FROM_LOCAL_DEVICE"
            case .clipboardCopyToLocalDevice: return "CLIPBOARD_COPY_TO_LOCAL_DEVICE"
            case .printingToLocalDevice: return "PRINTING_TO_LOCAL_DEVICE"
            case .smartCard: return "SMART_CARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum UserSettingPermissionEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [UserSettingPermissionEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Information about the user's permission settings.
    public struct UserSetting: Swift.Sendable {
        /// Indicates the type of action.
        /// This member is required.
        public var action: WorkSpacesClientTypes.UserSettingActionEnum?
        /// Indicates the maximum character length for the specified user setting.
        public var maximumLength: Swift.Int?
        /// Indicates if the setting is enabled or disabled.
        /// This member is required.
        public var permission: WorkSpacesClientTypes.UserSettingPermissionEnum?

        public init(
            action: WorkSpacesClientTypes.UserSettingActionEnum? = nil,
            maximumLength: Swift.Int? = nil,
            permission: WorkSpacesClientTypes.UserSettingPermissionEnum? = nil
        )
        {
            self.action = action
            self.maximumLength = maximumLength
            self.permission = permission
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the streaming properties.
    public struct StreamingProperties: Swift.Sendable {
        /// Indicates the storage connector used
        public var storageConnectors: [WorkSpacesClientTypes.StorageConnector]?
        /// Indicates the type of preferred protocol for the streaming experience.
        public var streamingExperiencePreferredProtocol: WorkSpacesClientTypes.StreamingExperiencePreferredProtocolEnum?
        /// Indicates the permission settings asscoiated with the user.
        public var userSettings: [WorkSpacesClientTypes.UserSetting]?

        public init(
            storageConnectors: [WorkSpacesClientTypes.StorageConnector]? = nil,
            streamingExperiencePreferredProtocol: WorkSpacesClientTypes.StreamingExperiencePreferredProtocolEnum? = nil,
            userSettings: [WorkSpacesClientTypes.UserSetting]? = nil
        )
        {
            self.storageConnectors = storageConnectors
            self.streamingExperiencePreferredProtocol = streamingExperiencePreferredProtocol
            self.userSettings = userSettings
        }
    }
}

extension WorkSpacesClientTypes {

    public enum Tenancy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dedicated
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [Tenancy] {
            return [
                .dedicated,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "DEDICATED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum UserIdentityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsDirectoryService
        case awsIamIdentityCenter
        case customerManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [UserIdentityType] {
            return [
                .awsDirectoryService,
                .awsIamIdentityCenter,
                .customerManaged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsDirectoryService: return "AWS_DIRECTORY_SERVICE"
            case .awsIamIdentityCenter: return "AWS_IAM_IDENTITY_CENTER"
            case .customerManaged: return "CUSTOMER_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// The device types and operating systems that can be used to access a WorkSpace. For more information, see [Amazon WorkSpaces Client Network Requirements](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-network-requirements.html).
    public struct WorkspaceAccessProperties: Swift.Sendable {
        /// Indicates whether users can use Android and Android-compatible Chrome OS devices to access their WorkSpaces.
        public var deviceTypeAndroid: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use Chromebooks to access their WorkSpaces.
        public var deviceTypeChromeOs: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use iOS devices to access their WorkSpaces.
        public var deviceTypeIos: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use Linux clients to access their WorkSpaces.
        public var deviceTypeLinux: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use macOS clients to access their WorkSpaces.
        public var deviceTypeOsx: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can access their WorkSpaces through a web browser.
        public var deviceTypeWeb: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use Windows clients to access their WorkSpaces.
        public var deviceTypeWindows: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use zero client devices to access their WorkSpaces.
        public var deviceTypeZeroClient: WorkSpacesClientTypes.AccessPropertyValue?

        public init(
            deviceTypeAndroid: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeChromeOs: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeIos: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeLinux: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeOsx: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeWeb: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeWindows: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeZeroClient: WorkSpacesClientTypes.AccessPropertyValue? = nil
        )
        {
            self.deviceTypeAndroid = deviceTypeAndroid
            self.deviceTypeChromeOs = deviceTypeChromeOs
            self.deviceTypeIos = deviceTypeIos
            self.deviceTypeLinux = deviceTypeLinux
            self.deviceTypeOsx = deviceTypeOsx
            self.deviceTypeWeb = deviceTypeWeb
            self.deviceTypeWindows = deviceTypeWindows
            self.deviceTypeZeroClient = deviceTypeZeroClient
        }
    }
}

extension WorkSpacesClientTypes {

    public enum WorkspaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case personal
        case pools
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceType] {
            return [
                .personal,
                .pools
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .personal: return "PERSONAL"
            case .pools: return "POOLS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a directory that is used with Amazon WorkSpaces.
    public struct WorkspaceDirectory: Swift.Sendable {
        /// Information about the Active Directory config.
        public var activeDirectoryConfig: WorkSpacesClientTypes.ActiveDirectoryConfig?
        /// The directory alias.
        public var alias: Swift.String?
        /// The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory for WorkSpaces login.
        public var certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties?
        /// The user name for the service account.
        public var customerUserName: Swift.String?
        /// The directory identifier.
        public var directoryId: Swift.String?
        /// The name of the directory.
        public var directoryName: Swift.String?
        /// The directory type.
        public var directoryType: WorkSpacesClientTypes.WorkspaceDirectoryType?
        /// The IP addresses of the DNS servers for the directory.
        public var dnsIpAddresses: [Swift.String]?
        /// The error message returned.
        public var errorMessage: Swift.String?
        /// The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.
        public var iamRoleId: Swift.String?
        /// Specifies details about identity center configurations.
        public var idcConfig: WorkSpacesClientTypes.IDCConfig?
        /// The identifiers of the IP access control groups associated with the directory.
        public var ipGroupIds: [Swift.String]?
        /// Specifies details about Microsoft Entra configurations.
        public var microsoftEntraConfig: WorkSpacesClientTypes.MicrosoftEntraConfig?
        /// The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.
        public var registrationCode: Swift.String?
        /// Describes the enablement status, user access URL, and relay state parameter name that are used for configuring federation with an SAML 2.0 identity provider.
        public var samlProperties: WorkSpacesClientTypes.SamlProperties?
        /// The default self-service permissions for WorkSpaces in the directory.
        public var selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions?
        /// The state of the directory's registration with Amazon WorkSpaces. After a directory is deregistered, the DEREGISTERED state is returned very briefly before the directory metadata is cleaned up, so this state is rarely returned. To confirm that a directory is deregistered, check for the directory ID by using [ DescribeWorkspaceDirectories](https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaceDirectories.html). If the directory ID isn't returned, then the directory has been successfully deregistered.
        public var state: WorkSpacesClientTypes.WorkspaceDirectoryState?
        /// The streaming properties to configure.
        public var streamingProperties: WorkSpacesClientTypes.StreamingProperties?
        /// The identifiers of the subnets used with the directory.
        public var subnetIds: [Swift.String]?
        /// Specifies whether the directory is dedicated or shared. To use Bring Your Own License (BYOL), this value must be set to DEDICATED. For more information, see [Bring Your Own Windows Desktop Images](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
        public var tenancy: WorkSpacesClientTypes.Tenancy?
        /// Indicates the identity type of the specifired user.
        public var userIdentityType: WorkSpacesClientTypes.UserIdentityType?
        /// The devices and operating systems that users can use to access WorkSpaces.
        public var workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties?
        /// The default creation properties for all WorkSpaces in the directory.
        public var workspaceCreationProperties: WorkSpacesClientTypes.DefaultWorkspaceCreationProperties?
        /// The description of the WorkSpace directory
        public var workspaceDirectoryDescription: Swift.String?
        /// The name fo the WorkSpace directory.
        public var workspaceDirectoryName: Swift.String?
        /// The identifier of the security group that is assigned to new WorkSpaces.
        public var workspaceSecurityGroupId: Swift.String?
        /// Indicates whether the directory's WorkSpace type is personal or pools.
        public var workspaceType: WorkSpacesClientTypes.WorkspaceType?

        public init(
            activeDirectoryConfig: WorkSpacesClientTypes.ActiveDirectoryConfig? = nil,
            alias: Swift.String? = nil,
            certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties? = nil,
            customerUserName: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            directoryName: Swift.String? = nil,
            directoryType: WorkSpacesClientTypes.WorkspaceDirectoryType? = nil,
            dnsIpAddresses: [Swift.String]? = nil,
            errorMessage: Swift.String? = nil,
            iamRoleId: Swift.String? = nil,
            idcConfig: WorkSpacesClientTypes.IDCConfig? = nil,
            ipGroupIds: [Swift.String]? = nil,
            microsoftEntraConfig: WorkSpacesClientTypes.MicrosoftEntraConfig? = nil,
            registrationCode: Swift.String? = nil,
            samlProperties: WorkSpacesClientTypes.SamlProperties? = nil,
            selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions? = nil,
            state: WorkSpacesClientTypes.WorkspaceDirectoryState? = nil,
            streamingProperties: WorkSpacesClientTypes.StreamingProperties? = nil,
            subnetIds: [Swift.String]? = nil,
            tenancy: WorkSpacesClientTypes.Tenancy? = nil,
            userIdentityType: WorkSpacesClientTypes.UserIdentityType? = nil,
            workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties? = nil,
            workspaceCreationProperties: WorkSpacesClientTypes.DefaultWorkspaceCreationProperties? = nil,
            workspaceDirectoryDescription: Swift.String? = nil,
            workspaceDirectoryName: Swift.String? = nil,
            workspaceSecurityGroupId: Swift.String? = nil,
            workspaceType: WorkSpacesClientTypes.WorkspaceType? = nil
        )
        {
            self.activeDirectoryConfig = activeDirectoryConfig
            self.alias = alias
            self.certificateBasedAuthProperties = certificateBasedAuthProperties
            self.customerUserName = customerUserName
            self.directoryId = directoryId
            self.directoryName = directoryName
            self.directoryType = directoryType
            self.dnsIpAddresses = dnsIpAddresses
            self.errorMessage = errorMessage
            self.iamRoleId = iamRoleId
            self.idcConfig = idcConfig
            self.ipGroupIds = ipGroupIds
            self.microsoftEntraConfig = microsoftEntraConfig
            self.registrationCode = registrationCode
            self.samlProperties = samlProperties
            self.selfservicePermissions = selfservicePermissions
            self.state = state
            self.streamingProperties = streamingProperties
            self.subnetIds = subnetIds
            self.tenancy = tenancy
            self.userIdentityType = userIdentityType
            self.workspaceAccessProperties = workspaceAccessProperties
            self.workspaceCreationProperties = workspaceCreationProperties
            self.workspaceDirectoryDescription = workspaceDirectoryDescription
            self.workspaceDirectoryName = workspaceDirectoryName
            self.workspaceSecurityGroupId = workspaceSecurityGroupId
            self.workspaceType = workspaceType
        }
    }
}

public struct DescribeWorkspaceDirectoriesOutput: Swift.Sendable {
    /// Information about the directories.
    public var directories: [WorkSpacesClientTypes.WorkspaceDirectory]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        directories: [WorkSpacesClientTypes.WorkspaceDirectory]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directories = directories
        self.nextToken = nextToken
    }
}

public struct DescribeWorkspaceImagePermissionsInput: Swift.Sendable {
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        imageId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WorkSpacesClientTypes {

    /// Describes the Amazon Web Services accounts that have been granted permission to use a shared image. For more information about sharing images, see [ Share or Unshare a Custom WorkSpaces Image](https://docs.aws.amazon.com/workspaces/latest/adminguide/share-custom-image.html).
    public struct ImagePermission: Swift.Sendable {
        /// The identifier of the Amazon Web Services account that an image has been shared with.
        public var sharedAccountId: Swift.String?

        public init(
            sharedAccountId: Swift.String? = nil
        )
        {
            self.sharedAccountId = sharedAccountId
        }
    }
}

public struct DescribeWorkspaceImagePermissionsOutput: Swift.Sendable {
    /// The identifier of the image.
    public var imageId: Swift.String?
    /// The identifiers of the Amazon Web Services accounts that the image has been shared with.
    public var imagePermissions: [WorkSpacesClientTypes.ImagePermission]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        imageId: Swift.String? = nil,
        imagePermissions: [WorkSpacesClientTypes.ImagePermission]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.imagePermissions = imagePermissions
        self.nextToken = nextToken
    }
}

extension WorkSpacesClientTypes {

    public enum ImageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case owned
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageType] {
            return [
                .owned,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .owned: return "OWNED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeWorkspaceImagesInput: Swift.Sendable {
    /// The identifier of the image.
    public var imageIds: [Swift.String]?
    /// The type (owned or shared) of the image.
    public var imageType: WorkSpacesClientTypes.ImageType?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        imageIds: [Swift.String]? = nil,
        imageType: WorkSpacesClientTypes.ImageType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageIds = imageIds
        self.imageType = imageType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WorkSpacesClientTypes {

    public enum WorkspaceImageErrorDetailCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case additionalDrivesAttached
        case antiVirusInstalled
        case appxPackagesInstalled
        case autoLogonEnabled
        case autoMountDisabled
        case azureDomainJoined
        case dhcpDisabled
        case diskFreeSpace
        case diskSizeExceeded
        case domainJoined
        case firewallEnabled
        case incompatiblePartitioning
        case inPlaceUpgrade
        case multipleBootPartition
        case officeInstalled
        case osNotSupported
        case outdatedPowershellVersion
        case pcoipAgentInstalled
        case pendingReboot
        case realtimeUniversalDisabled
        case reservedStorageInUse
        case sixtyFourBitOs
        case uefiNotSupported
        case unknownError
        case vmwareToolsInstalled
        case windowsUpdatesEnabled
        case workspacesByolAccountDisabled
        case workspacesByolAccountNotFound
        case zeroRearmCount
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageErrorDetailCode] {
            return [
                .additionalDrivesAttached,
                .antiVirusInstalled,
                .appxPackagesInstalled,
                .autoLogonEnabled,
                .autoMountDisabled,
                .azureDomainJoined,
                .dhcpDisabled,
                .diskFreeSpace,
                .diskSizeExceeded,
                .domainJoined,
                .firewallEnabled,
                .incompatiblePartitioning,
                .inPlaceUpgrade,
                .multipleBootPartition,
                .officeInstalled,
                .osNotSupported,
                .outdatedPowershellVersion,
                .pcoipAgentInstalled,
                .pendingReboot,
                .realtimeUniversalDisabled,
                .reservedStorageInUse,
                .sixtyFourBitOs,
                .uefiNotSupported,
                .unknownError,
                .vmwareToolsInstalled,
                .windowsUpdatesEnabled,
                .workspacesByolAccountDisabled,
                .workspacesByolAccountNotFound,
                .zeroRearmCount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .additionalDrivesAttached: return "AdditionalDrivesAttached"
            case .antiVirusInstalled: return "AntiVirusInstalled"
            case .appxPackagesInstalled: return "AppXPackagesInstalled"
            case .autoLogonEnabled: return "AutoLogonEnabled"
            case .autoMountDisabled: return "AutoMountDisabled"
            case .azureDomainJoined: return "AzureDomainJoined"
            case .dhcpDisabled: return "DHCPDisabled"
            case .diskFreeSpace: return "DiskFreeSpace"
            case .diskSizeExceeded: return "DiskSizeExceeded"
            case .domainJoined: return "DomainJoined"
            case .firewallEnabled: return "FirewallEnabled"
            case .incompatiblePartitioning: return "IncompatiblePartitioning"
            case .inPlaceUpgrade: return "InPlaceUpgrade"
            case .multipleBootPartition: return "MultipleBootPartition"
            case .officeInstalled: return "OfficeInstalled"
            case .osNotSupported: return "OSNotSupported"
            case .outdatedPowershellVersion: return "OutdatedPowershellVersion"
            case .pcoipAgentInstalled: return "PCoIPAgentInstalled"
            case .pendingReboot: return "PendingReboot"
            case .realtimeUniversalDisabled: return "RealTimeUniversalDisabled"
            case .reservedStorageInUse: return "ReservedStorageInUse"
            case .sixtyFourBitOs: return "Requires64BitOS"
            case .uefiNotSupported: return "UEFINotSupported"
            case .unknownError: return "UnknownError"
            case .vmwareToolsInstalled: return "VMWareToolsInstalled"
            case .windowsUpdatesEnabled: return "WindowsUpdatesEnabled"
            case .workspacesByolAccountDisabled: return "WorkspacesBYOLAccountDisabled"
            case .workspacesByolAccountNotFound: return "WorkspacesBYOLAccountNotFound"
            case .zeroRearmCount: return "ZeroRearmCount"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes in-depth details about the error. These details include the possible causes of the error and troubleshooting information.
    public struct ErrorDetails: Swift.Sendable {
        /// Indicates the error code returned.
        public var errorCode: WorkSpacesClientTypes.WorkspaceImageErrorDetailCode?
        /// The text of the error message related the error code.
        public var errorMessage: Swift.String?

        public init(
            errorCode: WorkSpacesClientTypes.WorkspaceImageErrorDetailCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes whether a WorkSpace image needs to be updated with the latest drivers and other components required by Amazon WorkSpaces. Only Windows 10 WorkSpace images can be programmatically updated at this time.
    public struct UpdateResult: Swift.Sendable {
        /// A description of whether updates for the WorkSpace image are pending or available.
        public var description: Swift.String?
        /// Indicates whether updated drivers or other components are available for the specified WorkSpace image.
        public var updateAvailable: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            updateAvailable: Swift.Bool? = nil
        )
        {
            self.description = description
            self.updateAvailable = updateAvailable
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a WorkSpace image.
    public struct WorkspaceImage: Swift.Sendable {
        /// The date when the image was created. If the image has been shared, the Amazon Web Services account that the image has been shared with sees the original creation date of the image.
        public var created: Foundation.Date?
        /// The description of the image.
        public var description: Swift.String?
        /// The error code that is returned for the image.
        public var errorCode: Swift.String?
        /// Additional details of the error returned for the image, including the possible causes of the errors and troubleshooting information.
        public var errorDetails: [WorkSpacesClientTypes.ErrorDetails]?
        /// The text of the error message that is returned for the image.
        public var errorMessage: Swift.String?
        /// The identifier of the image.
        public var imageId: Swift.String?
        /// The name of the image.
        public var name: Swift.String?
        /// The operating system that the image is running.
        public var operatingSystem: WorkSpacesClientTypes.OperatingSystem?
        /// The identifier of the Amazon Web Services account that owns the image.
        public var ownerAccountId: Swift.String?
        /// Specifies whether the image is running on dedicated hardware. When Bring Your Own License (BYOL) is enabled, this value is set to DEDICATED. For more information, see [Bring Your Own Windows Desktop Images](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
        public var requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy?
        /// The status of the image.
        public var state: WorkSpacesClientTypes.WorkspaceImageState?
        /// The updates (if any) that are available for the specified image.
        public var updates: WorkSpacesClientTypes.UpdateResult?

        public init(
            created: Foundation.Date? = nil,
            description: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorDetails: [WorkSpacesClientTypes.ErrorDetails]? = nil,
            errorMessage: Swift.String? = nil,
            imageId: Swift.String? = nil,
            name: Swift.String? = nil,
            operatingSystem: WorkSpacesClientTypes.OperatingSystem? = nil,
            ownerAccountId: Swift.String? = nil,
            requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy? = nil,
            state: WorkSpacesClientTypes.WorkspaceImageState? = nil,
            updates: WorkSpacesClientTypes.UpdateResult? = nil
        )
        {
            self.created = created
            self.description = description
            self.errorCode = errorCode
            self.errorDetails = errorDetails
            self.errorMessage = errorMessage
            self.imageId = imageId
            self.name = name
            self.operatingSystem = operatingSystem
            self.ownerAccountId = ownerAccountId
            self.requiredTenancy = requiredTenancy
            self.state = state
            self.updates = updates
        }
    }
}

public struct DescribeWorkspaceImagesOutput: Swift.Sendable {
    /// Information about the images.
    public var images: [WorkSpacesClientTypes.WorkspaceImage]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        images: [WorkSpacesClientTypes.WorkspaceImage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.images = images
        self.nextToken = nextToken
    }
}

public struct DescribeWorkspacesInput: Swift.Sendable {
    /// The identifier of the bundle. All WorkSpaces that are created from this bundle are retrieved. You cannot combine this parameter with any other filter.
    public var bundleId: Swift.String?
    /// The identifier of the directory. In addition, you can optionally specify a specific directory user (see UserName). You cannot combine this parameter with any other filter.
    public var directoryId: Swift.String?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The name of the directory user. You must specify this parameter with DirectoryId.
    public var userName: Swift.String?
    /// The identifiers of the WorkSpaces. You cannot combine this parameter with any other filter. Because the [CreateWorkspaces] operation is asynchronous, the identifier it returns is not immediately available. If you immediately call [DescribeWorkspaces] with this identifier, no information is returned.
    public var workspaceIds: [Swift.String]?
    /// The name of the user-decoupled WorkSpace.
    public var workspaceName: Swift.String?

    public init(
        bundleId: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userName: Swift.String? = nil,
        workspaceIds: [Swift.String]? = nil,
        workspaceName: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
        self.userName = userName
        self.workspaceIds = workspaceIds
        self.workspaceName = workspaceName
    }
}

public struct DescribeWorkspacesOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the WorkSpaces. Because [CreateWorkspaces] is an asynchronous operation, some of the returned information could be incomplete.
    public var workspaces: [WorkSpacesClientTypes.Workspace]?

    public init(
        nextToken: Swift.String? = nil,
        workspaces: [WorkSpacesClientTypes.Workspace]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaces = workspaces
    }
}

public struct DescribeWorkspacesConnectionStatusInput: Swift.Sendable {
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The identifiers of the WorkSpaces. You can specify up to 25 WorkSpaces.
    public var workspaceIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        workspaceIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaceIds = workspaceIds
    }
}

extension WorkSpacesClientTypes {

    /// Describes the connection status of a WorkSpace.
    public struct WorkspaceConnectionStatus: Swift.Sendable {
        /// The connection state of the WorkSpace. The connection state is unknown if the WorkSpace is stopped.
        public var connectionState: WorkSpacesClientTypes.ConnectionState?
        /// The timestamp of the connection status check.
        public var connectionStateCheckTimestamp: Foundation.Date?
        /// The timestamp of the last known user connection.
        public var lastKnownUserConnectionTimestamp: Foundation.Date?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            connectionState: WorkSpacesClientTypes.ConnectionState? = nil,
            connectionStateCheckTimestamp: Foundation.Date? = nil,
            lastKnownUserConnectionTimestamp: Foundation.Date? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.connectionState = connectionState
            self.connectionStateCheckTimestamp = connectionStateCheckTimestamp
            self.lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestamp
            self.workspaceId = workspaceId
        }
    }
}

public struct DescribeWorkspacesConnectionStatusOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the connection status of the WorkSpace.
    public var workspacesConnectionStatus: [WorkSpacesClientTypes.WorkspaceConnectionStatus]?

    public init(
        nextToken: Swift.String? = nil,
        workspacesConnectionStatus: [WorkSpacesClientTypes.WorkspaceConnectionStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspacesConnectionStatus = workspacesConnectionStatus
    }
}

public struct DescribeWorkspaceSnapshotsInput: Swift.Sendable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

extension WorkSpacesClientTypes {

    /// Describes a snapshot.
    public struct Snapshot: Swift.Sendable {
        /// The time when the snapshot was created.
        public var snapshotTime: Foundation.Date?

        public init(
            snapshotTime: Foundation.Date? = nil
        )
        {
            self.snapshotTime = snapshotTime
        }
    }
}

public struct DescribeWorkspaceSnapshotsOutput: Swift.Sendable {
    /// Information about the snapshots that can be used to rebuild a WorkSpace. These snapshots include the user volume.
    public var rebuildSnapshots: [WorkSpacesClientTypes.Snapshot]?
    /// Information about the snapshots that can be used to restore a WorkSpace. These snapshots include both the root volume and the user volume.
    public var restoreSnapshots: [WorkSpacesClientTypes.Snapshot]?

    public init(
        rebuildSnapshots: [WorkSpacesClientTypes.Snapshot]? = nil,
        restoreSnapshots: [WorkSpacesClientTypes.Snapshot]? = nil
    )
    {
        self.rebuildSnapshots = rebuildSnapshots
        self.restoreSnapshots = restoreSnapshots
    }
}

extension WorkSpacesClientTypes {

    public enum DescribeWorkspacesPoolsFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case poolname
        case sdkUnknown(Swift.String)

        public static var allCases: [DescribeWorkspacesPoolsFilterName] {
            return [
                .poolname
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .poolname: return "PoolName"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    public enum DescribeWorkspacesPoolsFilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case equals
        case notcontains
        case notequals
        case sdkUnknown(Swift.String)

        public static var allCases: [DescribeWorkspacesPoolsFilterOperator] {
            return [
                .contains,
                .equals,
                .notcontains,
                .notequals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .notcontains: return "NOTCONTAINS"
            case .notequals: return "NOTEQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the filter conditions for WorkSpaces Pools to return.
    public struct DescribeWorkspacesPoolsFilter: Swift.Sendable {
        /// The name of the pool to filter.
        /// This member is required.
        public var name: WorkSpacesClientTypes.DescribeWorkspacesPoolsFilterName?
        /// The operator values for filtering WorkSpaces Pools.
        /// This member is required.
        public var `operator`: WorkSpacesClientTypes.DescribeWorkspacesPoolsFilterOperator?
        /// The values for filtering WorkSpaces Pools.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: WorkSpacesClientTypes.DescribeWorkspacesPoolsFilterName? = nil,
            `operator`: WorkSpacesClientTypes.DescribeWorkspacesPoolsFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }
}

public struct DescribeWorkspacesPoolsInput: Swift.Sendable {
    /// The filter conditions for the WorkSpaces Pool to return.
    public var filters: [WorkSpacesClientTypes.DescribeWorkspacesPoolsFilter]?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the WorkSpaces Pools.
    public var poolIds: [Swift.String]?

    public init(
        filters: [WorkSpacesClientTypes.DescribeWorkspacesPoolsFilter]? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        poolIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.poolIds = poolIds
    }
}

public struct DescribeWorkspacesPoolsOutput: Swift.Sendable {
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// Information about the WorkSpaces Pools.
    public var workspacesPools: [WorkSpacesClientTypes.WorkspacesPool]?

    public init(
        nextToken: Swift.String? = nil,
        workspacesPools: [WorkSpacesClientTypes.WorkspacesPool]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspacesPools = workspacesPools
    }
}

public struct DescribeWorkspacesPoolSessionsInput: Swift.Sendable {
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the pool.
    /// This member is required.
    public var poolId: Swift.String?
    /// The identifier of the user.
    public var userId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        poolId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.poolId = poolId
        self.userId = userId
    }
}

extension WorkSpacesClientTypes {

    public enum SessionConnectionState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionConnectionState] {
            return [
                .connected,
                .notConnected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .notConnected: return "NOT_CONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes the network details of a WorkSpaces Pool.
    public struct NetworkAccessConfiguration: Swift.Sendable {
        /// The resource identifier of the elastic network interface that is attached to instances in your VPC. All network interfaces have the eni-xxxxxxxx resource identifier.
        public var eniId: Swift.String?
        /// The private IP address of the elastic network interface that is attached to instances in your VPC.
        public var eniPrivateIpAddress: Swift.String?

        public init(
            eniId: Swift.String? = nil,
            eniPrivateIpAddress: Swift.String? = nil
        )
        {
            self.eniId = eniId
            self.eniPrivateIpAddress = eniPrivateIpAddress
        }
    }
}

extension WorkSpacesClientTypes {

    /// Describes a pool session.
    public struct WorkspacesPoolSession: Swift.Sendable {
        /// The authentication method. The user is authenticated using a WorkSpaces Pools URL (API) or SAML 2.0 federation (SAML).
        public var authenticationType: WorkSpacesClientTypes.AuthenticationType?
        /// Specifies whether a user is connected to the pool session.
        public var connectionState: WorkSpacesClientTypes.SessionConnectionState?
        /// The time that the pool session ended.
        public var expirationTime: Foundation.Date?
        /// The identifier for the instance hosting the session.
        public var instanceId: Swift.String?
        /// Describes the network details of the pool.
        public var networkAccessConfiguration: WorkSpacesClientTypes.NetworkAccessConfiguration?
        /// The identifier of the pool.
        /// This member is required.
        public var poolId: Swift.String?
        /// The identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The time that the pool sission started.
        public var startTime: Foundation.Date?
        /// The identifier of the user.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            authenticationType: WorkSpacesClientTypes.AuthenticationType? = nil,
            connectionState: WorkSpacesClientTypes.SessionConnectionState? = nil,
            expirationTime: Foundation.Date? = nil,
            instanceId: Swift.String? = nil,
            networkAccessConfiguration: WorkSpacesClientTypes.NetworkAccessConfiguration? = nil,
            poolId: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            userId: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.connectionState = connectionState
            self.expirationTime = expirationTime
            self.instanceId = instanceId
            self.networkAccessConfiguration = networkAccessConfiguration
            self.poolId = poolId
            self.sessionId = sessionId
            self.startTime = startTime
            self.userId = userId
        }
    }
}

public struct DescribeWorkspacesPoolSessionsOutput: Swift.Sendable {
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// Describes the pool sessions.
    public var sessions: [WorkSpacesClientTypes.WorkspacesPoolSession]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [WorkSpacesClientTypes.WorkspacesPoolSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

public struct DisassociateConnectionAliasInput: Swift.Sendable {
    /// The identifier of the connection alias to disassociate.
    /// This member is required.
    public var aliasId: Swift.String?

    public init(
        aliasId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

public struct DisassociateConnectionAliasOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateIpGroupsInput: Swift.Sendable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The identifiers of one or more IP access control groups.
    /// This member is required.
    public var groupIds: [Swift.String]?

    public init(
        directoryId: Swift.String? = nil,
        groupIds: [Swift.String]? = nil
    )
    {
        self.directoryId = directoryId
        self.groupIds = groupIds
    }
}

public struct DisassociateIpGroupsOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateWorkspaceApplicationInput: Swift.Sendable {
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.workspaceId = workspaceId
    }
}

public struct DisassociateWorkspaceApplicationOutput: Swift.Sendable {
    /// Information about the targeted association.
    public var association: WorkSpacesClientTypes.WorkspaceResourceAssociation?

    public init(
        association: WorkSpacesClientTypes.WorkspaceResourceAssociation? = nil
    )
    {
        self.association = association
    }
}

extension WorkSpacesClientTypes {

    /// Describes a WorkSpace that could not be rebooted. ([RebootWorkspaces]), rebuilt ([RebuildWorkspaces]), restored ([RestoreWorkspace]), terminated ([TerminateWorkspaces]), started ([StartWorkspaces]), or stopped ([StopWorkspaces]).
    public struct FailedWorkspaceChangeRequest: Swift.Sendable {
        /// The error code that is returned if the WorkSpace cannot be rebooted.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the WorkSpace cannot be rebooted.
        public var errorMessage: Swift.String?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.workspaceId = workspaceId
        }
    }
}

public struct GetAccountLinkInput: Swift.Sendable {
    /// The identifier of the account to link.
    public var linkId: Swift.String?
    /// The identifier of the account link
    public var linkedAccountId: Swift.String?

    public init(
        linkId: Swift.String? = nil,
        linkedAccountId: Swift.String? = nil
    )
    {
        self.linkId = linkId
        self.linkedAccountId = linkedAccountId
    }
}

public struct GetAccountLinkOutput: Swift.Sendable {
    /// The account link of the account link to retrieve.
    public var accountLink: WorkSpacesClientTypes.AccountLink?

    public init(
        accountLink: WorkSpacesClientTypes.AccountLink? = nil
    )
    {
        self.accountLink = accountLink
    }
}

extension WorkSpacesClientTypes {

    /// The client branding attributes to import for iOS device types. These attributes are displayed on the iOS client login screen. Client branding attributes are public facing. Ensure you do not include sensitive information.
    public struct IosImportClientBrandingAttributes: Swift.Sendable {
        /// The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.
        public var forgotPasswordLink: Swift.String?
        /// The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is en_US. The HTML tags supported include the following: a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul.
        public var loginMessage: [Swift.String: Swift.String]?
        /// The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a .png file.
        public var logo: Foundation.Data?
        /// The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a .png file. For more information about iOS image size and resolution, see [Image Size and Resolution ](https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/) in the Apple Human Interface Guidelines.
        public var logo2x: Foundation.Data?
        /// The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x). The only image format accepted is a binary data object that is converted from a .png file. For more information about iOS image size and resolution, see [Image Size and Resolution ](https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/) in the Apple Human Interface Guidelines.
        public var logo3x: Foundation.Data?
        /// The support email. The company's customer support email address.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default email is workspaces-feedback@amazon.com.
        public var supportEmail: Swift.String?
        /// The support link. The link for the company's customer support page for their WorkSpace.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default support link is workspaces-feedback@amazon.com.
        public var supportLink: Swift.String?

        public init(
            forgotPasswordLink: Swift.String? = nil,
            loginMessage: [Swift.String: Swift.String]? = nil,
            logo: Foundation.Data? = nil,
            logo2x: Foundation.Data? = nil,
            logo3x: Foundation.Data? = nil,
            supportEmail: Swift.String? = nil,
            supportLink: Swift.String? = nil
        )
        {
            self.forgotPasswordLink = forgotPasswordLink
            self.loginMessage = loginMessage
            self.logo = logo
            self.logo2x = logo2x
            self.logo3x = logo3x
            self.supportEmail = supportEmail
            self.supportLink = supportLink
        }
    }
}

public struct ImportClientBrandingInput: Swift.Sendable {
    /// The branding information to import for Android devices.
    public var deviceTypeAndroid: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The branding information to import for iOS devices.
    public var deviceTypeIos: WorkSpacesClientTypes.IosImportClientBrandingAttributes?
    /// The branding information to import for Linux devices.
    public var deviceTypeLinux: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The branding information to import for macOS devices.
    public var deviceTypeOsx: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The branding information to import for web access.
    public var deviceTypeWeb: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The branding information to import for Windows devices.
    public var deviceTypeWindows: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The directory identifier of the WorkSpace for which you want to import client branding.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        deviceTypeAndroid: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        deviceTypeIos: WorkSpacesClientTypes.IosImportClientBrandingAttributes? = nil,
        deviceTypeLinux: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        deviceTypeOsx: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        deviceTypeWeb: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        deviceTypeWindows: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.deviceTypeAndroid = deviceTypeAndroid
        self.deviceTypeIos = deviceTypeIos
        self.deviceTypeLinux = deviceTypeLinux
        self.deviceTypeOsx = deviceTypeOsx
        self.deviceTypeWeb = deviceTypeWeb
        self.deviceTypeWindows = deviceTypeWindows
        self.resourceId = resourceId
    }
}

public struct ImportClientBrandingOutput: Swift.Sendable {
    /// The branding information configured for Android devices.
    public var deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information configured for iOS devices.
    public var deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes?
    /// The branding information configured for Linux devices.
    public var deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information configured for macOS devices.
    public var deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information configured for web access.
    public var deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information configured for Windows devices.
    public var deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes?

    public init(
        deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes? = nil,
        deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil
    )
    {
        self.deviceTypeAndroid = deviceTypeAndroid
        self.deviceTypeIos = deviceTypeIos
        self.deviceTypeLinux = deviceTypeLinux
        self.deviceTypeOsx = deviceTypeOsx
        self.deviceTypeWeb = deviceTypeWeb
        self.deviceTypeWindows = deviceTypeWindows
    }
}

extension WorkSpacesClientTypes {

    public enum WorkspaceImageIngestionProcess: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case byolGraphics
        case byolGraphicspro
        case byolGraphicsG4dn
        case byolGraphicsG4dnByop
        case byolGraphicsG4dnWsp
        case byolRegular
        case byolRegularByop
        case byolRegularWsp
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageIngestionProcess] {
            return [
                .byolGraphics,
                .byolGraphicspro,
                .byolGraphicsG4dn,
                .byolGraphicsG4dnByop,
                .byolGraphicsG4dnWsp,
                .byolRegular,
                .byolRegularByop,
                .byolRegularWsp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .byolGraphics: return "BYOL_GRAPHICS"
            case .byolGraphicspro: return "BYOL_GRAPHICSPRO"
            case .byolGraphicsG4dn: return "BYOL_GRAPHICS_G4DN"
            case .byolGraphicsG4dnByop: return "BYOL_GRAPHICS_G4DN_BYOP"
            case .byolGraphicsG4dnWsp: return "BYOL_GRAPHICS_G4DN_WSP"
            case .byolRegular: return "BYOL_REGULAR"
            case .byolRegularByop: return "BYOL_REGULAR_BYOP"
            case .byolRegularWsp: return "BYOL_REGULAR_WSP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ImportWorkspaceImageInput: Swift.Sendable {
    /// If specified, the version of Microsoft Office to subscribe to. Valid only for Windows 10 and 11 BYOL images. For more information about subscribing to Office for BYOL images, see [ Bring Your Own Windows Desktop Licenses](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
    ///
    /// * Although this parameter is an array, only one item is allowed at this time.
    ///
    /// * During the image import process, non-GPU DCV (formerly WSP) WorkSpaces with Windows 11 support only Microsoft_Office_2019. GPU DCV (formerly WSP) WorkSpaces with Windows 11 do not support Office installation.
    public var applications: [WorkSpacesClientTypes.Application]?
    /// The identifier of the EC2 image.
    /// This member is required.
    public var ec2ImageId: Swift.String?
    /// The description of the WorkSpace image.
    /// This member is required.
    public var imageDescription: Swift.String?
    /// The name of the WorkSpace image.
    /// This member is required.
    public var imageName: Swift.String?
    /// The ingestion process to be used when importing the image, depending on which protocol you want to use for your BYOL Workspace image, either PCoIP, DCV, or bring your own protocol (BYOP). To use WSP, specify a value that ends in _DCV. To use PCoIP, specify a value that does not end in _DCV. To use BYOP, specify a value that ends in _BYOP. For non-GPU-enabled bundles (bundles other than Graphics or GraphicsPro), specify BYOL_REGULAR, BYOL_REGULAR_DCV, or BYOL_REGULAR_BYOP, depending on the protocol. The BYOL_REGULAR_BYOP and BYOL_GRAPHICS_G4DN_BYOP values are only supported by Amazon WorkSpaces Core. Contact your account team to be allow-listed to use these values. For more information, see [Amazon WorkSpaces Core](http://aws.amazon.com/workspaces/core/).
    /// This member is required.
    public var ingestionProcess: WorkSpacesClientTypes.WorkspaceImageIngestionProcess?
    /// The tags. Each WorkSpaces resource can have a maximum of 50 tags.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init(
        applications: [WorkSpacesClientTypes.Application]? = nil,
        ec2ImageId: Swift.String? = nil,
        imageDescription: Swift.String? = nil,
        imageName: Swift.String? = nil,
        ingestionProcess: WorkSpacesClientTypes.WorkspaceImageIngestionProcess? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.applications = applications
        self.ec2ImageId = ec2ImageId
        self.imageDescription = imageDescription
        self.imageName = imageName
        self.ingestionProcess = ingestionProcess
        self.tags = tags
    }
}

public struct ImportWorkspaceImageOutput: Swift.Sendable {
    /// The identifier of the WorkSpace image.
    public var imageId: Swift.String?

    public init(
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

public struct ListAccountLinksInput: Swift.Sendable {
    /// Filters the account based on their link status.
    public var linkStatusFilter: [WorkSpacesClientTypes.AccountLinkStatusEnum]?
    /// The maximum number of accounts to return.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        linkStatusFilter: [WorkSpacesClientTypes.AccountLinkStatusEnum]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.linkStatusFilter = linkStatusFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAccountLinksOutput: Swift.Sendable {
    /// Information about the account links.
    public var accountLinks: [WorkSpacesClientTypes.AccountLink]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        accountLinks: [WorkSpacesClientTypes.AccountLink]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountLinks = accountLinks
        self.nextToken = nextToken
    }
}

public struct ListAvailableManagementCidrRangesInput: Swift.Sendable {
    /// The IP address range to search. Specify an IP address range that is compatible with your network and in CIDR notation (that is, specify the range as an IPv4 CIDR block).
    /// This member is required.
    public var managementCidrRangeConstraint: Swift.String?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        managementCidrRangeConstraint: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.managementCidrRangeConstraint = managementCidrRangeConstraint
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAvailableManagementCidrRangesOutput: Swift.Sendable {
    /// The list of available IP address ranges, specified as IPv4 CIDR blocks.
    public var managementCidrRanges: [Swift.String]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        managementCidrRanges: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.managementCidrRanges = managementCidrRanges
        self.nextToken = nextToken
    }
}

/// The properties of this WorkSpace are currently being modified. Try again in a moment.
public struct OperationInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationInProgressException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct MigrateWorkspaceInput: Swift.Sendable {
    /// The identifier of the target bundle type to migrate the WorkSpace to.
    /// This member is required.
    public var bundleId: Swift.String?
    /// The identifier of the WorkSpace to migrate from.
    /// This member is required.
    public var sourceWorkspaceId: Swift.String?

    public init(
        bundleId: Swift.String? = nil,
        sourceWorkspaceId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
        self.sourceWorkspaceId = sourceWorkspaceId
    }
}

public struct MigrateWorkspaceOutput: Swift.Sendable {
    /// The original identifier of the WorkSpace that is being migrated.
    public var sourceWorkspaceId: Swift.String?
    /// The new identifier of the WorkSpace that is being migrated. If the migration does not succeed, the target WorkSpace ID will not be used, and the WorkSpace will still have the original WorkSpace ID.
    public var targetWorkspaceId: Swift.String?

    public init(
        sourceWorkspaceId: Swift.String? = nil,
        targetWorkspaceId: Swift.String? = nil
    )
    {
        self.sourceWorkspaceId = sourceWorkspaceId
        self.targetWorkspaceId = targetWorkspaceId
    }
}

public struct ModifyAccountInput: Swift.Sendable {
    /// The IP address range, specified as an IPv4 CIDR block, for the management network interface. Specify an IP address range that is compatible with your network and in CIDR notation (that is, specify the range as an IPv4 CIDR block). The CIDR block size must be /16 (for example, 203.0.113.25/16). It must also be specified as available by the ListAvailableManagementCidrRanges operation.
    public var dedicatedTenancyManagementCidrRange: Swift.String?
    /// The status of BYOL.
    public var dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportEnum?

    public init(
        dedicatedTenancyManagementCidrRange: Swift.String? = nil,
        dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportEnum? = nil
    )
    {
        self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
        self.dedicatedTenancySupport = dedicatedTenancySupport
    }
}

public struct ModifyAccountOutput: Swift.Sendable {

    public init() { }
}

public struct ModifyCertificateBasedAuthPropertiesInput: Swift.Sendable {
    /// The properties of the certificate-based authentication.
    public var certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties?
    /// The properties of the certificate-based authentication you want to delete.
    public var propertiesToDelete: [WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty]?
    /// The resource identifiers, in the form of directory IDs.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties? = nil,
        propertiesToDelete: [WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.certificateBasedAuthProperties = certificateBasedAuthProperties
        self.propertiesToDelete = propertiesToDelete
        self.resourceId = resourceId
    }
}

public struct ModifyCertificateBasedAuthPropertiesOutput: Swift.Sendable {

    public init() { }
}

public struct ModifyClientPropertiesInput: Swift.Sendable {
    /// Information about the Amazon WorkSpaces client.
    /// This member is required.
    public var clientProperties: WorkSpacesClientTypes.ClientProperties?
    /// The resource identifiers, in the form of directory IDs.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        clientProperties: WorkSpacesClientTypes.ClientProperties? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.clientProperties = clientProperties
        self.resourceId = resourceId
    }
}

public struct ModifyClientPropertiesOutput: Swift.Sendable {

    public init() { }
}

public struct ModifySamlPropertiesInput: Swift.Sendable {
    /// The SAML properties to delete as part of your request. Specify one of the following options:
    ///
    /// * SAML_PROPERTIES_USER_ACCESS_URL to delete the user access URL.
    ///
    /// * SAML_PROPERTIES_RELAY_STATE_PARAMETER_NAME to delete the relay state parameter name.
    public var propertiesToDelete: [WorkSpacesClientTypes.DeletableSamlProperty]?
    /// The directory identifier for which you want to configure SAML properties.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The properties for configuring SAML 2.0 authentication.
    public var samlProperties: WorkSpacesClientTypes.SamlProperties?

    public init(
        propertiesToDelete: [WorkSpacesClientTypes.DeletableSamlProperty]? = nil,
        resourceId: Swift.String? = nil,
        samlProperties: WorkSpacesClientTypes.SamlProperties? = nil
    )
    {
        self.propertiesToDelete = propertiesToDelete
        self.resourceId = resourceId
        self.samlProperties = samlProperties
    }
}

public struct ModifySamlPropertiesOutput: Swift.Sendable {

    public init() { }
}

public struct ModifySelfservicePermissionsInput: Swift.Sendable {
    /// The identifier of the directory.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The permissions to enable or disable self-service capabilities.
    /// This member is required.
    public var selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions?

    public init(
        resourceId: Swift.String? = nil,
        selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions? = nil
    )
    {
        self.resourceId = resourceId
        self.selfservicePermissions = selfservicePermissions
    }
}

public struct ModifySelfservicePermissionsOutput: Swift.Sendable {

    public init() { }
}

public struct ModifyStreamingPropertiesInput: Swift.Sendable {
    /// The identifier of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The streaming properties to configure.
    public var streamingProperties: WorkSpacesClientTypes.StreamingProperties?

    public init(
        resourceId: Swift.String? = nil,
        streamingProperties: WorkSpacesClientTypes.StreamingProperties? = nil
    )
    {
        self.resourceId = resourceId
        self.streamingProperties = streamingProperties
    }
}

public struct ModifyStreamingPropertiesOutput: Swift.Sendable {

    public init() { }
}

public struct ModifyWorkspaceAccessPropertiesInput: Swift.Sendable {
    /// The identifier of the directory.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The device types and operating systems to enable or disable for access.
    /// This member is required.
    public var workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties?

    public init(
        resourceId: Swift.String? = nil,
        workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties? = nil
    )
    {
        self.resourceId = resourceId
        self.workspaceAccessProperties = workspaceAccessProperties
    }
}

public struct ModifyWorkspaceAccessPropertiesOutput: Swift.Sendable {

    public init() { }
}

extension WorkSpacesClientTypes {

    /// Describes the default properties that are used for creating WorkSpaces. For more information, see [Update Directory Details for Your WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html).
    public struct WorkspaceCreationProperties: Swift.Sendable {
        /// The identifier of your custom security group.
        public var customSecurityGroupId: Swift.String?
        /// The default organizational unit (OU) for your WorkSpaces directories. This string must be the full Lightweight Directory Access Protocol (LDAP) distinguished name for the target domain and OU. It must be in the form "OU=value,DC=value,DC=value", where value is any string of characters, and the number of domain components (DCs) is two or more. For example, OU=WorkSpaces_machines,DC=machines,DC=example,DC=com.
        ///
        /// * To avoid errors, certain characters in the distinguished name must be escaped. For more information, see [ Distinguished Names](https://docs.microsoft.com/previous-versions/windows/desktop/ldap/distinguished-names) in the Microsoft documentation.
        ///
        /// * The API doesn't validate whether the OU exists.
        public var defaultOu: Swift.String?
        /// Indicates whether internet access is enabled for your WorkSpaces.
        public var enableInternetAccess: Swift.Bool?
        /// Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see [WorkSpace Maintenance](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html).
        public var enableMaintenanceMode: Swift.Bool?
        /// Indicates whether Amazon WorkDocs is enabled for your WorkSpaces. If WorkDocs is already enabled for a WorkSpaces directory and you disable it, new WorkSpaces launched in the directory will not have WorkDocs enabled. However, WorkDocs remains enabled for any existing WorkSpaces, unless you either disable users' access to WorkDocs or you delete the WorkDocs site. To disable users' access to WorkDocs, see [Disabling Users](https://docs.aws.amazon.com/workdocs/latest/adminguide/inactive-user.html) in the Amazon WorkDocs Administration Guide. To delete a WorkDocs site, see [Deleting a Site](https://docs.aws.amazon.com/workdocs/latest/adminguide/manage-sites.html) in the Amazon WorkDocs Administration Guide. If you enable WorkDocs on a directory that already has existing WorkSpaces, the existing WorkSpaces and any new WorkSpaces that are launched in the directory will have WorkDocs enabled.
        public var enableWorkDocs: Swift.Bool?
        /// Indicates the IAM role ARN of the instance.
        public var instanceIamRoleArn: Swift.String?
        /// Indicates whether users are local administrators of their WorkSpaces.
        public var userEnabledAsLocalAdministrator: Swift.Bool?

        public init(
            customSecurityGroupId: Swift.String? = nil,
            defaultOu: Swift.String? = nil,
            enableInternetAccess: Swift.Bool? = nil,
            enableMaintenanceMode: Swift.Bool? = nil,
            enableWorkDocs: Swift.Bool? = nil,
            instanceIamRoleArn: Swift.String? = nil,
            userEnabledAsLocalAdministrator: Swift.Bool? = nil
        )
        {
            self.customSecurityGroupId = customSecurityGroupId
            self.defaultOu = defaultOu
            self.enableInternetAccess = enableInternetAccess
            self.enableMaintenanceMode = enableMaintenanceMode
            self.enableWorkDocs = enableWorkDocs
            self.instanceIamRoleArn = instanceIamRoleArn
            self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
        }
    }
}

public struct ModifyWorkspaceCreationPropertiesInput: Swift.Sendable {
    /// The identifier of the directory.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The default properties for creating WorkSpaces.
    /// This member is required.
    public var workspaceCreationProperties: WorkSpacesClientTypes.WorkspaceCreationProperties?

    public init(
        resourceId: Swift.String? = nil,
        workspaceCreationProperties: WorkSpacesClientTypes.WorkspaceCreationProperties? = nil
    )
    {
        self.resourceId = resourceId
        self.workspaceCreationProperties = workspaceCreationProperties
    }
}

public struct ModifyWorkspaceCreationPropertiesOutput: Swift.Sendable {

    public init() { }
}

/// The configuration of this WorkSpace is not supported for this operation. For more information, see [Required Configuration and Service Components for WorkSpaces ](https://docs.aws.amazon.com/workspaces/latest/adminguide/required-service-components.html).
public struct UnsupportedWorkspaceConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedWorkspaceConfigurationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ModifyWorkspacePropertiesInput: Swift.Sendable {
    /// Indicates the data replication status.
    public var dataReplication: WorkSpacesClientTypes.DataReplication?
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?
    /// The properties of the WorkSpace.
    public var workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?

    public init(
        dataReplication: WorkSpacesClientTypes.DataReplication? = nil,
        workspaceId: Swift.String? = nil,
        workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties? = nil
    )
    {
        self.dataReplication = dataReplication
        self.workspaceId = workspaceId
        self.workspaceProperties = workspaceProperties
    }
}

public struct ModifyWorkspacePropertiesOutput: Swift.Sendable {

    public init() { }
}

extension WorkSpacesClientTypes {

    public enum TargetWorkspaceState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case adminMaintenance
        case available
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetWorkspaceState] {
            return [
                .adminMaintenance,
                .available
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .adminMaintenance: return "ADMIN_MAINTENANCE"
            case .available: return "AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ModifyWorkspaceStateInput: Swift.Sendable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?
    /// The WorkSpace state.
    /// This member is required.
    public var workspaceState: WorkSpacesClientTypes.TargetWorkspaceState?

    public init(
        workspaceId: Swift.String? = nil,
        workspaceState: WorkSpacesClientTypes.TargetWorkspaceState? = nil
    )
    {
        self.workspaceId = workspaceId
        self.workspaceState = workspaceState
    }
}

public struct ModifyWorkspaceStateOutput: Swift.Sendable {

    public init() { }
}

extension WorkSpacesClientTypes {

    /// Describes the information used to reboot a WorkSpace.
    public struct RebootRequest: Swift.Sendable {
        /// The identifier of the WorkSpace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init(
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }
}

public struct RebootWorkspacesInput: Swift.Sendable {
    /// The WorkSpaces to reboot. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var rebootWorkspaceRequests: [WorkSpacesClientTypes.RebootRequest]?

    public init(
        rebootWorkspaceRequests: [WorkSpacesClientTypes.RebootRequest]? = nil
    )
    {
        self.rebootWorkspaceRequests = rebootWorkspaceRequests
    }
}

public struct RebootWorkspacesOutput: Swift.Sendable {
    /// Information about the WorkSpaces that could not be rebooted.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init(
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

extension WorkSpacesClientTypes {

    /// Describes the information used to rebuild a WorkSpace.
    public struct RebuildRequest: Swift.Sendable {
        /// The identifier of the WorkSpace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init(
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }
}

public struct RebuildWorkspacesInput: Swift.Sendable {
    /// The WorkSpace to rebuild. You can specify a single WorkSpace.
    /// This member is required.
    public var rebuildWorkspaceRequests: [WorkSpacesClientTypes.RebuildRequest]?

    public init(
        rebuildWorkspaceRequests: [WorkSpacesClientTypes.RebuildRequest]? = nil
    )
    {
        self.rebuildWorkspaceRequests = rebuildWorkspaceRequests
    }
}

public struct RebuildWorkspacesOutput: Swift.Sendable {
    /// Information about the WorkSpace that could not be rebuilt.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init(
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

/// The configuration of this network is not supported for this operation, or your network configuration conflicts with the Amazon WorkSpaces management network IP range. For more information, see [ Configure a VPC for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html).
public struct UnsupportedNetworkConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedNetworkConfigurationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The workspaces_DefaultRole role could not be found. If this is the first time you are registering a directory, you will need to create the workspaces_DefaultRole role before you can register a directory. For more information, see [Creating the workspaces_DefaultRole Role](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-access-control.html#create-default-role).
public struct WorkspacesDefaultRoleNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "WorkspacesDefaultRoleNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct RegisterWorkspaceDirectoryInput: Swift.Sendable {
    /// The active directory config of the directory.
    public var activeDirectoryConfig: WorkSpacesClientTypes.ActiveDirectoryConfig?
    /// The identifier of the directory. You cannot register a directory if it does not have a status of Active. If the directory does not have a status of Active, you will receive an InvalidResourceStateException error. If you have already registered the maximum number of directories that you can register with Amazon WorkSpaces, you will receive a ResourceLimitExceededException error. Deregister directories that you are not using for WorkSpaces, and try again.
    public var directoryId: Swift.String?
    /// Indicates whether self-service capabilities are enabled or disabled.
    public var enableSelfService: Swift.Bool?
    /// Indicates whether Amazon WorkDocs is enabled or disabled. If you have enabled this parameter and WorkDocs is not available in the Region, you will receive an OperationNotSupportedException error. Set EnableWorkDocs to disabled, and try again.
    public var enableWorkDocs: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the identity center instance.
    public var idcInstanceArn: Swift.String?
    /// The details about Microsoft Entra config.
    public var microsoftEntraConfig: WorkSpacesClientTypes.MicrosoftEntraConfig?
    /// The identifiers of the subnets for your virtual private cloud (VPC). Make sure that the subnets are in supported Availability Zones. The subnets must also be in separate Availability Zones. If these conditions are not met, you will receive an OperationNotSupportedException error.
    public var subnetIds: [Swift.String]?
    /// The tags associated with the directory.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// Indicates whether your WorkSpace directory is dedicated or shared. To use Bring Your Own License (BYOL) images, this value must be set to DEDICATED and your Amazon Web Services account must be enabled for BYOL. If your account has not been enabled for BYOL, you will receive an InvalidParameterValuesException error. For more information about BYOL images, see [Bring Your Own Windows Desktop Images](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
    public var tenancy: WorkSpacesClientTypes.Tenancy?
    /// The type of identity management the user is using.
    public var userIdentityType: WorkSpacesClientTypes.UserIdentityType?
    /// Description of the directory to register.
    public var workspaceDirectoryDescription: Swift.String?
    /// The name of the directory to register.
    public var workspaceDirectoryName: Swift.String?
    /// Indicates whether the directory's WorkSpace type is personal or pools.
    public var workspaceType: WorkSpacesClientTypes.WorkspaceType?

    public init(
        activeDirectoryConfig: WorkSpacesClientTypes.ActiveDirectoryConfig? = nil,
        directoryId: Swift.String? = nil,
        enableSelfService: Swift.Bool? = nil,
        enableWorkDocs: Swift.Bool? = nil,
        idcInstanceArn: Swift.String? = nil,
        microsoftEntraConfig: WorkSpacesClientTypes.MicrosoftEntraConfig? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        tenancy: WorkSpacesClientTypes.Tenancy? = nil,
        userIdentityType: WorkSpacesClientTypes.UserIdentityType? = nil,
        workspaceDirectoryDescription: Swift.String? = nil,
        workspaceDirectoryName: Swift.String? = nil,
        workspaceType: WorkSpacesClientTypes.WorkspaceType? = nil
    )
    {
        self.activeDirectoryConfig = activeDirectoryConfig
        self.directoryId = directoryId
        self.enableSelfService = enableSelfService
        self.enableWorkDocs = enableWorkDocs
        self.idcInstanceArn = idcInstanceArn
        self.microsoftEntraConfig = microsoftEntraConfig
        self.subnetIds = subnetIds
        self.tags = tags
        self.tenancy = tenancy
        self.userIdentityType = userIdentityType
        self.workspaceDirectoryDescription = workspaceDirectoryDescription
        self.workspaceDirectoryName = workspaceDirectoryName
        self.workspaceType = workspaceType
    }
}

public struct RegisterWorkspaceDirectoryOutput: Swift.Sendable {
    /// The identifier of the directory.
    public var directoryId: Swift.String?
    /// The registration status of the WorkSpace directory.
    public var state: WorkSpacesClientTypes.WorkspaceDirectoryState?

    public init(
        directoryId: Swift.String? = nil,
        state: WorkSpacesClientTypes.WorkspaceDirectoryState? = nil
    )
    {
        self.directoryId = directoryId
        self.state = state
    }
}

public struct RejectAccountLinkInvitationInput: Swift.Sendable {
    /// The client token of the account link invitation to reject.
    public var clientToken: Swift.String?
    /// The identifier of the account link
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.linkId = linkId
    }
}

public struct RejectAccountLinkInvitationOutput: Swift.Sendable {
    /// Information about the account link.
    public var accountLink: WorkSpacesClientTypes.AccountLink?

    public init(
        accountLink: WorkSpacesClientTypes.AccountLink? = nil
    )
    {
        self.accountLink = accountLink
    }
}

public struct RestoreWorkspaceInput: Swift.Sendable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

public struct RestoreWorkspaceOutput: Swift.Sendable {

    public init() { }
}

public struct RevokeIpRulesInput: Swift.Sendable {
    /// The identifier of the group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The rules to remove from the group.
    /// This member is required.
    public var userRules: [Swift.String]?

    public init(
        groupId: Swift.String? = nil,
        userRules: [Swift.String]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

public struct RevokeIpRulesOutput: Swift.Sendable {

    public init() { }
}

extension WorkSpacesClientTypes {

    /// Information used to start a WorkSpace.
    public struct StartRequest: Swift.Sendable {
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }
}

public struct StartWorkspacesInput: Swift.Sendable {
    /// The WorkSpaces to start. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var startWorkspaceRequests: [WorkSpacesClientTypes.StartRequest]?

    public init(
        startWorkspaceRequests: [WorkSpacesClientTypes.StartRequest]? = nil
    )
    {
        self.startWorkspaceRequests = startWorkspaceRequests
    }
}

public struct StartWorkspacesOutput: Swift.Sendable {
    /// Information about the WorkSpaces that could not be started.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init(
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

public struct StartWorkspacesPoolInput: Swift.Sendable {
    /// The identifier of the pool.
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        poolId: Swift.String? = nil
    )
    {
        self.poolId = poolId
    }
}

public struct StartWorkspacesPoolOutput: Swift.Sendable {

    public init() { }
}

extension WorkSpacesClientTypes {

    /// Describes the information used to stop a WorkSpace.
    public struct StopRequest: Swift.Sendable {
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }
}

public struct StopWorkspacesInput: Swift.Sendable {
    /// The WorkSpaces to stop. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var stopWorkspaceRequests: [WorkSpacesClientTypes.StopRequest]?

    public init(
        stopWorkspaceRequests: [WorkSpacesClientTypes.StopRequest]? = nil
    )
    {
        self.stopWorkspaceRequests = stopWorkspaceRequests
    }
}

public struct StopWorkspacesOutput: Swift.Sendable {
    /// Information about the WorkSpaces that could not be stopped.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init(
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

public struct StopWorkspacesPoolInput: Swift.Sendable {
    /// The identifier of the pool.
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        poolId: Swift.String? = nil
    )
    {
        self.poolId = poolId
    }
}

public struct StopWorkspacesPoolOutput: Swift.Sendable {

    public init() { }
}

extension WorkSpacesClientTypes {

    /// Describes the information used to terminate a WorkSpace.
    public struct TerminateRequest: Swift.Sendable {
        /// The identifier of the WorkSpace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init(
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }
}

public struct TerminateWorkspacesInput: Swift.Sendable {
    /// The WorkSpaces to terminate. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var terminateWorkspaceRequests: [WorkSpacesClientTypes.TerminateRequest]?

    public init(
        terminateWorkspaceRequests: [WorkSpacesClientTypes.TerminateRequest]? = nil
    )
    {
        self.terminateWorkspaceRequests = terminateWorkspaceRequests
    }
}

public struct TerminateWorkspacesOutput: Swift.Sendable {
    /// Information about the WorkSpaces that could not be terminated.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init(
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

public struct TerminateWorkspacesPoolInput: Swift.Sendable {
    /// The identifier of the pool.
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        poolId: Swift.String? = nil
    )
    {
        self.poolId = poolId
    }
}

public struct TerminateWorkspacesPoolOutput: Swift.Sendable {

    public init() { }
}

public struct TerminateWorkspacesPoolSessionInput: Swift.Sendable {
    /// The identifier of the pool session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

public struct TerminateWorkspacesPoolSessionOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateConnectClientAddInInput: Swift.Sendable {
    /// The identifier of the client add-in to update.
    /// This member is required.
    public var addInId: Swift.String?
    /// The name of the client add-in.
    public var name: Swift.String?
    /// The directory identifier for which the client add-in is configured.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The endpoint URL of the Amazon Connect client add-in.
    public var url: Swift.String?

    public init(
        addInId: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        url: Swift.String? = nil
    )
    {
        self.addInId = addInId
        self.name = name
        self.resourceId = resourceId
        self.url = url
    }
}

public struct UpdateConnectClientAddInOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateConnectionAliasPermissionInput: Swift.Sendable {
    /// The identifier of the connection alias that you want to update permissions for.
    /// This member is required.
    public var aliasId: Swift.String?
    /// Indicates whether to share or unshare the connection alias with the specified Amazon Web Services account.
    /// This member is required.
    public var connectionAliasPermission: WorkSpacesClientTypes.ConnectionAliasPermission?

    public init(
        aliasId: Swift.String? = nil,
        connectionAliasPermission: WorkSpacesClientTypes.ConnectionAliasPermission? = nil
    )
    {
        self.aliasId = aliasId
        self.connectionAliasPermission = connectionAliasPermission
    }
}

public struct UpdateConnectionAliasPermissionOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateRulesOfIpGroupInput: Swift.Sendable {
    /// The identifier of the group.
    /// This member is required.
    public var groupId: Swift.String?
    /// One or more rules.
    /// This member is required.
    public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

    public init(
        groupId: Swift.String? = nil,
        userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

public struct UpdateRulesOfIpGroupOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateWorkspaceBundleInput: Swift.Sendable {
    /// The identifier of the bundle.
    public var bundleId: Swift.String?
    /// The identifier of the image.
    public var imageId: Swift.String?

    public init(
        bundleId: Swift.String? = nil,
        imageId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
        self.imageId = imageId
    }
}

public struct UpdateWorkspaceBundleOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateWorkspaceImagePermissionInput: Swift.Sendable {
    /// The permission to copy the image. This permission can be revoked only after an image has been shared.
    /// This member is required.
    public var allowCopyImage: Swift.Bool?
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?
    /// The identifier of the Amazon Web Services account to share or unshare the image with. Before sharing the image, confirm that you are sharing to the correct Amazon Web Services account ID.
    /// This member is required.
    public var sharedAccountId: Swift.String?

    public init(
        allowCopyImage: Swift.Bool? = nil,
        imageId: Swift.String? = nil,
        sharedAccountId: Swift.String? = nil
    )
    {
        self.allowCopyImage = allowCopyImage
        self.imageId = imageId
        self.sharedAccountId = sharedAccountId
    }
}

public struct UpdateWorkspaceImagePermissionOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateWorkspacesPoolInput: Swift.Sendable {
    /// The persistent application settings for users in the pool.
    public var applicationSettings: WorkSpacesClientTypes.ApplicationSettingsRequest?
    /// The identifier of the bundle.
    public var bundleId: Swift.String?
    /// The desired capacity for the pool.
    public var capacity: WorkSpacesClientTypes.Capacity?
    /// Describes the specified pool to update.
    public var description: Swift.String?
    /// The identifier of the directory.
    public var directoryId: Swift.String?
    /// The identifier of the specified pool to update.
    /// This member is required.
    public var poolId: Swift.String?
    /// Indicates the timeout settings of the specified pool.
    public var timeoutSettings: WorkSpacesClientTypes.TimeoutSettings?

    public init(
        applicationSettings: WorkSpacesClientTypes.ApplicationSettingsRequest? = nil,
        bundleId: Swift.String? = nil,
        capacity: WorkSpacesClientTypes.Capacity? = nil,
        description: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        poolId: Swift.String? = nil,
        timeoutSettings: WorkSpacesClientTypes.TimeoutSettings? = nil
    )
    {
        self.applicationSettings = applicationSettings
        self.bundleId = bundleId
        self.capacity = capacity
        self.description = description
        self.directoryId = directoryId
        self.poolId = poolId
        self.timeoutSettings = timeoutSettings
    }
}

public struct UpdateWorkspacesPoolOutput: Swift.Sendable {
    /// Describes the specified pool.
    public var workspacesPool: WorkSpacesClientTypes.WorkspacesPool?

    public init(
        workspacesPool: WorkSpacesClientTypes.WorkspacesPool? = nil
    )
    {
        self.workspacesPool = workspacesPool
    }
}

extension AcceptAccountLinkInvitationInput {

    static func urlPathProvider(_ value: AcceptAccountLinkInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateConnectionAliasInput {

    static func urlPathProvider(_ value: AssociateConnectionAliasInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateIpGroupsInput {

    static func urlPathProvider(_ value: AssociateIpGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateWorkspaceApplicationInput {

    static func urlPathProvider(_ value: AssociateWorkspaceApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension AuthorizeIpRulesInput {

    static func urlPathProvider(_ value: AuthorizeIpRulesInput) -> Swift.String? {
        return "/"
    }
}

extension CopyWorkspaceImageInput {

    static func urlPathProvider(_ value: CopyWorkspaceImageInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAccountLinkInvitationInput {

    static func urlPathProvider(_ value: CreateAccountLinkInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateConnectClientAddInInput {

    static func urlPathProvider(_ value: CreateConnectClientAddInInput) -> Swift.String? {
        return "/"
    }
}

extension CreateConnectionAliasInput {

    static func urlPathProvider(_ value: CreateConnectionAliasInput) -> Swift.String? {
        return "/"
    }
}

extension CreateIpGroupInput {

    static func urlPathProvider(_ value: CreateIpGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateStandbyWorkspacesInput {

    static func urlPathProvider(_ value: CreateStandbyWorkspacesInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTagsInput {

    static func urlPathProvider(_ value: CreateTagsInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUpdatedWorkspaceImageInput {

    static func urlPathProvider(_ value: CreateUpdatedWorkspaceImageInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWorkspaceBundleInput {

    static func urlPathProvider(_ value: CreateWorkspaceBundleInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWorkspaceImageInput {

    static func urlPathProvider(_ value: CreateWorkspaceImageInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWorkspacesInput {

    static func urlPathProvider(_ value: CreateWorkspacesInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWorkspacesPoolInput {

    static func urlPathProvider(_ value: CreateWorkspacesPoolInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAccountLinkInvitationInput {

    static func urlPathProvider(_ value: DeleteAccountLinkInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteClientBrandingInput {

    static func urlPathProvider(_ value: DeleteClientBrandingInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConnectClientAddInInput {

    static func urlPathProvider(_ value: DeleteConnectClientAddInInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConnectionAliasInput {

    static func urlPathProvider(_ value: DeleteConnectionAliasInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteIpGroupInput {

    static func urlPathProvider(_ value: DeleteIpGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTagsInput {

    static func urlPathProvider(_ value: DeleteTagsInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWorkspaceBundleInput {

    static func urlPathProvider(_ value: DeleteWorkspaceBundleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWorkspaceImageInput {

    static func urlPathProvider(_ value: DeleteWorkspaceImageInput) -> Swift.String? {
        return "/"
    }
}

extension DeployWorkspaceApplicationsInput {

    static func urlPathProvider(_ value: DeployWorkspaceApplicationsInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterWorkspaceDirectoryInput {

    static func urlPathProvider(_ value: DeregisterWorkspaceDirectoryInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAccountInput {

    static func urlPathProvider(_ value: DescribeAccountInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAccountModificationsInput {

    static func urlPathProvider(_ value: DescribeAccountModificationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationAssociationsInput {

    static func urlPathProvider(_ value: DescribeApplicationAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationsInput {

    static func urlPathProvider(_ value: DescribeApplicationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBundleAssociationsInput {

    static func urlPathProvider(_ value: DescribeBundleAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeClientBrandingInput {

    static func urlPathProvider(_ value: DescribeClientBrandingInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeClientPropertiesInput {

    static func urlPathProvider(_ value: DescribeClientPropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConnectClientAddInsInput {

    static func urlPathProvider(_ value: DescribeConnectClientAddInsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConnectionAliasesInput {

    static func urlPathProvider(_ value: DescribeConnectionAliasesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConnectionAliasPermissionsInput {

    static func urlPathProvider(_ value: DescribeConnectionAliasPermissionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeImageAssociationsInput {

    static func urlPathProvider(_ value: DescribeImageAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeIpGroupsInput {

    static func urlPathProvider(_ value: DescribeIpGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTagsInput {

    static func urlPathProvider(_ value: DescribeTagsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkspaceAssociationsInput {

    static func urlPathProvider(_ value: DescribeWorkspaceAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkspaceBundlesInput {

    static func urlPathProvider(_ value: DescribeWorkspaceBundlesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkspaceDirectoriesInput {

    static func urlPathProvider(_ value: DescribeWorkspaceDirectoriesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkspaceImagePermissionsInput {

    static func urlPathProvider(_ value: DescribeWorkspaceImagePermissionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkspaceImagesInput {

    static func urlPathProvider(_ value: DescribeWorkspaceImagesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkspacesInput {

    static func urlPathProvider(_ value: DescribeWorkspacesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkspacesConnectionStatusInput {

    static func urlPathProvider(_ value: DescribeWorkspacesConnectionStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkspaceSnapshotsInput {

    static func urlPathProvider(_ value: DescribeWorkspaceSnapshotsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkspacesPoolsInput {

    static func urlPathProvider(_ value: DescribeWorkspacesPoolsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWorkspacesPoolSessionsInput {

    static func urlPathProvider(_ value: DescribeWorkspacesPoolSessionsInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateConnectionAliasInput {

    static func urlPathProvider(_ value: DisassociateConnectionAliasInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateIpGroupsInput {

    static func urlPathProvider(_ value: DisassociateIpGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateWorkspaceApplicationInput {

    static func urlPathProvider(_ value: DisassociateWorkspaceApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccountLinkInput {

    static func urlPathProvider(_ value: GetAccountLinkInput) -> Swift.String? {
        return "/"
    }
}

extension ImportClientBrandingInput {

    static func urlPathProvider(_ value: ImportClientBrandingInput) -> Swift.String? {
        return "/"
    }
}

extension ImportWorkspaceImageInput {

    static func urlPathProvider(_ value: ImportWorkspaceImageInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccountLinksInput {

    static func urlPathProvider(_ value: ListAccountLinksInput) -> Swift.String? {
        return "/"
    }
}

extension ListAvailableManagementCidrRangesInput {

    static func urlPathProvider(_ value: ListAvailableManagementCidrRangesInput) -> Swift.String? {
        return "/"
    }
}

extension MigrateWorkspaceInput {

    static func urlPathProvider(_ value: MigrateWorkspaceInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyAccountInput {

    static func urlPathProvider(_ value: ModifyAccountInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyCertificateBasedAuthPropertiesInput {

    static func urlPathProvider(_ value: ModifyCertificateBasedAuthPropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyClientPropertiesInput {

    static func urlPathProvider(_ value: ModifyClientPropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension ModifySamlPropertiesInput {

    static func urlPathProvider(_ value: ModifySamlPropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension ModifySelfservicePermissionsInput {

    static func urlPathProvider(_ value: ModifySelfservicePermissionsInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyStreamingPropertiesInput {

    static func urlPathProvider(_ value: ModifyStreamingPropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyWorkspaceAccessPropertiesInput {

    static func urlPathProvider(_ value: ModifyWorkspaceAccessPropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyWorkspaceCreationPropertiesInput {

    static func urlPathProvider(_ value: ModifyWorkspaceCreationPropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyWorkspacePropertiesInput {

    static func urlPathProvider(_ value: ModifyWorkspacePropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyWorkspaceStateInput {

    static func urlPathProvider(_ value: ModifyWorkspaceStateInput) -> Swift.String? {
        return "/"
    }
}

extension RebootWorkspacesInput {

    static func urlPathProvider(_ value: RebootWorkspacesInput) -> Swift.String? {
        return "/"
    }
}

extension RebuildWorkspacesInput {

    static func urlPathProvider(_ value: RebuildWorkspacesInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterWorkspaceDirectoryInput {

    static func urlPathProvider(_ value: RegisterWorkspaceDirectoryInput) -> Swift.String? {
        return "/"
    }
}

extension RejectAccountLinkInvitationInput {

    static func urlPathProvider(_ value: RejectAccountLinkInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension RestoreWorkspaceInput {

    static func urlPathProvider(_ value: RestoreWorkspaceInput) -> Swift.String? {
        return "/"
    }
}

extension RevokeIpRulesInput {

    static func urlPathProvider(_ value: RevokeIpRulesInput) -> Swift.String? {
        return "/"
    }
}

extension StartWorkspacesInput {

    static func urlPathProvider(_ value: StartWorkspacesInput) -> Swift.String? {
        return "/"
    }
}

extension StartWorkspacesPoolInput {

    static func urlPathProvider(_ value: StartWorkspacesPoolInput) -> Swift.String? {
        return "/"
    }
}

extension StopWorkspacesInput {

    static func urlPathProvider(_ value: StopWorkspacesInput) -> Swift.String? {
        return "/"
    }
}

extension StopWorkspacesPoolInput {

    static func urlPathProvider(_ value: StopWorkspacesPoolInput) -> Swift.String? {
        return "/"
    }
}

extension TerminateWorkspacesInput {

    static func urlPathProvider(_ value: TerminateWorkspacesInput) -> Swift.String? {
        return "/"
    }
}

extension TerminateWorkspacesPoolInput {

    static func urlPathProvider(_ value: TerminateWorkspacesPoolInput) -> Swift.String? {
        return "/"
    }
}

extension TerminateWorkspacesPoolSessionInput {

    static func urlPathProvider(_ value: TerminateWorkspacesPoolSessionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateConnectClientAddInInput {

    static func urlPathProvider(_ value: UpdateConnectClientAddInInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateConnectionAliasPermissionInput {

    static func urlPathProvider(_ value: UpdateConnectionAliasPermissionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRulesOfIpGroupInput {

    static func urlPathProvider(_ value: UpdateRulesOfIpGroupInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateWorkspaceBundleInput {

    static func urlPathProvider(_ value: UpdateWorkspaceBundleInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateWorkspaceImagePermissionInput {

    static func urlPathProvider(_ value: UpdateWorkspaceImagePermissionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateWorkspacesPoolInput {

    static func urlPathProvider(_ value: UpdateWorkspacesPoolInput) -> Swift.String? {
        return "/"
    }
}

extension AcceptAccountLinkInvitationInput {

    static func write(value: AcceptAccountLinkInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["LinkId"].write(value.linkId)
    }
}

extension AssociateConnectionAliasInput {

    static func write(value: AssociateConnectionAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AliasId"].write(value.aliasId)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension AssociateIpGroupsInput {

    static func write(value: AssociateIpGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryId"].write(value.directoryId)
        try writer["GroupIds"].writeList(value.groupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateWorkspaceApplicationInput {

    static func write(value: AssociateWorkspaceApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
        try writer["WorkspaceId"].write(value.workspaceId)
    }
}

extension AuthorizeIpRulesInput {

    static func write(value: AuthorizeIpRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
        try writer["UserRules"].writeList(value.userRules, memberWritingClosure: WorkSpacesClientTypes.IpRuleItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CopyWorkspaceImageInput {

    static func write(value: CopyWorkspaceImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["SourceImageId"].write(value.sourceImageId)
        try writer["SourceRegion"].write(value.sourceRegion)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkSpacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAccountLinkInvitationInput {

    static func write(value: CreateAccountLinkInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["TargetAccountId"].write(value.targetAccountId)
    }
}

extension CreateConnectClientAddInInput {

    static func write(value: CreateConnectClientAddInInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["ResourceId"].write(value.resourceId)
        try writer["URL"].write(value.url)
    }
}

extension CreateConnectionAliasInput {

    static func write(value: CreateConnectionAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionString"].write(value.connectionString)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkSpacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateIpGroupInput {

    static func write(value: CreateIpGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupDesc"].write(value.groupDesc)
        try writer["GroupName"].write(value.groupName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkSpacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserRules"].writeList(value.userRules, memberWritingClosure: WorkSpacesClientTypes.IpRuleItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateStandbyWorkspacesInput {

    static func write(value: CreateStandbyWorkspacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PrimaryRegion"].write(value.primaryRegion)
        try writer["StandbyWorkspaces"].writeList(value.standbyWorkspaces, memberWritingClosure: WorkSpacesClientTypes.StandbyWorkspace.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateTagsInput {

    static func write(value: CreateTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkSpacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateUpdatedWorkspaceImageInput {

    static func write(value: CreateUpdatedWorkspaceImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["SourceImageId"].write(value.sourceImageId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkSpacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateWorkspaceBundleInput {

    static func write(value: CreateWorkspaceBundleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BundleDescription"].write(value.bundleDescription)
        try writer["BundleName"].write(value.bundleName)
        try writer["ComputeType"].write(value.computeType, with: WorkSpacesClientTypes.ComputeType.write(value:to:))
        try writer["ImageId"].write(value.imageId)
        try writer["RootStorage"].write(value.rootStorage, with: WorkSpacesClientTypes.RootStorage.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkSpacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserStorage"].write(value.userStorage, with: WorkSpacesClientTypes.UserStorage.write(value:to:))
    }
}

extension CreateWorkspaceImageInput {

    static func write(value: CreateWorkspaceImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkSpacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkspaceId"].write(value.workspaceId)
    }
}

extension CreateWorkspacesInput {

    static func write(value: CreateWorkspacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Workspaces"].writeList(value.workspaces, memberWritingClosure: WorkSpacesClientTypes.WorkspaceRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateWorkspacesPoolInput {

    static func write(value: CreateWorkspacesPoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationSettings"].write(value.applicationSettings, with: WorkSpacesClientTypes.ApplicationSettingsRequest.write(value:to:))
        try writer["BundleId"].write(value.bundleId)
        try writer["Capacity"].write(value.capacity, with: WorkSpacesClientTypes.Capacity.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DirectoryId"].write(value.directoryId)
        try writer["PoolName"].write(value.poolName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkSpacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimeoutSettings"].write(value.timeoutSettings, with: WorkSpacesClientTypes.TimeoutSettings.write(value:to:))
    }
}

extension DeleteAccountLinkInvitationInput {

    static func write(value: DeleteAccountLinkInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["LinkId"].write(value.linkId)
    }
}

extension DeleteClientBrandingInput {

    static func write(value: DeleteClientBrandingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Platforms"].writeList(value.platforms, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesClientTypes.ClientDeviceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension DeleteConnectClientAddInInput {

    static func write(value: DeleteConnectClientAddInInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddInId"].write(value.addInId)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension DeleteConnectionAliasInput {

    static func write(value: DeleteConnectionAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AliasId"].write(value.aliasId)
    }
}

extension DeleteIpGroupInput {

    static func write(value: DeleteIpGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
    }
}

extension DeleteTagsInput {

    static func write(value: DeleteTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteWorkspaceBundleInput {

    static func write(value: DeleteWorkspaceBundleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BundleId"].write(value.bundleId)
    }
}

extension DeleteWorkspaceImageInput {

    static func write(value: DeleteWorkspaceImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImageId"].write(value.imageId)
    }
}

extension DeployWorkspaceApplicationsInput {

    static func write(value: DeployWorkspaceApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Force"].write(value.force)
        try writer["WorkspaceId"].write(value.workspaceId)
    }
}

extension DeregisterWorkspaceDirectoryInput {

    static func write(value: DeregisterWorkspaceDirectoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryId"].write(value.directoryId)
    }
}

extension DescribeAccountInput {

    static func write(value: DescribeAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeAccountModificationsInput {

    static func write(value: DescribeAccountModificationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeApplicationAssociationsInput {

    static func write(value: DescribeApplicationAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
        try writer["AssociatedResourceTypes"].writeList(value.associatedResourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesClientTypes.ApplicationAssociatedResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeApplicationsInput {

    static func write(value: DescribeApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationIds"].writeList(value.applicationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComputeTypeNames"].writeList(value.computeTypeNames, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesClientTypes.Compute>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LicenseType"].write(value.licenseType)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OperatingSystemNames"].writeList(value.operatingSystemNames, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesClientTypes.OperatingSystemName>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Owner"].write(value.owner)
    }
}

extension DescribeBundleAssociationsInput {

    static func write(value: DescribeBundleAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociatedResourceTypes"].writeList(value.associatedResourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesClientTypes.BundleAssociatedResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BundleId"].write(value.bundleId)
    }
}

extension DescribeClientBrandingInput {

    static func write(value: DescribeClientBrandingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension DescribeClientPropertiesInput {

    static func write(value: DescribeClientPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceIds"].writeList(value.resourceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeConnectClientAddInsInput {

    static func write(value: DescribeConnectClientAddInsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension DescribeConnectionAliasesInput {

    static func write(value: DescribeConnectionAliasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AliasIds"].writeList(value.aliasIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension DescribeConnectionAliasPermissionsInput {

    static func write(value: DescribeConnectionAliasPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AliasId"].write(value.aliasId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeImageAssociationsInput {

    static func write(value: DescribeImageAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociatedResourceTypes"].writeList(value.associatedResourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesClientTypes.ImageAssociatedResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ImageId"].write(value.imageId)
    }
}

extension DescribeIpGroupsInput {

    static func write(value: DescribeIpGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupIds"].writeList(value.groupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeTagsInput {

    static func write(value: DescribeTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension DescribeWorkspaceAssociationsInput {

    static func write(value: DescribeWorkspaceAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociatedResourceTypes"].writeList(value.associatedResourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesClientTypes.WorkSpaceAssociatedResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkspaceId"].write(value.workspaceId)
    }
}

extension DescribeWorkspaceBundlesInput {

    static func write(value: DescribeWorkspaceBundlesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BundleIds"].writeList(value.bundleIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
        try writer["Owner"].write(value.owner)
    }
}

extension DescribeWorkspaceDirectoriesInput {

    static func write(value: DescribeWorkspaceDirectoriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryIds"].writeList(value.directoryIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: WorkSpacesClientTypes.DescribeWorkspaceDirectoriesFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkspaceDirectoryNames"].writeList(value.workspaceDirectoryNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeWorkspaceImagePermissionsInput {

    static func write(value: DescribeWorkspaceImagePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImageId"].write(value.imageId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeWorkspaceImagesInput {

    static func write(value: DescribeWorkspaceImagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImageIds"].writeList(value.imageIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ImageType"].write(value.imageType)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeWorkspacesInput {

    static func write(value: DescribeWorkspacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BundleId"].write(value.bundleId)
        try writer["DirectoryId"].write(value.directoryId)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["UserName"].write(value.userName)
        try writer["WorkspaceIds"].writeList(value.workspaceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkspaceName"].write(value.workspaceName)
    }
}

extension DescribeWorkspacesConnectionStatusInput {

    static func write(value: DescribeWorkspacesConnectionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkspaceIds"].writeList(value.workspaceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeWorkspaceSnapshotsInput {

    static func write(value: DescribeWorkspaceSnapshotsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceId"].write(value.workspaceId)
    }
}

extension DescribeWorkspacesPoolsInput {

    static func write(value: DescribeWorkspacesPoolsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: WorkSpacesClientTypes.DescribeWorkspacesPoolsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["PoolIds"].writeList(value.poolIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeWorkspacesPoolSessionsInput {

    static func write(value: DescribeWorkspacesPoolSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["PoolId"].write(value.poolId)
        try writer["UserId"].write(value.userId)
    }
}

extension DisassociateConnectionAliasInput {

    static func write(value: DisassociateConnectionAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AliasId"].write(value.aliasId)
    }
}

extension DisassociateIpGroupsInput {

    static func write(value: DisassociateIpGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryId"].write(value.directoryId)
        try writer["GroupIds"].writeList(value.groupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisassociateWorkspaceApplicationInput {

    static func write(value: DisassociateWorkspaceApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationId"].write(value.applicationId)
        try writer["WorkspaceId"].write(value.workspaceId)
    }
}

extension GetAccountLinkInput {

    static func write(value: GetAccountLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LinkId"].write(value.linkId)
        try writer["LinkedAccountId"].write(value.linkedAccountId)
    }
}

extension ImportClientBrandingInput {

    static func write(value: ImportClientBrandingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceTypeAndroid"].write(value.deviceTypeAndroid, with: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.write(value:to:))
        try writer["DeviceTypeIos"].write(value.deviceTypeIos, with: WorkSpacesClientTypes.IosImportClientBrandingAttributes.write(value:to:))
        try writer["DeviceTypeLinux"].write(value.deviceTypeLinux, with: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.write(value:to:))
        try writer["DeviceTypeOsx"].write(value.deviceTypeOsx, with: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.write(value:to:))
        try writer["DeviceTypeWeb"].write(value.deviceTypeWeb, with: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.write(value:to:))
        try writer["DeviceTypeWindows"].write(value.deviceTypeWindows, with: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.write(value:to:))
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension ImportWorkspaceImageInput {

    static func write(value: ImportWorkspaceImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Applications"].writeList(value.applications, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesClientTypes.Application>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Ec2ImageId"].write(value.ec2ImageId)
        try writer["ImageDescription"].write(value.imageDescription)
        try writer["ImageName"].write(value.imageName)
        try writer["IngestionProcess"].write(value.ingestionProcess)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkSpacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListAccountLinksInput {

    static func write(value: ListAccountLinksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LinkStatusFilter"].writeList(value.linkStatusFilter, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesClientTypes.AccountLinkStatusEnum>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListAvailableManagementCidrRangesInput {

    static func write(value: ListAvailableManagementCidrRangesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ManagementCidrRangeConstraint"].write(value.managementCidrRangeConstraint)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension MigrateWorkspaceInput {

    static func write(value: MigrateWorkspaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BundleId"].write(value.bundleId)
        try writer["SourceWorkspaceId"].write(value.sourceWorkspaceId)
    }
}

extension ModifyAccountInput {

    static func write(value: ModifyAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DedicatedTenancyManagementCidrRange"].write(value.dedicatedTenancyManagementCidrRange)
        try writer["DedicatedTenancySupport"].write(value.dedicatedTenancySupport)
    }
}

extension ModifyCertificateBasedAuthPropertiesInput {

    static func write(value: ModifyCertificateBasedAuthPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateBasedAuthProperties"].write(value.certificateBasedAuthProperties, with: WorkSpacesClientTypes.CertificateBasedAuthProperties.write(value:to:))
        try writer["PropertiesToDelete"].writeList(value.propertiesToDelete, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension ModifyClientPropertiesInput {

    static func write(value: ModifyClientPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientProperties"].write(value.clientProperties, with: WorkSpacesClientTypes.ClientProperties.write(value:to:))
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension ModifySamlPropertiesInput {

    static func write(value: ModifySamlPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PropertiesToDelete"].writeList(value.propertiesToDelete, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesClientTypes.DeletableSamlProperty>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceId"].write(value.resourceId)
        try writer["SamlProperties"].write(value.samlProperties, with: WorkSpacesClientTypes.SamlProperties.write(value:to:))
    }
}

extension ModifySelfservicePermissionsInput {

    static func write(value: ModifySelfservicePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["SelfservicePermissions"].write(value.selfservicePermissions, with: WorkSpacesClientTypes.SelfservicePermissions.write(value:to:))
    }
}

extension ModifyStreamingPropertiesInput {

    static func write(value: ModifyStreamingPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["StreamingProperties"].write(value.streamingProperties, with: WorkSpacesClientTypes.StreamingProperties.write(value:to:))
    }
}

extension ModifyWorkspaceAccessPropertiesInput {

    static func write(value: ModifyWorkspaceAccessPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["WorkspaceAccessProperties"].write(value.workspaceAccessProperties, with: WorkSpacesClientTypes.WorkspaceAccessProperties.write(value:to:))
    }
}

extension ModifyWorkspaceCreationPropertiesInput {

    static func write(value: ModifyWorkspaceCreationPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["WorkspaceCreationProperties"].write(value.workspaceCreationProperties, with: WorkSpacesClientTypes.WorkspaceCreationProperties.write(value:to:))
    }
}

extension ModifyWorkspacePropertiesInput {

    static func write(value: ModifyWorkspacePropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataReplication"].write(value.dataReplication)
        try writer["WorkspaceId"].write(value.workspaceId)
        try writer["WorkspaceProperties"].write(value.workspaceProperties, with: WorkSpacesClientTypes.WorkspaceProperties.write(value:to:))
    }
}

extension ModifyWorkspaceStateInput {

    static func write(value: ModifyWorkspaceStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceId"].write(value.workspaceId)
        try writer["WorkspaceState"].write(value.workspaceState)
    }
}

extension RebootWorkspacesInput {

    static func write(value: RebootWorkspacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RebootWorkspaceRequests"].writeList(value.rebootWorkspaceRequests, memberWritingClosure: WorkSpacesClientTypes.RebootRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RebuildWorkspacesInput {

    static func write(value: RebuildWorkspacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RebuildWorkspaceRequests"].writeList(value.rebuildWorkspaceRequests, memberWritingClosure: WorkSpacesClientTypes.RebuildRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RegisterWorkspaceDirectoryInput {

    static func write(value: RegisterWorkspaceDirectoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActiveDirectoryConfig"].write(value.activeDirectoryConfig, with: WorkSpacesClientTypes.ActiveDirectoryConfig.write(value:to:))
        try writer["DirectoryId"].write(value.directoryId)
        try writer["EnableSelfService"].write(value.enableSelfService)
        try writer["EnableWorkDocs"].write(value.enableWorkDocs)
        try writer["IdcInstanceArn"].write(value.idcInstanceArn)
        try writer["MicrosoftEntraConfig"].write(value.microsoftEntraConfig, with: WorkSpacesClientTypes.MicrosoftEntraConfig.write(value:to:))
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkSpacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tenancy"].write(value.tenancy)
        try writer["UserIdentityType"].write(value.userIdentityType)
        try writer["WorkspaceDirectoryDescription"].write(value.workspaceDirectoryDescription)
        try writer["WorkspaceDirectoryName"].write(value.workspaceDirectoryName)
        try writer["WorkspaceType"].write(value.workspaceType)
    }
}

extension RejectAccountLinkInvitationInput {

    static func write(value: RejectAccountLinkInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["LinkId"].write(value.linkId)
    }
}

extension RestoreWorkspaceInput {

    static func write(value: RestoreWorkspaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceId"].write(value.workspaceId)
    }
}

extension RevokeIpRulesInput {

    static func write(value: RevokeIpRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
        try writer["UserRules"].writeList(value.userRules, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartWorkspacesInput {

    static func write(value: StartWorkspacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StartWorkspaceRequests"].writeList(value.startWorkspaceRequests, memberWritingClosure: WorkSpacesClientTypes.StartRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartWorkspacesPoolInput {

    static func write(value: StartWorkspacesPoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PoolId"].write(value.poolId)
    }
}

extension StopWorkspacesInput {

    static func write(value: StopWorkspacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StopWorkspaceRequests"].writeList(value.stopWorkspaceRequests, memberWritingClosure: WorkSpacesClientTypes.StopRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StopWorkspacesPoolInput {

    static func write(value: StopWorkspacesPoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PoolId"].write(value.poolId)
    }
}

extension TerminateWorkspacesInput {

    static func write(value: TerminateWorkspacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TerminateWorkspaceRequests"].writeList(value.terminateWorkspaceRequests, memberWritingClosure: WorkSpacesClientTypes.TerminateRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TerminateWorkspacesPoolInput {

    static func write(value: TerminateWorkspacesPoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PoolId"].write(value.poolId)
    }
}

extension TerminateWorkspacesPoolSessionInput {

    static func write(value: TerminateWorkspacesPoolSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SessionId"].write(value.sessionId)
    }
}

extension UpdateConnectClientAddInInput {

    static func write(value: UpdateConnectClientAddInInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddInId"].write(value.addInId)
        try writer["Name"].write(value.name)
        try writer["ResourceId"].write(value.resourceId)
        try writer["URL"].write(value.url)
    }
}

extension UpdateConnectionAliasPermissionInput {

    static func write(value: UpdateConnectionAliasPermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AliasId"].write(value.aliasId)
        try writer["ConnectionAliasPermission"].write(value.connectionAliasPermission, with: WorkSpacesClientTypes.ConnectionAliasPermission.write(value:to:))
    }
}

extension UpdateRulesOfIpGroupInput {

    static func write(value: UpdateRulesOfIpGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
        try writer["UserRules"].writeList(value.userRules, memberWritingClosure: WorkSpacesClientTypes.IpRuleItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateWorkspaceBundleInput {

    static func write(value: UpdateWorkspaceBundleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BundleId"].write(value.bundleId)
        try writer["ImageId"].write(value.imageId)
    }
}

extension UpdateWorkspaceImagePermissionInput {

    static func write(value: UpdateWorkspaceImagePermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowCopyImage"].write(value.allowCopyImage)
        try writer["ImageId"].write(value.imageId)
        try writer["SharedAccountId"].write(value.sharedAccountId)
    }
}

extension UpdateWorkspacesPoolInput {

    static func write(value: UpdateWorkspacesPoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationSettings"].write(value.applicationSettings, with: WorkSpacesClientTypes.ApplicationSettingsRequest.write(value:to:))
        try writer["BundleId"].write(value.bundleId)
        try writer["Capacity"].write(value.capacity, with: WorkSpacesClientTypes.Capacity.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DirectoryId"].write(value.directoryId)
        try writer["PoolId"].write(value.poolId)
        try writer["TimeoutSettings"].write(value.timeoutSettings, with: WorkSpacesClientTypes.TimeoutSettings.write(value:to:))
    }
}

extension AcceptAccountLinkInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptAccountLinkInvitationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptAccountLinkInvitationOutput()
        value.accountLink = try reader["AccountLink"].readIfPresent(with: WorkSpacesClientTypes.AccountLink.read(from:))
        return value
    }
}

extension AssociateConnectionAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateConnectionAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateConnectionAliasOutput()
        value.connectionIdentifier = try reader["ConnectionIdentifier"].readIfPresent()
        return value
    }
}

extension AssociateIpGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateIpGroupsOutput {
        return AssociateIpGroupsOutput()
    }
}

extension AssociateWorkspaceApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateWorkspaceApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateWorkspaceApplicationOutput()
        value.association = try reader["Association"].readIfPresent(with: WorkSpacesClientTypes.WorkspaceResourceAssociation.read(from:))
        return value
    }
}

extension AuthorizeIpRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AuthorizeIpRulesOutput {
        return AuthorizeIpRulesOutput()
    }
}

extension CopyWorkspaceImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CopyWorkspaceImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CopyWorkspaceImageOutput()
        value.imageId = try reader["ImageId"].readIfPresent()
        return value
    }
}

extension CreateAccountLinkInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccountLinkInvitationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccountLinkInvitationOutput()
        value.accountLink = try reader["AccountLink"].readIfPresent(with: WorkSpacesClientTypes.AccountLink.read(from:))
        return value
    }
}

extension CreateConnectClientAddInOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectClientAddInOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectClientAddInOutput()
        value.addInId = try reader["AddInId"].readIfPresent()
        return value
    }
}

extension CreateConnectionAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectionAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectionAliasOutput()
        value.aliasId = try reader["AliasId"].readIfPresent()
        return value
    }
}

extension CreateIpGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIpGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIpGroupOutput()
        value.groupId = try reader["GroupId"].readIfPresent()
        return value
    }
}

extension CreateStandbyWorkspacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStandbyWorkspacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStandbyWorkspacesOutput()
        value.failedStandbyRequests = try reader["FailedStandbyRequests"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.pendingStandbyRequests = try reader["PendingStandbyRequests"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTagsOutput {
        return CreateTagsOutput()
    }
}

extension CreateUpdatedWorkspaceImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUpdatedWorkspaceImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUpdatedWorkspaceImageOutput()
        value.imageId = try reader["ImageId"].readIfPresent()
        return value
    }
}

extension CreateWorkspaceBundleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkspaceBundleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkspaceBundleOutput()
        value.workspaceBundle = try reader["WorkspaceBundle"].readIfPresent(with: WorkSpacesClientTypes.WorkspaceBundle.read(from:))
        return value
    }
}

extension CreateWorkspaceImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkspaceImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkspaceImageOutput()
        value.created = try reader["Created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.imageId = try reader["ImageId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.operatingSystem = try reader["OperatingSystem"].readIfPresent(with: WorkSpacesClientTypes.OperatingSystem.read(from:))
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.requiredTenancy = try reader["RequiredTenancy"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension CreateWorkspacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkspacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkspacesOutput()
        value.failedRequests = try reader["FailedRequests"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.FailedCreateWorkspaceRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.pendingRequests = try reader["PendingRequests"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.Workspace.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateWorkspacesPoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkspacesPoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkspacesPoolOutput()
        value.workspacesPool = try reader["WorkspacesPool"].readIfPresent(with: WorkSpacesClientTypes.WorkspacesPool.read(from:))
        return value
    }
}

extension DeleteAccountLinkInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccountLinkInvitationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAccountLinkInvitationOutput()
        value.accountLink = try reader["AccountLink"].readIfPresent(with: WorkSpacesClientTypes.AccountLink.read(from:))
        return value
    }
}

extension DeleteClientBrandingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteClientBrandingOutput {
        return DeleteClientBrandingOutput()
    }
}

extension DeleteConnectClientAddInOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectClientAddInOutput {
        return DeleteConnectClientAddInOutput()
    }
}

extension DeleteConnectionAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectionAliasOutput {
        return DeleteConnectionAliasOutput()
    }
}

extension DeleteIpGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIpGroupOutput {
        return DeleteIpGroupOutput()
    }
}

extension DeleteTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTagsOutput {
        return DeleteTagsOutput()
    }
}

extension DeleteWorkspaceBundleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkspaceBundleOutput {
        return DeleteWorkspaceBundleOutput()
    }
}

extension DeleteWorkspaceImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkspaceImageOutput {
        return DeleteWorkspaceImageOutput()
    }
}

extension DeployWorkspaceApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeployWorkspaceApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeployWorkspaceApplicationsOutput()
        value.deployment = try reader["Deployment"].readIfPresent(with: WorkSpacesClientTypes.WorkSpaceApplicationDeployment.read(from:))
        return value
    }
}

extension DeregisterWorkspaceDirectoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterWorkspaceDirectoryOutput {
        return DeregisterWorkspaceDirectoryOutput()
    }
}

extension DescribeAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountOutput()
        value.dedicatedTenancyAccountType = try reader["DedicatedTenancyAccountType"].readIfPresent()
        value.dedicatedTenancyManagementCidrRange = try reader["DedicatedTenancyManagementCidrRange"].readIfPresent()
        value.dedicatedTenancySupport = try reader["DedicatedTenancySupport"].readIfPresent()
        return value
    }
}

extension DescribeAccountModificationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountModificationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountModificationsOutput()
        value.accountModifications = try reader["AccountModifications"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.AccountModification.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeApplicationAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationAssociationsOutput()
        value.associations = try reader["Associations"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.ApplicationResourceAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationsOutput()
        value.applications = try reader["Applications"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.WorkSpaceApplication.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeBundleAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBundleAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBundleAssociationsOutput()
        value.associations = try reader["Associations"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.BundleResourceAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeClientBrandingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeClientBrandingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeClientBrandingOutput()
        value.deviceTypeAndroid = try reader["DeviceTypeAndroid"].readIfPresent(with: WorkSpacesClientTypes.DefaultClientBrandingAttributes.read(from:))
        value.deviceTypeIos = try reader["DeviceTypeIos"].readIfPresent(with: WorkSpacesClientTypes.IosClientBrandingAttributes.read(from:))
        value.deviceTypeLinux = try reader["DeviceTypeLinux"].readIfPresent(with: WorkSpacesClientTypes.DefaultClientBrandingAttributes.read(from:))
        value.deviceTypeOsx = try reader["DeviceTypeOsx"].readIfPresent(with: WorkSpacesClientTypes.DefaultClientBrandingAttributes.read(from:))
        value.deviceTypeWeb = try reader["DeviceTypeWeb"].readIfPresent(with: WorkSpacesClientTypes.DefaultClientBrandingAttributes.read(from:))
        value.deviceTypeWindows = try reader["DeviceTypeWindows"].readIfPresent(with: WorkSpacesClientTypes.DefaultClientBrandingAttributes.read(from:))
        return value
    }
}

extension DescribeClientPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeClientPropertiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeClientPropertiesOutput()
        value.clientPropertiesList = try reader["ClientPropertiesList"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.ClientPropertiesResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeConnectClientAddInsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectClientAddInsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectClientAddInsOutput()
        value.addIns = try reader["AddIns"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.ConnectClientAddIn.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeConnectionAliasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectionAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectionAliasesOutput()
        value.connectionAliases = try reader["ConnectionAliases"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.ConnectionAlias.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeConnectionAliasPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectionAliasPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectionAliasPermissionsOutput()
        value.aliasId = try reader["AliasId"].readIfPresent()
        value.connectionAliasPermissions = try reader["ConnectionAliasPermissions"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.ConnectionAliasPermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeImageAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeImageAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeImageAssociationsOutput()
        value.associations = try reader["Associations"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.ImageResourceAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeIpGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeIpGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeIpGroupsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.result = try reader["Result"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.WorkspacesIpGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTagsOutput()
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeWorkspaceAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspaceAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspaceAssociationsOutput()
        value.associations = try reader["Associations"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.WorkspaceResourceAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeWorkspaceBundlesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspaceBundlesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspaceBundlesOutput()
        value.bundles = try reader["Bundles"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.WorkspaceBundle.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeWorkspaceDirectoriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspaceDirectoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspaceDirectoriesOutput()
        value.directories = try reader["Directories"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.WorkspaceDirectory.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeWorkspaceImagePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspaceImagePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspaceImagePermissionsOutput()
        value.imageId = try reader["ImageId"].readIfPresent()
        value.imagePermissions = try reader["ImagePermissions"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.ImagePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeWorkspaceImagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspaceImagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspaceImagesOutput()
        value.images = try reader["Images"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.WorkspaceImage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeWorkspacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspacesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workspaces = try reader["Workspaces"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.Workspace.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeWorkspacesConnectionStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspacesConnectionStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspacesConnectionStatusOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workspacesConnectionStatus = try reader["WorkspacesConnectionStatus"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.WorkspaceConnectionStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeWorkspaceSnapshotsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspaceSnapshotsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspaceSnapshotsOutput()
        value.rebuildSnapshots = try reader["RebuildSnapshots"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.Snapshot.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.restoreSnapshots = try reader["RestoreSnapshots"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.Snapshot.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeWorkspacesPoolsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspacesPoolsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspacesPoolsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workspacesPools = try reader["WorkspacesPools"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.WorkspacesPool.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeWorkspacesPoolSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkspacesPoolSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkspacesPoolSessionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sessions = try reader["Sessions"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.WorkspacesPoolSession.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DisassociateConnectionAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateConnectionAliasOutput {
        return DisassociateConnectionAliasOutput()
    }
}

extension DisassociateIpGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateIpGroupsOutput {
        return DisassociateIpGroupsOutput()
    }
}

extension DisassociateWorkspaceApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateWorkspaceApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateWorkspaceApplicationOutput()
        value.association = try reader["Association"].readIfPresent(with: WorkSpacesClientTypes.WorkspaceResourceAssociation.read(from:))
        return value
    }
}

extension GetAccountLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountLinkOutput()
        value.accountLink = try reader["AccountLink"].readIfPresent(with: WorkSpacesClientTypes.AccountLink.read(from:))
        return value
    }
}

extension ImportClientBrandingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportClientBrandingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportClientBrandingOutput()
        value.deviceTypeAndroid = try reader["DeviceTypeAndroid"].readIfPresent(with: WorkSpacesClientTypes.DefaultClientBrandingAttributes.read(from:))
        value.deviceTypeIos = try reader["DeviceTypeIos"].readIfPresent(with: WorkSpacesClientTypes.IosClientBrandingAttributes.read(from:))
        value.deviceTypeLinux = try reader["DeviceTypeLinux"].readIfPresent(with: WorkSpacesClientTypes.DefaultClientBrandingAttributes.read(from:))
        value.deviceTypeOsx = try reader["DeviceTypeOsx"].readIfPresent(with: WorkSpacesClientTypes.DefaultClientBrandingAttributes.read(from:))
        value.deviceTypeWeb = try reader["DeviceTypeWeb"].readIfPresent(with: WorkSpacesClientTypes.DefaultClientBrandingAttributes.read(from:))
        value.deviceTypeWindows = try reader["DeviceTypeWindows"].readIfPresent(with: WorkSpacesClientTypes.DefaultClientBrandingAttributes.read(from:))
        return value
    }
}

extension ImportWorkspaceImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportWorkspaceImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportWorkspaceImageOutput()
        value.imageId = try reader["ImageId"].readIfPresent()
        return value
    }
}

extension ListAccountLinksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountLinksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountLinksOutput()
        value.accountLinks = try reader["AccountLinks"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.AccountLink.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAvailableManagementCidrRangesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAvailableManagementCidrRangesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAvailableManagementCidrRangesOutput()
        value.managementCidrRanges = try reader["ManagementCidrRanges"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension MigrateWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MigrateWorkspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MigrateWorkspaceOutput()
        value.sourceWorkspaceId = try reader["SourceWorkspaceId"].readIfPresent()
        value.targetWorkspaceId = try reader["TargetWorkspaceId"].readIfPresent()
        return value
    }
}

extension ModifyAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyAccountOutput {
        return ModifyAccountOutput()
    }
}

extension ModifyCertificateBasedAuthPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyCertificateBasedAuthPropertiesOutput {
        return ModifyCertificateBasedAuthPropertiesOutput()
    }
}

extension ModifyClientPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyClientPropertiesOutput {
        return ModifyClientPropertiesOutput()
    }
}

extension ModifySamlPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifySamlPropertiesOutput {
        return ModifySamlPropertiesOutput()
    }
}

extension ModifySelfservicePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifySelfservicePermissionsOutput {
        return ModifySelfservicePermissionsOutput()
    }
}

extension ModifyStreamingPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyStreamingPropertiesOutput {
        return ModifyStreamingPropertiesOutput()
    }
}

extension ModifyWorkspaceAccessPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyWorkspaceAccessPropertiesOutput {
        return ModifyWorkspaceAccessPropertiesOutput()
    }
}

extension ModifyWorkspaceCreationPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyWorkspaceCreationPropertiesOutput {
        return ModifyWorkspaceCreationPropertiesOutput()
    }
}

extension ModifyWorkspacePropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyWorkspacePropertiesOutput {
        return ModifyWorkspacePropertiesOutput()
    }
}

extension ModifyWorkspaceStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyWorkspaceStateOutput {
        return ModifyWorkspaceStateOutput()
    }
}

extension RebootWorkspacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RebootWorkspacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RebootWorkspacesOutput()
        value.failedRequests = try reader["FailedRequests"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.FailedWorkspaceChangeRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RebuildWorkspacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RebuildWorkspacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RebuildWorkspacesOutput()
        value.failedRequests = try reader["FailedRequests"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.FailedWorkspaceChangeRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RegisterWorkspaceDirectoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterWorkspaceDirectoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterWorkspaceDirectoryOutput()
        value.directoryId = try reader["DirectoryId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension RejectAccountLinkInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectAccountLinkInvitationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RejectAccountLinkInvitationOutput()
        value.accountLink = try reader["AccountLink"].readIfPresent(with: WorkSpacesClientTypes.AccountLink.read(from:))
        return value
    }
}

extension RestoreWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreWorkspaceOutput {
        return RestoreWorkspaceOutput()
    }
}

extension RevokeIpRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RevokeIpRulesOutput {
        return RevokeIpRulesOutput()
    }
}

extension StartWorkspacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartWorkspacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartWorkspacesOutput()
        value.failedRequests = try reader["FailedRequests"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.FailedWorkspaceChangeRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartWorkspacesPoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartWorkspacesPoolOutput {
        return StartWorkspacesPoolOutput()
    }
}

extension StopWorkspacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopWorkspacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopWorkspacesOutput()
        value.failedRequests = try reader["FailedRequests"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.FailedWorkspaceChangeRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StopWorkspacesPoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopWorkspacesPoolOutput {
        return StopWorkspacesPoolOutput()
    }
}

extension TerminateWorkspacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TerminateWorkspacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TerminateWorkspacesOutput()
        value.failedRequests = try reader["FailedRequests"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.FailedWorkspaceChangeRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TerminateWorkspacesPoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TerminateWorkspacesPoolOutput {
        return TerminateWorkspacesPoolOutput()
    }
}

extension TerminateWorkspacesPoolSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TerminateWorkspacesPoolSessionOutput {
        return TerminateWorkspacesPoolSessionOutput()
    }
}

extension UpdateConnectClientAddInOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectClientAddInOutput {
        return UpdateConnectClientAddInOutput()
    }
}

extension UpdateConnectionAliasPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectionAliasPermissionOutput {
        return UpdateConnectionAliasPermissionOutput()
    }
}

extension UpdateRulesOfIpGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRulesOfIpGroupOutput {
        return UpdateRulesOfIpGroupOutput()
    }
}

extension UpdateWorkspaceBundleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkspaceBundleOutput {
        return UpdateWorkspaceBundleOutput()
    }
}

extension UpdateWorkspaceImagePermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkspaceImagePermissionOutput {
        return UpdateWorkspaceImagePermissionOutput()
    }
}

extension UpdateWorkspacesPoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkspacesPoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkspacesPoolOutput()
        value.workspacesPool = try reader["WorkspacesPool"].readIfPresent(with: WorkSpacesClientTypes.WorkspacesPool.read(from:))
        return value
    }
}

enum AcceptAccountLinkInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateConnectionAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceAssociatedException": return try ResourceAssociatedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateIpGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateWorkspaceApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ApplicationNotSupportedException": return try ApplicationNotSupportedException.makeError(baseError: baseError)
            case "ComputeNotCompatibleException": return try ComputeNotCompatibleException.makeError(baseError: baseError)
            case "IncompatibleApplicationsException": return try IncompatibleApplicationsException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperatingSystemNotCompatibleException": return try OperatingSystemNotCompatibleException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AuthorizeIpRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CopyWorkspaceImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccountLinkInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectClientAddInOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceCreationFailedException": return try ResourceCreationFailedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectionAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIpGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceCreationFailedException": return try ResourceCreationFailedException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStandbyWorkspacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUpdatedWorkspaceImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkspaceBundleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkspaceImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkspacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkspacesPoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccountLinkInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteClientBrandingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectClientAddInOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectionAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceAssociatedException": return try ResourceAssociatedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIpGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceAssociatedException": return try ResourceAssociatedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkspaceBundleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceAssociatedException": return try ResourceAssociatedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkspaceImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "ResourceAssociatedException": return try ResourceAssociatedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeployWorkspaceApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IncompatibleApplicationsException": return try IncompatibleApplicationsException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterWorkspaceDirectoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountModificationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBundleAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeClientBrandingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeClientPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectClientAddInsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectionAliasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectionAliasPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeImageAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeIpGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspaceAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspaceBundlesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspaceDirectoriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspaceImagePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspaceImagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspacesConnectionStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspaceSnapshotsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspacesPoolsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkspacesPoolSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateConnectionAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateIpGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateWorkspaceApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportClientBrandingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportWorkspaceImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountLinksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAvailableManagementCidrRangesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MigrateWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationInProgressException": return try OperationInProgressException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyCertificateBasedAuthPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyClientPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifySamlPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifySelfservicePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyStreamingPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyWorkspaceAccessPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyWorkspaceCreationPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyWorkspacePropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationInProgressException": return try OperationInProgressException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "UnsupportedWorkspaceConfigurationException": return try UnsupportedWorkspaceConfigurationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyWorkspaceStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RebootWorkspacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RebuildWorkspacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterWorkspaceDirectoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedNetworkConfigurationException": return try UnsupportedNetworkConfigurationException.makeError(baseError: baseError)
            case "WorkspacesDefaultRoleNotFoundException": return try WorkspacesDefaultRoleNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectAccountLinkInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RevokeIpRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartWorkspacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartWorkspacesPoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationInProgressException": return try OperationInProgressException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopWorkspacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopWorkspacesPoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationInProgressException": return try OperationInProgressException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TerminateWorkspacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TerminateWorkspacesPoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationInProgressException": return try OperationInProgressException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TerminateWorkspacesPoolSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationInProgressException": return try OperationInProgressException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectClientAddInOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectionAliasPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceAssociatedException": return try ResourceAssociatedException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRulesOfIpGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkspaceBundleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkspaceImagePermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkspacesPoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterValuesException": return try InvalidParameterValuesException.makeError(baseError: baseError)
            case "InvalidResourceStateException": return try InvalidResourceStateException.makeError(baseError: baseError)
            case "OperationInProgressException": return try OperationInProgressException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterValuesException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterValuesException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterValuesException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationNotSupportedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationNotSupportedException {
        let reader = baseError.errorBodyReader
        var value = OperationNotSupportedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResourceStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidResourceStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidResourceStateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAssociatedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceAssociatedException {
        let reader = baseError.errorBodyReader
        var value = ResourceAssociatedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ComputeNotCompatibleException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ComputeNotCompatibleException {
        var value = ComputeNotCompatibleException()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApplicationNotSupportedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ApplicationNotSupportedException {
        var value = ApplicationNotSupportedException()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperatingSystemNotCompatibleException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperatingSystemNotCompatibleException {
        var value = OperatingSystemNotCompatibleException()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IncompatibleApplicationsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IncompatibleApplicationsException {
        var value = IncompatibleApplicationsException()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ResourceUnavailableException()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceCreationFailedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceCreationFailedException {
        let reader = baseError.errorBodyReader
        var value = ResourceCreationFailedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationInProgressException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationInProgressException {
        let reader = baseError.errorBodyReader
        var value = OperationInProgressException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedWorkspaceConfigurationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedWorkspaceConfigurationException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedWorkspaceConfigurationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedNetworkConfigurationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedNetworkConfigurationException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedNetworkConfigurationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WorkspacesDefaultRoleNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> WorkspacesDefaultRoleNotFoundException {
        let reader = baseError.errorBodyReader
        var value = WorkspacesDefaultRoleNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WorkSpacesClientTypes.AccountLink {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.AccountLink {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.AccountLink()
        value.accountLinkId = try reader["AccountLinkId"].readIfPresent()
        value.accountLinkStatus = try reader["AccountLinkStatus"].readIfPresent()
        value.sourceAccountId = try reader["SourceAccountId"].readIfPresent()
        value.targetAccountId = try reader["TargetAccountId"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.WorkspaceResourceAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkspaceResourceAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkspaceResourceAssociation()
        value.associatedResourceId = try reader["AssociatedResourceId"].readIfPresent()
        value.associatedResourceType = try reader["AssociatedResourceType"].readIfPresent()
        value.created = try reader["Created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent(with: WorkSpacesClientTypes.AssociationStateReason.read(from:))
        value.workspaceId = try reader["WorkspaceId"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.AssociationStateReason {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.AssociationStateReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.AssociationStateReason()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest()
        value.standbyWorkspaceRequest = try reader["StandbyWorkspaceRequest"].readIfPresent(with: WorkSpacesClientTypes.StandbyWorkspace.read(from:))
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.StandbyWorkspace {

    static func write(value: WorkSpacesClientTypes.StandbyWorkspace?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataReplication"].write(value.dataReplication)
        try writer["DirectoryId"].write(value.directoryId)
        try writer["PrimaryWorkspaceId"].write(value.primaryWorkspaceId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkSpacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VolumeEncryptionKey"].write(value.volumeEncryptionKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.StandbyWorkspace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.StandbyWorkspace()
        value.primaryWorkspaceId = try reader["PrimaryWorkspaceId"].readIfPresent() ?? ""
        value.volumeEncryptionKey = try reader["VolumeEncryptionKey"].readIfPresent()
        value.directoryId = try reader["DirectoryId"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataReplication = try reader["DataReplication"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.Tag {

    static func write(value: WorkSpacesClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest()
        value.userName = try reader["UserName"].readIfPresent()
        value.directoryId = try reader["DirectoryId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.workspaceId = try reader["WorkspaceId"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.WorkspaceBundle {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkspaceBundle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkspaceBundle()
        value.bundleId = try reader["BundleId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.imageId = try reader["ImageId"].readIfPresent()
        value.rootStorage = try reader["RootStorage"].readIfPresent(with: WorkSpacesClientTypes.RootStorage.read(from:))
        value.userStorage = try reader["UserStorage"].readIfPresent(with: WorkSpacesClientTypes.UserStorage.read(from:))
        value.computeType = try reader["ComputeType"].readIfPresent(with: WorkSpacesClientTypes.ComputeType.read(from:))
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.bundleType = try reader["BundleType"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.ComputeType {

    static func write(value: WorkSpacesClientTypes.ComputeType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ComputeType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ComputeType()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.UserStorage {

    static func write(value: WorkSpacesClientTypes.UserStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Capacity"].write(value.capacity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.UserStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.UserStorage()
        value.capacity = try reader["Capacity"].readIfPresent() ?? ""
        return value
    }
}

extension WorkSpacesClientTypes.RootStorage {

    static func write(value: WorkSpacesClientTypes.RootStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Capacity"].write(value.capacity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.RootStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.RootStorage()
        value.capacity = try reader["Capacity"].readIfPresent() ?? ""
        return value
    }
}

extension WorkSpacesClientTypes.OperatingSystem {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.OperatingSystem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.OperatingSystem()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.FailedCreateWorkspaceRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.FailedCreateWorkspaceRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.FailedCreateWorkspaceRequest()
        value.workspaceRequest = try reader["WorkspaceRequest"].readIfPresent(with: WorkSpacesClientTypes.WorkspaceRequest.read(from:))
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.WorkspaceRequest {

    static func write(value: WorkSpacesClientTypes.WorkspaceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BundleId"].write(value.bundleId)
        try writer["DirectoryId"].write(value.directoryId)
        try writer["RootVolumeEncryptionEnabled"].write(value.rootVolumeEncryptionEnabled)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkSpacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserName"].write(value.userName)
        try writer["UserVolumeEncryptionEnabled"].write(value.userVolumeEncryptionEnabled)
        try writer["VolumeEncryptionKey"].write(value.volumeEncryptionKey)
        try writer["WorkspaceName"].write(value.workspaceName)
        try writer["WorkspaceProperties"].write(value.workspaceProperties, with: WorkSpacesClientTypes.WorkspaceProperties.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkspaceRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkspaceRequest()
        value.directoryId = try reader["DirectoryId"].readIfPresent() ?? ""
        value.userName = try reader["UserName"].readIfPresent() ?? ""
        value.bundleId = try reader["BundleId"].readIfPresent() ?? ""
        value.volumeEncryptionKey = try reader["VolumeEncryptionKey"].readIfPresent()
        value.userVolumeEncryptionEnabled = try reader["UserVolumeEncryptionEnabled"].readIfPresent()
        value.rootVolumeEncryptionEnabled = try reader["RootVolumeEncryptionEnabled"].readIfPresent()
        value.workspaceProperties = try reader["WorkspaceProperties"].readIfPresent(with: WorkSpacesClientTypes.WorkspaceProperties.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.workspaceName = try reader["WorkspaceName"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.WorkspaceProperties {

    static func write(value: WorkSpacesClientTypes.WorkspaceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComputeTypeName"].write(value.computeTypeName)
        try writer["OperatingSystemName"].write(value.operatingSystemName)
        try writer["Protocols"].writeList(value.protocols, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesClientTypes.ModelProtocol>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RootVolumeSizeGib"].write(value.rootVolumeSizeGib)
        try writer["RunningMode"].write(value.runningMode)
        try writer["RunningModeAutoStopTimeoutInMinutes"].write(value.runningModeAutoStopTimeoutInMinutes)
        try writer["UserVolumeSizeGib"].write(value.userVolumeSizeGib)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkspaceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkspaceProperties()
        value.runningMode = try reader["RunningMode"].readIfPresent()
        value.runningModeAutoStopTimeoutInMinutes = try reader["RunningModeAutoStopTimeoutInMinutes"].readIfPresent()
        value.rootVolumeSizeGib = try reader["RootVolumeSizeGib"].readIfPresent()
        value.userVolumeSizeGib = try reader["UserVolumeSizeGib"].readIfPresent()
        value.computeTypeName = try reader["ComputeTypeName"].readIfPresent()
        value.protocols = try reader["Protocols"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<WorkSpacesClientTypes.ModelProtocol>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.operatingSystemName = try reader["OperatingSystemName"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.Workspace {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.Workspace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.Workspace()
        value.workspaceId = try reader["WorkspaceId"].readIfPresent()
        value.directoryId = try reader["DirectoryId"].readIfPresent()
        value.userName = try reader["UserName"].readIfPresent()
        value.ipAddress = try reader["IpAddress"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.bundleId = try reader["BundleId"].readIfPresent()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.computerName = try reader["ComputerName"].readIfPresent()
        value.volumeEncryptionKey = try reader["VolumeEncryptionKey"].readIfPresent()
        value.userVolumeEncryptionEnabled = try reader["UserVolumeEncryptionEnabled"].readIfPresent()
        value.rootVolumeEncryptionEnabled = try reader["RootVolumeEncryptionEnabled"].readIfPresent()
        value.workspaceName = try reader["WorkspaceName"].readIfPresent()
        value.workspaceProperties = try reader["WorkspaceProperties"].readIfPresent(with: WorkSpacesClientTypes.WorkspaceProperties.read(from:))
        value.modificationStates = try reader["ModificationStates"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.ModificationState.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.relatedWorkspaces = try reader["RelatedWorkspaces"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.RelatedWorkspaceProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataReplicationSettings = try reader["DataReplicationSettings"].readIfPresent(with: WorkSpacesClientTypes.DataReplicationSettings.read(from:))
        value.standbyWorkspacesProperties = try reader["StandbyWorkspacesProperties"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.StandbyWorkspacesProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkSpacesClientTypes.StandbyWorkspacesProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.StandbyWorkspacesProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.StandbyWorkspacesProperties()
        value.standbyWorkspaceId = try reader["StandbyWorkspaceId"].readIfPresent()
        value.dataReplication = try reader["DataReplication"].readIfPresent()
        value.recoverySnapshotTime = try reader["RecoverySnapshotTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkSpacesClientTypes.DataReplicationSettings {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.DataReplicationSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.DataReplicationSettings()
        value.dataReplication = try reader["DataReplication"].readIfPresent()
        value.recoverySnapshotTime = try reader["RecoverySnapshotTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkSpacesClientTypes.RelatedWorkspaceProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.RelatedWorkspaceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.RelatedWorkspaceProperties()
        value.workspaceId = try reader["WorkspaceId"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.ModificationState {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ModificationState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ModificationState()
        value.resource = try reader["Resource"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.WorkspacesPool {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkspacesPool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkspacesPool()
        value.poolId = try reader["PoolId"].readIfPresent() ?? ""
        value.poolArn = try reader["PoolArn"].readIfPresent() ?? ""
        value.capacityStatus = try reader["CapacityStatus"].readIfPresent(with: WorkSpacesClientTypes.CapacityStatus.read(from:))
        value.poolName = try reader["PoolName"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.bundleId = try reader["BundleId"].readIfPresent() ?? ""
        value.directoryId = try reader["DirectoryId"].readIfPresent() ?? ""
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.WorkspacesPoolError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.applicationSettings = try reader["ApplicationSettings"].readIfPresent(with: WorkSpacesClientTypes.ApplicationSettingsResponse.read(from:))
        value.timeoutSettings = try reader["TimeoutSettings"].readIfPresent(with: WorkSpacesClientTypes.TimeoutSettings.read(from:))
        return value
    }
}

extension WorkSpacesClientTypes.TimeoutSettings {

    static func write(value: WorkSpacesClientTypes.TimeoutSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisconnectTimeoutInSeconds"].write(value.disconnectTimeoutInSeconds)
        try writer["IdleDisconnectTimeoutInSeconds"].write(value.idleDisconnectTimeoutInSeconds)
        try writer["MaxUserDurationInSeconds"].write(value.maxUserDurationInSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.TimeoutSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.TimeoutSettings()
        value.disconnectTimeoutInSeconds = try reader["DisconnectTimeoutInSeconds"].readIfPresent()
        value.idleDisconnectTimeoutInSeconds = try reader["IdleDisconnectTimeoutInSeconds"].readIfPresent()
        value.maxUserDurationInSeconds = try reader["MaxUserDurationInSeconds"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.ApplicationSettingsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ApplicationSettingsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ApplicationSettingsResponse()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.settingsGroup = try reader["SettingsGroup"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.WorkspacesPoolError {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkspacesPoolError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkspacesPoolError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.CapacityStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.CapacityStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.CapacityStatus()
        value.availableUserSessions = try reader["AvailableUserSessions"].readIfPresent() ?? 0
        value.desiredUserSessions = try reader["DesiredUserSessions"].readIfPresent() ?? 0
        value.actualUserSessions = try reader["ActualUserSessions"].readIfPresent() ?? 0
        value.activeUserSessions = try reader["ActiveUserSessions"].readIfPresent() ?? 0
        return value
    }
}

extension WorkSpacesClientTypes.WorkSpaceApplicationDeployment {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkSpaceApplicationDeployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkSpaceApplicationDeployment()
        value.associations = try reader["Associations"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.WorkspaceResourceAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkSpacesClientTypes.AccountModification {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.AccountModification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.AccountModification()
        value.modificationState = try reader["ModificationState"].readIfPresent()
        value.dedicatedTenancySupport = try reader["DedicatedTenancySupport"].readIfPresent()
        value.dedicatedTenancyManagementCidrRange = try reader["DedicatedTenancyManagementCidrRange"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.ApplicationResourceAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ApplicationResourceAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ApplicationResourceAssociation()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.associatedResourceId = try reader["AssociatedResourceId"].readIfPresent()
        value.associatedResourceType = try reader["AssociatedResourceType"].readIfPresent()
        value.created = try reader["Created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent(with: WorkSpacesClientTypes.AssociationStateReason.read(from:))
        return value
    }
}

extension WorkSpacesClientTypes.WorkSpaceApplication {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkSpaceApplication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkSpaceApplication()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.created = try reader["Created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.licenseType = try reader["LicenseType"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.supportedComputeTypeNames = try reader["SupportedComputeTypeNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<WorkSpacesClientTypes.Compute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.supportedOperatingSystemNames = try reader["SupportedOperatingSystemNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<WorkSpacesClientTypes.OperatingSystemName>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkSpacesClientTypes.BundleResourceAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.BundleResourceAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.BundleResourceAssociation()
        value.associatedResourceId = try reader["AssociatedResourceId"].readIfPresent()
        value.associatedResourceType = try reader["AssociatedResourceType"].readIfPresent()
        value.bundleId = try reader["BundleId"].readIfPresent()
        value.created = try reader["Created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent(with: WorkSpacesClientTypes.AssociationStateReason.read(from:))
        return value
    }
}

extension WorkSpacesClientTypes.DefaultClientBrandingAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.DefaultClientBrandingAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.DefaultClientBrandingAttributes()
        value.logoUrl = try reader["LogoUrl"].readIfPresent()
        value.supportEmail = try reader["SupportEmail"].readIfPresent()
        value.supportLink = try reader["SupportLink"].readIfPresent()
        value.forgotPasswordLink = try reader["ForgotPasswordLink"].readIfPresent()
        value.loginMessage = try reader["LoginMessage"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WorkSpacesClientTypes.IosClientBrandingAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.IosClientBrandingAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.IosClientBrandingAttributes()
        value.logoUrl = try reader["LogoUrl"].readIfPresent()
        value.logo2xUrl = try reader["Logo2xUrl"].readIfPresent()
        value.logo3xUrl = try reader["Logo3xUrl"].readIfPresent()
        value.supportEmail = try reader["SupportEmail"].readIfPresent()
        value.supportLink = try reader["SupportLink"].readIfPresent()
        value.forgotPasswordLink = try reader["ForgotPasswordLink"].readIfPresent()
        value.loginMessage = try reader["LoginMessage"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WorkSpacesClientTypes.ClientPropertiesResult {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ClientPropertiesResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ClientPropertiesResult()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.clientProperties = try reader["ClientProperties"].readIfPresent(with: WorkSpacesClientTypes.ClientProperties.read(from:))
        return value
    }
}

extension WorkSpacesClientTypes.ClientProperties {

    static func write(value: WorkSpacesClientTypes.ClientProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogUploadEnabled"].write(value.logUploadEnabled)
        try writer["ReconnectEnabled"].write(value.reconnectEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ClientProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ClientProperties()
        value.reconnectEnabled = try reader["ReconnectEnabled"].readIfPresent()
        value.logUploadEnabled = try reader["LogUploadEnabled"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.ConnectClientAddIn {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ConnectClientAddIn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ConnectClientAddIn()
        value.addInId = try reader["AddInId"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.url = try reader["URL"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.ConnectionAlias {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ConnectionAlias {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ConnectionAlias()
        value.connectionString = try reader["ConnectionString"].readIfPresent()
        value.aliasId = try reader["AliasId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.associations = try reader["Associations"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.ConnectionAliasAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkSpacesClientTypes.ConnectionAliasAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ConnectionAliasAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ConnectionAliasAssociation()
        value.associationStatus = try reader["AssociationStatus"].readIfPresent()
        value.associatedAccountId = try reader["AssociatedAccountId"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.connectionIdentifier = try reader["ConnectionIdentifier"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.ConnectionAliasPermission {

    static func write(value: WorkSpacesClientTypes.ConnectionAliasPermission?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowAssociation"].write(value.allowAssociation)
        try writer["SharedAccountId"].write(value.sharedAccountId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ConnectionAliasPermission {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ConnectionAliasPermission()
        value.sharedAccountId = try reader["SharedAccountId"].readIfPresent() ?? ""
        value.allowAssociation = try reader["AllowAssociation"].readIfPresent() ?? false
        return value
    }
}

extension WorkSpacesClientTypes.ImageResourceAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ImageResourceAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ImageResourceAssociation()
        value.associatedResourceId = try reader["AssociatedResourceId"].readIfPresent()
        value.associatedResourceType = try reader["AssociatedResourceType"].readIfPresent()
        value.created = try reader["Created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.imageId = try reader["ImageId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent(with: WorkSpacesClientTypes.AssociationStateReason.read(from:))
        return value
    }
}

extension WorkSpacesClientTypes.WorkspacesIpGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkspacesIpGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkspacesIpGroup()
        value.groupId = try reader["groupId"].readIfPresent()
        value.groupName = try reader["groupName"].readIfPresent()
        value.groupDesc = try reader["groupDesc"].readIfPresent()
        value.userRules = try reader["userRules"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.IpRuleItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkSpacesClientTypes.IpRuleItem {

    static func write(value: WorkSpacesClientTypes.IpRuleItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ipRule"].write(value.ipRule)
        try writer["ruleDesc"].write(value.ruleDesc)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.IpRuleItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.IpRuleItem()
        value.ipRule = try reader["ipRule"].readIfPresent()
        value.ruleDesc = try reader["ruleDesc"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.WorkspaceDirectory {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkspaceDirectory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkspaceDirectory()
        value.directoryId = try reader["DirectoryId"].readIfPresent()
        value.alias = try reader["Alias"].readIfPresent()
        value.directoryName = try reader["DirectoryName"].readIfPresent()
        value.registrationCode = try reader["RegistrationCode"].readIfPresent()
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dnsIpAddresses = try reader["DnsIpAddresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.customerUserName = try reader["CustomerUserName"].readIfPresent()
        value.iamRoleId = try reader["IamRoleId"].readIfPresent()
        value.directoryType = try reader["DirectoryType"].readIfPresent()
        value.workspaceSecurityGroupId = try reader["WorkspaceSecurityGroupId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.workspaceCreationProperties = try reader["WorkspaceCreationProperties"].readIfPresent(with: WorkSpacesClientTypes.DefaultWorkspaceCreationProperties.read(from:))
        value.ipGroupIds = try reader["ipGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.workspaceAccessProperties = try reader["WorkspaceAccessProperties"].readIfPresent(with: WorkSpacesClientTypes.WorkspaceAccessProperties.read(from:))
        value.tenancy = try reader["Tenancy"].readIfPresent()
        value.selfservicePermissions = try reader["SelfservicePermissions"].readIfPresent(with: WorkSpacesClientTypes.SelfservicePermissions.read(from:))
        value.samlProperties = try reader["SamlProperties"].readIfPresent(with: WorkSpacesClientTypes.SamlProperties.read(from:))
        value.certificateBasedAuthProperties = try reader["CertificateBasedAuthProperties"].readIfPresent(with: WorkSpacesClientTypes.CertificateBasedAuthProperties.read(from:))
        value.microsoftEntraConfig = try reader["MicrosoftEntraConfig"].readIfPresent(with: WorkSpacesClientTypes.MicrosoftEntraConfig.read(from:))
        value.workspaceDirectoryName = try reader["WorkspaceDirectoryName"].readIfPresent()
        value.workspaceDirectoryDescription = try reader["WorkspaceDirectoryDescription"].readIfPresent()
        value.userIdentityType = try reader["UserIdentityType"].readIfPresent()
        value.workspaceType = try reader["WorkspaceType"].readIfPresent()
        value.idcConfig = try reader["IDCConfig"].readIfPresent(with: WorkSpacesClientTypes.IDCConfig.read(from:))
        value.activeDirectoryConfig = try reader["ActiveDirectoryConfig"].readIfPresent(with: WorkSpacesClientTypes.ActiveDirectoryConfig.read(from:))
        value.streamingProperties = try reader["StreamingProperties"].readIfPresent(with: WorkSpacesClientTypes.StreamingProperties.read(from:))
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.StreamingProperties {

    static func write(value: WorkSpacesClientTypes.StreamingProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StorageConnectors"].writeList(value.storageConnectors, memberWritingClosure: WorkSpacesClientTypes.StorageConnector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StreamingExperiencePreferredProtocol"].write(value.streamingExperiencePreferredProtocol)
        try writer["UserSettings"].writeList(value.userSettings, memberWritingClosure: WorkSpacesClientTypes.UserSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.StreamingProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.StreamingProperties()
        value.streamingExperiencePreferredProtocol = try reader["StreamingExperiencePreferredProtocol"].readIfPresent()
        value.userSettings = try reader["UserSettings"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.UserSetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.storageConnectors = try reader["StorageConnectors"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.StorageConnector.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkSpacesClientTypes.StorageConnector {

    static func write(value: WorkSpacesClientTypes.StorageConnector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorType"].write(value.connectorType)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.StorageConnector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.StorageConnector()
        value.connectorType = try reader["ConnectorType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension WorkSpacesClientTypes.UserSetting {

    static func write(value: WorkSpacesClientTypes.UserSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["MaximumLength"].write(value.maximumLength)
        try writer["Permission"].write(value.permission)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.UserSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.UserSetting()
        value.action = try reader["Action"].readIfPresent() ?? .sdkUnknown("")
        value.permission = try reader["Permission"].readIfPresent() ?? .sdkUnknown("")
        value.maximumLength = try reader["MaximumLength"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.ActiveDirectoryConfig {

    static func write(value: WorkSpacesClientTypes.ActiveDirectoryConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["ServiceAccountSecretArn"].write(value.serviceAccountSecretArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ActiveDirectoryConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ActiveDirectoryConfig()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.serviceAccountSecretArn = try reader["ServiceAccountSecretArn"].readIfPresent() ?? ""
        return value
    }
}

extension WorkSpacesClientTypes.IDCConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.IDCConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.IDCConfig()
        value.instanceArn = try reader["InstanceArn"].readIfPresent()
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.MicrosoftEntraConfig {

    static func write(value: WorkSpacesClientTypes.MicrosoftEntraConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationConfigSecretArn"].write(value.applicationConfigSecretArn)
        try writer["TenantId"].write(value.tenantId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.MicrosoftEntraConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.MicrosoftEntraConfig()
        value.tenantId = try reader["TenantId"].readIfPresent()
        value.applicationConfigSecretArn = try reader["ApplicationConfigSecretArn"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.CertificateBasedAuthProperties {

    static func write(value: WorkSpacesClientTypes.CertificateBasedAuthProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateAuthorityArn"].write(value.certificateAuthorityArn)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.CertificateBasedAuthProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.CertificateBasedAuthProperties()
        value.status = try reader["Status"].readIfPresent()
        value.certificateAuthorityArn = try reader["CertificateAuthorityArn"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.SamlProperties {

    static func write(value: WorkSpacesClientTypes.SamlProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RelayStateParameterName"].write(value.relayStateParameterName)
        try writer["Status"].write(value.status)
        try writer["UserAccessUrl"].write(value.userAccessUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.SamlProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.SamlProperties()
        value.status = try reader["Status"].readIfPresent()
        value.userAccessUrl = try reader["UserAccessUrl"].readIfPresent()
        value.relayStateParameterName = try reader["RelayStateParameterName"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.SelfservicePermissions {

    static func write(value: WorkSpacesClientTypes.SelfservicePermissions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChangeComputeType"].write(value.changeComputeType)
        try writer["IncreaseVolumeSize"].write(value.increaseVolumeSize)
        try writer["RebuildWorkspace"].write(value.rebuildWorkspace)
        try writer["RestartWorkspace"].write(value.restartWorkspace)
        try writer["SwitchRunningMode"].write(value.switchRunningMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.SelfservicePermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.SelfservicePermissions()
        value.restartWorkspace = try reader["RestartWorkspace"].readIfPresent()
        value.increaseVolumeSize = try reader["IncreaseVolumeSize"].readIfPresent()
        value.changeComputeType = try reader["ChangeComputeType"].readIfPresent()
        value.switchRunningMode = try reader["SwitchRunningMode"].readIfPresent()
        value.rebuildWorkspace = try reader["RebuildWorkspace"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.WorkspaceAccessProperties {

    static func write(value: WorkSpacesClientTypes.WorkspaceAccessProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceTypeAndroid"].write(value.deviceTypeAndroid)
        try writer["DeviceTypeChromeOs"].write(value.deviceTypeChromeOs)
        try writer["DeviceTypeIos"].write(value.deviceTypeIos)
        try writer["DeviceTypeLinux"].write(value.deviceTypeLinux)
        try writer["DeviceTypeOsx"].write(value.deviceTypeOsx)
        try writer["DeviceTypeWeb"].write(value.deviceTypeWeb)
        try writer["DeviceTypeWindows"].write(value.deviceTypeWindows)
        try writer["DeviceTypeZeroClient"].write(value.deviceTypeZeroClient)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkspaceAccessProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkspaceAccessProperties()
        value.deviceTypeWindows = try reader["DeviceTypeWindows"].readIfPresent()
        value.deviceTypeOsx = try reader["DeviceTypeOsx"].readIfPresent()
        value.deviceTypeWeb = try reader["DeviceTypeWeb"].readIfPresent()
        value.deviceTypeIos = try reader["DeviceTypeIos"].readIfPresent()
        value.deviceTypeAndroid = try reader["DeviceTypeAndroid"].readIfPresent()
        value.deviceTypeChromeOs = try reader["DeviceTypeChromeOs"].readIfPresent()
        value.deviceTypeZeroClient = try reader["DeviceTypeZeroClient"].readIfPresent()
        value.deviceTypeLinux = try reader["DeviceTypeLinux"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.DefaultWorkspaceCreationProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.DefaultWorkspaceCreationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.DefaultWorkspaceCreationProperties()
        value.enableWorkDocs = try reader["EnableWorkDocs"].readIfPresent()
        value.enableInternetAccess = try reader["EnableInternetAccess"].readIfPresent()
        value.defaultOu = try reader["DefaultOu"].readIfPresent()
        value.customSecurityGroupId = try reader["CustomSecurityGroupId"].readIfPresent()
        value.userEnabledAsLocalAdministrator = try reader["UserEnabledAsLocalAdministrator"].readIfPresent()
        value.enableMaintenanceMode = try reader["EnableMaintenanceMode"].readIfPresent()
        value.instanceIamRoleArn = try reader["InstanceIamRoleArn"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.ImagePermission {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ImagePermission {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ImagePermission()
        value.sharedAccountId = try reader["SharedAccountId"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.WorkspaceImage {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkspaceImage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkspaceImage()
        value.imageId = try reader["ImageId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.operatingSystem = try reader["OperatingSystem"].readIfPresent(with: WorkSpacesClientTypes.OperatingSystem.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.requiredTenancy = try reader["RequiredTenancy"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.created = try reader["Created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.updates = try reader["Updates"].readIfPresent(with: WorkSpacesClientTypes.UpdateResult.read(from:))
        value.errorDetails = try reader["ErrorDetails"].readListIfPresent(memberReadingClosure: WorkSpacesClientTypes.ErrorDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkSpacesClientTypes.ErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.ErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.ErrorDetails()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.UpdateResult {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.UpdateResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.UpdateResult()
        value.updateAvailable = try reader["UpdateAvailable"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.WorkspaceConnectionStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkspaceConnectionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkspaceConnectionStatus()
        value.workspaceId = try reader["WorkspaceId"].readIfPresent()
        value.connectionState = try reader["ConnectionState"].readIfPresent()
        value.connectionStateCheckTimestamp = try reader["ConnectionStateCheckTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastKnownUserConnectionTimestamp = try reader["LastKnownUserConnectionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkSpacesClientTypes.Snapshot {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.Snapshot {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.Snapshot()
        value.snapshotTime = try reader["SnapshotTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkSpacesClientTypes.WorkspacesPoolSession {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.WorkspacesPoolSession {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.WorkspacesPoolSession()
        value.authenticationType = try reader["AuthenticationType"].readIfPresent()
        value.connectionState = try reader["ConnectionState"].readIfPresent()
        value.sessionId = try reader["SessionId"].readIfPresent() ?? ""
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent() ?? ""
        value.expirationTime = try reader["ExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.networkAccessConfiguration = try reader["NetworkAccessConfiguration"].readIfPresent(with: WorkSpacesClientTypes.NetworkAccessConfiguration.read(from:))
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.userId = try reader["UserId"].readIfPresent() ?? ""
        return value
    }
}

extension WorkSpacesClientTypes.NetworkAccessConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.NetworkAccessConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.NetworkAccessConfiguration()
        value.eniPrivateIpAddress = try reader["EniPrivateIpAddress"].readIfPresent()
        value.eniId = try reader["EniId"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.FailedWorkspaceChangeRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesClientTypes.FailedWorkspaceChangeRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesClientTypes.FailedWorkspaceChangeRequest()
        value.workspaceId = try reader["WorkspaceId"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension WorkSpacesClientTypes.Capacity {

    static func write(value: WorkSpacesClientTypes.Capacity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DesiredUserSessions"].write(value.desiredUserSessions)
    }
}

extension WorkSpacesClientTypes.ApplicationSettingsRequest {

    static func write(value: WorkSpacesClientTypes.ApplicationSettingsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SettingsGroup"].write(value.settingsGroup)
        try writer["Status"].write(value.status)
    }
}

extension WorkSpacesClientTypes.DescribeWorkspaceDirectoriesFilter {

    static func write(value: WorkSpacesClientTypes.DescribeWorkspaceDirectoriesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension WorkSpacesClientTypes.DescribeWorkspacesPoolsFilter {

    static func write(value: WorkSpacesClientTypes.DescribeWorkspacesPoolsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension WorkSpacesClientTypes.DefaultImportClientBrandingAttributes {

    static func write(value: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForgotPasswordLink"].write(value.forgotPasswordLink)
        try writer["LoginMessage"].writeMap(value.loginMessage, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Logo"].write(value.logo)
        try writer["SupportEmail"].write(value.supportEmail)
        try writer["SupportLink"].write(value.supportLink)
    }
}

extension WorkSpacesClientTypes.IosImportClientBrandingAttributes {

    static func write(value: WorkSpacesClientTypes.IosImportClientBrandingAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForgotPasswordLink"].write(value.forgotPasswordLink)
        try writer["LoginMessage"].writeMap(value.loginMessage, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Logo"].write(value.logo)
        try writer["Logo2x"].write(value.logo2x)
        try writer["Logo3x"].write(value.logo3x)
        try writer["SupportEmail"].write(value.supportEmail)
        try writer["SupportLink"].write(value.supportLink)
    }
}

extension WorkSpacesClientTypes.WorkspaceCreationProperties {

    static func write(value: WorkSpacesClientTypes.WorkspaceCreationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomSecurityGroupId"].write(value.customSecurityGroupId)
        try writer["DefaultOu"].write(value.defaultOu)
        try writer["EnableInternetAccess"].write(value.enableInternetAccess)
        try writer["EnableMaintenanceMode"].write(value.enableMaintenanceMode)
        try writer["EnableWorkDocs"].write(value.enableWorkDocs)
        try writer["InstanceIamRoleArn"].write(value.instanceIamRoleArn)
        try writer["UserEnabledAsLocalAdministrator"].write(value.userEnabledAsLocalAdministrator)
    }
}

extension WorkSpacesClientTypes.RebootRequest {

    static func write(value: WorkSpacesClientTypes.RebootRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceId"].write(value.workspaceId)
    }
}

extension WorkSpacesClientTypes.RebuildRequest {

    static func write(value: WorkSpacesClientTypes.RebuildRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceId"].write(value.workspaceId)
    }
}

extension WorkSpacesClientTypes.StartRequest {

    static func write(value: WorkSpacesClientTypes.StartRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceId"].write(value.workspaceId)
    }
}

extension WorkSpacesClientTypes.StopRequest {

    static func write(value: WorkSpacesClientTypes.StopRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceId"].write(value.workspaceId)
    }
}

extension WorkSpacesClientTypes.TerminateRequest {

    static func write(value: WorkSpacesClientTypes.TerminateRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceId"].write(value.workspaceId)
    }
}

public enum WorkSpacesClientTypes {}
