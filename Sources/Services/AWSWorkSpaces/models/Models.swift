// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user is not authorized to access a resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesClientTypes {
    public enum AccessPropertyValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPropertyValue] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessPropertyValue(rawValue: rawValue) ?? AccessPropertyValue.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.AccountModification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case modificationState = "ModificationState"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dedicatedTenancyManagementCidrRange = self.dedicatedTenancyManagementCidrRange {
            try encodeContainer.encode(dedicatedTenancyManagementCidrRange, forKey: .dedicatedTenancyManagementCidrRange)
        }
        if let dedicatedTenancySupport = self.dedicatedTenancySupport {
            try encodeContainer.encode(dedicatedTenancySupport.rawValue, forKey: .dedicatedTenancySupport)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let modificationState = self.modificationState {
            try encodeContainer.encode(modificationState.rawValue, forKey: .modificationState)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modificationStateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DedicatedTenancyModificationStateEnum.self, forKey: .modificationState)
        modificationState = modificationStateDecoded
        let dedicatedTenancySupportDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DedicatedTenancySupportResultEnum.self, forKey: .dedicatedTenancySupport)
        dedicatedTenancySupport = dedicatedTenancySupportDecoded
        let dedicatedTenancyManagementCidrRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedTenancyManagementCidrRange)
        dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRangeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a modification to the configuration of Bring Your Own License (BYOL) for the specified account.
    public struct AccountModification: Swift.Equatable {
        /// The IP address range, specified as an IPv4 CIDR block, for the management network interface used for the account.
        public var dedicatedTenancyManagementCidrRange: Swift.String?
        /// The status of BYOL (whether BYOL is being enabled or disabled).
        public var dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum?
        /// The error code that is returned if the configuration of BYOL cannot be modified.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the configuration of BYOL cannot be modified.
        public var errorMessage: Swift.String?
        /// The state of the modification to the configuration of BYOL.
        public var modificationState: WorkSpacesClientTypes.DedicatedTenancyModificationStateEnum?
        /// The timestamp when the modification of the BYOL configuration was started.
        public var startTime: ClientRuntime.Date?

        public init(
            dedicatedTenancyManagementCidrRange: Swift.String? = nil,
            dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            modificationState: WorkSpacesClientTypes.DedicatedTenancyModificationStateEnum? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
            self.dedicatedTenancySupport = dedicatedTenancySupport
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.modificationState = modificationState
            self.startTime = startTime
        }
    }

}

extension WorkSpacesClientTypes {
    public enum Application: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case microsoftOffice2016
        case microsoftOffice2019
        case sdkUnknown(Swift.String)

        public static var allCases: [Application] {
            return [
                .microsoftOffice2016,
                .microsoftOffice2019,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .microsoftOffice2016: return "Microsoft_Office_2016"
            case .microsoftOffice2019: return "Microsoft_Office_2019"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Application(rawValue: rawValue) ?? Application.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum ApplicationAssociatedResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bundle
        case image
        case workspace
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationAssociatedResourceType] {
            return [
                .bundle,
                .image,
                .workspace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bundle: return "BUNDLE"
            case .image: return "IMAGE"
            case .workspace: return "WORKSPACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationAssociatedResourceType(rawValue: rawValue) ?? ApplicationAssociatedResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationNotSupportedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified application is not supported.
public struct ApplicationNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "ApplicationNotSupportedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension WorkSpacesClientTypes.ApplicationResourceAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case associatedResourceId = "AssociatedResourceId"
        case associatedResourceType = "AssociatedResourceType"
        case created = "Created"
        case lastUpdatedTime = "LastUpdatedTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let associatedResourceId = self.associatedResourceId {
            try encodeContainer.encode(associatedResourceId, forKey: .associatedResourceId)
        }
        if let associatedResourceType = self.associatedResourceType {
            try encodeContainer.encode(associatedResourceType.rawValue, forKey: .associatedResourceType)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = self.stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let associatedResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedResourceId)
        associatedResourceId = associatedResourceIdDecoded
        let associatedResourceTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ApplicationAssociatedResourceType.self, forKey: .associatedResourceType)
        associatedResourceType = associatedResourceTypeDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AssociationState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AssociationStateReason.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the association between an application and an application resource.
    public struct ApplicationResourceAssociation: Swift.Equatable {
        /// The identifier of the application.
        public var applicationId: Swift.String?
        /// The identifier of the associated resource.
        public var associatedResourceId: Swift.String?
        /// The resource type of the associated resource.
        public var associatedResourceType: WorkSpacesClientTypes.ApplicationAssociatedResourceType?
        /// The time the association was created.
        public var created: ClientRuntime.Date?
        /// The time the association status was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The status of the application resource association.
        public var state: WorkSpacesClientTypes.AssociationState?
        /// The reason the association deployment failed.
        public var stateReason: WorkSpacesClientTypes.AssociationStateReason?

        public init(
            applicationId: Swift.String? = nil,
            associatedResourceId: Swift.String? = nil,
            associatedResourceType: WorkSpacesClientTypes.ApplicationAssociatedResourceType? = nil,
            created: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            state: WorkSpacesClientTypes.AssociationState? = nil,
            stateReason: WorkSpacesClientTypes.AssociationStateReason? = nil
        )
        {
            self.applicationId = applicationId
            self.associatedResourceId = associatedResourceId
            self.associatedResourceType = associatedResourceType
            self.created = created
            self.lastUpdatedTime = lastUpdatedTime
            self.state = state
            self.stateReason = stateReason
        }
    }

}

extension AssociateConnectionAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = self.aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension AssociateConnectionAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateConnectionAliasInput: Swift.Equatable {
    /// The identifier of the connection alias.
    /// This member is required.
    public var aliasId: Swift.String?
    /// The identifier of the directory to associate the connection alias with.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        aliasId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
        self.resourceId = resourceId
    }
}

struct AssociateConnectionAliasInputBody: Swift.Equatable {
    let aliasId: Swift.String?
    let resourceId: Swift.String?
}

extension AssociateConnectionAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension AssociateConnectionAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateConnectionAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectionIdentifier = output.connectionIdentifier
        } else {
            self.connectionIdentifier = nil
        }
    }
}

public struct AssociateConnectionAliasOutput: Swift.Equatable {
    /// The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when you're configuring your DNS routing policies.
    public var connectionIdentifier: Swift.String?

    public init(
        connectionIdentifier: Swift.String? = nil
    )
    {
        self.connectionIdentifier = connectionIdentifier
    }
}

struct AssociateConnectionAliasOutputBody: Swift.Equatable {
    let connectionIdentifier: Swift.String?
}

extension AssociateConnectionAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionIdentifier = "ConnectionIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionIdentifier)
        connectionIdentifier = connectionIdentifierDecoded
    }
}

enum AssociateConnectionAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAssociatedException": return try await ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateIpGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for ipgroupid0 in groupIds {
                try groupIdsContainer.encode(ipgroupid0)
            }
        }
    }
}

extension AssociateIpGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateIpGroupsInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The identifiers of one or more IP access control groups.
    /// This member is required.
    public var groupIds: [Swift.String]?

    public init(
        directoryId: Swift.String? = nil,
        groupIds: [Swift.String]? = nil
    )
    {
        self.directoryId = directoryId
        self.groupIds = groupIds
    }
}

struct AssociateIpGroupsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let groupIds: [Swift.String]?
}

extension AssociateIpGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let groupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[Swift.String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [Swift.String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
    }
}

extension AssociateIpGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateIpGroupsOutput: Swift.Equatable {

    public init() { }
}

enum AssociateIpGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateWorkspaceApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension AssociateWorkspaceApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateWorkspaceApplicationInput: Swift.Equatable {
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.workspaceId = workspaceId
    }
}

struct AssociateWorkspaceApplicationInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let applicationId: Swift.String?
}

extension AssociateWorkspaceApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case workspaceId = "WorkspaceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
    }
}

extension AssociateWorkspaceApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateWorkspaceApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.association = output.association
        } else {
            self.association = nil
        }
    }
}

public struct AssociateWorkspaceApplicationOutput: Swift.Equatable {
    /// Information about the association between the specified WorkSpace and the specified application.
    public var association: WorkSpacesClientTypes.WorkspaceResourceAssociation?

    public init(
        association: WorkSpacesClientTypes.WorkspaceResourceAssociation? = nil
    )
    {
        self.association = association
    }
}

struct AssociateWorkspaceApplicationOutputBody: Swift.Equatable {
    let association: WorkSpacesClientTypes.WorkspaceResourceAssociation?
}

extension AssociateWorkspaceApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case association = "Association"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceResourceAssociation.self, forKey: .association)
        association = associationDecoded
    }
}

enum AssociateWorkspaceApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ApplicationNotSupportedException": return try await ApplicationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ComputeNotCompatibleException": return try await ComputeNotCompatibleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncompatibleApplicationsException": return try await IncompatibleApplicationsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperatingSystemNotCompatibleException": return try await OperatingSystemNotCompatibleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum AssociationErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insufficientDiskspace
        case insufficientMemory
        case internalServerError
        case unsupportedOperatingSystem
        case workspaceUnreachable
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationErrorCode] {
            return [
                .insufficientDiskspace,
                .insufficientMemory,
                .internalServerError,
                .unsupportedOperatingSystem,
                .workspaceUnreachable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insufficientDiskspace: return "ValidationError.InsufficientDiskSpace"
            case .insufficientMemory: return "ValidationError.InsufficientMemory"
            case .internalServerError: return "DeploymentError.InternalServerError"
            case .unsupportedOperatingSystem: return "ValidationError.UnsupportedOperatingSystem"
            case .workspaceUnreachable: return "DeploymentError.WorkspaceUnreachable"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationErrorCode(rawValue: rawValue) ?? AssociationErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum AssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case error
        case installing
        case pendingInstall
        case pendingInstallDeployment
        case pendingUninstall
        case pendingUninstallDeployment
        case removed
        case uninstalling
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationState] {
            return [
                .completed,
                .error,
                .installing,
                .pendingInstall,
                .pendingInstallDeployment,
                .pendingUninstall,
                .pendingUninstallDeployment,
                .removed,
                .uninstalling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .error: return "ERROR"
            case .installing: return "INSTALLING"
            case .pendingInstall: return "PENDING_INSTALL"
            case .pendingInstallDeployment: return "PENDING_INSTALL_DEPLOYMENT"
            case .pendingUninstall: return "PENDING_UNINSTALL"
            case .pendingUninstallDeployment: return "PENDING_UNINSTALL_DEPLOYMENT"
            case .removed: return "REMOVED"
            case .uninstalling: return "UNINSTALLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationState(rawValue: rawValue) ?? AssociationState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.AssociationStateReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AssociationErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Indicates the reason that the association deployment failed, including the error code and error message.
    public struct AssociationStateReason: Swift.Equatable {
        /// The error code of the association deployment failure.
        public var errorCode: WorkSpacesClientTypes.AssociationErrorCode?
        /// The error message of the association deployment failure.
        public var errorMessage: Swift.String?

        public init(
            errorCode: WorkSpacesClientTypes.AssociationErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension WorkSpacesClientTypes {
    public enum AssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associatedWithOwnerAccount
        case associatedWithSharedAccount
        case notAssociated
        case pendingAssociation
        case pendingDisassociation
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationStatus] {
            return [
                .associatedWithOwnerAccount,
                .associatedWithSharedAccount,
                .notAssociated,
                .pendingAssociation,
                .pendingDisassociation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associatedWithOwnerAccount: return "ASSOCIATED_WITH_OWNER_ACCOUNT"
            case .associatedWithSharedAccount: return "ASSOCIATED_WITH_SHARED_ACCOUNT"
            case .notAssociated: return "NOT_ASSOCIATED"
            case .pendingAssociation: return "PENDING_ASSOCIATION"
            case .pendingDisassociation: return "PENDING_DISASSOCIATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationStatus(rawValue: rawValue) ?? AssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuthorizeIpRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for ipruleitem0 in userRules {
                try userRulesContainer.encode(ipruleitem0)
            }
        }
    }
}

extension AuthorizeIpRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AuthorizeIpRulesInput: Swift.Equatable {
    /// The identifier of the group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The rules to add to the group.
    /// This member is required.
    public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

    public init(
        groupId: Swift.String? = nil,
        userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

struct AuthorizeIpRulesInputBody: Swift.Equatable {
    let groupId: Swift.String?
    let userRules: [WorkSpacesClientTypes.IpRuleItem]?
}

extension AuthorizeIpRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[WorkSpacesClientTypes.IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [WorkSpacesClientTypes.IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension AuthorizeIpRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AuthorizeIpRulesOutput: Swift.Equatable {

    public init() { }
}

enum AuthorizeIpRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum BundleAssociatedResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case sdkUnknown(Swift.String)

        public static var allCases: [BundleAssociatedResourceType] {
            return [
                .application,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BundleAssociatedResourceType(rawValue: rawValue) ?? BundleAssociatedResourceType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.BundleResourceAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceId = "AssociatedResourceId"
        case associatedResourceType = "AssociatedResourceType"
        case bundleId = "BundleId"
        case created = "Created"
        case lastUpdatedTime = "LastUpdatedTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedResourceId = self.associatedResourceId {
            try encodeContainer.encode(associatedResourceId, forKey: .associatedResourceId)
        }
        if let associatedResourceType = self.associatedResourceType {
            try encodeContainer.encode(associatedResourceType.rawValue, forKey: .associatedResourceType)
        }
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = self.stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedResourceId)
        associatedResourceId = associatedResourceIdDecoded
        let associatedResourceTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.BundleAssociatedResourceType.self, forKey: .associatedResourceType)
        associatedResourceType = associatedResourceTypeDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AssociationState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AssociationStateReason.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the association between an application and a bundle resource.
    public struct BundleResourceAssociation: Swift.Equatable {
        /// The identifier of the associated resource.
        public var associatedResourceId: Swift.String?
        /// The resource type of the associated resources.
        public var associatedResourceType: WorkSpacesClientTypes.BundleAssociatedResourceType?
        /// The identifier of the bundle.
        public var bundleId: Swift.String?
        /// The time the association is created.
        public var created: ClientRuntime.Date?
        /// The time the association status was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The status of the bundle resource association.
        public var state: WorkSpacesClientTypes.AssociationState?
        /// The reason the association deployment failed.
        public var stateReason: WorkSpacesClientTypes.AssociationStateReason?

        public init(
            associatedResourceId: Swift.String? = nil,
            associatedResourceType: WorkSpacesClientTypes.BundleAssociatedResourceType? = nil,
            bundleId: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            state: WorkSpacesClientTypes.AssociationState? = nil,
            stateReason: WorkSpacesClientTypes.AssociationStateReason? = nil
        )
        {
            self.associatedResourceId = associatedResourceId
            self.associatedResourceType = associatedResourceType
            self.bundleId = bundleId
            self.created = created
            self.lastUpdatedTime = lastUpdatedTime
            self.state = state
            self.stateReason = stateReason
        }
    }

}

extension WorkSpacesClientTypes {
    public enum BundleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case regular
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [BundleType] {
            return [
                .regular,
                .standby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .regular: return "REGULAR"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BundleType(rawValue: rawValue) ?? BundleType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.CertificateBasedAuthProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = self.certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.CertificateBasedAuthStatusEnum.self, forKey: .status)
        status = statusDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the properties of the certificate-based authentication you want to use with your WorkSpaces.
    public struct CertificateBasedAuthProperties: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Certificate Manager Private CA resource.
        public var certificateAuthorityArn: Swift.String?
        /// The status of the certificate-based authentication properties.
        public var status: WorkSpacesClientTypes.CertificateBasedAuthStatusEnum?

        public init(
            certificateAuthorityArn: Swift.String? = nil,
            status: WorkSpacesClientTypes.CertificateBasedAuthStatusEnum? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.status = status
        }
    }

}

extension WorkSpacesClientTypes {
    public enum CertificateBasedAuthStatusEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateBasedAuthStatusEnum] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateBasedAuthStatusEnum(rawValue: rawValue) ?? CertificateBasedAuthStatusEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum ClientDeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deviceTypeAndroid
        case deviceTypeIos
        case deviceTypeLinux
        case deviceTypeOsx
        case deviceTypeWeb
        case deviceTypeWindows
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientDeviceType] {
            return [
                .deviceTypeAndroid,
                .deviceTypeIos,
                .deviceTypeLinux,
                .deviceTypeOsx,
                .deviceTypeWeb,
                .deviceTypeWindows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deviceTypeAndroid: return "DeviceTypeAndroid"
            case .deviceTypeIos: return "DeviceTypeIos"
            case .deviceTypeLinux: return "DeviceTypeLinux"
            case .deviceTypeOsx: return "DeviceTypeOsx"
            case .deviceTypeWeb: return "DeviceTypeWeb"
            case .deviceTypeWindows: return "DeviceTypeWindows"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientDeviceType(rawValue: rawValue) ?? ClientDeviceType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.ClientProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logUploadEnabled = "LogUploadEnabled"
        case reconnectEnabled = "ReconnectEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logUploadEnabled = self.logUploadEnabled {
            try encodeContainer.encode(logUploadEnabled.rawValue, forKey: .logUploadEnabled)
        }
        if let reconnectEnabled = self.reconnectEnabled {
            try encodeContainer.encode(reconnectEnabled.rawValue, forKey: .reconnectEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reconnectEnabledDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .reconnectEnabled)
        reconnectEnabled = reconnectEnabledDecoded
        let logUploadEnabledDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.LogUploadEnum.self, forKey: .logUploadEnabled)
        logUploadEnabled = logUploadEnabledDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes an Amazon WorkSpaces client.
    public struct ClientProperties: Swift.Equatable {
        /// Specifies whether users can upload diagnostic log files of Amazon WorkSpaces client directly to WorkSpaces to troubleshoot issues when using the WorkSpaces client. When enabled, the log files will be sent to WorkSpaces automatically and will be applied to all users in the specified directory.
        public var logUploadEnabled: WorkSpacesClientTypes.LogUploadEnum?
        /// Specifies whether users can cache their credentials on the Amazon WorkSpaces client. When enabled, users can choose to reconnect to their WorkSpaces without re-entering their credentials.
        public var reconnectEnabled: WorkSpacesClientTypes.ReconnectEnum?

        public init(
            logUploadEnabled: WorkSpacesClientTypes.LogUploadEnum? = nil,
            reconnectEnabled: WorkSpacesClientTypes.ReconnectEnum? = nil
        )
        {
            self.logUploadEnabled = logUploadEnabled
            self.reconnectEnabled = reconnectEnabled
        }
    }

}

extension WorkSpacesClientTypes.ClientPropertiesResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientProperties = "ClientProperties"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientProperties = self.clientProperties {
            try encodeContainer.encode(clientProperties, forKey: .clientProperties)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let clientPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ClientProperties.self, forKey: .clientProperties)
        clientProperties = clientPropertiesDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Information about the Amazon WorkSpaces client.
    public struct ClientPropertiesResult: Swift.Equatable {
        /// Information about the Amazon WorkSpaces client.
        public var clientProperties: WorkSpacesClientTypes.ClientProperties?
        /// The resource identifier, in the form of a directory ID.
        public var resourceId: Swift.String?

        public init(
            clientProperties: WorkSpacesClientTypes.ClientProperties? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.clientProperties = clientProperties
            self.resourceId = resourceId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum Compute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case graphics
        case graphicspro
        case graphicsproG4dn
        case graphicsG4dn
        case performance
        case power
        case powerpro
        case standard
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [Compute] {
            return [
                .graphics,
                .graphicspro,
                .graphicsproG4dn,
                .graphicsG4dn,
                .performance,
                .power,
                .powerpro,
                .standard,
                .value,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .graphics: return "GRAPHICS"
            case .graphicspro: return "GRAPHICSPRO"
            case .graphicsproG4dn: return "GRAPHICSPRO_G4DN"
            case .graphicsG4dn: return "GRAPHICS_G4DN"
            case .performance: return "PERFORMANCE"
            case .power: return "POWER"
            case .powerpro: return "POWERPRO"
            case .standard: return "STANDARD"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Compute(rawValue: rawValue) ?? Compute.sdkUnknown(rawValue)
        }
    }
}

extension ComputeNotCompatibleException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The compute type of the WorkSpace is not compatible with the application.
public struct ComputeNotCompatibleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "ComputeNotCompatibleException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension WorkSpacesClientTypes.ComputeType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.Compute.self, forKey: .name)
        name = nameDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the compute type of the bundle.
    public struct ComputeType: Swift.Equatable {
        /// The compute type.
        public var name: WorkSpacesClientTypes.Compute?

        public init(
            name: WorkSpacesClientTypes.Compute? = nil
        )
        {
            self.name = name
        }
    }

}

extension WorkSpacesClientTypes.ConnectClientAddIn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addInId = "AddInId"
        case name = "Name"
        case resourceId = "ResourceId"
        case url = "URL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addInId = self.addInId {
            try encodeContainer.encode(addInId, forKey: .addInId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addInIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addInId)
        addInId = addInIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes an Amazon Connect client add-in.
    public struct ConnectClientAddIn: Swift.Equatable {
        /// The client add-in identifier.
        public var addInId: Swift.String?
        /// The name of the client add in.
        public var name: Swift.String?
        /// The directory identifier for which the client add-in is configured.
        public var resourceId: Swift.String?
        /// The endpoint URL of the client add-in.
        public var url: Swift.String?

        public init(
            addInId: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.addInId = addInId
            self.name = name
            self.resourceId = resourceId
            self.url = url
        }
    }

}

extension WorkSpacesClientTypes.ConnectionAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case associations = "Associations"
        case connectionString = "ConnectionString"
        case ownerAccountId = "OwnerAccountId"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = self.aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let associations = associations {
            var associationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associations)
            for connectionaliasassociation0 in associations {
                try associationsContainer.encode(connectionaliasassociation0)
            }
        }
        if let connectionString = self.connectionString {
            try encodeContainer.encode(connectionString, forKey: .connectionString)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionString)
        connectionString = connectionStringDecoded
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ConnectionAliasState.self, forKey: .state)
        state = stateDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let associationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ConnectionAliasAssociation?].self, forKey: .associations)
        var associationsDecoded0:[WorkSpacesClientTypes.ConnectionAliasAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [WorkSpacesClientTypes.ConnectionAliasAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes a connection alias. Connection aliases are used for cross-Region redirection. For more information, see [ Cross-Region Redirection for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html).
    public struct ConnectionAlias: Swift.Equatable {
        /// The identifier of the connection alias.
        public var aliasId: Swift.String?
        /// The association status of the connection alias.
        public var associations: [WorkSpacesClientTypes.ConnectionAliasAssociation]?
        /// The connection string specified for the connection alias. The connection string must be in the form of a fully qualified domain name (FQDN), such as www.example.com.
        public var connectionString: Swift.String?
        /// The identifier of the Amazon Web Services account that owns the connection alias.
        public var ownerAccountId: Swift.String?
        /// The current state of the connection alias.
        public var state: WorkSpacesClientTypes.ConnectionAliasState?

        public init(
            aliasId: Swift.String? = nil,
            associations: [WorkSpacesClientTypes.ConnectionAliasAssociation]? = nil,
            connectionString: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            state: WorkSpacesClientTypes.ConnectionAliasState? = nil
        )
        {
            self.aliasId = aliasId
            self.associations = associations
            self.connectionString = connectionString
            self.ownerAccountId = ownerAccountId
            self.state = state
        }
    }

}

extension WorkSpacesClientTypes.ConnectionAliasAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAccountId = "AssociatedAccountId"
        case associationStatus = "AssociationStatus"
        case connectionIdentifier = "ConnectionIdentifier"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedAccountId = self.associatedAccountId {
            try encodeContainer.encode(associatedAccountId, forKey: .associatedAccountId)
        }
        if let associationStatus = self.associationStatus {
            try encodeContainer.encode(associationStatus.rawValue, forKey: .associationStatus)
        }
        if let connectionIdentifier = self.connectionIdentifier {
            try encodeContainer.encode(connectionIdentifier, forKey: .connectionIdentifier)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let associatedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAccountId)
        associatedAccountId = associatedAccountIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let connectionIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionIdentifier)
        connectionIdentifier = connectionIdentifierDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a connection alias association that is used for cross-Region redirection. For more information, see [ Cross-Region Redirection for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html).
    public struct ConnectionAliasAssociation: Swift.Equatable {
        /// The identifier of the Amazon Web Services account that associated the connection alias with a directory.
        public var associatedAccountId: Swift.String?
        /// The association status of the connection alias.
        public var associationStatus: WorkSpacesClientTypes.AssociationStatus?
        /// The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when you're configuring your DNS routing policies.
        public var connectionIdentifier: Swift.String?
        /// The identifier of the directory associated with a connection alias.
        public var resourceId: Swift.String?

        public init(
            associatedAccountId: Swift.String? = nil,
            associationStatus: WorkSpacesClientTypes.AssociationStatus? = nil,
            connectionIdentifier: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.associatedAccountId = associatedAccountId
            self.associationStatus = associationStatus
            self.connectionIdentifier = connectionIdentifier
            self.resourceId = resourceId
        }
    }

}

extension WorkSpacesClientTypes.ConnectionAliasPermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowAssociation = "AllowAssociation"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowAssociation = self.allowAssociation {
            try encodeContainer.encode(allowAssociation, forKey: .allowAssociation)
        }
        if let sharedAccountId = self.sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let allowAssociationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowAssociation)
        allowAssociation = allowAssociationDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the permissions for a connection alias. Connection aliases are used for cross-Region redirection. For more information, see [ Cross-Region Redirection for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html).
    public struct ConnectionAliasPermission: Swift.Equatable {
        /// Indicates whether the specified Amazon Web Services account is allowed to associate the connection alias with a directory.
        /// This member is required.
        public var allowAssociation: Swift.Bool?
        /// The identifier of the Amazon Web Services account that the connection alias is shared with.
        /// This member is required.
        public var sharedAccountId: Swift.String?

        public init(
            allowAssociation: Swift.Bool? = nil,
            sharedAccountId: Swift.String? = nil
        )
        {
            self.allowAssociation = allowAssociation
            self.sharedAccountId = sharedAccountId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum ConnectionAliasState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionAliasState] {
            return [
                .created,
                .creating,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionAliasState(rawValue: rawValue) ?? ConnectionAliasState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum ConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case disconnected
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionState] {
            return [
                .connected,
                .disconnected,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
        }
    }
}

extension CopyWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case sourceRegion = "SourceRegion"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceImageId = self.sourceImageId {
            try encodeContainer.encode(sourceImageId, forKey: .sourceImageId)
        }
        if let sourceRegion = self.sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CopyWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CopyWorkspaceImageInput: Swift.Equatable {
    /// A description of the image.
    public var description: Swift.String?
    /// The name of the image.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the source image.
    /// This member is required.
    public var sourceImageId: Swift.String?
    /// The identifier of the source Region.
    /// This member is required.
    public var sourceRegion: Swift.String?
    /// The tags for the image.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceImageId: Swift.String? = nil,
        sourceRegion: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.sourceImageId = sourceImageId
        self.sourceRegion = sourceRegion
        self.tags = tags
    }
}

struct CopyWorkspaceImageInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let sourceImageId: Swift.String?
    let sourceRegion: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CopyWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case sourceRegion = "SourceRegion"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceImageId)
        sourceImageId = sourceImageIdDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CopyWorkspaceImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CopyWorkspaceImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
        } else {
            self.imageId = nil
        }
    }
}

public struct CopyWorkspaceImageOutput: Swift.Equatable {
    /// The identifier of the image.
    public var imageId: Swift.String?

    public init(
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct CopyWorkspaceImageOutputBody: Swift.Equatable {
    let imageId: Swift.String?
}

extension CopyWorkspaceImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

enum CopyWorkspaceImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConnectClientAddInInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resourceId = "ResourceId"
        case url = "URL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }
}

extension CreateConnectClientAddInInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConnectClientAddInInput: Swift.Equatable {
    /// The name of the client add-in.
    /// This member is required.
    public var name: Swift.String?
    /// The directory identifier for which to configure the client add-in.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The endpoint URL of the Amazon Connect client add-in.
    /// This member is required.
    public var url: Swift.String?

    public init(
        name: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        url: Swift.String? = nil
    )
    {
        self.name = name
        self.resourceId = resourceId
        self.url = url
    }
}

struct CreateConnectClientAddInInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let name: Swift.String?
    let url: Swift.String?
}

extension CreateConnectClientAddInInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resourceId = "ResourceId"
        case url = "URL"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension CreateConnectClientAddInOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConnectClientAddInOutputBody = try responseDecoder.decode(responseBody: data)
            self.addInId = output.addInId
        } else {
            self.addInId = nil
        }
    }
}

public struct CreateConnectClientAddInOutput: Swift.Equatable {
    /// The client add-in identifier.
    public var addInId: Swift.String?

    public init(
        addInId: Swift.String? = nil
    )
    {
        self.addInId = addInId
    }
}

struct CreateConnectClientAddInOutputBody: Swift.Equatable {
    let addInId: Swift.String?
}

extension CreateConnectClientAddInOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addInId = "AddInId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addInIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addInId)
        addInId = addInIdDecoded
    }
}

enum CreateConnectClientAddInOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceCreationFailedException": return try await ResourceCreationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConnectionAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionString = "ConnectionString"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionString = self.connectionString {
            try encodeContainer.encode(connectionString, forKey: .connectionString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateConnectionAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConnectionAliasInput: Swift.Equatable {
    /// A connection string in the form of a fully qualified domain name (FQDN), such as www.example.com. After you create a connection string, it is always associated to your Amazon Web Services account. You cannot recreate the same connection string with a different account, even if you delete all instances of it from the original account. The connection string is globally reserved for your account.
    /// This member is required.
    public var connectionString: Swift.String?
    /// The tags to associate with the connection alias.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init(
        connectionString: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.connectionString = connectionString
        self.tags = tags
    }
}

struct CreateConnectionAliasInputBody: Swift.Equatable {
    let connectionString: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateConnectionAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionString = "ConnectionString"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionString)
        connectionString = connectionStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectionAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConnectionAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.aliasId = output.aliasId
        } else {
            self.aliasId = nil
        }
    }
}

public struct CreateConnectionAliasOutput: Swift.Equatable {
    /// The identifier of the connection alias.
    public var aliasId: Swift.String?

    public init(
        aliasId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

struct CreateConnectionAliasOutputBody: Swift.Equatable {
    let aliasId: Swift.String?
}

extension CreateConnectionAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
    }
}

enum CreateConnectionAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIpGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupDesc = "GroupDesc"
        case groupName = "GroupName"
        case tags = "Tags"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupDesc = self.groupDesc {
            try encodeContainer.encode(groupDesc, forKey: .groupDesc)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for ipruleitem0 in userRules {
                try userRulesContainer.encode(ipruleitem0)
            }
        }
    }
}

extension CreateIpGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateIpGroupInput: Swift.Equatable {
    /// The description of the group.
    public var groupDesc: Swift.String?
    /// The name of the group.
    /// This member is required.
    public var groupName: Swift.String?
    /// The tags. Each WorkSpaces resource can have a maximum of 50 tags.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// The rules to add to the group.
    public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

    public init(
        groupDesc: Swift.String? = nil,
        groupName: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
    )
    {
        self.groupDesc = groupDesc
        self.groupName = groupName
        self.tags = tags
        self.userRules = userRules
    }
}

struct CreateIpGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let groupDesc: Swift.String?
    let userRules: [WorkSpacesClientTypes.IpRuleItem]?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateIpGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupDesc = "GroupDesc"
        case groupName = "GroupName"
        case tags = "Tags"
        case userRules = "UserRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDescDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupDesc)
        groupDesc = groupDescDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[WorkSpacesClientTypes.IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [WorkSpacesClientTypes.IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIpGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIpGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.groupId = output.groupId
        } else {
            self.groupId = nil
        }
    }
}

public struct CreateIpGroupOutput: Swift.Equatable {
    /// The identifier of the group.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct CreateIpGroupOutputBody: Swift.Equatable {
    let groupId: Swift.String?
}

extension CreateIpGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

enum CreateIpGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceCreationFailedException": return try await ResourceCreationFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStandbyWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primaryRegion = "PrimaryRegion"
        case standbyWorkspaces = "StandbyWorkspaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let primaryRegion = self.primaryRegion {
            try encodeContainer.encode(primaryRegion, forKey: .primaryRegion)
        }
        if let standbyWorkspaces = standbyWorkspaces {
            var standbyWorkspacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standbyWorkspaces)
            for standbyworkspace0 in standbyWorkspaces {
                try standbyWorkspacesContainer.encode(standbyworkspace0)
            }
        }
    }
}

extension CreateStandbyWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateStandbyWorkspacesInput: Swift.Equatable {
    /// The Region of the primary WorkSpace.
    /// This member is required.
    public var primaryRegion: Swift.String?
    /// Information about the standby WorkSpace to be created.
    /// This member is required.
    public var standbyWorkspaces: [WorkSpacesClientTypes.StandbyWorkspace]?

    public init(
        primaryRegion: Swift.String? = nil,
        standbyWorkspaces: [WorkSpacesClientTypes.StandbyWorkspace]? = nil
    )
    {
        self.primaryRegion = primaryRegion
        self.standbyWorkspaces = standbyWorkspaces
    }
}

struct CreateStandbyWorkspacesInputBody: Swift.Equatable {
    let primaryRegion: Swift.String?
    let standbyWorkspaces: [WorkSpacesClientTypes.StandbyWorkspace]?
}

extension CreateStandbyWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primaryRegion = "PrimaryRegion"
        case standbyWorkspaces = "StandbyWorkspaces"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryRegion)
        primaryRegion = primaryRegionDecoded
        let standbyWorkspacesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.StandbyWorkspace?].self, forKey: .standbyWorkspaces)
        var standbyWorkspacesDecoded0:[WorkSpacesClientTypes.StandbyWorkspace]? = nil
        if let standbyWorkspacesContainer = standbyWorkspacesContainer {
            standbyWorkspacesDecoded0 = [WorkSpacesClientTypes.StandbyWorkspace]()
            for structure0 in standbyWorkspacesContainer {
                if let structure0 = structure0 {
                    standbyWorkspacesDecoded0?.append(structure0)
                }
            }
        }
        standbyWorkspaces = standbyWorkspacesDecoded0
    }
}

extension CreateStandbyWorkspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStandbyWorkspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedStandbyRequests = output.failedStandbyRequests
            self.pendingStandbyRequests = output.pendingStandbyRequests
        } else {
            self.failedStandbyRequests = nil
            self.pendingStandbyRequests = nil
        }
    }
}

public struct CreateStandbyWorkspacesOutput: Swift.Equatable {
    /// Information about the standby WorkSpace that could not be created.
    public var failedStandbyRequests: [WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest]?
    /// Information about the standby WorkSpace that was created.
    public var pendingStandbyRequests: [WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest]?

    public init(
        failedStandbyRequests: [WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest]? = nil,
        pendingStandbyRequests: [WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest]? = nil
    )
    {
        self.failedStandbyRequests = failedStandbyRequests
        self.pendingStandbyRequests = pendingStandbyRequests
    }
}

struct CreateStandbyWorkspacesOutputBody: Swift.Equatable {
    let failedStandbyRequests: [WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest]?
    let pendingStandbyRequests: [WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest]?
}

extension CreateStandbyWorkspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedStandbyRequests = "FailedStandbyRequests"
        case pendingStandbyRequests = "PendingStandbyRequests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedStandbyRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest?].self, forKey: .failedStandbyRequests)
        var failedStandbyRequestsDecoded0:[WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest]? = nil
        if let failedStandbyRequestsContainer = failedStandbyRequestsContainer {
            failedStandbyRequestsDecoded0 = [WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest]()
            for structure0 in failedStandbyRequestsContainer {
                if let structure0 = structure0 {
                    failedStandbyRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedStandbyRequests = failedStandbyRequestsDecoded0
        let pendingStandbyRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest?].self, forKey: .pendingStandbyRequests)
        var pendingStandbyRequestsDecoded0:[WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest]? = nil
        if let pendingStandbyRequestsContainer = pendingStandbyRequestsContainer {
            pendingStandbyRequestsDecoded0 = [WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest]()
            for structure0 in pendingStandbyRequestsContainer {
                if let structure0 = structure0 {
                    pendingStandbyRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingStandbyRequests = pendingStandbyRequestsDecoded0
    }
}

enum CreateStandbyWorkspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTagsInput: Swift.Equatable {
    /// The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces, registered directories, images, custom bundles, IP access control groups, and connection aliases.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The tags. Each WorkSpaces resource can have a maximum of 50 tags.
    /// This member is required.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init(
        resourceId: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tags = tags
    }
}

struct CreateTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateTagsOutput: Swift.Equatable {

    public init() { }
}

enum CreateTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUpdatedWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceImageId = self.sourceImageId {
            try encodeContainer.encode(sourceImageId, forKey: .sourceImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateUpdatedWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUpdatedWorkspaceImageInput: Swift.Equatable {
    /// A description of whether updates for the WorkSpace image are available.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the new updated WorkSpace image.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the source WorkSpace image.
    /// This member is required.
    public var sourceImageId: Swift.String?
    /// The tags that you want to add to the new updated WorkSpace image. To add tags at the same time when you're creating the updated image, you must create an IAM policy that grants your IAM user permissions to use workspaces:CreateTags.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceImageId: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.sourceImageId = sourceImageId
        self.tags = tags
    }
}

struct CreateUpdatedWorkspaceImageInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let sourceImageId: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateUpdatedWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceImageId)
        sourceImageId = sourceImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUpdatedWorkspaceImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUpdatedWorkspaceImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
        } else {
            self.imageId = nil
        }
    }
}

public struct CreateUpdatedWorkspaceImageOutput: Swift.Equatable {
    /// The identifier of the new updated WorkSpace image.
    public var imageId: Swift.String?

    public init(
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct CreateUpdatedWorkspaceImageOutputBody: Swift.Equatable {
    let imageId: Swift.String?
}

extension CreateUpdatedWorkspaceImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

enum CreateUpdatedWorkspaceImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkspaceBundleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleDescription = "BundleDescription"
        case bundleName = "BundleName"
        case computeType = "ComputeType"
        case imageId = "ImageId"
        case rootStorage = "RootStorage"
        case tags = "Tags"
        case userStorage = "UserStorage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleDescription = self.bundleDescription {
            try encodeContainer.encode(bundleDescription, forKey: .bundleDescription)
        }
        if let bundleName = self.bundleName {
            try encodeContainer.encode(bundleName, forKey: .bundleName)
        }
        if let computeType = self.computeType {
            try encodeContainer.encode(computeType, forKey: .computeType)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let rootStorage = self.rootStorage {
            try encodeContainer.encode(rootStorage, forKey: .rootStorage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userStorage = self.userStorage {
            try encodeContainer.encode(userStorage, forKey: .userStorage)
        }
    }
}

extension CreateWorkspaceBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkspaceBundleInput: Swift.Equatable {
    /// The description of the bundle.
    /// This member is required.
    public var bundleDescription: Swift.String?
    /// The name of the bundle.
    /// This member is required.
    public var bundleName: Swift.String?
    /// Describes the compute type of the bundle.
    /// This member is required.
    public var computeType: WorkSpacesClientTypes.ComputeType?
    /// The identifier of the image that is used to create the bundle.
    /// This member is required.
    public var imageId: Swift.String?
    /// Describes the root volume for a WorkSpace bundle.
    public var rootStorage: WorkSpacesClientTypes.RootStorage?
    /// The tags associated with the bundle. To add tags at the same time when you're creating the bundle, you must create an IAM policy that grants your IAM user permissions to use workspaces:CreateTags.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// Describes the user volume for a WorkSpace bundle.
    /// This member is required.
    public var userStorage: WorkSpacesClientTypes.UserStorage?

    public init(
        bundleDescription: Swift.String? = nil,
        bundleName: Swift.String? = nil,
        computeType: WorkSpacesClientTypes.ComputeType? = nil,
        imageId: Swift.String? = nil,
        rootStorage: WorkSpacesClientTypes.RootStorage? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        userStorage: WorkSpacesClientTypes.UserStorage? = nil
    )
    {
        self.bundleDescription = bundleDescription
        self.bundleName = bundleName
        self.computeType = computeType
        self.imageId = imageId
        self.rootStorage = rootStorage
        self.tags = tags
        self.userStorage = userStorage
    }
}

struct CreateWorkspaceBundleInputBody: Swift.Equatable {
    let bundleName: Swift.String?
    let bundleDescription: Swift.String?
    let imageId: Swift.String?
    let computeType: WorkSpacesClientTypes.ComputeType?
    let userStorage: WorkSpacesClientTypes.UserStorage?
    let rootStorage: WorkSpacesClientTypes.RootStorage?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateWorkspaceBundleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleDescription = "BundleDescription"
        case bundleName = "BundleName"
        case computeType = "ComputeType"
        case imageId = "ImageId"
        case rootStorage = "RootStorage"
        case tags = "Tags"
        case userStorage = "UserStorage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleName)
        bundleName = bundleNameDecoded
        let bundleDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleDescription)
        bundleDescription = bundleDescriptionDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let userStorageDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.UserStorage.self, forKey: .userStorage)
        userStorage = userStorageDecoded
        let rootStorageDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.RootStorage.self, forKey: .rootStorage)
        rootStorage = rootStorageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkspaceBundleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkspaceBundleOutputBody = try responseDecoder.decode(responseBody: data)
            self.workspaceBundle = output.workspaceBundle
        } else {
            self.workspaceBundle = nil
        }
    }
}

public struct CreateWorkspaceBundleOutput: Swift.Equatable {
    /// Describes a WorkSpace bundle.
    public var workspaceBundle: WorkSpacesClientTypes.WorkspaceBundle?

    public init(
        workspaceBundle: WorkSpacesClientTypes.WorkspaceBundle? = nil
    )
    {
        self.workspaceBundle = workspaceBundle
    }
}

struct CreateWorkspaceBundleOutputBody: Swift.Equatable {
    let workspaceBundle: WorkSpacesClientTypes.WorkspaceBundle?
}

extension CreateWorkspaceBundleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceBundle = "WorkspaceBundle"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceBundleDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceBundle.self, forKey: .workspaceBundle)
        workspaceBundle = workspaceBundleDecoded
    }
}

enum CreateWorkspaceBundleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension CreateWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkspaceImageInput: Swift.Equatable {
    /// The description of the new WorkSpace image.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the new WorkSpace image.
    /// This member is required.
    public var name: Swift.String?
    /// The tags that you want to add to the new WorkSpace image. To add tags when you're creating the image, you must create an IAM policy that grants your IAM user permission to use workspaces:CreateTags.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// The identifier of the source WorkSpace
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateWorkspaceImageInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let workspaceId: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case workspaceId = "WorkspaceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkspaceImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkspaceImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.created = output.created
            self.description = output.description
            self.imageId = output.imageId
            self.name = output.name
            self.operatingSystem = output.operatingSystem
            self.ownerAccountId = output.ownerAccountId
            self.requiredTenancy = output.requiredTenancy
            self.state = output.state
        } else {
            self.created = nil
            self.description = nil
            self.imageId = nil
            self.name = nil
            self.operatingSystem = nil
            self.ownerAccountId = nil
            self.requiredTenancy = nil
            self.state = nil
        }
    }
}

public struct CreateWorkspaceImageOutput: Swift.Equatable {
    /// The date when the image was created.
    public var created: ClientRuntime.Date?
    /// The description of the image.
    public var description: Swift.String?
    /// The identifier of the new WorkSpace image.
    public var imageId: Swift.String?
    /// The name of the image.
    public var name: Swift.String?
    /// The operating system that the image is running.
    public var operatingSystem: WorkSpacesClientTypes.OperatingSystem?
    /// The identifier of the Amazon Web Services account that owns the image.
    public var ownerAccountId: Swift.String?
    /// Specifies whether the image is running on dedicated hardware. When Bring Your Own License (BYOL) is enabled, this value is set to DEDICATED. For more information, see [ Bring Your Own Windows Desktop Images.](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.htm).
    public var requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy?
    /// The availability status of the image.
    public var state: WorkSpacesClientTypes.WorkspaceImageState?

    public init(
        created: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        imageId: Swift.String? = nil,
        name: Swift.String? = nil,
        operatingSystem: WorkSpacesClientTypes.OperatingSystem? = nil,
        ownerAccountId: Swift.String? = nil,
        requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy? = nil,
        state: WorkSpacesClientTypes.WorkspaceImageState? = nil
    )
    {
        self.created = created
        self.description = description
        self.imageId = imageId
        self.name = name
        self.operatingSystem = operatingSystem
        self.ownerAccountId = ownerAccountId
        self.requiredTenancy = requiredTenancy
        self.state = state
    }
}

struct CreateWorkspaceImageOutputBody: Swift.Equatable {
    let imageId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let operatingSystem: WorkSpacesClientTypes.OperatingSystem?
    let state: WorkSpacesClientTypes.WorkspaceImageState?
    let requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy?
    let created: ClientRuntime.Date?
    let ownerAccountId: Swift.String?
}

extension CreateWorkspaceImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case description = "Description"
        case imageId = "ImageId"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case ownerAccountId = "OwnerAccountId"
        case requiredTenancy = "RequiredTenancy"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageState.self, forKey: .state)
        state = stateDecoded
        let requiredTenancyDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageRequiredTenancy.self, forKey: .requiredTenancy)
        requiredTenancy = requiredTenancyDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
    }
}

enum CreateWorkspaceImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaces = "Workspaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaces = workspaces {
            var workspacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaces)
            for workspacerequest0 in workspaces {
                try workspacesContainer.encode(workspacerequest0)
            }
        }
    }
}

extension CreateWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to create. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var workspaces: [WorkSpacesClientTypes.WorkspaceRequest]?

    public init(
        workspaces: [WorkSpacesClientTypes.WorkspaceRequest]? = nil
    )
    {
        self.workspaces = workspaces
    }
}

struct CreateWorkspacesInputBody: Swift.Equatable {
    let workspaces: [WorkSpacesClientTypes.WorkspaceRequest]?
}

extension CreateWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaces = "Workspaces"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceRequest?].self, forKey: .workspaces)
        var workspacesDecoded0:[WorkSpacesClientTypes.WorkspaceRequest]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [WorkSpacesClientTypes.WorkspaceRequest]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
    }
}

extension CreateWorkspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
            self.pendingRequests = output.pendingRequests
        } else {
            self.failedRequests = nil
            self.pendingRequests = nil
        }
    }
}

public struct CreateWorkspacesOutput: Swift.Equatable {
    /// Information about the WorkSpaces that could not be created.
    public var failedRequests: [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]?
    /// Information about the WorkSpaces that were created. Because this operation is asynchronous, the identifier returned is not immediately available for use with other operations. For example, if you call [DescribeWorkspaces] before the WorkSpace is created, the information returned can be incomplete.
    public var pendingRequests: [WorkSpacesClientTypes.Workspace]?

    public init(
        failedRequests: [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]? = nil,
        pendingRequests: [WorkSpacesClientTypes.Workspace]? = nil
    )
    {
        self.failedRequests = failedRequests
        self.pendingRequests = pendingRequests
    }
}

struct CreateWorkspacesOutputBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]?
    let pendingRequests: [WorkSpacesClientTypes.Workspace]?
}

extension CreateWorkspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
        case pendingRequests = "PendingRequests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedCreateWorkspaceRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedCreateWorkspaceRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
        let pendingRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Workspace?].self, forKey: .pendingRequests)
        var pendingRequestsDecoded0:[WorkSpacesClientTypes.Workspace]? = nil
        if let pendingRequestsContainer = pendingRequestsContainer {
            pendingRequestsDecoded0 = [WorkSpacesClientTypes.Workspace]()
            for structure0 in pendingRequestsContainer {
                if let structure0 = structure0 {
                    pendingRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingRequests = pendingRequestsDecoded0
    }
}

enum CreateWorkspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum DataReplication: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noReplication
        case primaryAsSource
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplication] {
            return [
                .noReplication,
                .primaryAsSource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noReplication: return "NO_REPLICATION"
            case .primaryAsSource: return "PRIMARY_AS_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplication(rawValue: rawValue) ?? DataReplication.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.DataReplicationSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplication = "DataReplication"
        case recoverySnapshotTime = "RecoverySnapshotTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplication = self.dataReplication {
            try encodeContainer.encode(dataReplication.rawValue, forKey: .dataReplication)
        }
        if let recoverySnapshotTime = self.recoverySnapshotTime {
            try encodeContainer.encodeTimestamp(recoverySnapshotTime, format: .epochSeconds, forKey: .recoverySnapshotTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataReplicationDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DataReplication.self, forKey: .dataReplication)
        dataReplication = dataReplicationDecoded
        let recoverySnapshotTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .recoverySnapshotTime)
        recoverySnapshotTime = recoverySnapshotTimeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the data replication settings.
    public struct DataReplicationSettings: Swift.Equatable {
        /// Indicates whether data replication is enabled, and if enabled, the type of data replication.
        public var dataReplication: WorkSpacesClientTypes.DataReplication?
        /// The date and time at which the last successful snapshot was taken of the primary WorkSpace used for replicating data.
        public var recoverySnapshotTime: ClientRuntime.Date?

        public init(
            dataReplication: WorkSpacesClientTypes.DataReplication? = nil,
            recoverySnapshotTime: ClientRuntime.Date? = nil
        )
        {
            self.dataReplication = dataReplication
            self.recoverySnapshotTime = recoverySnapshotTime
        }
    }

}

extension WorkSpacesClientTypes {
    public enum DedicatedTenancyModificationStateEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancyModificationStateEnum] {
            return [
                .completed,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DedicatedTenancyModificationStateEnum(rawValue: rawValue) ?? DedicatedTenancyModificationStateEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum DedicatedTenancySupportEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancySupportEnum] {
            return [
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DedicatedTenancySupportEnum(rawValue: rawValue) ?? DedicatedTenancySupportEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum DedicatedTenancySupportResultEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancySupportResultEnum] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DedicatedTenancySupportResultEnum(rawValue: rawValue) ?? DedicatedTenancySupportResultEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.DefaultClientBrandingAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPasswordLink = "ForgotPasswordLink"
        case loginMessage = "LoginMessage"
        case logoUrl = "LogoUrl"
        case supportEmail = "SupportEmail"
        case supportLink = "SupportLink"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPasswordLink = self.forgotPasswordLink {
            try encodeContainer.encode(forgotPasswordLink, forKey: .forgotPasswordLink)
        }
        if let loginMessage = loginMessage {
            var loginMessageContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .loginMessage)
            for (dictKey0, loginMessage0) in loginMessage {
                try loginMessageContainer.encode(loginMessage0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let logoUrl = self.logoUrl {
            try encodeContainer.encode(logoUrl, forKey: .logoUrl)
        }
        if let supportEmail = self.supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportLink = self.supportLink {
            try encodeContainer.encode(supportLink, forKey: .supportLink)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logoUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logoUrl)
        logoUrl = logoUrlDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportLink)
        supportLink = supportLinkDecoded
        let forgotPasswordLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forgotPasswordLink)
        forgotPasswordLink = forgotPasswordLinkDecoded
        let loginMessageContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .loginMessage)
        var loginMessageDecoded0: [Swift.String:Swift.String]? = nil
        if let loginMessageContainer = loginMessageContainer {
            loginMessageDecoded0 = [Swift.String:Swift.String]()
            for (key0, clientloginmessage0) in loginMessageContainer {
                if let clientloginmessage0 = clientloginmessage0 {
                    loginMessageDecoded0?[key0] = clientloginmessage0
                }
            }
        }
        loginMessage = loginMessageDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Returns default client branding attributes that were imported. These attributes display on the client login screen. Client branding attributes are public facing. Ensure that you don't include sensitive information.
    public struct DefaultClientBrandingAttributes: Swift.Equatable {
        /// The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.
        public var forgotPasswordLink: Swift.String?
        /// The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is en_US. The HTML tags supported include the following: a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul.
        public var loginMessage: [Swift.String:Swift.String]?
        /// The logo. The only image format accepted is a binary data object that is converted from a .png file.
        public var logoUrl: Swift.String?
        /// The support email. The company's customer support email address.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default email is workspaces-feedback@amazon.com.
        public var supportEmail: Swift.String?
        /// The support link. The link for the company's customer support page for their WorkSpace.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive.You can specify one parameter for each platform type, but not both.
        ///
        /// * The default support link is workspaces-feedback@amazon.com.
        public var supportLink: Swift.String?

        public init(
            forgotPasswordLink: Swift.String? = nil,
            loginMessage: [Swift.String:Swift.String]? = nil,
            logoUrl: Swift.String? = nil,
            supportEmail: Swift.String? = nil,
            supportLink: Swift.String? = nil
        )
        {
            self.forgotPasswordLink = forgotPasswordLink
            self.loginMessage = loginMessage
            self.logoUrl = logoUrl
            self.supportEmail = supportEmail
            self.supportLink = supportLink
        }
    }

}

extension WorkSpacesClientTypes.DefaultImportClientBrandingAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPasswordLink = "ForgotPasswordLink"
        case loginMessage = "LoginMessage"
        case logo = "Logo"
        case supportEmail = "SupportEmail"
        case supportLink = "SupportLink"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPasswordLink = self.forgotPasswordLink {
            try encodeContainer.encode(forgotPasswordLink, forKey: .forgotPasswordLink)
        }
        if let loginMessage = loginMessage {
            var loginMessageContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .loginMessage)
            for (dictKey0, loginMessage0) in loginMessage {
                try loginMessageContainer.encode(loginMessage0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let logo = self.logo {
            try encodeContainer.encode(logo.base64EncodedString(), forKey: .logo)
        }
        if let supportEmail = self.supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportLink = self.supportLink {
            try encodeContainer.encode(supportLink, forKey: .supportLink)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logoDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .logo)
        logo = logoDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportLink)
        supportLink = supportLinkDecoded
        let forgotPasswordLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forgotPasswordLink)
        forgotPasswordLink = forgotPasswordLinkDecoded
        let loginMessageContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .loginMessage)
        var loginMessageDecoded0: [Swift.String:Swift.String]? = nil
        if let loginMessageContainer = loginMessageContainer {
            loginMessageDecoded0 = [Swift.String:Swift.String]()
            for (key0, clientloginmessage0) in loginMessageContainer {
                if let clientloginmessage0 = clientloginmessage0 {
                    loginMessageDecoded0?[key0] = clientloginmessage0
                }
            }
        }
        loginMessage = loginMessageDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// The default client branding attributes to be imported. These attributes display on the client login screen. Client branding attributes are public facing. Ensure that you do not include sensitive information.
    public struct DefaultImportClientBrandingAttributes: Swift.Equatable {
        /// The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.
        public var forgotPasswordLink: Swift.String?
        /// The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is en_US. The HTML tags supported include the following: a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul.
        public var loginMessage: [Swift.String:Swift.String]?
        /// The logo. The only image format accepted is a binary data object that is converted from a .png file.
        public var logo: ClientRuntime.Data?
        /// The support email. The company's customer support email address.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default email is workspaces-feedback@amazon.com.
        public var supportEmail: Swift.String?
        /// The support link. The link for the company's customer support page for their WorkSpace.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default support link is workspaces-feedback@amazon.com.
        public var supportLink: Swift.String?

        public init(
            forgotPasswordLink: Swift.String? = nil,
            loginMessage: [Swift.String:Swift.String]? = nil,
            logo: ClientRuntime.Data? = nil,
            supportEmail: Swift.String? = nil,
            supportLink: Swift.String? = nil
        )
        {
            self.forgotPasswordLink = forgotPasswordLink
            self.loginMessage = loginMessage
            self.logo = logo
            self.supportEmail = supportEmail
            self.supportLink = supportLink
        }
    }

}

extension WorkSpacesClientTypes.DefaultWorkspaceCreationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customSecurityGroupId = "CustomSecurityGroupId"
        case defaultOu = "DefaultOu"
        case enableInternetAccess = "EnableInternetAccess"
        case enableMaintenanceMode = "EnableMaintenanceMode"
        case enableWorkDocs = "EnableWorkDocs"
        case userEnabledAsLocalAdministrator = "UserEnabledAsLocalAdministrator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customSecurityGroupId = self.customSecurityGroupId {
            try encodeContainer.encode(customSecurityGroupId, forKey: .customSecurityGroupId)
        }
        if let defaultOu = self.defaultOu {
            try encodeContainer.encode(defaultOu, forKey: .defaultOu)
        }
        if let enableInternetAccess = self.enableInternetAccess {
            try encodeContainer.encode(enableInternetAccess, forKey: .enableInternetAccess)
        }
        if let enableMaintenanceMode = self.enableMaintenanceMode {
            try encodeContainer.encode(enableMaintenanceMode, forKey: .enableMaintenanceMode)
        }
        if let enableWorkDocs = self.enableWorkDocs {
            try encodeContainer.encode(enableWorkDocs, forKey: .enableWorkDocs)
        }
        if let userEnabledAsLocalAdministrator = self.userEnabledAsLocalAdministrator {
            try encodeContainer.encode(userEnabledAsLocalAdministrator, forKey: .userEnabledAsLocalAdministrator)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableWorkDocsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWorkDocs)
        enableWorkDocs = enableWorkDocsDecoded
        let enableInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableInternetAccess)
        enableInternetAccess = enableInternetAccessDecoded
        let defaultOuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOu)
        defaultOu = defaultOuDecoded
        let customSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customSecurityGroupId)
        customSecurityGroupId = customSecurityGroupIdDecoded
        let userEnabledAsLocalAdministratorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userEnabledAsLocalAdministrator)
        userEnabledAsLocalAdministrator = userEnabledAsLocalAdministratorDecoded
        let enableMaintenanceModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMaintenanceMode)
        enableMaintenanceMode = enableMaintenanceModeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the default values that are used to create WorkSpaces. For more information, see [Update Directory Details for Your WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html).
    public struct DefaultWorkspaceCreationProperties: Swift.Equatable {
        /// The identifier of the default security group to apply to WorkSpaces when they are created. For more information, see [ Security Groups for Your WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-security-groups.html).
        public var customSecurityGroupId: Swift.String?
        /// The organizational unit (OU) in the directory for the WorkSpace machine accounts.
        public var defaultOu: Swift.String?
        /// Specifies whether to automatically assign an Elastic public IP address to WorkSpaces in this directory by default. If enabled, the Elastic public IP address allows outbound internet access from your WorkSpaces when you’re using an internet gateway in the Amazon VPC in which your WorkSpaces are located. If you're using a Network Address Translation (NAT) gateway for outbound internet access from your VPC, or if your WorkSpaces are in public subnets and you manually assign them Elastic IP addresses, you should disable this setting. This setting applies to new WorkSpaces that you launch or to existing WorkSpaces that you rebuild. For more information, see [ Configure a VPC for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html).
        public var enableInternetAccess: Swift.Bool?
        /// Specifies whether maintenance mode is enabled for WorkSpaces. For more information, see [WorkSpace Maintenance](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html).
        public var enableMaintenanceMode: Swift.Bool?
        /// Specifies whether the directory is enabled for Amazon WorkDocs.
        public var enableWorkDocs: Swift.Bool?
        /// Specifies whether WorkSpace users are local administrators on their WorkSpaces.
        public var userEnabledAsLocalAdministrator: Swift.Bool?

        public init(
            customSecurityGroupId: Swift.String? = nil,
            defaultOu: Swift.String? = nil,
            enableInternetAccess: Swift.Bool? = nil,
            enableMaintenanceMode: Swift.Bool? = nil,
            enableWorkDocs: Swift.Bool? = nil,
            userEnabledAsLocalAdministrator: Swift.Bool? = nil
        )
        {
            self.customSecurityGroupId = customSecurityGroupId
            self.defaultOu = defaultOu
            self.enableInternetAccess = enableInternetAccess
            self.enableMaintenanceMode = enableMaintenanceMode
            self.enableWorkDocs = enableWorkDocs
            self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
        }
    }

}

extension WorkSpacesClientTypes {
    public enum DeletableCertificateBasedAuthProperty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case certificateBasedAuthPropertiesCertificateAuthorityArn
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletableCertificateBasedAuthProperty] {
            return [
                .certificateBasedAuthPropertiesCertificateAuthorityArn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .certificateBasedAuthPropertiesCertificateAuthorityArn: return "CERTIFICATE_BASED_AUTH_PROPERTIES_CERTIFICATE_AUTHORITY_ARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeletableCertificateBasedAuthProperty(rawValue: rawValue) ?? DeletableCertificateBasedAuthProperty.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum DeletableSamlProperty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case samlPropertiesRelayStateParameterName
        case samlPropertiesUserAccessUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletableSamlProperty] {
            return [
                .samlPropertiesRelayStateParameterName,
                .samlPropertiesUserAccessUrl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .samlPropertiesRelayStateParameterName: return "SAML_PROPERTIES_RELAY_STATE_PARAMETER_NAME"
            case .samlPropertiesUserAccessUrl: return "SAML_PROPERTIES_USER_ACCESS_URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeletableSamlProperty(rawValue: rawValue) ?? DeletableSamlProperty.sdkUnknown(rawValue)
        }
    }
}

extension DeleteClientBrandingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platforms = "Platforms"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let platforms = platforms {
            var platformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platforms)
            for clientdevicetype0 in platforms {
                try platformsContainer.encode(clientdevicetype0.rawValue)
            }
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DeleteClientBrandingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteClientBrandingInput: Swift.Equatable {
    /// The device type for which you want to delete client branding.
    /// This member is required.
    public var platforms: [WorkSpacesClientTypes.ClientDeviceType]?
    /// The directory identifier of the WorkSpace for which you want to delete client branding.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        platforms: [WorkSpacesClientTypes.ClientDeviceType]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.platforms = platforms
        self.resourceId = resourceId
    }
}

struct DeleteClientBrandingInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let platforms: [WorkSpacesClientTypes.ClientDeviceType]?
}

extension DeleteClientBrandingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platforms = "Platforms"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let platformsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ClientDeviceType?].self, forKey: .platforms)
        var platformsDecoded0:[WorkSpacesClientTypes.ClientDeviceType]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [WorkSpacesClientTypes.ClientDeviceType]()
            for enum0 in platformsContainer {
                if let enum0 = enum0 {
                    platformsDecoded0?.append(enum0)
                }
            }
        }
        platforms = platformsDecoded0
    }
}

extension DeleteClientBrandingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteClientBrandingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteClientBrandingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConnectClientAddInInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addInId = "AddInId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addInId = self.addInId {
            try encodeContainer.encode(addInId, forKey: .addInId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DeleteConnectClientAddInInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConnectClientAddInInput: Swift.Equatable {
    /// The identifier of the client add-in to delete.
    /// This member is required.
    public var addInId: Swift.String?
    /// The directory identifier for which the client add-in is configured.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        addInId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.addInId = addInId
        self.resourceId = resourceId
    }
}

struct DeleteConnectClientAddInInputBody: Swift.Equatable {
    let addInId: Swift.String?
    let resourceId: Swift.String?
}

extension DeleteConnectClientAddInInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addInId = "AddInId"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addInIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addInId)
        addInId = addInIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DeleteConnectClientAddInOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConnectClientAddInOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConnectClientAddInOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConnectionAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = self.aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
    }
}

extension DeleteConnectionAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConnectionAliasInput: Swift.Equatable {
    /// The identifier of the connection alias to delete.
    /// This member is required.
    public var aliasId: Swift.String?

    public init(
        aliasId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

struct DeleteConnectionAliasInputBody: Swift.Equatable {
    let aliasId: Swift.String?
}

extension DeleteConnectionAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
    }
}

extension DeleteConnectionAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConnectionAliasOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConnectionAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAssociatedException": return try await ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIpGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
    }
}

extension DeleteIpGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteIpGroupInput: Swift.Equatable {
    /// The identifier of the IP access control group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct DeleteIpGroupInputBody: Swift.Equatable {
    let groupId: Swift.String?
}

extension DeleteIpGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DeleteIpGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIpGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIpGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAssociatedException": return try await ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for nonemptystring0 in tagKeys {
                try tagKeysContainer.encode(nonemptystring0)
            }
        }
    }
}

extension DeleteTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTagsInput: Swift.Equatable {
    /// The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces, registered directories, images, custom bundles, IP access control groups, and connection aliases.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeys = tagKeys
    }
}

struct DeleteTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagKeys: [Swift.String]?
}

extension DeleteTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension DeleteTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTagsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkspaceBundleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
    }
}

extension DeleteWorkspaceBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkspaceBundleInput: Swift.Equatable {
    /// The identifier of the bundle.
    public var bundleId: Swift.String?

    public init(
        bundleId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
    }
}

struct DeleteWorkspaceBundleInputBody: Swift.Equatable {
    let bundleId: Swift.String?
}

extension DeleteWorkspaceBundleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
    }
}

extension DeleteWorkspaceBundleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkspaceBundleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorkspaceBundleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAssociatedException": return try await ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }
}

extension DeleteWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkspaceImageInput: Swift.Equatable {
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?

    public init(
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct DeleteWorkspaceImageInputBody: Swift.Equatable {
    let imageId: Swift.String?
}

extension DeleteWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension DeleteWorkspaceImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkspaceImageOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorkspaceImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAssociatedException": return try await ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeployWorkspaceApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force = "Force"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let force = self.force {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension DeployWorkspaceApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeployWorkspaceApplicationsInput: Swift.Equatable {
    /// Indicates whether the force flag is applied for the specified WorkSpace. When the force flag is enabled, it allows previously failed deployments to be retried.
    public var force: Swift.Bool?
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.force = force
        self.workspaceId = workspaceId
    }
}

struct DeployWorkspaceApplicationsInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let force: Swift.Bool?
}

extension DeployWorkspaceApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force = "Force"
        case workspaceId = "WorkspaceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension DeployWorkspaceApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeployWorkspaceApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deployment = output.deployment
        } else {
            self.deployment = nil
        }
    }
}

public struct DeployWorkspaceApplicationsOutput: Swift.Equatable {
    /// The list of deployed associations and information about them.
    public var deployment: WorkSpacesClientTypes.WorkSpaceApplicationDeployment?

    public init(
        deployment: WorkSpacesClientTypes.WorkSpaceApplicationDeployment? = nil
    )
    {
        self.deployment = deployment
    }
}

struct DeployWorkspaceApplicationsOutputBody: Swift.Equatable {
    let deployment: WorkSpacesClientTypes.WorkSpaceApplicationDeployment?
}

extension DeployWorkspaceApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployment = "Deployment"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkSpaceApplicationDeployment.self, forKey: .deployment)
        deployment = deploymentDecoded
    }
}

enum DeployWorkspaceApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncompatibleApplicationsException": return try await IncompatibleApplicationsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterWorkspaceDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension DeregisterWorkspaceDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterWorkspaceDirectoryInput: Swift.Equatable {
    /// The identifier of the directory. If any WorkSpaces are registered to this directory, you must remove them before you deregister the directory, or you will receive an OperationNotSupportedException error.
    /// This member is required.
    public var directoryId: Swift.String?

    public init(
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct DeregisterWorkspaceDirectoryInputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension DeregisterWorkspaceDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension DeregisterWorkspaceDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterWorkspaceDirectoryOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterWorkspaceDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountInput: Swift.Equatable {

    public init() { }
}

struct DescribeAccountInputBody: Swift.Equatable {
}

extension DescribeAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountModificationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAccountModificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountModificationsInput: Swift.Equatable {
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct DescribeAccountModificationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension DescribeAccountModificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAccountModificationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountModificationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountModifications = output.accountModifications
            self.nextToken = output.nextToken
        } else {
            self.accountModifications = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAccountModificationsOutput: Swift.Equatable {
    /// The list of modifications to the configuration of BYOL.
    public var accountModifications: [WorkSpacesClientTypes.AccountModification]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        accountModifications: [WorkSpacesClientTypes.AccountModification]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountModifications = accountModifications
        self.nextToken = nextToken
    }
}

struct DescribeAccountModificationsOutputBody: Swift.Equatable {
    let accountModifications: [WorkSpacesClientTypes.AccountModification]?
    let nextToken: Swift.String?
}

extension DescribeAccountModificationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountModifications = "AccountModifications"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountModificationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.AccountModification?].self, forKey: .accountModifications)
        var accountModificationsDecoded0:[WorkSpacesClientTypes.AccountModification]? = nil
        if let accountModificationsContainer = accountModificationsContainer {
            accountModificationsDecoded0 = [WorkSpacesClientTypes.AccountModification]()
            for structure0 in accountModificationsContainer {
                if let structure0 = structure0 {
                    accountModificationsDecoded0?.append(structure0)
                }
            }
        }
        accountModifications = accountModificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAccountModificationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.dedicatedTenancyManagementCidrRange = output.dedicatedTenancyManagementCidrRange
            self.dedicatedTenancySupport = output.dedicatedTenancySupport
        } else {
            self.dedicatedTenancyManagementCidrRange = nil
            self.dedicatedTenancySupport = nil
        }
    }
}

public struct DescribeAccountOutput: Swift.Equatable {
    /// The IP address range, specified as an IPv4 CIDR block, used for the management network interface. The management network interface is connected to a secure Amazon WorkSpaces management network. It is used for interactive streaming of the WorkSpace desktop to Amazon WorkSpaces clients, and to allow Amazon WorkSpaces to manage the WorkSpace.
    public var dedicatedTenancyManagementCidrRange: Swift.String?
    /// The status of BYOL (whether BYOL is enabled or disabled).
    public var dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum?

    public init(
        dedicatedTenancyManagementCidrRange: Swift.String? = nil,
        dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum? = nil
    )
    {
        self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
        self.dedicatedTenancySupport = dedicatedTenancySupport
    }
}

struct DescribeAccountOutputBody: Swift.Equatable {
    let dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum?
    let dedicatedTenancyManagementCidrRange: Swift.String?
}

extension DescribeAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedTenancySupportDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DedicatedTenancySupportResultEnum.self, forKey: .dedicatedTenancySupport)
        dedicatedTenancySupport = dedicatedTenancySupportDecoded
        let dedicatedTenancyManagementCidrRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedTenancyManagementCidrRange)
        dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRangeDecoded
    }
}

enum DescribeAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeApplicationAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case associatedResourceTypes = "AssociatedResourceTypes"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let associatedResourceTypes = associatedResourceTypes {
            var associatedResourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedResourceTypes)
            for applicationassociatedresourcetype0 in associatedResourceTypes {
                try associatedResourceTypesContainer.encode(applicationassociatedresourcetype0.rawValue)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeApplicationAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationAssociationsInput: Swift.Equatable {
    /// The identifier of the specified application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The resource type of the associated resources.
    /// This member is required.
    public var associatedResourceTypes: [WorkSpacesClientTypes.ApplicationAssociatedResourceType]?
    /// The maximum number of associations to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        associatedResourceTypes: [WorkSpacesClientTypes.ApplicationAssociatedResourceType]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.associatedResourceTypes = associatedResourceTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeApplicationAssociationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let applicationId: Swift.String?
    let associatedResourceTypes: [WorkSpacesClientTypes.ApplicationAssociatedResourceType]?
}

extension DescribeApplicationAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case associatedResourceTypes = "AssociatedResourceTypes"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let associatedResourceTypesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ApplicationAssociatedResourceType?].self, forKey: .associatedResourceTypes)
        var associatedResourceTypesDecoded0:[WorkSpacesClientTypes.ApplicationAssociatedResourceType]? = nil
        if let associatedResourceTypesContainer = associatedResourceTypesContainer {
            associatedResourceTypesDecoded0 = [WorkSpacesClientTypes.ApplicationAssociatedResourceType]()
            for enum0 in associatedResourceTypesContainer {
                if let enum0 = enum0 {
                    associatedResourceTypesDecoded0?.append(enum0)
                }
            }
        }
        associatedResourceTypes = associatedResourceTypesDecoded0
    }
}

extension DescribeApplicationAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeApplicationAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.associations = output.associations
            self.nextToken = output.nextToken
        } else {
            self.associations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeApplicationAssociationsOutput: Swift.Equatable {
    /// List of associations and information about them.
    public var associations: [WorkSpacesClientTypes.ApplicationResourceAssociation]?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        associations: [WorkSpacesClientTypes.ApplicationResourceAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associations = associations
        self.nextToken = nextToken
    }
}

struct DescribeApplicationAssociationsOutputBody: Swift.Equatable {
    let associations: [WorkSpacesClientTypes.ApplicationResourceAssociation]?
    let nextToken: Swift.String?
}

extension DescribeApplicationAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ApplicationResourceAssociation?].self, forKey: .associations)
        var associationsDecoded0:[WorkSpacesClientTypes.ApplicationResourceAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [WorkSpacesClientTypes.ApplicationResourceAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeApplicationAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIds = "ApplicationIds"
        case computeTypeNames = "ComputeTypeNames"
        case licenseType = "LicenseType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case operatingSystemNames = "OperatingSystemNames"
        case owner = "Owner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIds = applicationIds {
            var applicationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIds)
            for workspaceapplicationid0 in applicationIds {
                try applicationIdsContainer.encode(workspaceapplicationid0)
            }
        }
        if let computeTypeNames = computeTypeNames {
            var computeTypeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computeTypeNames)
            for compute0 in computeTypeNames {
                try computeTypeNamesContainer.encode(compute0.rawValue)
            }
        }
        if let licenseType = self.licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let operatingSystemNames = operatingSystemNames {
            var operatingSystemNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operatingSystemNames)
            for operatingsystemname0 in operatingSystemNames {
                try operatingSystemNamesContainer.encode(operatingsystemname0.rawValue)
            }
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
    }
}

extension DescribeApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationsInput: Swift.Equatable {
    /// The identifiers of one or more applications.
    public var applicationIds: [Swift.String]?
    /// The compute types supported by the applications.
    public var computeTypeNames: [WorkSpacesClientTypes.Compute]?
    /// The license availability for the applications.
    public var licenseType: WorkSpacesClientTypes.WorkSpaceApplicationLicenseType?
    /// The maximum number of applications to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The operating systems supported by the applications.
    public var operatingSystemNames: [WorkSpacesClientTypes.OperatingSystemName]?
    /// The owner of the applications.
    public var owner: Swift.String?

    public init(
        applicationIds: [Swift.String]? = nil,
        computeTypeNames: [WorkSpacesClientTypes.Compute]? = nil,
        licenseType: WorkSpacesClientTypes.WorkSpaceApplicationLicenseType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        operatingSystemNames: [WorkSpacesClientTypes.OperatingSystemName]? = nil,
        owner: Swift.String? = nil
    )
    {
        self.applicationIds = applicationIds
        self.computeTypeNames = computeTypeNames
        self.licenseType = licenseType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operatingSystemNames = operatingSystemNames
        self.owner = owner
    }
}

struct DescribeApplicationsInputBody: Swift.Equatable {
    let applicationIds: [Swift.String]?
    let computeTypeNames: [WorkSpacesClientTypes.Compute]?
    let licenseType: WorkSpacesClientTypes.WorkSpaceApplicationLicenseType?
    let operatingSystemNames: [WorkSpacesClientTypes.OperatingSystemName]?
    let owner: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIds = "ApplicationIds"
        case computeTypeNames = "ComputeTypeNames"
        case licenseType = "LicenseType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case operatingSystemNames = "OperatingSystemNames"
        case owner = "Owner"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationIds)
        var applicationIdsDecoded0:[Swift.String]? = nil
        if let applicationIdsContainer = applicationIdsContainer {
            applicationIdsDecoded0 = [Swift.String]()
            for string0 in applicationIdsContainer {
                if let string0 = string0 {
                    applicationIdsDecoded0?.append(string0)
                }
            }
        }
        applicationIds = applicationIdsDecoded0
        let computeTypeNamesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Compute?].self, forKey: .computeTypeNames)
        var computeTypeNamesDecoded0:[WorkSpacesClientTypes.Compute]? = nil
        if let computeTypeNamesContainer = computeTypeNamesContainer {
            computeTypeNamesDecoded0 = [WorkSpacesClientTypes.Compute]()
            for enum0 in computeTypeNamesContainer {
                if let enum0 = enum0 {
                    computeTypeNamesDecoded0?.append(enum0)
                }
            }
        }
        computeTypeNames = computeTypeNamesDecoded0
        let licenseTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkSpaceApplicationLicenseType.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let operatingSystemNamesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.OperatingSystemName?].self, forKey: .operatingSystemNames)
        var operatingSystemNamesDecoded0:[WorkSpacesClientTypes.OperatingSystemName]? = nil
        if let operatingSystemNamesContainer = operatingSystemNamesContainer {
            operatingSystemNamesDecoded0 = [WorkSpacesClientTypes.OperatingSystemName]()
            for enum0 in operatingSystemNamesContainer {
                if let enum0 = enum0 {
                    operatingSystemNamesDecoded0?.append(enum0)
                }
            }
        }
        operatingSystemNames = operatingSystemNamesDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeApplicationsOutput: Swift.Equatable {
    /// List of information about the specified applications.
    public var applications: [WorkSpacesClientTypes.WorkSpaceApplication]?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        applications: [WorkSpacesClientTypes.WorkSpaceApplication]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct DescribeApplicationsOutputBody: Swift.Equatable {
    let applications: [WorkSpacesClientTypes.WorkSpaceApplication]?
    let nextToken: Swift.String?
}

extension DescribeApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkSpaceApplication?].self, forKey: .applications)
        var applicationsDecoded0:[WorkSpacesClientTypes.WorkSpaceApplication]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [WorkSpacesClientTypes.WorkSpaceApplication]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBundleAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceTypes = "AssociatedResourceTypes"
        case bundleId = "BundleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedResourceTypes = associatedResourceTypes {
            var associatedResourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedResourceTypes)
            for bundleassociatedresourcetype0 in associatedResourceTypes {
                try associatedResourceTypesContainer.encode(bundleassociatedresourcetype0.rawValue)
            }
        }
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
    }
}

extension DescribeBundleAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBundleAssociationsInput: Swift.Equatable {
    /// The resource types of the associated resource.
    /// This member is required.
    public var associatedResourceTypes: [WorkSpacesClientTypes.BundleAssociatedResourceType]?
    /// The identifier of the bundle.
    /// This member is required.
    public var bundleId: Swift.String?

    public init(
        associatedResourceTypes: [WorkSpacesClientTypes.BundleAssociatedResourceType]? = nil,
        bundleId: Swift.String? = nil
    )
    {
        self.associatedResourceTypes = associatedResourceTypes
        self.bundleId = bundleId
    }
}

struct DescribeBundleAssociationsInputBody: Swift.Equatable {
    let bundleId: Swift.String?
    let associatedResourceTypes: [WorkSpacesClientTypes.BundleAssociatedResourceType]?
}

extension DescribeBundleAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceTypes = "AssociatedResourceTypes"
        case bundleId = "BundleId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let associatedResourceTypesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.BundleAssociatedResourceType?].self, forKey: .associatedResourceTypes)
        var associatedResourceTypesDecoded0:[WorkSpacesClientTypes.BundleAssociatedResourceType]? = nil
        if let associatedResourceTypesContainer = associatedResourceTypesContainer {
            associatedResourceTypesDecoded0 = [WorkSpacesClientTypes.BundleAssociatedResourceType]()
            for enum0 in associatedResourceTypesContainer {
                if let enum0 = enum0 {
                    associatedResourceTypesDecoded0?.append(enum0)
                }
            }
        }
        associatedResourceTypes = associatedResourceTypesDecoded0
    }
}

extension DescribeBundleAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBundleAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.associations = output.associations
        } else {
            self.associations = nil
        }
    }
}

public struct DescribeBundleAssociationsOutput: Swift.Equatable {
    /// List of information about the specified associations.
    public var associations: [WorkSpacesClientTypes.BundleResourceAssociation]?

    public init(
        associations: [WorkSpacesClientTypes.BundleResourceAssociation]? = nil
    )
    {
        self.associations = associations
    }
}

struct DescribeBundleAssociationsOutputBody: Swift.Equatable {
    let associations: [WorkSpacesClientTypes.BundleResourceAssociation]?
}

extension DescribeBundleAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.BundleResourceAssociation?].self, forKey: .associations)
        var associationsDecoded0:[WorkSpacesClientTypes.BundleResourceAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [WorkSpacesClientTypes.BundleResourceAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
    }
}

enum DescribeBundleAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeClientBrandingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DescribeClientBrandingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeClientBrandingInput: Swift.Equatable {
    /// The directory identifier of the WorkSpace for which you want to view client branding information.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct DescribeClientBrandingInputBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension DescribeClientBrandingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DescribeClientBrandingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeClientBrandingOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceTypeAndroid = output.deviceTypeAndroid
            self.deviceTypeIos = output.deviceTypeIos
            self.deviceTypeLinux = output.deviceTypeLinux
            self.deviceTypeOsx = output.deviceTypeOsx
            self.deviceTypeWeb = output.deviceTypeWeb
            self.deviceTypeWindows = output.deviceTypeWindows
        } else {
            self.deviceTypeAndroid = nil
            self.deviceTypeIos = nil
            self.deviceTypeLinux = nil
            self.deviceTypeOsx = nil
            self.deviceTypeWeb = nil
            self.deviceTypeWindows = nil
        }
    }
}

public struct DescribeClientBrandingOutput: Swift.Equatable {
    /// The branding information for Android devices.
    public var deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information for iOS devices.
    public var deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes?
    /// The branding information for Linux devices.
    public var deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information for macOS devices.
    public var deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information for Web access.
    public var deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information for Windows devices.
    public var deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes?

    public init(
        deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes? = nil,
        deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil
    )
    {
        self.deviceTypeAndroid = deviceTypeAndroid
        self.deviceTypeIos = deviceTypeIos
        self.deviceTypeLinux = deviceTypeLinux
        self.deviceTypeOsx = deviceTypeOsx
        self.deviceTypeWeb = deviceTypeWeb
        self.deviceTypeWindows = deviceTypeWindows
    }
}

struct DescribeClientBrandingOutputBody: Swift.Equatable {
    let deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes?
    let deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
}

extension DescribeClientBrandingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceTypeAndroid = "DeviceTypeAndroid"
        case deviceTypeIos = "DeviceTypeIos"
        case deviceTypeLinux = "DeviceTypeLinux"
        case deviceTypeOsx = "DeviceTypeOsx"
        case deviceTypeWeb = "DeviceTypeWeb"
        case deviceTypeWindows = "DeviceTypeWindows"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTypeWindowsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeWindows)
        deviceTypeWindows = deviceTypeWindowsDecoded
        let deviceTypeOsxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeOsx)
        deviceTypeOsx = deviceTypeOsxDecoded
        let deviceTypeAndroidDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeAndroid)
        deviceTypeAndroid = deviceTypeAndroidDecoded
        let deviceTypeIosDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.IosClientBrandingAttributes.self, forKey: .deviceTypeIos)
        deviceTypeIos = deviceTypeIosDecoded
        let deviceTypeLinuxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeLinux)
        deviceTypeLinux = deviceTypeLinuxDecoded
        let deviceTypeWebDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeWeb)
        deviceTypeWeb = deviceTypeWebDecoded
    }
}

enum DescribeClientBrandingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeClientPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIds = "ResourceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for nonemptystring0 in resourceIds {
                try resourceIdsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension DescribeClientPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeClientPropertiesInput: Swift.Equatable {
    /// The resource identifier, in the form of directory IDs.
    /// This member is required.
    public var resourceIds: [Swift.String]?

    public init(
        resourceIds: [Swift.String]? = nil
    )
    {
        self.resourceIds = resourceIds
    }
}

struct DescribeClientPropertiesInputBody: Swift.Equatable {
    let resourceIds: [Swift.String]?
}

extension DescribeClientPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIds = "ResourceIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Swift.String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Swift.String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
    }
}

extension DescribeClientPropertiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeClientPropertiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientPropertiesList = output.clientPropertiesList
        } else {
            self.clientPropertiesList = nil
        }
    }
}

public struct DescribeClientPropertiesOutput: Swift.Equatable {
    /// Information about the specified Amazon WorkSpaces clients.
    public var clientPropertiesList: [WorkSpacesClientTypes.ClientPropertiesResult]?

    public init(
        clientPropertiesList: [WorkSpacesClientTypes.ClientPropertiesResult]? = nil
    )
    {
        self.clientPropertiesList = clientPropertiesList
    }
}

struct DescribeClientPropertiesOutputBody: Swift.Equatable {
    let clientPropertiesList: [WorkSpacesClientTypes.ClientPropertiesResult]?
}

extension DescribeClientPropertiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientPropertiesList = "ClientPropertiesList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientPropertiesListContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ClientPropertiesResult?].self, forKey: .clientPropertiesList)
        var clientPropertiesListDecoded0:[WorkSpacesClientTypes.ClientPropertiesResult]? = nil
        if let clientPropertiesListContainer = clientPropertiesListContainer {
            clientPropertiesListDecoded0 = [WorkSpacesClientTypes.ClientPropertiesResult]()
            for structure0 in clientPropertiesListContainer {
                if let structure0 = structure0 {
                    clientPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        clientPropertiesList = clientPropertiesListDecoded0
    }
}

enum DescribeClientPropertiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConnectClientAddInsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DescribeConnectClientAddInsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectClientAddInsInput: Swift.Equatable {
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The directory identifier for which the client add-in is configured.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct DescribeConnectClientAddInsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeConnectClientAddInsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeConnectClientAddInsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConnectClientAddInsOutputBody = try responseDecoder.decode(responseBody: data)
            self.addIns = output.addIns
            self.nextToken = output.nextToken
        } else {
            self.addIns = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectClientAddInsOutput: Swift.Equatable {
    /// Information about client add-ins.
    public var addIns: [WorkSpacesClientTypes.ConnectClientAddIn]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        addIns: [WorkSpacesClientTypes.ConnectClientAddIn]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.addIns = addIns
        self.nextToken = nextToken
    }
}

struct DescribeConnectClientAddInsOutputBody: Swift.Equatable {
    let addIns: [WorkSpacesClientTypes.ConnectClientAddIn]?
    let nextToken: Swift.String?
}

extension DescribeConnectClientAddInsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addIns = "AddIns"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addInsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ConnectClientAddIn?].self, forKey: .addIns)
        var addInsDecoded0:[WorkSpacesClientTypes.ConnectClientAddIn]? = nil
        if let addInsContainer = addInsContainer {
            addInsDecoded0 = [WorkSpacesClientTypes.ConnectClientAddIn]()
            for structure0 in addInsContainer {
                if let structure0 = structure0 {
                    addInsDecoded0?.append(structure0)
                }
            }
        }
        addIns = addInsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeConnectClientAddInsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConnectionAliasPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = self.aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConnectionAliasPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectionAliasPermissionsInput: Swift.Equatable {
    /// The identifier of the connection alias.
    /// This member is required.
    public var aliasId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        aliasId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeConnectionAliasPermissionsInputBody: Swift.Equatable {
    let aliasId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeConnectionAliasPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeConnectionAliasPermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConnectionAliasPermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.aliasId = output.aliasId
            self.connectionAliasPermissions = output.connectionAliasPermissions
            self.nextToken = output.nextToken
        } else {
            self.aliasId = nil
            self.connectionAliasPermissions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectionAliasPermissionsOutput: Swift.Equatable {
    /// The identifier of the connection alias.
    public var aliasId: Swift.String?
    /// The permissions associated with a connection alias.
    public var connectionAliasPermissions: [WorkSpacesClientTypes.ConnectionAliasPermission]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        aliasId: Swift.String? = nil,
        connectionAliasPermissions: [WorkSpacesClientTypes.ConnectionAliasPermission]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
        self.connectionAliasPermissions = connectionAliasPermissions
        self.nextToken = nextToken
    }
}

struct DescribeConnectionAliasPermissionsOutputBody: Swift.Equatable {
    let aliasId: Swift.String?
    let connectionAliasPermissions: [WorkSpacesClientTypes.ConnectionAliasPermission]?
    let nextToken: Swift.String?
}

extension DescribeConnectionAliasPermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case connectionAliasPermissions = "ConnectionAliasPermissions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let connectionAliasPermissionsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ConnectionAliasPermission?].self, forKey: .connectionAliasPermissions)
        var connectionAliasPermissionsDecoded0:[WorkSpacesClientTypes.ConnectionAliasPermission]? = nil
        if let connectionAliasPermissionsContainer = connectionAliasPermissionsContainer {
            connectionAliasPermissionsDecoded0 = [WorkSpacesClientTypes.ConnectionAliasPermission]()
            for structure0 in connectionAliasPermissionsContainer {
                if let structure0 = structure0 {
                    connectionAliasPermissionsDecoded0?.append(structure0)
                }
            }
        }
        connectionAliasPermissions = connectionAliasPermissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeConnectionAliasPermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConnectionAliasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasIds = "AliasIds"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasIds = aliasIds {
            var aliasIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliasIds)
            for connectionaliasid0 in aliasIds {
                try aliasIdsContainer.encode(connectionaliasid0)
            }
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DescribeConnectionAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectionAliasesInput: Swift.Equatable {
    /// The identifiers of the connection aliases to describe.
    public var aliasIds: [Swift.String]?
    /// The maximum number of connection aliases to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the directory associated with the connection alias.
    public var resourceId: Swift.String?

    public init(
        aliasIds: [Swift.String]? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.aliasIds = aliasIds
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct DescribeConnectionAliasesInputBody: Swift.Equatable {
    let aliasIds: [Swift.String]?
    let resourceId: Swift.String?
    let limit: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeConnectionAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasIds = "AliasIds"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .aliasIds)
        var aliasIdsDecoded0:[Swift.String]? = nil
        if let aliasIdsContainer = aliasIdsContainer {
            aliasIdsDecoded0 = [Swift.String]()
            for string0 in aliasIdsContainer {
                if let string0 = string0 {
                    aliasIdsDecoded0?.append(string0)
                }
            }
        }
        aliasIds = aliasIdsDecoded0
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectionAliasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConnectionAliasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectionAliases = output.connectionAliases
            self.nextToken = output.nextToken
        } else {
            self.connectionAliases = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectionAliasesOutput: Swift.Equatable {
    /// Information about the specified connection aliases.
    public var connectionAliases: [WorkSpacesClientTypes.ConnectionAlias]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        connectionAliases: [WorkSpacesClientTypes.ConnectionAlias]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionAliases = connectionAliases
        self.nextToken = nextToken
    }
}

struct DescribeConnectionAliasesOutputBody: Swift.Equatable {
    let connectionAliases: [WorkSpacesClientTypes.ConnectionAlias]?
    let nextToken: Swift.String?
}

extension DescribeConnectionAliasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionAliases = "ConnectionAliases"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionAliasesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ConnectionAlias?].self, forKey: .connectionAliases)
        var connectionAliasesDecoded0:[WorkSpacesClientTypes.ConnectionAlias]? = nil
        if let connectionAliasesContainer = connectionAliasesContainer {
            connectionAliasesDecoded0 = [WorkSpacesClientTypes.ConnectionAlias]()
            for structure0 in connectionAliasesContainer {
                if let structure0 = structure0 {
                    connectionAliasesDecoded0?.append(structure0)
                }
            }
        }
        connectionAliases = connectionAliasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeConnectionAliasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeImageAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceTypes = "AssociatedResourceTypes"
        case imageId = "ImageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedResourceTypes = associatedResourceTypes {
            var associatedResourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedResourceTypes)
            for imageassociatedresourcetype0 in associatedResourceTypes {
                try associatedResourceTypesContainer.encode(imageassociatedresourcetype0.rawValue)
            }
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }
}

extension DescribeImageAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImageAssociationsInput: Swift.Equatable {
    /// The resource types of the associated resource.
    /// This member is required.
    public var associatedResourceTypes: [WorkSpacesClientTypes.ImageAssociatedResourceType]?
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?

    public init(
        associatedResourceTypes: [WorkSpacesClientTypes.ImageAssociatedResourceType]? = nil,
        imageId: Swift.String? = nil
    )
    {
        self.associatedResourceTypes = associatedResourceTypes
        self.imageId = imageId
    }
}

struct DescribeImageAssociationsInputBody: Swift.Equatable {
    let imageId: Swift.String?
    let associatedResourceTypes: [WorkSpacesClientTypes.ImageAssociatedResourceType]?
}

extension DescribeImageAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceTypes = "AssociatedResourceTypes"
        case imageId = "ImageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let associatedResourceTypesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ImageAssociatedResourceType?].self, forKey: .associatedResourceTypes)
        var associatedResourceTypesDecoded0:[WorkSpacesClientTypes.ImageAssociatedResourceType]? = nil
        if let associatedResourceTypesContainer = associatedResourceTypesContainer {
            associatedResourceTypesDecoded0 = [WorkSpacesClientTypes.ImageAssociatedResourceType]()
            for enum0 in associatedResourceTypesContainer {
                if let enum0 = enum0 {
                    associatedResourceTypesDecoded0?.append(enum0)
                }
            }
        }
        associatedResourceTypes = associatedResourceTypesDecoded0
    }
}

extension DescribeImageAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeImageAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.associations = output.associations
        } else {
            self.associations = nil
        }
    }
}

public struct DescribeImageAssociationsOutput: Swift.Equatable {
    /// List of information about the specified associations.
    public var associations: [WorkSpacesClientTypes.ImageResourceAssociation]?

    public init(
        associations: [WorkSpacesClientTypes.ImageResourceAssociation]? = nil
    )
    {
        self.associations = associations
    }
}

struct DescribeImageAssociationsOutputBody: Swift.Equatable {
    let associations: [WorkSpacesClientTypes.ImageResourceAssociation]?
}

extension DescribeImageAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ImageResourceAssociation?].self, forKey: .associations)
        var associationsDecoded0:[WorkSpacesClientTypes.ImageResourceAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [WorkSpacesClientTypes.ImageResourceAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
    }
}

enum DescribeImageAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeIpGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIds = "GroupIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for ipgroupid0 in groupIds {
                try groupIdsContainer.encode(ipgroupid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeIpGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeIpGroupsInput: Swift.Equatable {
    /// The identifiers of one or more IP access control groups.
    public var groupIds: [Swift.String]?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        groupIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupIds = groupIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeIpGroupsInputBody: Swift.Equatable {
    let groupIds: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeIpGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIds = "GroupIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[Swift.String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [Swift.String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeIpGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeIpGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.result = output.result
        } else {
            self.nextToken = nil
            self.result = nil
        }
    }
}

public struct DescribeIpGroupsOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the IP access control groups.
    public var result: [WorkSpacesClientTypes.WorkspacesIpGroup]?

    public init(
        nextToken: Swift.String? = nil,
        result: [WorkSpacesClientTypes.WorkspacesIpGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.result = result
    }
}

struct DescribeIpGroupsOutputBody: Swift.Equatable {
    let result: [WorkSpacesClientTypes.WorkspacesIpGroup]?
    let nextToken: Swift.String?
}

extension DescribeIpGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case result = "Result"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspacesIpGroup?].self, forKey: .result)
        var resultDecoded0:[WorkSpacesClientTypes.WorkspacesIpGroup]? = nil
        if let resultContainer = resultContainer {
            resultDecoded0 = [WorkSpacesClientTypes.WorkspacesIpGroup]()
            for structure0 in resultContainer {
                if let structure0 = structure0 {
                    resultDecoded0?.append(structure0)
                }
            }
        }
        result = resultDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeIpGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DescribeTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeTagsInput: Swift.Equatable {
    /// The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces, registered directories, images, custom bundles, IP access control groups, and connection aliases.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct DescribeTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension DescribeTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DescribeTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct DescribeTagsOutput: Swift.Equatable {
    /// The tags.
    public var tagList: [WorkSpacesClientTypes.Tag]?

    public init(
        tagList: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct DescribeTagsOutputBody: Swift.Equatable {
    let tagList: [WorkSpacesClientTypes.Tag]?
}

extension DescribeTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

enum DescribeTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkspaceAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceTypes = "AssociatedResourceTypes"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedResourceTypes = associatedResourceTypes {
            var associatedResourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedResourceTypes)
            for workspaceassociatedresourcetype0 in associatedResourceTypes {
                try associatedResourceTypesContainer.encode(workspaceassociatedresourcetype0.rawValue)
            }
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension DescribeWorkspaceAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceAssociationsInput: Swift.Equatable {
    /// The resource types of the associated resources.
    /// This member is required.
    public var associatedResourceTypes: [WorkSpacesClientTypes.WorkSpaceAssociatedResourceType]?
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        associatedResourceTypes: [WorkSpacesClientTypes.WorkSpaceAssociatedResourceType]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.associatedResourceTypes = associatedResourceTypes
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceAssociationsInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let associatedResourceTypes: [WorkSpacesClientTypes.WorkSpaceAssociatedResourceType]?
}

extension DescribeWorkspaceAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceTypes = "AssociatedResourceTypes"
        case workspaceId = "WorkspaceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let associatedResourceTypesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkSpaceAssociatedResourceType?].self, forKey: .associatedResourceTypes)
        var associatedResourceTypesDecoded0:[WorkSpacesClientTypes.WorkSpaceAssociatedResourceType]? = nil
        if let associatedResourceTypesContainer = associatedResourceTypesContainer {
            associatedResourceTypesDecoded0 = [WorkSpacesClientTypes.WorkSpaceAssociatedResourceType]()
            for enum0 in associatedResourceTypesContainer {
                if let enum0 = enum0 {
                    associatedResourceTypesDecoded0?.append(enum0)
                }
            }
        }
        associatedResourceTypes = associatedResourceTypesDecoded0
    }
}

extension DescribeWorkspaceAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkspaceAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.associations = output.associations
        } else {
            self.associations = nil
        }
    }
}

public struct DescribeWorkspaceAssociationsOutput: Swift.Equatable {
    /// List of information about the specified associations.
    public var associations: [WorkSpacesClientTypes.WorkspaceResourceAssociation]?

    public init(
        associations: [WorkSpacesClientTypes.WorkspaceResourceAssociation]? = nil
    )
    {
        self.associations = associations
    }
}

struct DescribeWorkspaceAssociationsOutputBody: Swift.Equatable {
    let associations: [WorkSpacesClientTypes.WorkspaceResourceAssociation]?
}

extension DescribeWorkspaceAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceResourceAssociation?].self, forKey: .associations)
        var associationsDecoded0:[WorkSpacesClientTypes.WorkspaceResourceAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [WorkSpacesClientTypes.WorkspaceResourceAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
    }
}

enum DescribeWorkspaceAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkspaceBundlesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleIds = "BundleIds"
        case nextToken = "NextToken"
        case owner = "Owner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleIds = bundleIds {
            var bundleIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bundleIds)
            for bundleid0 in bundleIds {
                try bundleIdsContainer.encode(bundleid0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
    }
}

extension DescribeWorkspaceBundlesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceBundlesInput: Swift.Equatable {
    /// The identifiers of the bundles. You cannot combine this parameter with any other filter.
    public var bundleIds: [Swift.String]?
    /// The token for the next set of results. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The owner of the bundles. You cannot combine this parameter with any other filter. To describe the bundles provided by Amazon Web Services, specify AMAZON. To describe the bundles that belong to your account, don't specify a value.
    public var owner: Swift.String?

    public init(
        bundleIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        owner: Swift.String? = nil
    )
    {
        self.bundleIds = bundleIds
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct DescribeWorkspaceBundlesInputBody: Swift.Equatable {
    let bundleIds: [Swift.String]?
    let owner: Swift.String?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceBundlesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleIds = "BundleIds"
        case nextToken = "NextToken"
        case owner = "Owner"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bundleIds)
        var bundleIdsDecoded0:[Swift.String]? = nil
        if let bundleIdsContainer = bundleIdsContainer {
            bundleIdsDecoded0 = [Swift.String]()
            for string0 in bundleIdsContainer {
                if let string0 = string0 {
                    bundleIdsDecoded0?.append(string0)
                }
            }
        }
        bundleIds = bundleIdsDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceBundlesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkspaceBundlesOutputBody = try responseDecoder.decode(responseBody: data)
            self.bundles = output.bundles
            self.nextToken = output.nextToken
        } else {
            self.bundles = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceBundlesOutput: Swift.Equatable {
    /// Information about the bundles.
    public var bundles: [WorkSpacesClientTypes.WorkspaceBundle]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return. This token is valid for one day and must be used within that time frame.
    public var nextToken: Swift.String?

    public init(
        bundles: [WorkSpacesClientTypes.WorkspaceBundle]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bundles = bundles
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceBundlesOutputBody: Swift.Equatable {
    let bundles: [WorkSpacesClientTypes.WorkspaceBundle]?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceBundlesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundles = "Bundles"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundlesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceBundle?].self, forKey: .bundles)
        var bundlesDecoded0:[WorkSpacesClientTypes.WorkspaceBundle]? = nil
        if let bundlesContainer = bundlesContainer {
            bundlesDecoded0 = [WorkSpacesClientTypes.WorkspaceBundle]()
            for structure0 in bundlesContainer {
                if let structure0 = structure0 {
                    bundlesDecoded0?.append(structure0)
                }
            }
        }
        bundles = bundlesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeWorkspaceBundlesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkspaceDirectoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryIds = "DirectoryIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryIds = directoryIds {
            var directoryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .directoryIds)
            for directoryid0 in directoryIds {
                try directoryIdsContainer.encode(directoryid0)
            }
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeWorkspaceDirectoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceDirectoriesInput: Swift.Equatable {
    /// The identifiers of the directories. If the value is null, all directories are retrieved.
    public var directoryIds: [Swift.String]?
    /// The maximum number of directories to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        directoryIds: [Swift.String]? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryIds = directoryIds
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceDirectoriesInputBody: Swift.Equatable {
    let directoryIds: [Swift.String]?
    let limit: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceDirectoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryIds = "DirectoryIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .directoryIds)
        var directoryIdsDecoded0:[Swift.String]? = nil
        if let directoryIdsContainer = directoryIdsContainer {
            directoryIdsDecoded0 = [Swift.String]()
            for string0 in directoryIdsContainer {
                if let string0 = string0 {
                    directoryIdsDecoded0?.append(string0)
                }
            }
        }
        directoryIds = directoryIdsDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceDirectoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkspaceDirectoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.directories = output.directories
            self.nextToken = output.nextToken
        } else {
            self.directories = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceDirectoriesOutput: Swift.Equatable {
    /// Information about the directories.
    public var directories: [WorkSpacesClientTypes.WorkspaceDirectory]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        directories: [WorkSpacesClientTypes.WorkspaceDirectory]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directories = directories
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceDirectoriesOutputBody: Swift.Equatable {
    let directories: [WorkSpacesClientTypes.WorkspaceDirectory]?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceDirectoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directories = "Directories"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoriesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceDirectory?].self, forKey: .directories)
        var directoriesDecoded0:[WorkSpacesClientTypes.WorkspaceDirectory]? = nil
        if let directoriesContainer = directoriesContainer {
            directoriesDecoded0 = [WorkSpacesClientTypes.WorkspaceDirectory]()
            for structure0 in directoriesContainer {
                if let structure0 = structure0 {
                    directoriesDecoded0?.append(structure0)
                }
            }
        }
        directories = directoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeWorkspaceDirectoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkspaceImagePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeWorkspaceImagePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceImagePermissionsInput: Swift.Equatable {
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        imageId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagePermissionsInputBody: Swift.Equatable {
    let imageId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeWorkspaceImagePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeWorkspaceImagePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkspaceImagePermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
            self.imagePermissions = output.imagePermissions
            self.nextToken = output.nextToken
        } else {
            self.imageId = nil
            self.imagePermissions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceImagePermissionsOutput: Swift.Equatable {
    /// The identifier of the image.
    public var imageId: Swift.String?
    /// The identifiers of the Amazon Web Services accounts that the image has been shared with.
    public var imagePermissions: [WorkSpacesClientTypes.ImagePermission]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        imageId: Swift.String? = nil,
        imagePermissions: [WorkSpacesClientTypes.ImagePermission]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.imagePermissions = imagePermissions
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagePermissionsOutputBody: Swift.Equatable {
    let imageId: Swift.String?
    let imagePermissions: [WorkSpacesClientTypes.ImagePermission]?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceImagePermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
        case imagePermissions = "ImagePermissions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imagePermissionsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ImagePermission?].self, forKey: .imagePermissions)
        var imagePermissionsDecoded0:[WorkSpacesClientTypes.ImagePermission]? = nil
        if let imagePermissionsContainer = imagePermissionsContainer {
            imagePermissionsDecoded0 = [WorkSpacesClientTypes.ImagePermission]()
            for structure0 in imagePermissionsContainer {
                if let structure0 = structure0 {
                    imagePermissionsDecoded0?.append(structure0)
                }
            }
        }
        imagePermissions = imagePermissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeWorkspaceImagePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkspaceImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds = "ImageIds"
        case imageType = "ImageType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for workspaceimageid0 in imageIds {
                try imageIdsContainer.encode(workspaceimageid0)
            }
        }
        if let imageType = self.imageType {
            try encodeContainer.encode(imageType.rawValue, forKey: .imageType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeWorkspaceImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceImagesInput: Swift.Equatable {
    /// The identifier of the image.
    public var imageIds: [Swift.String]?
    /// The type (owned or shared) of the image.
    public var imageType: WorkSpacesClientTypes.ImageType?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        imageIds: [Swift.String]? = nil,
        imageType: WorkSpacesClientTypes.ImageType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageIds = imageIds
        self.imageType = imageType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagesInputBody: Swift.Equatable {
    let imageIds: [Swift.String]?
    let imageType: WorkSpacesClientTypes.ImageType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeWorkspaceImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds = "ImageIds"
        case imageType = "ImageType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageIds)
        var imageIdsDecoded0:[Swift.String]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [Swift.String]()
            for string0 in imageIdsContainer {
                if let string0 = string0 {
                    imageIdsDecoded0?.append(string0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let imageTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ImageType.self, forKey: .imageType)
        imageType = imageTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeWorkspaceImagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkspaceImagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.images = output.images
            self.nextToken = output.nextToken
        } else {
            self.images = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceImagesOutput: Swift.Equatable {
    /// Information about the images.
    public var images: [WorkSpacesClientTypes.WorkspaceImage]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        images: [WorkSpacesClientTypes.WorkspaceImage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.images = images
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagesOutputBody: Swift.Equatable {
    let images: [WorkSpacesClientTypes.WorkspaceImage]?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceImagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case images = "Images"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceImage?].self, forKey: .images)
        var imagesDecoded0:[WorkSpacesClientTypes.WorkspaceImage]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [WorkSpacesClientTypes.WorkspaceImage]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeWorkspaceImagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkspaceSnapshotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension DescribeWorkspaceSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceSnapshotsInput: Swift.Equatable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceSnapshotsInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
}

extension DescribeWorkspaceSnapshotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension DescribeWorkspaceSnapshotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkspaceSnapshotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.rebuildSnapshots = output.rebuildSnapshots
            self.restoreSnapshots = output.restoreSnapshots
        } else {
            self.rebuildSnapshots = nil
            self.restoreSnapshots = nil
        }
    }
}

public struct DescribeWorkspaceSnapshotsOutput: Swift.Equatable {
    /// Information about the snapshots that can be used to rebuild a WorkSpace. These snapshots include the user volume.
    public var rebuildSnapshots: [WorkSpacesClientTypes.Snapshot]?
    /// Information about the snapshots that can be used to restore a WorkSpace. These snapshots include both the root volume and the user volume.
    public var restoreSnapshots: [WorkSpacesClientTypes.Snapshot]?

    public init(
        rebuildSnapshots: [WorkSpacesClientTypes.Snapshot]? = nil,
        restoreSnapshots: [WorkSpacesClientTypes.Snapshot]? = nil
    )
    {
        self.rebuildSnapshots = rebuildSnapshots
        self.restoreSnapshots = restoreSnapshots
    }
}

struct DescribeWorkspaceSnapshotsOutputBody: Swift.Equatable {
    let rebuildSnapshots: [WorkSpacesClientTypes.Snapshot]?
    let restoreSnapshots: [WorkSpacesClientTypes.Snapshot]?
}

extension DescribeWorkspaceSnapshotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebuildSnapshots = "RebuildSnapshots"
        case restoreSnapshots = "RestoreSnapshots"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rebuildSnapshotsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Snapshot?].self, forKey: .rebuildSnapshots)
        var rebuildSnapshotsDecoded0:[WorkSpacesClientTypes.Snapshot]? = nil
        if let rebuildSnapshotsContainer = rebuildSnapshotsContainer {
            rebuildSnapshotsDecoded0 = [WorkSpacesClientTypes.Snapshot]()
            for structure0 in rebuildSnapshotsContainer {
                if let structure0 = structure0 {
                    rebuildSnapshotsDecoded0?.append(structure0)
                }
            }
        }
        rebuildSnapshots = rebuildSnapshotsDecoded0
        let restoreSnapshotsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Snapshot?].self, forKey: .restoreSnapshots)
        var restoreSnapshotsDecoded0:[WorkSpacesClientTypes.Snapshot]? = nil
        if let restoreSnapshotsContainer = restoreSnapshotsContainer {
            restoreSnapshotsDecoded0 = [WorkSpacesClientTypes.Snapshot]()
            for structure0 in restoreSnapshotsContainer {
                if let structure0 = structure0 {
                    restoreSnapshotsDecoded0?.append(structure0)
                }
            }
        }
        restoreSnapshots = restoreSnapshotsDecoded0
    }
}

enum DescribeWorkspaceSnapshotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkspacesConnectionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workspaceIds = "WorkspaceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workspaceIds = workspaceIds {
            var workspaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceIds)
            for workspaceid0 in workspaceIds {
                try workspaceIdsContainer.encode(workspaceid0)
            }
        }
    }
}

extension DescribeWorkspacesConnectionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspacesConnectionStatusInput: Swift.Equatable {
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The identifiers of the WorkSpaces. You can specify up to 25 WorkSpaces.
    public var workspaceIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        workspaceIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaceIds = workspaceIds
    }
}

struct DescribeWorkspacesConnectionStatusInputBody: Swift.Equatable {
    let workspaceIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension DescribeWorkspacesConnectionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workspaceIds = "WorkspaceIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workspaceIds)
        var workspaceIdsDecoded0:[Swift.String]? = nil
        if let workspaceIdsContainer = workspaceIdsContainer {
            workspaceIdsDecoded0 = [Swift.String]()
            for string0 in workspaceIdsContainer {
                if let string0 = string0 {
                    workspaceIdsDecoded0?.append(string0)
                }
            }
        }
        workspaceIds = workspaceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspacesConnectionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkspacesConnectionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspacesConnectionStatus = output.workspacesConnectionStatus
        } else {
            self.nextToken = nil
            self.workspacesConnectionStatus = nil
        }
    }
}

public struct DescribeWorkspacesConnectionStatusOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the connection status of the WorkSpace.
    public var workspacesConnectionStatus: [WorkSpacesClientTypes.WorkspaceConnectionStatus]?

    public init(
        nextToken: Swift.String? = nil,
        workspacesConnectionStatus: [WorkSpacesClientTypes.WorkspaceConnectionStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspacesConnectionStatus = workspacesConnectionStatus
    }
}

struct DescribeWorkspacesConnectionStatusOutputBody: Swift.Equatable {
    let workspacesConnectionStatus: [WorkSpacesClientTypes.WorkspaceConnectionStatus]?
    let nextToken: Swift.String?
}

extension DescribeWorkspacesConnectionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workspacesConnectionStatus = "WorkspacesConnectionStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesConnectionStatusContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceConnectionStatus?].self, forKey: .workspacesConnectionStatus)
        var workspacesConnectionStatusDecoded0:[WorkSpacesClientTypes.WorkspaceConnectionStatus]? = nil
        if let workspacesConnectionStatusContainer = workspacesConnectionStatusContainer {
            workspacesConnectionStatusDecoded0 = [WorkSpacesClientTypes.WorkspaceConnectionStatus]()
            for structure0 in workspacesConnectionStatusContainer {
                if let structure0 = structure0 {
                    workspacesConnectionStatusDecoded0?.append(structure0)
                }
            }
        }
        workspacesConnectionStatus = workspacesConnectionStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeWorkspacesConnectionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case userName = "UserName"
        case workspaceIds = "WorkspaceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let workspaceIds = workspaceIds {
            var workspaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceIds)
            for workspaceid0 in workspaceIds {
                try workspaceIdsContainer.encode(workspaceid0)
            }
        }
    }
}

extension DescribeWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspacesInput: Swift.Equatable {
    /// The identifier of the bundle. All WorkSpaces that are created from this bundle are retrieved. You cannot combine this parameter with any other filter.
    public var bundleId: Swift.String?
    /// The identifier of the directory. In addition, you can optionally specify a specific directory user (see UserName). You cannot combine this parameter with any other filter.
    public var directoryId: Swift.String?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The name of the directory user. You must specify this parameter with DirectoryId.
    public var userName: Swift.String?
    /// The identifiers of the WorkSpaces. You cannot combine this parameter with any other filter. Because the [CreateWorkspaces] operation is asynchronous, the identifier it returns is not immediately available. If you immediately call [DescribeWorkspaces] with this identifier, no information is returned.
    public var workspaceIds: [Swift.String]?

    public init(
        bundleId: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userName: Swift.String? = nil,
        workspaceIds: [Swift.String]? = nil
    )
    {
        self.bundleId = bundleId
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
        self.userName = userName
        self.workspaceIds = workspaceIds
    }
}

struct DescribeWorkspacesInputBody: Swift.Equatable {
    let workspaceIds: [Swift.String]?
    let directoryId: Swift.String?
    let userName: Swift.String?
    let bundleId: Swift.String?
    let limit: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case userName = "UserName"
        case workspaceIds = "WorkspaceIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workspaceIds)
        var workspaceIdsDecoded0:[Swift.String]? = nil
        if let workspaceIdsContainer = workspaceIdsContainer {
            workspaceIdsDecoded0 = [Swift.String]()
            for string0 in workspaceIdsContainer {
                if let string0 = string0 {
                    workspaceIdsDecoded0?.append(string0)
                }
            }
        }
        workspaceIds = workspaceIdsDecoded0
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWorkspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspaces = output.workspaces
        } else {
            self.nextToken = nil
            self.workspaces = nil
        }
    }
}

public struct DescribeWorkspacesOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the WorkSpaces. Because [CreateWorkspaces] is an asynchronous operation, some of the returned information could be incomplete.
    public var workspaces: [WorkSpacesClientTypes.Workspace]?

    public init(
        nextToken: Swift.String? = nil,
        workspaces: [WorkSpacesClientTypes.Workspace]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaces = workspaces
    }
}

struct DescribeWorkspacesOutputBody: Swift.Equatable {
    let workspaces: [WorkSpacesClientTypes.Workspace]?
    let nextToken: Swift.String?
}

extension DescribeWorkspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workspaces = "Workspaces"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Workspace?].self, forKey: .workspaces)
        var workspacesDecoded0:[WorkSpacesClientTypes.Workspace]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [WorkSpacesClientTypes.Workspace]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeWorkspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateConnectionAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = self.aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
    }
}

extension DisassociateConnectionAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateConnectionAliasInput: Swift.Equatable {
    /// The identifier of the connection alias to disassociate.
    /// This member is required.
    public var aliasId: Swift.String?

    public init(
        aliasId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

struct DisassociateConnectionAliasInputBody: Swift.Equatable {
    let aliasId: Swift.String?
}

extension DisassociateConnectionAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
    }
}

extension DisassociateConnectionAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateConnectionAliasOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateConnectionAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateIpGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for ipgroupid0 in groupIds {
                try groupIdsContainer.encode(ipgroupid0)
            }
        }
    }
}

extension DisassociateIpGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateIpGroupsInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The identifiers of one or more IP access control groups.
    /// This member is required.
    public var groupIds: [Swift.String]?

    public init(
        directoryId: Swift.String? = nil,
        groupIds: [Swift.String]? = nil
    )
    {
        self.directoryId = directoryId
        self.groupIds = groupIds
    }
}

struct DisassociateIpGroupsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let groupIds: [Swift.String]?
}

extension DisassociateIpGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let groupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[Swift.String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [Swift.String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
    }
}

extension DisassociateIpGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateIpGroupsOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateIpGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateWorkspaceApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension DisassociateWorkspaceApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateWorkspaceApplicationInput: Swift.Equatable {
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.workspaceId = workspaceId
    }
}

struct DisassociateWorkspaceApplicationInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let applicationId: Swift.String?
}

extension DisassociateWorkspaceApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case workspaceId = "WorkspaceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
    }
}

extension DisassociateWorkspaceApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateWorkspaceApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.association = output.association
        } else {
            self.association = nil
        }
    }
}

public struct DisassociateWorkspaceApplicationOutput: Swift.Equatable {
    /// Information about the targeted association.
    public var association: WorkSpacesClientTypes.WorkspaceResourceAssociation?

    public init(
        association: WorkSpacesClientTypes.WorkspaceResourceAssociation? = nil
    )
    {
        self.association = association
    }
}

struct DisassociateWorkspaceApplicationOutputBody: Swift.Equatable {
    let association: WorkSpacesClientTypes.WorkspaceResourceAssociation?
}

extension DisassociateWorkspaceApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case association = "Association"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceResourceAssociation.self, forKey: .association)
        association = associationDecoded
    }
}

enum DisassociateWorkspaceApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageErrorDetailCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes in-depth details about the error. These details include the possible causes of the error and troubleshooting information.
    public struct ErrorDetails: Swift.Equatable {
        /// Indicates the error code returned.
        public var errorCode: WorkSpacesClientTypes.WorkspaceImageErrorDetailCode?
        /// The text of the error message related the error code.
        public var errorMessage: Swift.String?

        public init(
            errorCode: WorkSpacesClientTypes.WorkspaceImageErrorDetailCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case standbyWorkspaceRequest = "StandbyWorkspaceRequest"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let standbyWorkspaceRequest = self.standbyWorkspaceRequest {
            try encodeContainer.encode(standbyWorkspaceRequest, forKey: .standbyWorkspaceRequest)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standbyWorkspaceRequestDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.StandbyWorkspace.self, forKey: .standbyWorkspaceRequest)
        standbyWorkspaceRequest = standbyWorkspaceRequestDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the standby WorkSpace that could not be created.
    public struct FailedCreateStandbyWorkspacesRequest: Swift.Equatable {
        /// The error code that is returned if the standby WorkSpace could not be created.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the standby WorkSpace could not be created.
        public var errorMessage: Swift.String?
        /// Information about the standby WorkSpace that could not be created.
        public var standbyWorkspaceRequest: WorkSpacesClientTypes.StandbyWorkspace?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            standbyWorkspaceRequest: WorkSpacesClientTypes.StandbyWorkspace? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.standbyWorkspaceRequest = standbyWorkspaceRequest
        }
    }

}

extension WorkSpacesClientTypes.FailedCreateWorkspaceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case workspaceRequest = "WorkspaceRequest"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let workspaceRequest = self.workspaceRequest {
            try encodeContainer.encode(workspaceRequest, forKey: .workspaceRequest)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceRequestDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceRequest.self, forKey: .workspaceRequest)
        workspaceRequest = workspaceRequestDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace that cannot be created.
    public struct FailedCreateWorkspaceRequest: Swift.Equatable {
        /// The error code that is returned if the WorkSpace cannot be created.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the WorkSpace cannot be created.
        public var errorMessage: Swift.String?
        /// Information about the WorkSpace.
        public var workspaceRequest: WorkSpacesClientTypes.WorkspaceRequest?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            workspaceRequest: WorkSpacesClientTypes.WorkspaceRequest? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.workspaceRequest = workspaceRequest
        }
    }

}

extension WorkSpacesClientTypes.FailedWorkspaceChangeRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace that could not be rebooted. ([RebootWorkspaces]), rebuilt ([RebuildWorkspaces]), restored ([RestoreWorkspace]), terminated ([TerminateWorkspaces]), started ([StartWorkspaces]), or stopped ([StopWorkspaces]).
    public struct FailedWorkspaceChangeRequest: Swift.Equatable {
        /// The error code that is returned if the WorkSpace cannot be rebooted.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the WorkSpace cannot be rebooted.
        public var errorMessage: Swift.String?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.workspaceId = workspaceId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum ImageAssociatedResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageAssociatedResourceType] {
            return [
                .application,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageAssociatedResourceType(rawValue: rawValue) ?? ImageAssociatedResourceType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.ImagePermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sharedAccountId = self.sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the Amazon Web Services accounts that have been granted permission to use a shared image. For more information about sharing images, see [ Share or Unshare a Custom WorkSpaces Image](https://docs.aws.amazon.com/workspaces/latest/adminguide/share-custom-image.html).
    public struct ImagePermission: Swift.Equatable {
        /// The identifier of the Amazon Web Services account that an image has been shared with.
        public var sharedAccountId: Swift.String?

        public init(
            sharedAccountId: Swift.String? = nil
        )
        {
            self.sharedAccountId = sharedAccountId
        }
    }

}

extension WorkSpacesClientTypes.ImageResourceAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceId = "AssociatedResourceId"
        case associatedResourceType = "AssociatedResourceType"
        case created = "Created"
        case imageId = "ImageId"
        case lastUpdatedTime = "LastUpdatedTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedResourceId = self.associatedResourceId {
            try encodeContainer.encode(associatedResourceId, forKey: .associatedResourceId)
        }
        if let associatedResourceType = self.associatedResourceType {
            try encodeContainer.encode(associatedResourceType.rawValue, forKey: .associatedResourceType)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = self.stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedResourceId)
        associatedResourceId = associatedResourceIdDecoded
        let associatedResourceTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ImageAssociatedResourceType.self, forKey: .associatedResourceType)
        associatedResourceType = associatedResourceTypeDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AssociationState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AssociationStateReason.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the association between an application and an image resource.
    public struct ImageResourceAssociation: Swift.Equatable {
        /// The identifier of the associated resource.
        public var associatedResourceId: Swift.String?
        /// The resource type of the associated resources.
        public var associatedResourceType: WorkSpacesClientTypes.ImageAssociatedResourceType?
        /// The time the association is created.
        public var created: ClientRuntime.Date?
        /// The identifier of the image.
        public var imageId: Swift.String?
        /// The time the association status was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The status of the image resource association.
        public var state: WorkSpacesClientTypes.AssociationState?
        /// The reason the association deployment failed.
        public var stateReason: WorkSpacesClientTypes.AssociationStateReason?

        public init(
            associatedResourceId: Swift.String? = nil,
            associatedResourceType: WorkSpacesClientTypes.ImageAssociatedResourceType? = nil,
            created: ClientRuntime.Date? = nil,
            imageId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            state: WorkSpacesClientTypes.AssociationState? = nil,
            stateReason: WorkSpacesClientTypes.AssociationStateReason? = nil
        )
        {
            self.associatedResourceId = associatedResourceId
            self.associatedResourceType = associatedResourceType
            self.created = created
            self.imageId = imageId
            self.lastUpdatedTime = lastUpdatedTime
            self.state = state
            self.stateReason = stateReason
        }
    }

}

extension WorkSpacesClientTypes {
    public enum ImageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case owned
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageType] {
            return [
                .owned,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .owned: return "OWNED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageType(rawValue: rawValue) ?? ImageType.sdkUnknown(rawValue)
        }
    }
}

extension ImportClientBrandingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceTypeAndroid = "DeviceTypeAndroid"
        case deviceTypeIos = "DeviceTypeIos"
        case deviceTypeLinux = "DeviceTypeLinux"
        case deviceTypeOsx = "DeviceTypeOsx"
        case deviceTypeWeb = "DeviceTypeWeb"
        case deviceTypeWindows = "DeviceTypeWindows"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceTypeAndroid = self.deviceTypeAndroid {
            try encodeContainer.encode(deviceTypeAndroid, forKey: .deviceTypeAndroid)
        }
        if let deviceTypeIos = self.deviceTypeIos {
            try encodeContainer.encode(deviceTypeIos, forKey: .deviceTypeIos)
        }
        if let deviceTypeLinux = self.deviceTypeLinux {
            try encodeContainer.encode(deviceTypeLinux, forKey: .deviceTypeLinux)
        }
        if let deviceTypeOsx = self.deviceTypeOsx {
            try encodeContainer.encode(deviceTypeOsx, forKey: .deviceTypeOsx)
        }
        if let deviceTypeWeb = self.deviceTypeWeb {
            try encodeContainer.encode(deviceTypeWeb, forKey: .deviceTypeWeb)
        }
        if let deviceTypeWindows = self.deviceTypeWindows {
            try encodeContainer.encode(deviceTypeWindows, forKey: .deviceTypeWindows)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ImportClientBrandingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportClientBrandingInput: Swift.Equatable {
    /// The branding information to import for Android devices.
    public var deviceTypeAndroid: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The branding information to import for iOS devices.
    public var deviceTypeIos: WorkSpacesClientTypes.IosImportClientBrandingAttributes?
    /// The branding information to import for Linux devices.
    public var deviceTypeLinux: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The branding information to import for macOS devices.
    public var deviceTypeOsx: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The branding information to import for web access.
    public var deviceTypeWeb: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The branding information to import for Windows devices.
    public var deviceTypeWindows: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The directory identifier of the WorkSpace for which you want to import client branding.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        deviceTypeAndroid: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        deviceTypeIos: WorkSpacesClientTypes.IosImportClientBrandingAttributes? = nil,
        deviceTypeLinux: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        deviceTypeOsx: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        deviceTypeWeb: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        deviceTypeWindows: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.deviceTypeAndroid = deviceTypeAndroid
        self.deviceTypeIos = deviceTypeIos
        self.deviceTypeLinux = deviceTypeLinux
        self.deviceTypeOsx = deviceTypeOsx
        self.deviceTypeWeb = deviceTypeWeb
        self.deviceTypeWindows = deviceTypeWindows
        self.resourceId = resourceId
    }
}

struct ImportClientBrandingInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let deviceTypeWindows: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    let deviceTypeOsx: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    let deviceTypeAndroid: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    let deviceTypeIos: WorkSpacesClientTypes.IosImportClientBrandingAttributes?
    let deviceTypeLinux: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    let deviceTypeWeb: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
}

extension ImportClientBrandingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceTypeAndroid = "DeviceTypeAndroid"
        case deviceTypeIos = "DeviceTypeIos"
        case deviceTypeLinux = "DeviceTypeLinux"
        case deviceTypeOsx = "DeviceTypeOsx"
        case deviceTypeWeb = "DeviceTypeWeb"
        case deviceTypeWindows = "DeviceTypeWindows"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let deviceTypeWindowsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.self, forKey: .deviceTypeWindows)
        deviceTypeWindows = deviceTypeWindowsDecoded
        let deviceTypeOsxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.self, forKey: .deviceTypeOsx)
        deviceTypeOsx = deviceTypeOsxDecoded
        let deviceTypeAndroidDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.self, forKey: .deviceTypeAndroid)
        deviceTypeAndroid = deviceTypeAndroidDecoded
        let deviceTypeIosDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.IosImportClientBrandingAttributes.self, forKey: .deviceTypeIos)
        deviceTypeIos = deviceTypeIosDecoded
        let deviceTypeLinuxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.self, forKey: .deviceTypeLinux)
        deviceTypeLinux = deviceTypeLinuxDecoded
        let deviceTypeWebDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.self, forKey: .deviceTypeWeb)
        deviceTypeWeb = deviceTypeWebDecoded
    }
}

extension ImportClientBrandingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportClientBrandingOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceTypeAndroid = output.deviceTypeAndroid
            self.deviceTypeIos = output.deviceTypeIos
            self.deviceTypeLinux = output.deviceTypeLinux
            self.deviceTypeOsx = output.deviceTypeOsx
            self.deviceTypeWeb = output.deviceTypeWeb
            self.deviceTypeWindows = output.deviceTypeWindows
        } else {
            self.deviceTypeAndroid = nil
            self.deviceTypeIos = nil
            self.deviceTypeLinux = nil
            self.deviceTypeOsx = nil
            self.deviceTypeWeb = nil
            self.deviceTypeWindows = nil
        }
    }
}

public struct ImportClientBrandingOutput: Swift.Equatable {
    /// The branding information configured for Android devices.
    public var deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information configured for iOS devices.
    public var deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes?
    /// The branding information configured for Linux devices.
    public var deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information configured for macOS devices.
    public var deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information configured for web access.
    public var deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information configured for Windows devices.
    public var deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes?

    public init(
        deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes? = nil,
        deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil
    )
    {
        self.deviceTypeAndroid = deviceTypeAndroid
        self.deviceTypeIos = deviceTypeIos
        self.deviceTypeLinux = deviceTypeLinux
        self.deviceTypeOsx = deviceTypeOsx
        self.deviceTypeWeb = deviceTypeWeb
        self.deviceTypeWindows = deviceTypeWindows
    }
}

struct ImportClientBrandingOutputBody: Swift.Equatable {
    let deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes?
    let deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
}

extension ImportClientBrandingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceTypeAndroid = "DeviceTypeAndroid"
        case deviceTypeIos = "DeviceTypeIos"
        case deviceTypeLinux = "DeviceTypeLinux"
        case deviceTypeOsx = "DeviceTypeOsx"
        case deviceTypeWeb = "DeviceTypeWeb"
        case deviceTypeWindows = "DeviceTypeWindows"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTypeWindowsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeWindows)
        deviceTypeWindows = deviceTypeWindowsDecoded
        let deviceTypeOsxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeOsx)
        deviceTypeOsx = deviceTypeOsxDecoded
        let deviceTypeAndroidDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeAndroid)
        deviceTypeAndroid = deviceTypeAndroidDecoded
        let deviceTypeIosDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.IosClientBrandingAttributes.self, forKey: .deviceTypeIos)
        deviceTypeIos = deviceTypeIosDecoded
        let deviceTypeLinuxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeLinux)
        deviceTypeLinux = deviceTypeLinuxDecoded
        let deviceTypeWebDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeWeb)
        deviceTypeWeb = deviceTypeWebDecoded
    }
}

enum ImportClientBrandingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case ec2ImageId = "Ec2ImageId"
        case imageDescription = "ImageDescription"
        case imageName = "ImageName"
        case ingestionProcess = "IngestionProcess"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for application0 in applications {
                try applicationsContainer.encode(application0.rawValue)
            }
        }
        if let ec2ImageId = self.ec2ImageId {
            try encodeContainer.encode(ec2ImageId, forKey: .ec2ImageId)
        }
        if let imageDescription = self.imageDescription {
            try encodeContainer.encode(imageDescription, forKey: .imageDescription)
        }
        if let imageName = self.imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let ingestionProcess = self.ingestionProcess {
            try encodeContainer.encode(ingestionProcess.rawValue, forKey: .ingestionProcess)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension ImportWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportWorkspaceImageInput: Swift.Equatable {
    /// If specified, the version of Microsoft Office to subscribe to. Valid only for Windows 10 and 11 BYOL images. For more information about subscribing to Office for BYOL images, see [ Bring Your Own Windows Desktop Licenses](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
    ///
    /// * Although this parameter is an array, only one item is allowed at this time.
    ///
    /// * Windows 11 only supports Microsoft_Office_2019.
    public var applications: [WorkSpacesClientTypes.Application]?
    /// The identifier of the EC2 image.
    /// This member is required.
    public var ec2ImageId: Swift.String?
    /// The description of the WorkSpace image.
    /// This member is required.
    public var imageDescription: Swift.String?
    /// The name of the WorkSpace image.
    /// This member is required.
    public var imageName: Swift.String?
    /// The ingestion process to be used when importing the image, depending on which protocol you want to use for your BYOL Workspace image, either PCoIP, WorkSpaces Streaming Protocol (WSP), or bring your own protocol (BYOP). To use WSP, specify a value that ends in _WSP. To use PCoIP, specify a value that does not end in _WSP. To use BYOP, specify a value that ends in _BYOP. For non-GPU-enabled bundles (bundles other than Graphics or GraphicsPro), specify BYOL_REGULAR, BYOL_REGULAR_WSP, or BYOL_REGULAR_BYOP, depending on the protocol. The BYOL_REGULAR_BYOP and BYOL_GRAPHICS_G4DN_BYOP values are only supported by Amazon WorkSpaces Core. Contact your account team to be allow-listed to use these values. For more information, see [Amazon WorkSpaces Core](http://aws.amazon.com/workspaces/core/).
    /// This member is required.
    public var ingestionProcess: WorkSpacesClientTypes.WorkspaceImageIngestionProcess?
    /// The tags. Each WorkSpaces resource can have a maximum of 50 tags.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init(
        applications: [WorkSpacesClientTypes.Application]? = nil,
        ec2ImageId: Swift.String? = nil,
        imageDescription: Swift.String? = nil,
        imageName: Swift.String? = nil,
        ingestionProcess: WorkSpacesClientTypes.WorkspaceImageIngestionProcess? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.applications = applications
        self.ec2ImageId = ec2ImageId
        self.imageDescription = imageDescription
        self.imageName = imageName
        self.ingestionProcess = ingestionProcess
        self.tags = tags
    }
}

struct ImportWorkspaceImageInputBody: Swift.Equatable {
    let ec2ImageId: Swift.String?
    let ingestionProcess: WorkSpacesClientTypes.WorkspaceImageIngestionProcess?
    let imageName: Swift.String?
    let imageDescription: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
    let applications: [WorkSpacesClientTypes.Application]?
}

extension ImportWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case ec2ImageId = "Ec2ImageId"
        case imageDescription = "ImageDescription"
        case imageName = "ImageName"
        case ingestionProcess = "IngestionProcess"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2ImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2ImageId)
        ec2ImageId = ec2ImageIdDecoded
        let ingestionProcessDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageIngestionProcess.self, forKey: .ingestionProcess)
        ingestionProcess = ingestionProcessDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDescription)
        imageDescription = imageDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let applicationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[WorkSpacesClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [WorkSpacesClientTypes.Application]()
            for enum0 in applicationsContainer {
                if let enum0 = enum0 {
                    applicationsDecoded0?.append(enum0)
                }
            }
        }
        applications = applicationsDecoded0
    }
}

extension ImportWorkspaceImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportWorkspaceImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
        } else {
            self.imageId = nil
        }
    }
}

public struct ImportWorkspaceImageOutput: Swift.Equatable {
    /// The identifier of the WorkSpace image.
    public var imageId: Swift.String?

    public init(
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct ImportWorkspaceImageOutputBody: Swift.Equatable {
    let imageId: Swift.String?
}

extension ImportWorkspaceImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

enum ImportWorkspaceImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IncompatibleApplicationsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified application is not compatible with the resource.
public struct IncompatibleApplicationsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "IncompatibleApplicationsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension InvalidParameterValuesException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterValuesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more parameter values are not valid.
public struct InvalidParameterValuesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValuesException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterValuesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterValuesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The state of the resource is not valid for this operation.
public struct InvalidResourceStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidResourceStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesClientTypes.IosClientBrandingAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPasswordLink = "ForgotPasswordLink"
        case loginMessage = "LoginMessage"
        case logo2xUrl = "Logo2xUrl"
        case logo3xUrl = "Logo3xUrl"
        case logoUrl = "LogoUrl"
        case supportEmail = "SupportEmail"
        case supportLink = "SupportLink"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPasswordLink = self.forgotPasswordLink {
            try encodeContainer.encode(forgotPasswordLink, forKey: .forgotPasswordLink)
        }
        if let loginMessage = loginMessage {
            var loginMessageContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .loginMessage)
            for (dictKey0, loginMessage0) in loginMessage {
                try loginMessageContainer.encode(loginMessage0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let logo2xUrl = self.logo2xUrl {
            try encodeContainer.encode(logo2xUrl, forKey: .logo2xUrl)
        }
        if let logo3xUrl = self.logo3xUrl {
            try encodeContainer.encode(logo3xUrl, forKey: .logo3xUrl)
        }
        if let logoUrl = self.logoUrl {
            try encodeContainer.encode(logoUrl, forKey: .logoUrl)
        }
        if let supportEmail = self.supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportLink = self.supportLink {
            try encodeContainer.encode(supportLink, forKey: .supportLink)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logoUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logoUrl)
        logoUrl = logoUrlDecoded
        let logo2xUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logo2xUrl)
        logo2xUrl = logo2xUrlDecoded
        let logo3xUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logo3xUrl)
        logo3xUrl = logo3xUrlDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportLink)
        supportLink = supportLinkDecoded
        let forgotPasswordLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forgotPasswordLink)
        forgotPasswordLink = forgotPasswordLinkDecoded
        let loginMessageContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .loginMessage)
        var loginMessageDecoded0: [Swift.String:Swift.String]? = nil
        if let loginMessageContainer = loginMessageContainer {
            loginMessageDecoded0 = [Swift.String:Swift.String]()
            for (key0, clientloginmessage0) in loginMessageContainer {
                if let clientloginmessage0 = clientloginmessage0 {
                    loginMessageDecoded0?[key0] = clientloginmessage0
                }
            }
        }
        loginMessage = loginMessageDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// The client branding attributes for iOS device types. These attributes are displayed on the iOS client login screen only. Client branding attributes are public facing. Ensure you do not include sensitive information.
    public struct IosClientBrandingAttributes: Swift.Equatable {
        /// The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.
        public var forgotPasswordLink: Swift.String?
        /// The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is en_US. The HTML tags supported include the following: a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul.
        public var loginMessage: [Swift.String:Swift.String]?
        /// The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a .png file. For more information about iOS image size and resolution, see [Image Size and Resolution ](https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/) in the Apple Human Interface Guidelines.
        public var logo2xUrl: Swift.String?
        /// The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x).The only image format accepted is a binary data object that is converted from a .png file. For more information about iOS image size and resolution, see [Image Size and Resolution ](https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/) in the Apple Human Interface Guidelines.
        public var logo3xUrl: Swift.String?
        /// The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a .png file.
        public var logoUrl: Swift.String?
        /// The support email. The company's customer support email address.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default email is workspaces-feedback@amazon.com.
        public var supportEmail: Swift.String?
        /// The support link. The link for the company's customer support page for their WorkSpace.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default support link is workspaces-feedback@amazon.com.
        public var supportLink: Swift.String?

        public init(
            forgotPasswordLink: Swift.String? = nil,
            loginMessage: [Swift.String:Swift.String]? = nil,
            logo2xUrl: Swift.String? = nil,
            logo3xUrl: Swift.String? = nil,
            logoUrl: Swift.String? = nil,
            supportEmail: Swift.String? = nil,
            supportLink: Swift.String? = nil
        )
        {
            self.forgotPasswordLink = forgotPasswordLink
            self.loginMessage = loginMessage
            self.logo2xUrl = logo2xUrl
            self.logo3xUrl = logo3xUrl
            self.logoUrl = logoUrl
            self.supportEmail = supportEmail
            self.supportLink = supportLink
        }
    }

}

extension WorkSpacesClientTypes.IosImportClientBrandingAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPasswordLink = "ForgotPasswordLink"
        case loginMessage = "LoginMessage"
        case logo = "Logo"
        case logo2x = "Logo2x"
        case logo3x = "Logo3x"
        case supportEmail = "SupportEmail"
        case supportLink = "SupportLink"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPasswordLink = self.forgotPasswordLink {
            try encodeContainer.encode(forgotPasswordLink, forKey: .forgotPasswordLink)
        }
        if let loginMessage = loginMessage {
            var loginMessageContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .loginMessage)
            for (dictKey0, loginMessage0) in loginMessage {
                try loginMessageContainer.encode(loginMessage0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let logo = self.logo {
            try encodeContainer.encode(logo.base64EncodedString(), forKey: .logo)
        }
        if let logo2x = self.logo2x {
            try encodeContainer.encode(logo2x.base64EncodedString(), forKey: .logo2x)
        }
        if let logo3x = self.logo3x {
            try encodeContainer.encode(logo3x.base64EncodedString(), forKey: .logo3x)
        }
        if let supportEmail = self.supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportLink = self.supportLink {
            try encodeContainer.encode(supportLink, forKey: .supportLink)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logoDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .logo)
        logo = logoDecoded
        let logo2xDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .logo2x)
        logo2x = logo2xDecoded
        let logo3xDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .logo3x)
        logo3x = logo3xDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportLink)
        supportLink = supportLinkDecoded
        let forgotPasswordLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forgotPasswordLink)
        forgotPasswordLink = forgotPasswordLinkDecoded
        let loginMessageContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .loginMessage)
        var loginMessageDecoded0: [Swift.String:Swift.String]? = nil
        if let loginMessageContainer = loginMessageContainer {
            loginMessageDecoded0 = [Swift.String:Swift.String]()
            for (key0, clientloginmessage0) in loginMessageContainer {
                if let clientloginmessage0 = clientloginmessage0 {
                    loginMessageDecoded0?[key0] = clientloginmessage0
                }
            }
        }
        loginMessage = loginMessageDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// The client branding attributes to import for iOS device types. These attributes are displayed on the iOS client login screen. Client branding attributes are public facing. Ensure you do not include sensitive information.
    public struct IosImportClientBrandingAttributes: Swift.Equatable {
        /// The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.
        public var forgotPasswordLink: Swift.String?
        /// The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is en_US. The HTML tags supported include the following: a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul.
        public var loginMessage: [Swift.String:Swift.String]?
        /// The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a .png file.
        public var logo: ClientRuntime.Data?
        /// The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a .png file. For more information about iOS image size and resolution, see [Image Size and Resolution ](https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/) in the Apple Human Interface Guidelines.
        public var logo2x: ClientRuntime.Data?
        /// The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x). The only image format accepted is a binary data object that is converted from a .png file. For more information about iOS image size and resolution, see [Image Size and Resolution ](https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/) in the Apple Human Interface Guidelines.
        public var logo3x: ClientRuntime.Data?
        /// The support email. The company's customer support email address.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default email is workspaces-feedback@amazon.com.
        public var supportEmail: Swift.String?
        /// The support link. The link for the company's customer support page for their WorkSpace.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default support link is workspaces-feedback@amazon.com.
        public var supportLink: Swift.String?

        public init(
            forgotPasswordLink: Swift.String? = nil,
            loginMessage: [Swift.String:Swift.String]? = nil,
            logo: ClientRuntime.Data? = nil,
            logo2x: ClientRuntime.Data? = nil,
            logo3x: ClientRuntime.Data? = nil,
            supportEmail: Swift.String? = nil,
            supportLink: Swift.String? = nil
        )
        {
            self.forgotPasswordLink = forgotPasswordLink
            self.loginMessage = loginMessage
            self.logo = logo
            self.logo2x = logo2x
            self.logo3x = logo3x
            self.supportEmail = supportEmail
            self.supportLink = supportLink
        }
    }

}

extension WorkSpacesClientTypes.IpRuleItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipRule
        case ruleDesc
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipRule = self.ipRule {
            try encodeContainer.encode(ipRule, forKey: .ipRule)
        }
        if let ruleDesc = self.ruleDesc {
            try encodeContainer.encode(ruleDesc, forKey: .ruleDesc)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipRuleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipRule)
        ipRule = ipRuleDecoded
        let ruleDescDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleDesc)
        ruleDesc = ruleDescDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a rule for an IP access control group.
    public struct IpRuleItem: Swift.Equatable {
        /// The IP address range, in CIDR notation.
        public var ipRule: Swift.String?
        /// The description.
        public var ruleDesc: Swift.String?

        public init(
            ipRule: Swift.String? = nil,
            ruleDesc: Swift.String? = nil
        )
        {
            self.ipRule = ipRule
            self.ruleDesc = ruleDesc
        }
    }

}

extension ListAvailableManagementCidrRangesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managementCidrRangeConstraint = "ManagementCidrRangeConstraint"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let managementCidrRangeConstraint = self.managementCidrRangeConstraint {
            try encodeContainer.encode(managementCidrRangeConstraint, forKey: .managementCidrRangeConstraint)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAvailableManagementCidrRangesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAvailableManagementCidrRangesInput: Swift.Equatable {
    /// The IP address range to search. Specify an IP address range that is compatible with your network and in CIDR notation (that is, specify the range as an IPv4 CIDR block).
    /// This member is required.
    public var managementCidrRangeConstraint: Swift.String?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init(
        managementCidrRangeConstraint: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.managementCidrRangeConstraint = managementCidrRangeConstraint
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAvailableManagementCidrRangesInputBody: Swift.Equatable {
    let managementCidrRangeConstraint: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAvailableManagementCidrRangesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managementCidrRangeConstraint = "ManagementCidrRangeConstraint"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managementCidrRangeConstraintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managementCidrRangeConstraint)
        managementCidrRangeConstraint = managementCidrRangeConstraintDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAvailableManagementCidrRangesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAvailableManagementCidrRangesOutputBody = try responseDecoder.decode(responseBody: data)
            self.managementCidrRanges = output.managementCidrRanges
            self.nextToken = output.nextToken
        } else {
            self.managementCidrRanges = nil
            self.nextToken = nil
        }
    }
}

public struct ListAvailableManagementCidrRangesOutput: Swift.Equatable {
    /// The list of available IP address ranges, specified as IPv4 CIDR blocks.
    public var managementCidrRanges: [Swift.String]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        managementCidrRanges: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.managementCidrRanges = managementCidrRanges
        self.nextToken = nextToken
    }
}

struct ListAvailableManagementCidrRangesOutputBody: Swift.Equatable {
    let managementCidrRanges: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAvailableManagementCidrRangesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managementCidrRanges = "ManagementCidrRanges"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managementCidrRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managementCidrRanges)
        var managementCidrRangesDecoded0:[Swift.String]? = nil
        if let managementCidrRangesContainer = managementCidrRangesContainer {
            managementCidrRangesDecoded0 = [Swift.String]()
            for string0 in managementCidrRangesContainer {
                if let string0 = string0 {
                    managementCidrRangesDecoded0?.append(string0)
                }
            }
        }
        managementCidrRanges = managementCidrRangesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAvailableManagementCidrRangesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum LogUploadEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LogUploadEnum] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogUploadEnum(rawValue: rawValue) ?? LogUploadEnum.sdkUnknown(rawValue)
        }
    }
}

extension MigrateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case sourceWorkspaceId = "SourceWorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let sourceWorkspaceId = self.sourceWorkspaceId {
            try encodeContainer.encode(sourceWorkspaceId, forKey: .sourceWorkspaceId)
        }
    }
}

extension MigrateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MigrateWorkspaceInput: Swift.Equatable {
    /// The identifier of the target bundle type to migrate the WorkSpace to.
    /// This member is required.
    public var bundleId: Swift.String?
    /// The identifier of the WorkSpace to migrate from.
    /// This member is required.
    public var sourceWorkspaceId: Swift.String?

    public init(
        bundleId: Swift.String? = nil,
        sourceWorkspaceId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
        self.sourceWorkspaceId = sourceWorkspaceId
    }
}

struct MigrateWorkspaceInputBody: Swift.Equatable {
    let sourceWorkspaceId: Swift.String?
    let bundleId: Swift.String?
}

extension MigrateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case sourceWorkspaceId = "SourceWorkspaceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceWorkspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceWorkspaceId)
        sourceWorkspaceId = sourceWorkspaceIdDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
    }
}

extension MigrateWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MigrateWorkspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceWorkspaceId = output.sourceWorkspaceId
            self.targetWorkspaceId = output.targetWorkspaceId
        } else {
            self.sourceWorkspaceId = nil
            self.targetWorkspaceId = nil
        }
    }
}

public struct MigrateWorkspaceOutput: Swift.Equatable {
    /// The original identifier of the WorkSpace that is being migrated.
    public var sourceWorkspaceId: Swift.String?
    /// The new identifier of the WorkSpace that is being migrated. If the migration does not succeed, the target WorkSpace ID will not be used, and the WorkSpace will still have the original WorkSpace ID.
    public var targetWorkspaceId: Swift.String?

    public init(
        sourceWorkspaceId: Swift.String? = nil,
        targetWorkspaceId: Swift.String? = nil
    )
    {
        self.sourceWorkspaceId = sourceWorkspaceId
        self.targetWorkspaceId = targetWorkspaceId
    }
}

struct MigrateWorkspaceOutputBody: Swift.Equatable {
    let sourceWorkspaceId: Swift.String?
    let targetWorkspaceId: Swift.String?
}

extension MigrateWorkspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceWorkspaceId = "SourceWorkspaceId"
        case targetWorkspaceId = "TargetWorkspaceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceWorkspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceWorkspaceId)
        sourceWorkspaceId = sourceWorkspaceIdDecoded
        let targetWorkspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetWorkspaceId)
        targetWorkspaceId = targetWorkspaceIdDecoded
    }
}

enum MigrateWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationInProgressException": return try await OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum ModificationResourceEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case computeType
        case rootVolume
        case userVolume
        case sdkUnknown(Swift.String)

        public static var allCases: [ModificationResourceEnum] {
            return [
                .computeType,
                .rootVolume,
                .userVolume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .computeType: return "COMPUTE_TYPE"
            case .rootVolume: return "ROOT_VOLUME"
            case .userVolume: return "USER_VOLUME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModificationResourceEnum(rawValue: rawValue) ?? ModificationResourceEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.ModificationState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource.rawValue, forKey: .resource)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ModificationResourceEnum.self, forKey: .resource)
        resource = resourceDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ModificationStateEnum.self, forKey: .state)
        state = stateDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace modification.
    public struct ModificationState: Swift.Equatable {
        /// The resource.
        public var resource: WorkSpacesClientTypes.ModificationResourceEnum?
        /// The modification state.
        public var state: WorkSpacesClientTypes.ModificationStateEnum?

        public init(
            resource: WorkSpacesClientTypes.ModificationResourceEnum? = nil,
            state: WorkSpacesClientTypes.ModificationStateEnum? = nil
        )
        {
            self.resource = resource
            self.state = state
        }
    }

}

extension WorkSpacesClientTypes {
    public enum ModificationStateEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case updateInitiated
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ModificationStateEnum] {
            return [
                .updateInitiated,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .updateInitiated: return "UPDATE_INITIATED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModificationStateEnum(rawValue: rawValue) ?? ModificationStateEnum.sdkUnknown(rawValue)
        }
    }
}

extension ModifyAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dedicatedTenancyManagementCidrRange = self.dedicatedTenancyManagementCidrRange {
            try encodeContainer.encode(dedicatedTenancyManagementCidrRange, forKey: .dedicatedTenancyManagementCidrRange)
        }
        if let dedicatedTenancySupport = self.dedicatedTenancySupport {
            try encodeContainer.encode(dedicatedTenancySupport.rawValue, forKey: .dedicatedTenancySupport)
        }
    }
}

extension ModifyAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyAccountInput: Swift.Equatable {
    /// The IP address range, specified as an IPv4 CIDR block, for the management network interface. Specify an IP address range that is compatible with your network and in CIDR notation (that is, specify the range as an IPv4 CIDR block). The CIDR block size must be /16 (for example, 203.0.113.25/16). It must also be specified as available by the ListAvailableManagementCidrRanges operation.
    public var dedicatedTenancyManagementCidrRange: Swift.String?
    /// The status of BYOL.
    public var dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportEnum?

    public init(
        dedicatedTenancyManagementCidrRange: Swift.String? = nil,
        dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportEnum? = nil
    )
    {
        self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
        self.dedicatedTenancySupport = dedicatedTenancySupport
    }
}

struct ModifyAccountInputBody: Swift.Equatable {
    let dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportEnum?
    let dedicatedTenancyManagementCidrRange: Swift.String?
}

extension ModifyAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedTenancySupportDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DedicatedTenancySupportEnum.self, forKey: .dedicatedTenancySupport)
        dedicatedTenancySupport = dedicatedTenancySupportDecoded
        let dedicatedTenancyManagementCidrRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedTenancyManagementCidrRange)
        dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRangeDecoded
    }
}

extension ModifyAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ModifyAccountOutput: Swift.Equatable {

    public init() { }
}

enum ModifyAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyCertificateBasedAuthPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBasedAuthProperties = "CertificateBasedAuthProperties"
        case propertiesToDelete = "PropertiesToDelete"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateBasedAuthProperties = self.certificateBasedAuthProperties {
            try encodeContainer.encode(certificateBasedAuthProperties, forKey: .certificateBasedAuthProperties)
        }
        if let propertiesToDelete = propertiesToDelete {
            var propertiesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertiesToDelete)
            for deletablecertificatebasedauthproperty0 in propertiesToDelete {
                try propertiesToDeleteContainer.encode(deletablecertificatebasedauthproperty0.rawValue)
            }
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ModifyCertificateBasedAuthPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyCertificateBasedAuthPropertiesInput: Swift.Equatable {
    /// The properties of the certificate-based authentication.
    public var certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties?
    /// The properties of the certificate-based authentication you want to delete.
    public var propertiesToDelete: [WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty]?
    /// The resource identifiers, in the form of directory IDs.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties? = nil,
        propertiesToDelete: [WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.certificateBasedAuthProperties = certificateBasedAuthProperties
        self.propertiesToDelete = propertiesToDelete
        self.resourceId = resourceId
    }
}

struct ModifyCertificateBasedAuthPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties?
    let propertiesToDelete: [WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty]?
}

extension ModifyCertificateBasedAuthPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBasedAuthProperties = "CertificateBasedAuthProperties"
        case propertiesToDelete = "PropertiesToDelete"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let certificateBasedAuthPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.CertificateBasedAuthProperties.self, forKey: .certificateBasedAuthProperties)
        certificateBasedAuthProperties = certificateBasedAuthPropertiesDecoded
        let propertiesToDeleteContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty?].self, forKey: .propertiesToDelete)
        var propertiesToDeleteDecoded0:[WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty]? = nil
        if let propertiesToDeleteContainer = propertiesToDeleteContainer {
            propertiesToDeleteDecoded0 = [WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty]()
            for enum0 in propertiesToDeleteContainer {
                if let enum0 = enum0 {
                    propertiesToDeleteDecoded0?.append(enum0)
                }
            }
        }
        propertiesToDelete = propertiesToDeleteDecoded0
    }
}

extension ModifyCertificateBasedAuthPropertiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ModifyCertificateBasedAuthPropertiesOutput: Swift.Equatable {

    public init() { }
}

enum ModifyCertificateBasedAuthPropertiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyClientPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientProperties = "ClientProperties"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientProperties = self.clientProperties {
            try encodeContainer.encode(clientProperties, forKey: .clientProperties)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ModifyClientPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyClientPropertiesInput: Swift.Equatable {
    /// Information about the Amazon WorkSpaces client.
    /// This member is required.
    public var clientProperties: WorkSpacesClientTypes.ClientProperties?
    /// The resource identifiers, in the form of directory IDs.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        clientProperties: WorkSpacesClientTypes.ClientProperties? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.clientProperties = clientProperties
        self.resourceId = resourceId
    }
}

struct ModifyClientPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let clientProperties: WorkSpacesClientTypes.ClientProperties?
}

extension ModifyClientPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientProperties = "ClientProperties"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let clientPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ClientProperties.self, forKey: .clientProperties)
        clientProperties = clientPropertiesDecoded
    }
}

extension ModifyClientPropertiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ModifyClientPropertiesOutput: Swift.Equatable {

    public init() { }
}

enum ModifyClientPropertiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifySamlPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertiesToDelete = "PropertiesToDelete"
        case resourceId = "ResourceId"
        case samlProperties = "SamlProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertiesToDelete = propertiesToDelete {
            var propertiesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertiesToDelete)
            for deletablesamlproperty0 in propertiesToDelete {
                try propertiesToDeleteContainer.encode(deletablesamlproperty0.rawValue)
            }
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let samlProperties = self.samlProperties {
            try encodeContainer.encode(samlProperties, forKey: .samlProperties)
        }
    }
}

extension ModifySamlPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifySamlPropertiesInput: Swift.Equatable {
    /// The SAML properties to delete as part of your request. Specify one of the following options:
    ///
    /// * SAML_PROPERTIES_USER_ACCESS_URL to delete the user access URL.
    ///
    /// * SAML_PROPERTIES_RELAY_STATE_PARAMETER_NAME to delete the relay state parameter name.
    public var propertiesToDelete: [WorkSpacesClientTypes.DeletableSamlProperty]?
    /// The directory identifier for which you want to configure SAML properties.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The properties for configuring SAML 2.0 authentication.
    public var samlProperties: WorkSpacesClientTypes.SamlProperties?

    public init(
        propertiesToDelete: [WorkSpacesClientTypes.DeletableSamlProperty]? = nil,
        resourceId: Swift.String? = nil,
        samlProperties: WorkSpacesClientTypes.SamlProperties? = nil
    )
    {
        self.propertiesToDelete = propertiesToDelete
        self.resourceId = resourceId
        self.samlProperties = samlProperties
    }
}

struct ModifySamlPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let samlProperties: WorkSpacesClientTypes.SamlProperties?
    let propertiesToDelete: [WorkSpacesClientTypes.DeletableSamlProperty]?
}

extension ModifySamlPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertiesToDelete = "PropertiesToDelete"
        case resourceId = "ResourceId"
        case samlProperties = "SamlProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let samlPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.SamlProperties.self, forKey: .samlProperties)
        samlProperties = samlPropertiesDecoded
        let propertiesToDeleteContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.DeletableSamlProperty?].self, forKey: .propertiesToDelete)
        var propertiesToDeleteDecoded0:[WorkSpacesClientTypes.DeletableSamlProperty]? = nil
        if let propertiesToDeleteContainer = propertiesToDeleteContainer {
            propertiesToDeleteDecoded0 = [WorkSpacesClientTypes.DeletableSamlProperty]()
            for enum0 in propertiesToDeleteContainer {
                if let enum0 = enum0 {
                    propertiesToDeleteDecoded0?.append(enum0)
                }
            }
        }
        propertiesToDelete = propertiesToDeleteDecoded0
    }
}

extension ModifySamlPropertiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ModifySamlPropertiesOutput: Swift.Equatable {

    public init() { }
}

enum ModifySamlPropertiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifySelfservicePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case selfservicePermissions = "SelfservicePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let selfservicePermissions = self.selfservicePermissions {
            try encodeContainer.encode(selfservicePermissions, forKey: .selfservicePermissions)
        }
    }
}

extension ModifySelfservicePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifySelfservicePermissionsInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The permissions to enable or disable self-service capabilities.
    /// This member is required.
    public var selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions?

    public init(
        resourceId: Swift.String? = nil,
        selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions? = nil
    )
    {
        self.resourceId = resourceId
        self.selfservicePermissions = selfservicePermissions
    }
}

struct ModifySelfservicePermissionsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions?
}

extension ModifySelfservicePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case selfservicePermissions = "SelfservicePermissions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let selfservicePermissionsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.SelfservicePermissions.self, forKey: .selfservicePermissions)
        selfservicePermissions = selfservicePermissionsDecoded
    }
}

extension ModifySelfservicePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ModifySelfservicePermissionsOutput: Swift.Equatable {

    public init() { }
}

enum ModifySelfservicePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyWorkspaceAccessPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case workspaceAccessProperties = "WorkspaceAccessProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let workspaceAccessProperties = self.workspaceAccessProperties {
            try encodeContainer.encode(workspaceAccessProperties, forKey: .workspaceAccessProperties)
        }
    }
}

extension ModifyWorkspaceAccessPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyWorkspaceAccessPropertiesInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The device types and operating systems to enable or disable for access.
    /// This member is required.
    public var workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties?

    public init(
        resourceId: Swift.String? = nil,
        workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties? = nil
    )
    {
        self.resourceId = resourceId
        self.workspaceAccessProperties = workspaceAccessProperties
    }
}

struct ModifyWorkspaceAccessPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties?
}

extension ModifyWorkspaceAccessPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case workspaceAccessProperties = "WorkspaceAccessProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let workspaceAccessPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceAccessProperties.self, forKey: .workspaceAccessProperties)
        workspaceAccessProperties = workspaceAccessPropertiesDecoded
    }
}

extension ModifyWorkspaceAccessPropertiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ModifyWorkspaceAccessPropertiesOutput: Swift.Equatable {

    public init() { }
}

enum ModifyWorkspaceAccessPropertiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyWorkspaceCreationPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case workspaceCreationProperties = "WorkspaceCreationProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let workspaceCreationProperties = self.workspaceCreationProperties {
            try encodeContainer.encode(workspaceCreationProperties, forKey: .workspaceCreationProperties)
        }
    }
}

extension ModifyWorkspaceCreationPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyWorkspaceCreationPropertiesInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The default properties for creating WorkSpaces.
    /// This member is required.
    public var workspaceCreationProperties: WorkSpacesClientTypes.WorkspaceCreationProperties?

    public init(
        resourceId: Swift.String? = nil,
        workspaceCreationProperties: WorkSpacesClientTypes.WorkspaceCreationProperties? = nil
    )
    {
        self.resourceId = resourceId
        self.workspaceCreationProperties = workspaceCreationProperties
    }
}

struct ModifyWorkspaceCreationPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let workspaceCreationProperties: WorkSpacesClientTypes.WorkspaceCreationProperties?
}

extension ModifyWorkspaceCreationPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case workspaceCreationProperties = "WorkspaceCreationProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let workspaceCreationPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceCreationProperties.self, forKey: .workspaceCreationProperties)
        workspaceCreationProperties = workspaceCreationPropertiesDecoded
    }
}

extension ModifyWorkspaceCreationPropertiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ModifyWorkspaceCreationPropertiesOutput: Swift.Equatable {

    public init() { }
}

enum ModifyWorkspaceCreationPropertiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyWorkspacePropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplication = "DataReplication"
        case workspaceId = "WorkspaceId"
        case workspaceProperties = "WorkspaceProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplication = self.dataReplication {
            try encodeContainer.encode(dataReplication.rawValue, forKey: .dataReplication)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
        if let workspaceProperties = self.workspaceProperties {
            try encodeContainer.encode(workspaceProperties, forKey: .workspaceProperties)
        }
    }
}

extension ModifyWorkspacePropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyWorkspacePropertiesInput: Swift.Equatable {
    /// Indicates the data replication status.
    public var dataReplication: WorkSpacesClientTypes.DataReplication?
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?
    /// The properties of the WorkSpace.
    public var workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?

    public init(
        dataReplication: WorkSpacesClientTypes.DataReplication? = nil,
        workspaceId: Swift.String? = nil,
        workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties? = nil
    )
    {
        self.dataReplication = dataReplication
        self.workspaceId = workspaceId
        self.workspaceProperties = workspaceProperties
    }
}

struct ModifyWorkspacePropertiesInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?
    let dataReplication: WorkSpacesClientTypes.DataReplication?
}

extension ModifyWorkspacePropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplication = "DataReplication"
        case workspaceId = "WorkspaceId"
        case workspaceProperties = "WorkspaceProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let workspacePropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceProperties.self, forKey: .workspaceProperties)
        workspaceProperties = workspacePropertiesDecoded
        let dataReplicationDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DataReplication.self, forKey: .dataReplication)
        dataReplication = dataReplicationDecoded
    }
}

extension ModifyWorkspacePropertiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ModifyWorkspacePropertiesOutput: Swift.Equatable {

    public init() { }
}

enum ModifyWorkspacePropertiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationInProgressException": return try await OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedWorkspaceConfigurationException": return try await UnsupportedWorkspaceConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyWorkspaceStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceState = "WorkspaceState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
        if let workspaceState = self.workspaceState {
            try encodeContainer.encode(workspaceState.rawValue, forKey: .workspaceState)
        }
    }
}

extension ModifyWorkspaceStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyWorkspaceStateInput: Swift.Equatable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?
    /// The WorkSpace state.
    /// This member is required.
    public var workspaceState: WorkSpacesClientTypes.TargetWorkspaceState?

    public init(
        workspaceId: Swift.String? = nil,
        workspaceState: WorkSpacesClientTypes.TargetWorkspaceState? = nil
    )
    {
        self.workspaceId = workspaceId
        self.workspaceState = workspaceState
    }
}

struct ModifyWorkspaceStateInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let workspaceState: WorkSpacesClientTypes.TargetWorkspaceState?
}

extension ModifyWorkspaceStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceState = "WorkspaceState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let workspaceStateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.TargetWorkspaceState.self, forKey: .workspaceState)
        workspaceState = workspaceStateDecoded
    }
}

extension ModifyWorkspaceStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ModifyWorkspaceStateOutput: Swift.Equatable {

    public init() { }
}

enum ModifyWorkspaceStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes.OperatingSystem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.OperatingSystemType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// The operating system that the image is running.
    public struct OperatingSystem: Swift.Equatable {
        /// The operating system.
        public var type: WorkSpacesClientTypes.OperatingSystemType?

        public init(
            type: WorkSpacesClientTypes.OperatingSystemType? = nil
        )
        {
            self.type = type
        }
    }

}

extension WorkSpacesClientTypes {
    public enum OperatingSystemName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonLinux2
        case ubuntu1804
        case ubuntu2004
        case ubuntu2204
        case unknown
        case windows10
        case windows11
        case windows7
        case windowsServer2016
        case windowsServer2019
        case windowsServer2022
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatingSystemName] {
            return [
                .amazonLinux2,
                .ubuntu1804,
                .ubuntu2004,
                .ubuntu2204,
                .unknown,
                .windows10,
                .windows11,
                .windows7,
                .windowsServer2016,
                .windowsServer2019,
                .windowsServer2022,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonLinux2: return "AMAZON_LINUX_2"
            case .ubuntu1804: return "UBUNTU_18_04"
            case .ubuntu2004: return "UBUNTU_20_04"
            case .ubuntu2204: return "UBUNTU_22_04"
            case .unknown: return "UNKNOWN"
            case .windows10: return "WINDOWS_10"
            case .windows11: return "WINDOWS_11"
            case .windows7: return "WINDOWS_7"
            case .windowsServer2016: return "WINDOWS_SERVER_2016"
            case .windowsServer2019: return "WINDOWS_SERVER_2019"
            case .windowsServer2022: return "WINDOWS_SERVER_2022"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperatingSystemName(rawValue: rawValue) ?? OperatingSystemName.sdkUnknown(rawValue)
        }
    }
}

extension OperatingSystemNotCompatibleException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operating system of the WorkSpace is not compatible with the application.
public struct OperatingSystemNotCompatibleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "OperatingSystemNotCompatibleException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension WorkSpacesClientTypes {
    public enum OperatingSystemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatingSystemType] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperatingSystemType(rawValue: rawValue) ?? OperatingSystemType.sdkUnknown(rawValue)
        }
    }
}

extension OperationInProgressException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OperationInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The properties of this WorkSpace are currently being modified. Try again in a moment.
public struct OperationInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationInProgressException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OperationInProgressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotSupportedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OperationNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This operation is not supported.
public struct OperationNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception error message.
        public internal(set) var message: Swift.String? = nil
        /// The exception error reason.
        public internal(set) var reason: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotSupportedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct OperationNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Swift.String?
}

extension OperationNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case state = "State"
        case userName = "UserName"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceState.self, forKey: .state)
        state = stateDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Information about the standby WorkSpace.
    public struct PendingCreateStandbyWorkspacesRequest: Swift.Equatable {
        /// The identifier of the directory for the standby WorkSpace.
        public var directoryId: Swift.String?
        /// The operational state of the standby WorkSpace.
        public var state: WorkSpacesClientTypes.WorkspaceState?
        /// Describes the standby WorkSpace that was created. Because this operation is asynchronous, the identifier returned is not immediately available for use with other operations. For example, if you call [ DescribeWorkspaces](https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html) before the WorkSpace is created, the information returned can be incomplete.
        public var userName: Swift.String?
        /// The identifier of the standby WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            directoryId: Swift.String? = nil,
            state: WorkSpacesClientTypes.WorkspaceState? = nil,
            userName: Swift.String? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
            self.state = state
            self.userName = userName
            self.workspaceId = workspaceId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pcoip
        case wsp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .pcoip,
                .wsp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pcoip: return "PCOIP"
            case .wsp: return "WSP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.RebootRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to reboot a WorkSpace.
    public struct RebootRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init(
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension RebootWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebootWorkspaceRequests = "RebootWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rebootWorkspaceRequests = rebootWorkspaceRequests {
            var rebootWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rebootWorkspaceRequests)
            for rebootrequest0 in rebootWorkspaceRequests {
                try rebootWorkspaceRequestsContainer.encode(rebootrequest0)
            }
        }
    }
}

extension RebootWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RebootWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to reboot. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var rebootWorkspaceRequests: [WorkSpacesClientTypes.RebootRequest]?

    public init(
        rebootWorkspaceRequests: [WorkSpacesClientTypes.RebootRequest]? = nil
    )
    {
        self.rebootWorkspaceRequests = rebootWorkspaceRequests
    }
}

struct RebootWorkspacesInputBody: Swift.Equatable {
    let rebootWorkspaceRequests: [WorkSpacesClientTypes.RebootRequest]?
}

extension RebootWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebootWorkspaceRequests = "RebootWorkspaceRequests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rebootWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.RebootRequest?].self, forKey: .rebootWorkspaceRequests)
        var rebootWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.RebootRequest]? = nil
        if let rebootWorkspaceRequestsContainer = rebootWorkspaceRequestsContainer {
            rebootWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.RebootRequest]()
            for structure0 in rebootWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    rebootWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        rebootWorkspaceRequests = rebootWorkspaceRequestsDecoded0
    }
}

extension RebootWorkspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RebootWorkspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct RebootWorkspacesOutput: Swift.Equatable {
    /// Information about the WorkSpaces that could not be rebooted.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init(
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct RebootWorkspacesOutputBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension RebootWorkspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

enum RebootWorkspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes.RebuildRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to rebuild a WorkSpace.
    public struct RebuildRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init(
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension RebuildWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebuildWorkspaceRequests = "RebuildWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rebuildWorkspaceRequests = rebuildWorkspaceRequests {
            var rebuildWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rebuildWorkspaceRequests)
            for rebuildrequest0 in rebuildWorkspaceRequests {
                try rebuildWorkspaceRequestsContainer.encode(rebuildrequest0)
            }
        }
    }
}

extension RebuildWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RebuildWorkspacesInput: Swift.Equatable {
    /// The WorkSpace to rebuild. You can specify a single WorkSpace.
    /// This member is required.
    public var rebuildWorkspaceRequests: [WorkSpacesClientTypes.RebuildRequest]?

    public init(
        rebuildWorkspaceRequests: [WorkSpacesClientTypes.RebuildRequest]? = nil
    )
    {
        self.rebuildWorkspaceRequests = rebuildWorkspaceRequests
    }
}

struct RebuildWorkspacesInputBody: Swift.Equatable {
    let rebuildWorkspaceRequests: [WorkSpacesClientTypes.RebuildRequest]?
}

extension RebuildWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebuildWorkspaceRequests = "RebuildWorkspaceRequests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rebuildWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.RebuildRequest?].self, forKey: .rebuildWorkspaceRequests)
        var rebuildWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.RebuildRequest]? = nil
        if let rebuildWorkspaceRequestsContainer = rebuildWorkspaceRequestsContainer {
            rebuildWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.RebuildRequest]()
            for structure0 in rebuildWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    rebuildWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        rebuildWorkspaceRequests = rebuildWorkspaceRequestsDecoded0
    }
}

extension RebuildWorkspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RebuildWorkspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct RebuildWorkspacesOutput: Swift.Equatable {
    /// Information about the WorkSpace that could not be rebuilt.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init(
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct RebuildWorkspacesOutputBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension RebuildWorkspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

enum RebuildWorkspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum ReconnectEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReconnectEnum] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReconnectEnum(rawValue: rawValue) ?? ReconnectEnum.sdkUnknown(rawValue)
        }
    }
}

extension RegisterWorkspaceDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case enableSelfService = "EnableSelfService"
        case enableWorkDocs = "EnableWorkDocs"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case tenancy = "Tenancy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let enableSelfService = self.enableSelfService {
            try encodeContainer.encode(enableSelfService, forKey: .enableSelfService)
        }
        if let enableWorkDocs = self.enableWorkDocs {
            try encodeContainer.encode(enableWorkDocs, forKey: .enableWorkDocs)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let tenancy = self.tenancy {
            try encodeContainer.encode(tenancy.rawValue, forKey: .tenancy)
        }
    }
}

extension RegisterWorkspaceDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterWorkspaceDirectoryInput: Swift.Equatable {
    /// The identifier of the directory. You cannot register a directory if it does not have a status of Active. If the directory does not have a status of Active, you will receive an InvalidResourceStateException error. If you have already registered the maximum number of directories that you can register with Amazon WorkSpaces, you will receive a ResourceLimitExceededException error. Deregister directories that you are not using for WorkSpaces, and try again.
    /// This member is required.
    public var directoryId: Swift.String?
    /// Indicates whether self-service capabilities are enabled or disabled.
    public var enableSelfService: Swift.Bool?
    /// Indicates whether Amazon WorkDocs is enabled or disabled. If you have enabled this parameter and WorkDocs is not available in the Region, you will receive an OperationNotSupportedException error. Set EnableWorkDocs to disabled, and try again.
    /// This member is required.
    public var enableWorkDocs: Swift.Bool?
    /// The identifiers of the subnets for your virtual private cloud (VPC). Make sure that the subnets are in supported Availability Zones. The subnets must also be in separate Availability Zones. If these conditions are not met, you will receive an OperationNotSupportedException error.
    public var subnetIds: [Swift.String]?
    /// The tags associated with the directory.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// Indicates whether your WorkSpace directory is dedicated or shared. To use Bring Your Own License (BYOL) images, this value must be set to DEDICATED and your Amazon Web Services account must be enabled for BYOL. If your account has not been enabled for BYOL, you will receive an InvalidParameterValuesException error. For more information about BYOL images, see [Bring Your Own Windows Desktop Images](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
    public var tenancy: WorkSpacesClientTypes.Tenancy?

    public init(
        directoryId: Swift.String? = nil,
        enableSelfService: Swift.Bool? = nil,
        enableWorkDocs: Swift.Bool? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        tenancy: WorkSpacesClientTypes.Tenancy? = nil
    )
    {
        self.directoryId = directoryId
        self.enableSelfService = enableSelfService
        self.enableWorkDocs = enableWorkDocs
        self.subnetIds = subnetIds
        self.tags = tags
        self.tenancy = tenancy
    }
}

struct RegisterWorkspaceDirectoryInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let subnetIds: [Swift.String]?
    let enableWorkDocs: Swift.Bool?
    let enableSelfService: Swift.Bool?
    let tenancy: WorkSpacesClientTypes.Tenancy?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension RegisterWorkspaceDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case enableSelfService = "EnableSelfService"
        case enableWorkDocs = "EnableWorkDocs"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case tenancy = "Tenancy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let enableWorkDocsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWorkDocs)
        enableWorkDocs = enableWorkDocsDecoded
        let enableSelfServiceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSelfService)
        enableSelfService = enableSelfServiceDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.Tenancy.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RegisterWorkspaceDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RegisterWorkspaceDirectoryOutput: Swift.Equatable {

    public init() { }
}

enum RegisterWorkspaceDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedNetworkConfigurationException": return try await UnsupportedNetworkConfigurationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "WorkspacesDefaultRoleNotFoundException": return try await WorkspacesDefaultRoleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes.RelatedWorkspaceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case region = "Region"
        case state = "State"
        case type = "Type"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.StandbyWorkspaceRelationshipType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the related WorkSpace. The related WorkSpace could be a standby WorkSpace or primary WorkSpace related to the specified WorkSpace.
    public struct RelatedWorkspaceProperties: Swift.Equatable {
        /// The Region of the related WorkSpace.
        public var region: Swift.String?
        /// Indicates the state of the WorkSpace.
        public var state: WorkSpacesClientTypes.WorkspaceState?
        /// Indicates the type of WorkSpace.
        public var type: WorkSpacesClientTypes.StandbyWorkspaceRelationshipType?
        /// The identifier of the related WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            region: Swift.String? = nil,
            state: WorkSpacesClientTypes.WorkspaceState? = nil,
            type: WorkSpacesClientTypes.StandbyWorkspaceRelationshipType? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.region = region
            self.state = state
            self.type = type
            self.workspaceId = workspaceId
        }
    }

}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceAssociatedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAssociatedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is associated with a directory.
public struct ResourceAssociatedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAssociatedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAssociatedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAssociatedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceCreationFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceCreationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource could not be created.
public struct ResourceCreationFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceCreationFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceCreationFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceCreationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.resourceId = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource is currently in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that is in use.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ResourceLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your resource limits have been exceeded.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.resourceId = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The resource could not be found.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that could not be found.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ResourceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.resourceId = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource is not available.
public struct ResourceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception error message.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that is not available.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceUnavailableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct ResourceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ResourceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension RestoreWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension RestoreWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreWorkspaceInput: Swift.Equatable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct RestoreWorkspaceInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
}

extension RestoreWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension RestoreWorkspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RestoreWorkspaceOutput: Swift.Equatable {

    public init() { }
}

enum RestoreWorkspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RevokeIpRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for iprule0 in userRules {
                try userRulesContainer.encode(iprule0)
            }
        }
    }
}

extension RevokeIpRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RevokeIpRulesInput: Swift.Equatable {
    /// The identifier of the group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The rules to remove from the group.
    /// This member is required.
    public var userRules: [Swift.String]?

    public init(
        groupId: Swift.String? = nil,
        userRules: [Swift.String]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

struct RevokeIpRulesInputBody: Swift.Equatable {
    let groupId: Swift.String?
    let userRules: [Swift.String]?
}

extension RevokeIpRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userRules)
        var userRulesDecoded0:[Swift.String]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [Swift.String]()
            for string0 in userRulesContainer {
                if let string0 = string0 {
                    userRulesDecoded0?.append(string0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension RevokeIpRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RevokeIpRulesOutput: Swift.Equatable {

    public init() { }
}

enum RevokeIpRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes.RootStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity = "Capacity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = self.capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacity)
        capacity = capacityDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the root volume for a WorkSpace bundle.
    public struct RootStorage: Swift.Equatable {
        /// The size of the root volume.
        public var capacity: Swift.String?

        public init(
            capacity: Swift.String? = nil
        )
        {
            self.capacity = capacity
        }
    }

}

extension WorkSpacesClientTypes {
    public enum RunningMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alwaysOn
        case autoStop
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [RunningMode] {
            return [
                .alwaysOn,
                .autoStop,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alwaysOn: return "ALWAYS_ON"
            case .autoStop: return "AUTO_STOP"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunningMode(rawValue: rawValue) ?? RunningMode.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.SamlProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relayStateParameterName = "RelayStateParameterName"
        case status = "Status"
        case userAccessUrl = "UserAccessUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relayStateParameterName = self.relayStateParameterName {
            try encodeContainer.encode(relayStateParameterName, forKey: .relayStateParameterName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let userAccessUrl = self.userAccessUrl {
            try encodeContainer.encode(userAccessUrl, forKey: .userAccessUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.SamlStatusEnum.self, forKey: .status)
        status = statusDecoded
        let userAccessUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessUrl)
        userAccessUrl = userAccessUrlDecoded
        let relayStateParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relayStateParameterName)
        relayStateParameterName = relayStateParameterNameDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the enablement status, user access URL, and relay state parameter name that are used for configuring federation with an SAML 2.0 identity provider.
    public struct SamlProperties: Swift.Equatable {
        /// The relay state parameter name supported by the SAML 2.0 identity provider (IdP). When the end user is redirected to the user access URL from the WorkSpaces client application, this relay state parameter name is appended as a query parameter to the URL along with the relay state endpoint to return the user to the client application session. To use SAML 2.0 authentication with WorkSpaces, the IdP must support IdP-initiated deep linking for the relay state URL. Consult your IdP documentation for more information.
        public var relayStateParameterName: Swift.String?
        /// Indicates the status of SAML 2.0 authentication. These statuses include the following.
        ///
        /// * If the setting is DISABLED, end users will be directed to login with their directory credentials.
        ///
        /// * If the setting is ENABLED, end users will be directed to login via the user access URL. Users attempting to connect to WorkSpaces from a client application that does not support SAML 2.0 authentication will not be able to connect.
        ///
        /// * If the setting is ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK, end users will be directed to login via the user access URL on supported client applications, but will not prevent clients that do not support SAML 2.0 authentication from connecting as if SAML 2.0 authentication was disabled.
        public var status: WorkSpacesClientTypes.SamlStatusEnum?
        /// The SAML 2.0 identity provider (IdP) user access URL is the URL a user would navigate to in their web browser in order to federate from the IdP and directly access the application, without any SAML 2.0 service provider (SP) bindings.
        public var userAccessUrl: Swift.String?

        public init(
            relayStateParameterName: Swift.String? = nil,
            status: WorkSpacesClientTypes.SamlStatusEnum? = nil,
            userAccessUrl: Swift.String? = nil
        )
        {
            self.relayStateParameterName = relayStateParameterName
            self.status = status
            self.userAccessUrl = userAccessUrl
        }
    }

}

extension WorkSpacesClientTypes {
    public enum SamlStatusEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case enabledWithDirectoryLoginFallback
        case sdkUnknown(Swift.String)

        public static var allCases: [SamlStatusEnum] {
            return [
                .disabled,
                .enabled,
                .enabledWithDirectoryLoginFallback,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .enabledWithDirectoryLoginFallback: return "ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SamlStatusEnum(rawValue: rawValue) ?? SamlStatusEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.SelfservicePermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeComputeType = "ChangeComputeType"
        case increaseVolumeSize = "IncreaseVolumeSize"
        case rebuildWorkspace = "RebuildWorkspace"
        case restartWorkspace = "RestartWorkspace"
        case switchRunningMode = "SwitchRunningMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeComputeType = self.changeComputeType {
            try encodeContainer.encode(changeComputeType.rawValue, forKey: .changeComputeType)
        }
        if let increaseVolumeSize = self.increaseVolumeSize {
            try encodeContainer.encode(increaseVolumeSize.rawValue, forKey: .increaseVolumeSize)
        }
        if let rebuildWorkspace = self.rebuildWorkspace {
            try encodeContainer.encode(rebuildWorkspace.rawValue, forKey: .rebuildWorkspace)
        }
        if let restartWorkspace = self.restartWorkspace {
            try encodeContainer.encode(restartWorkspace.rawValue, forKey: .restartWorkspace)
        }
        if let switchRunningMode = self.switchRunningMode {
            try encodeContainer.encode(switchRunningMode.rawValue, forKey: .switchRunningMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restartWorkspaceDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .restartWorkspace)
        restartWorkspace = restartWorkspaceDecoded
        let increaseVolumeSizeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .increaseVolumeSize)
        increaseVolumeSize = increaseVolumeSizeDecoded
        let changeComputeTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .changeComputeType)
        changeComputeType = changeComputeTypeDecoded
        let switchRunningModeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .switchRunningMode)
        switchRunningMode = switchRunningModeDecoded
        let rebuildWorkspaceDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .rebuildWorkspace)
        rebuildWorkspace = rebuildWorkspaceDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the self-service permissions for a directory. For more information, see [Enable Self-Service WorkSpace Management Capabilities for Your Users](https://docs.aws.amazon.com/workspaces/latest/adminguide/enable-user-self-service-workspace-management.html).
    public struct SelfservicePermissions: Swift.Equatable {
        /// Specifies whether users can change the compute type (bundle) for their WorkSpace.
        public var changeComputeType: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can increase the volume size of the drives on their WorkSpace.
        public var increaseVolumeSize: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can rebuild the operating system of a WorkSpace to its original state.
        public var rebuildWorkspace: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can restart their WorkSpace.
        public var restartWorkspace: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can switch the running mode of their WorkSpace.
        public var switchRunningMode: WorkSpacesClientTypes.ReconnectEnum?

        public init(
            changeComputeType: WorkSpacesClientTypes.ReconnectEnum? = nil,
            increaseVolumeSize: WorkSpacesClientTypes.ReconnectEnum? = nil,
            rebuildWorkspace: WorkSpacesClientTypes.ReconnectEnum? = nil,
            restartWorkspace: WorkSpacesClientTypes.ReconnectEnum? = nil,
            switchRunningMode: WorkSpacesClientTypes.ReconnectEnum? = nil
        )
        {
            self.changeComputeType = changeComputeType
            self.increaseVolumeSize = increaseVolumeSize
            self.rebuildWorkspace = rebuildWorkspace
            self.restartWorkspace = restartWorkspace
            self.switchRunningMode = switchRunningMode
        }
    }

}

extension WorkSpacesClientTypes.Snapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotTime = "SnapshotTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotTime = self.snapshotTime {
            try encodeContainer.encodeTimestamp(snapshotTime, format: .epochSeconds, forKey: .snapshotTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotTime)
        snapshotTime = snapshotTimeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a snapshot.
    public struct Snapshot: Swift.Equatable {
        /// The time when the snapshot was created.
        public var snapshotTime: ClientRuntime.Date?

        public init(
            snapshotTime: ClientRuntime.Date? = nil
        )
        {
            self.snapshotTime = snapshotTime
        }
    }

}

extension WorkSpacesClientTypes.StandbyWorkspace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplication = "DataReplication"
        case directoryId = "DirectoryId"
        case primaryWorkspaceId = "PrimaryWorkspaceId"
        case tags = "Tags"
        case volumeEncryptionKey = "VolumeEncryptionKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplication = self.dataReplication {
            try encodeContainer.encode(dataReplication.rawValue, forKey: .dataReplication)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let primaryWorkspaceId = self.primaryWorkspaceId {
            try encodeContainer.encode(primaryWorkspaceId, forKey: .primaryWorkspaceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let volumeEncryptionKey = self.volumeEncryptionKey {
            try encodeContainer.encode(volumeEncryptionKey, forKey: .volumeEncryptionKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryWorkspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryWorkspaceId)
        primaryWorkspaceId = primaryWorkspaceIdDecoded
        let volumeEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeEncryptionKey)
        volumeEncryptionKey = volumeEncryptionKeyDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let dataReplicationDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DataReplication.self, forKey: .dataReplication)
        dataReplication = dataReplicationDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a standby WorkSpace.
    public struct StandbyWorkspace: Swift.Equatable {
        /// Indicates whether data replication is enabled, and if enabled, the type of data replication.
        public var dataReplication: WorkSpacesClientTypes.DataReplication?
        /// The identifier of the directory for the standby WorkSpace.
        /// This member is required.
        public var directoryId: Swift.String?
        /// The identifier of the standby WorkSpace.
        /// This member is required.
        public var primaryWorkspaceId: Swift.String?
        /// The tags associated with the standby WorkSpace.
        public var tags: [WorkSpacesClientTypes.Tag]?
        /// The volume encryption key of the standby WorkSpace.
        public var volumeEncryptionKey: Swift.String?

        public init(
            dataReplication: WorkSpacesClientTypes.DataReplication? = nil,
            directoryId: Swift.String? = nil,
            primaryWorkspaceId: Swift.String? = nil,
            tags: [WorkSpacesClientTypes.Tag]? = nil,
            volumeEncryptionKey: Swift.String? = nil
        )
        {
            self.dataReplication = dataReplication
            self.directoryId = directoryId
            self.primaryWorkspaceId = primaryWorkspaceId
            self.tags = tags
            self.volumeEncryptionKey = volumeEncryptionKey
        }
    }

}

extension WorkSpacesClientTypes {
    public enum StandbyWorkspaceRelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case primary
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [StandbyWorkspaceRelationshipType] {
            return [
                .primary,
                .standby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .primary: return "PRIMARY"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StandbyWorkspaceRelationshipType(rawValue: rawValue) ?? StandbyWorkspaceRelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.StandbyWorkspacesProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplication = "DataReplication"
        case recoverySnapshotTime = "RecoverySnapshotTime"
        case standbyWorkspaceId = "StandbyWorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplication = self.dataReplication {
            try encodeContainer.encode(dataReplication.rawValue, forKey: .dataReplication)
        }
        if let recoverySnapshotTime = self.recoverySnapshotTime {
            try encodeContainer.encodeTimestamp(recoverySnapshotTime, format: .epochSeconds, forKey: .recoverySnapshotTime)
        }
        if let standbyWorkspaceId = self.standbyWorkspaceId {
            try encodeContainer.encode(standbyWorkspaceId, forKey: .standbyWorkspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standbyWorkspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standbyWorkspaceId)
        standbyWorkspaceId = standbyWorkspaceIdDecoded
        let dataReplicationDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DataReplication.self, forKey: .dataReplication)
        dataReplication = dataReplicationDecoded
        let recoverySnapshotTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .recoverySnapshotTime)
        recoverySnapshotTime = recoverySnapshotTimeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the properties of the related standby WorkSpaces.
    public struct StandbyWorkspacesProperties: Swift.Equatable {
        /// Indicates whether data replication is enabled, and if enabled, the type of data replication.
        public var dataReplication: WorkSpacesClientTypes.DataReplication?
        /// The date and time at which the last successful snapshot was taken of the primary WorkSpace used for replicating data.
        public var recoverySnapshotTime: ClientRuntime.Date?
        /// The identifier of the standby WorkSpace
        public var standbyWorkspaceId: Swift.String?

        public init(
            dataReplication: WorkSpacesClientTypes.DataReplication? = nil,
            recoverySnapshotTime: ClientRuntime.Date? = nil,
            standbyWorkspaceId: Swift.String? = nil
        )
        {
            self.dataReplication = dataReplication
            self.recoverySnapshotTime = recoverySnapshotTime
            self.standbyWorkspaceId = standbyWorkspaceId
        }
    }

}

extension WorkSpacesClientTypes.StartRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Information used to start a WorkSpace.
    public struct StartRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension StartWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startWorkspaceRequests = "StartWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startWorkspaceRequests = startWorkspaceRequests {
            var startWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startWorkspaceRequests)
            for startrequest0 in startWorkspaceRequests {
                try startWorkspaceRequestsContainer.encode(startrequest0)
            }
        }
    }
}

extension StartWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to start. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var startWorkspaceRequests: [WorkSpacesClientTypes.StartRequest]?

    public init(
        startWorkspaceRequests: [WorkSpacesClientTypes.StartRequest]? = nil
    )
    {
        self.startWorkspaceRequests = startWorkspaceRequests
    }
}

struct StartWorkspacesInputBody: Swift.Equatable {
    let startWorkspaceRequests: [WorkSpacesClientTypes.StartRequest]?
}

extension StartWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startWorkspaceRequests = "StartWorkspaceRequests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.StartRequest?].self, forKey: .startWorkspaceRequests)
        var startWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.StartRequest]? = nil
        if let startWorkspaceRequestsContainer = startWorkspaceRequestsContainer {
            startWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.StartRequest]()
            for structure0 in startWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    startWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        startWorkspaceRequests = startWorkspaceRequestsDecoded0
    }
}

extension StartWorkspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartWorkspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct StartWorkspacesOutput: Swift.Equatable {
    /// Information about the WorkSpaces that could not be started.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init(
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct StartWorkspacesOutputBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension StartWorkspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

enum StartWorkspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes.StopRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to stop a WorkSpace.
    public struct StopRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension StopWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stopWorkspaceRequests = "StopWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stopWorkspaceRequests = stopWorkspaceRequests {
            var stopWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopWorkspaceRequests)
            for stoprequest0 in stopWorkspaceRequests {
                try stopWorkspaceRequestsContainer.encode(stoprequest0)
            }
        }
    }
}

extension StopWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to stop. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var stopWorkspaceRequests: [WorkSpacesClientTypes.StopRequest]?

    public init(
        stopWorkspaceRequests: [WorkSpacesClientTypes.StopRequest]? = nil
    )
    {
        self.stopWorkspaceRequests = stopWorkspaceRequests
    }
}

struct StopWorkspacesInputBody: Swift.Equatable {
    let stopWorkspaceRequests: [WorkSpacesClientTypes.StopRequest]?
}

extension StopWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stopWorkspaceRequests = "StopWorkspaceRequests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stopWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.StopRequest?].self, forKey: .stopWorkspaceRequests)
        var stopWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.StopRequest]? = nil
        if let stopWorkspaceRequestsContainer = stopWorkspaceRequestsContainer {
            stopWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.StopRequest]()
            for structure0 in stopWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    stopWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        stopWorkspaceRequests = stopWorkspaceRequestsDecoded0
    }
}

extension StopWorkspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopWorkspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct StopWorkspacesOutput: Swift.Equatable {
    /// Information about the WorkSpaces that could not be stopped.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init(
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct StopWorkspacesOutputBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension StopWorkspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

enum StopWorkspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a tag.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension WorkSpacesClientTypes {
    public enum TargetWorkspaceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adminMaintenance
        case available
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetWorkspaceState] {
            return [
                .adminMaintenance,
                .available,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adminMaintenance: return "ADMIN_MAINTENANCE"
            case .available: return "AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetWorkspaceState(rawValue: rawValue) ?? TargetWorkspaceState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum Tenancy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dedicated
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [Tenancy] {
            return [
                .dedicated,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "DEDICATED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Tenancy(rawValue: rawValue) ?? Tenancy.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.TerminateRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to terminate a WorkSpace.
    public struct TerminateRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init(
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension TerminateWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminateWorkspaceRequests = "TerminateWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let terminateWorkspaceRequests = terminateWorkspaceRequests {
            var terminateWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terminateWorkspaceRequests)
            for terminaterequest0 in terminateWorkspaceRequests {
                try terminateWorkspaceRequestsContainer.encode(terminaterequest0)
            }
        }
    }
}

extension TerminateWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TerminateWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to terminate. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var terminateWorkspaceRequests: [WorkSpacesClientTypes.TerminateRequest]?

    public init(
        terminateWorkspaceRequests: [WorkSpacesClientTypes.TerminateRequest]? = nil
    )
    {
        self.terminateWorkspaceRequests = terminateWorkspaceRequests
    }
}

struct TerminateWorkspacesInputBody: Swift.Equatable {
    let terminateWorkspaceRequests: [WorkSpacesClientTypes.TerminateRequest]?
}

extension TerminateWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminateWorkspaceRequests = "TerminateWorkspaceRequests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminateWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.TerminateRequest?].self, forKey: .terminateWorkspaceRequests)
        var terminateWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.TerminateRequest]? = nil
        if let terminateWorkspaceRequestsContainer = terminateWorkspaceRequestsContainer {
            terminateWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.TerminateRequest]()
            for structure0 in terminateWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    terminateWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        terminateWorkspaceRequests = terminateWorkspaceRequestsDecoded0
    }
}

extension TerminateWorkspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TerminateWorkspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct TerminateWorkspacesOutput: Swift.Equatable {
    /// Information about the WorkSpaces that could not be terminated.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init(
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct TerminateWorkspacesOutputBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension TerminateWorkspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

enum TerminateWorkspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UnsupportedNetworkConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedNetworkConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The configuration of this network is not supported for this operation, or your network configuration conflicts with the Amazon WorkSpaces management network IP range. For more information, see [ Configure a VPC for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html).
public struct UnsupportedNetworkConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedNetworkConfigurationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedNetworkConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedNetworkConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedWorkspaceConfigurationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedWorkspaceConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The configuration of this WorkSpace is not supported for this operation. For more information, see [Required Configuration and Service Components for WorkSpaces ](https://docs.aws.amazon.com/workspaces/latest/adminguide/required-service-components.html).
public struct UnsupportedWorkspaceConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedWorkspaceConfigurationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedWorkspaceConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedWorkspaceConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateConnectClientAddInInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addInId = "AddInId"
        case name = "Name"
        case resourceId = "ResourceId"
        case url = "URL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addInId = self.addInId {
            try encodeContainer.encode(addInId, forKey: .addInId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }
}

extension UpdateConnectClientAddInInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateConnectClientAddInInput: Swift.Equatable {
    /// The identifier of the client add-in to update.
    /// This member is required.
    public var addInId: Swift.String?
    /// The name of the client add-in.
    public var name: Swift.String?
    /// The directory identifier for which the client add-in is configured.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The endpoint URL of the Amazon Connect client add-in.
    public var url: Swift.String?

    public init(
        addInId: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        url: Swift.String? = nil
    )
    {
        self.addInId = addInId
        self.name = name
        self.resourceId = resourceId
        self.url = url
    }
}

struct UpdateConnectClientAddInInputBody: Swift.Equatable {
    let addInId: Swift.String?
    let resourceId: Swift.String?
    let name: Swift.String?
    let url: Swift.String?
}

extension UpdateConnectClientAddInInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addInId = "AddInId"
        case name = "Name"
        case resourceId = "ResourceId"
        case url = "URL"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addInIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addInId)
        addInId = addInIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension UpdateConnectClientAddInOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateConnectClientAddInOutput: Swift.Equatable {

    public init() { }
}

enum UpdateConnectClientAddInOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConnectionAliasPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case connectionAliasPermission = "ConnectionAliasPermission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = self.aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let connectionAliasPermission = self.connectionAliasPermission {
            try encodeContainer.encode(connectionAliasPermission, forKey: .connectionAliasPermission)
        }
    }
}

extension UpdateConnectionAliasPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateConnectionAliasPermissionInput: Swift.Equatable {
    /// The identifier of the connection alias that you want to update permissions for.
    /// This member is required.
    public var aliasId: Swift.String?
    /// Indicates whether to share or unshare the connection alias with the specified Amazon Web Services account.
    /// This member is required.
    public var connectionAliasPermission: WorkSpacesClientTypes.ConnectionAliasPermission?

    public init(
        aliasId: Swift.String? = nil,
        connectionAliasPermission: WorkSpacesClientTypes.ConnectionAliasPermission? = nil
    )
    {
        self.aliasId = aliasId
        self.connectionAliasPermission = connectionAliasPermission
    }
}

struct UpdateConnectionAliasPermissionInputBody: Swift.Equatable {
    let aliasId: Swift.String?
    let connectionAliasPermission: WorkSpacesClientTypes.ConnectionAliasPermission?
}

extension UpdateConnectionAliasPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case connectionAliasPermission = "ConnectionAliasPermission"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let connectionAliasPermissionDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ConnectionAliasPermission.self, forKey: .connectionAliasPermission)
        connectionAliasPermission = connectionAliasPermissionDecoded
    }
}

extension UpdateConnectionAliasPermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateConnectionAliasPermissionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateConnectionAliasPermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAssociatedException": return try await ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes.UpdateResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case updateAvailable = "UpdateAvailable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let updateAvailable = self.updateAvailable {
            try encodeContainer.encode(updateAvailable, forKey: .updateAvailable)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateAvailableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .updateAvailable)
        updateAvailable = updateAvailableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes whether a WorkSpace image needs to be updated with the latest drivers and other components required by Amazon WorkSpaces. Only Windows 10 WorkSpace images can be programmatically updated at this time.
    public struct UpdateResult: Swift.Equatable {
        /// A description of whether updates for the WorkSpace image are pending or available.
        public var description: Swift.String?
        /// Indicates whether updated drivers or other components are available for the specified WorkSpace image.
        public var updateAvailable: Swift.Bool?

        public init(
            description: Swift.String? = nil,
            updateAvailable: Swift.Bool? = nil
        )
        {
            self.description = description
            self.updateAvailable = updateAvailable
        }
    }

}

extension UpdateRulesOfIpGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for ipruleitem0 in userRules {
                try userRulesContainer.encode(ipruleitem0)
            }
        }
    }
}

extension UpdateRulesOfIpGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRulesOfIpGroupInput: Swift.Equatable {
    /// The identifier of the group.
    /// This member is required.
    public var groupId: Swift.String?
    /// One or more rules.
    /// This member is required.
    public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

    public init(
        groupId: Swift.String? = nil,
        userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

struct UpdateRulesOfIpGroupInputBody: Swift.Equatable {
    let groupId: Swift.String?
    let userRules: [WorkSpacesClientTypes.IpRuleItem]?
}

extension UpdateRulesOfIpGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[WorkSpacesClientTypes.IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [WorkSpacesClientTypes.IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension UpdateRulesOfIpGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRulesOfIpGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRulesOfIpGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateException": return try await InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkspaceBundleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case imageId = "ImageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }
}

extension UpdateWorkspaceBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWorkspaceBundleInput: Swift.Equatable {
    /// The identifier of the bundle.
    public var bundleId: Swift.String?
    /// The identifier of the image.
    public var imageId: Swift.String?

    public init(
        bundleId: Swift.String? = nil,
        imageId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
        self.imageId = imageId
    }
}

struct UpdateWorkspaceBundleInputBody: Swift.Equatable {
    let bundleId: Swift.String?
    let imageId: Swift.String?
}

extension UpdateWorkspaceBundleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case imageId = "ImageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension UpdateWorkspaceBundleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateWorkspaceBundleOutput: Swift.Equatable {

    public init() { }
}

enum UpdateWorkspaceBundleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkspaceImagePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCopyImage = "AllowCopyImage"
        case imageId = "ImageId"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowCopyImage = self.allowCopyImage {
            try encodeContainer.encode(allowCopyImage, forKey: .allowCopyImage)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let sharedAccountId = self.sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }
}

extension UpdateWorkspaceImagePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWorkspaceImagePermissionInput: Swift.Equatable {
    /// The permission to copy the image. This permission can be revoked only after an image has been shared.
    /// This member is required.
    public var allowCopyImage: Swift.Bool?
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?
    /// The identifier of the Amazon Web Services account to share or unshare the image with. Before sharing the image, confirm that you are sharing to the correct Amazon Web Services account ID.
    /// This member is required.
    public var sharedAccountId: Swift.String?

    public init(
        allowCopyImage: Swift.Bool? = nil,
        imageId: Swift.String? = nil,
        sharedAccountId: Swift.String? = nil
    )
    {
        self.allowCopyImage = allowCopyImage
        self.imageId = imageId
        self.sharedAccountId = sharedAccountId
    }
}

struct UpdateWorkspaceImagePermissionInputBody: Swift.Equatable {
    let imageId: Swift.String?
    let allowCopyImage: Swift.Bool?
    let sharedAccountId: Swift.String?
}

extension UpdateWorkspaceImagePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCopyImage = "AllowCopyImage"
        case imageId = "ImageId"
        case sharedAccountId = "SharedAccountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let allowCopyImageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowCopyImage)
        allowCopyImage = allowCopyImageDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
    }
}

extension UpdateWorkspaceImagePermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateWorkspaceImagePermissionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateWorkspaceImagePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValuesException": return try await InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotSupportedException": return try await OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesClientTypes.UserStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity = "Capacity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = self.capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacity)
        capacity = capacityDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the user volume for a WorkSpace bundle.
    public struct UserStorage: Swift.Equatable {
        /// The size of the user volume.
        public var capacity: Swift.String?

        public init(
            capacity: Swift.String? = nil
        )
        {
            self.capacity = capacity
        }
    }

}

extension WorkSpacesClientTypes.WorkSpaceApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case created = "Created"
        case description = "Description"
        case licenseType = "LicenseType"
        case name = "Name"
        case owner = "Owner"
        case state = "State"
        case supportedComputeTypeNames = "SupportedComputeTypeNames"
        case supportedOperatingSystemNames = "SupportedOperatingSystemNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let licenseType = self.licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let supportedComputeTypeNames = supportedComputeTypeNames {
            var supportedComputeTypeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedComputeTypeNames)
            for compute0 in supportedComputeTypeNames {
                try supportedComputeTypeNamesContainer.encode(compute0.rawValue)
            }
        }
        if let supportedOperatingSystemNames = supportedOperatingSystemNames {
            var supportedOperatingSystemNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOperatingSystemNames)
            for operatingsystemname0 in supportedOperatingSystemNames {
                try supportedOperatingSystemNamesContainer.encode(operatingsystemname0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkSpaceApplicationLicenseType.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkSpaceApplicationState.self, forKey: .state)
        state = stateDecoded
        let supportedComputeTypeNamesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Compute?].self, forKey: .supportedComputeTypeNames)
        var supportedComputeTypeNamesDecoded0:[WorkSpacesClientTypes.Compute]? = nil
        if let supportedComputeTypeNamesContainer = supportedComputeTypeNamesContainer {
            supportedComputeTypeNamesDecoded0 = [WorkSpacesClientTypes.Compute]()
            for enum0 in supportedComputeTypeNamesContainer {
                if let enum0 = enum0 {
                    supportedComputeTypeNamesDecoded0?.append(enum0)
                }
            }
        }
        supportedComputeTypeNames = supportedComputeTypeNamesDecoded0
        let supportedOperatingSystemNamesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.OperatingSystemName?].self, forKey: .supportedOperatingSystemNames)
        var supportedOperatingSystemNamesDecoded0:[WorkSpacesClientTypes.OperatingSystemName]? = nil
        if let supportedOperatingSystemNamesContainer = supportedOperatingSystemNamesContainer {
            supportedOperatingSystemNamesDecoded0 = [WorkSpacesClientTypes.OperatingSystemName]()
            for enum0 in supportedOperatingSystemNamesContainer {
                if let enum0 = enum0 {
                    supportedOperatingSystemNamesDecoded0?.append(enum0)
                }
            }
        }
        supportedOperatingSystemNames = supportedOperatingSystemNamesDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes the WorkSpace application.
    public struct WorkSpaceApplication: Swift.Equatable {
        /// The identifier of the application.
        public var applicationId: Swift.String?
        /// The time the application is created.
        public var created: ClientRuntime.Date?
        /// The description of the WorkSpace application.
        public var description: Swift.String?
        /// The license availability for the applications.
        public var licenseType: WorkSpacesClientTypes.WorkSpaceApplicationLicenseType?
        /// The name of the WorkSpace application.
        public var name: Swift.String?
        /// The owner of the WorkSpace application.
        public var owner: Swift.String?
        /// The status of WorkSpace application.
        public var state: WorkSpacesClientTypes.WorkSpaceApplicationState?
        /// The supported compute types of the WorkSpace application.
        public var supportedComputeTypeNames: [WorkSpacesClientTypes.Compute]?
        /// The supported operating systems of the WorkSpace application.
        public var supportedOperatingSystemNames: [WorkSpacesClientTypes.OperatingSystemName]?

        public init(
            applicationId: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            licenseType: WorkSpacesClientTypes.WorkSpaceApplicationLicenseType? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            state: WorkSpacesClientTypes.WorkSpaceApplicationState? = nil,
            supportedComputeTypeNames: [WorkSpacesClientTypes.Compute]? = nil,
            supportedOperatingSystemNames: [WorkSpacesClientTypes.OperatingSystemName]? = nil
        )
        {
            self.applicationId = applicationId
            self.created = created
            self.description = description
            self.licenseType = licenseType
            self.name = name
            self.owner = owner
            self.state = state
            self.supportedComputeTypeNames = supportedComputeTypeNames
            self.supportedOperatingSystemNames = supportedOperatingSystemNames
        }
    }

}

extension WorkSpacesClientTypes.WorkSpaceApplicationDeployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associations = associations {
            var associationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associations)
            for workspaceresourceassociation0 in associations {
                try associationsContainer.encode(workspaceresourceassociation0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceResourceAssociation?].self, forKey: .associations)
        var associationsDecoded0:[WorkSpacesClientTypes.WorkspaceResourceAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [WorkSpacesClientTypes.WorkspaceResourceAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes the WorkSpace application deployment.
    public struct WorkSpaceApplicationDeployment: Swift.Equatable {
        /// The associations between the applications and the associated resources.
        public var associations: [WorkSpacesClientTypes.WorkspaceResourceAssociation]?

        public init(
            associations: [WorkSpacesClientTypes.WorkspaceResourceAssociation]? = nil
        )
        {
            self.associations = associations
        }
    }

}

extension WorkSpacesClientTypes {
    public enum WorkSpaceApplicationLicenseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case licensed
        case unlicensed
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkSpaceApplicationLicenseType] {
            return [
                .licensed,
                .unlicensed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .licensed: return "LICENSED"
            case .unlicensed: return "UNLICENSED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkSpaceApplicationLicenseType(rawValue: rawValue) ?? WorkSpaceApplicationLicenseType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum WorkSpaceApplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case error
        case pending
        case uninstallOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkSpaceApplicationState] {
            return [
                .available,
                .error,
                .pending,
                .uninstallOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .pending: return "PENDING"
            case .uninstallOnly: return "UNINSTALL_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkSpaceApplicationState(rawValue: rawValue) ?? WorkSpaceApplicationState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum WorkSpaceAssociatedResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkSpaceAssociatedResourceType] {
            return [
                .application,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkSpaceAssociatedResourceType(rawValue: rawValue) ?? WorkSpaceAssociatedResourceType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.Workspace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case computerName = "ComputerName"
        case dataReplicationSettings = "DataReplicationSettings"
        case directoryId = "DirectoryId"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case ipAddress = "IpAddress"
        case modificationStates = "ModificationStates"
        case relatedWorkspaces = "RelatedWorkspaces"
        case rootVolumeEncryptionEnabled = "RootVolumeEncryptionEnabled"
        case standbyWorkspacesProperties = "StandbyWorkspacesProperties"
        case state = "State"
        case subnetId = "SubnetId"
        case userName = "UserName"
        case userVolumeEncryptionEnabled = "UserVolumeEncryptionEnabled"
        case volumeEncryptionKey = "VolumeEncryptionKey"
        case workspaceId = "WorkspaceId"
        case workspaceProperties = "WorkspaceProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let computerName = self.computerName {
            try encodeContainer.encode(computerName, forKey: .computerName)
        }
        if let dataReplicationSettings = self.dataReplicationSettings {
            try encodeContainer.encode(dataReplicationSettings, forKey: .dataReplicationSettings)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let modificationStates = modificationStates {
            var modificationStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modificationStates)
            for modificationstate0 in modificationStates {
                try modificationStatesContainer.encode(modificationstate0)
            }
        }
        if let relatedWorkspaces = relatedWorkspaces {
            var relatedWorkspacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedWorkspaces)
            for relatedworkspaceproperties0 in relatedWorkspaces {
                try relatedWorkspacesContainer.encode(relatedworkspaceproperties0)
            }
        }
        if let rootVolumeEncryptionEnabled = self.rootVolumeEncryptionEnabled {
            try encodeContainer.encode(rootVolumeEncryptionEnabled, forKey: .rootVolumeEncryptionEnabled)
        }
        if let standbyWorkspacesProperties = standbyWorkspacesProperties {
            var standbyWorkspacesPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standbyWorkspacesProperties)
            for standbyworkspacesproperties0 in standbyWorkspacesProperties {
                try standbyWorkspacesPropertiesContainer.encode(standbyworkspacesproperties0)
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userVolumeEncryptionEnabled = self.userVolumeEncryptionEnabled {
            try encodeContainer.encode(userVolumeEncryptionEnabled, forKey: .userVolumeEncryptionEnabled)
        }
        if let volumeEncryptionKey = self.volumeEncryptionKey {
            try encodeContainer.encode(volumeEncryptionKey, forKey: .volumeEncryptionKey)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
        if let workspaceProperties = self.workspaceProperties {
            try encodeContainer.encode(workspaceProperties, forKey: .workspaceProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceState.self, forKey: .state)
        state = stateDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let computerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computerName)
        computerName = computerNameDecoded
        let volumeEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeEncryptionKey)
        volumeEncryptionKey = volumeEncryptionKeyDecoded
        let userVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userVolumeEncryptionEnabled)
        userVolumeEncryptionEnabled = userVolumeEncryptionEnabledDecoded
        let rootVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rootVolumeEncryptionEnabled)
        rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabledDecoded
        let workspacePropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceProperties.self, forKey: .workspaceProperties)
        workspaceProperties = workspacePropertiesDecoded
        let modificationStatesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ModificationState?].self, forKey: .modificationStates)
        var modificationStatesDecoded0:[WorkSpacesClientTypes.ModificationState]? = nil
        if let modificationStatesContainer = modificationStatesContainer {
            modificationStatesDecoded0 = [WorkSpacesClientTypes.ModificationState]()
            for structure0 in modificationStatesContainer {
                if let structure0 = structure0 {
                    modificationStatesDecoded0?.append(structure0)
                }
            }
        }
        modificationStates = modificationStatesDecoded0
        let relatedWorkspacesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.RelatedWorkspaceProperties?].self, forKey: .relatedWorkspaces)
        var relatedWorkspacesDecoded0:[WorkSpacesClientTypes.RelatedWorkspaceProperties]? = nil
        if let relatedWorkspacesContainer = relatedWorkspacesContainer {
            relatedWorkspacesDecoded0 = [WorkSpacesClientTypes.RelatedWorkspaceProperties]()
            for structure0 in relatedWorkspacesContainer {
                if let structure0 = structure0 {
                    relatedWorkspacesDecoded0?.append(structure0)
                }
            }
        }
        relatedWorkspaces = relatedWorkspacesDecoded0
        let dataReplicationSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DataReplicationSettings.self, forKey: .dataReplicationSettings)
        dataReplicationSettings = dataReplicationSettingsDecoded
        let standbyWorkspacesPropertiesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.StandbyWorkspacesProperties?].self, forKey: .standbyWorkspacesProperties)
        var standbyWorkspacesPropertiesDecoded0:[WorkSpacesClientTypes.StandbyWorkspacesProperties]? = nil
        if let standbyWorkspacesPropertiesContainer = standbyWorkspacesPropertiesContainer {
            standbyWorkspacesPropertiesDecoded0 = [WorkSpacesClientTypes.StandbyWorkspacesProperties]()
            for structure0 in standbyWorkspacesPropertiesContainer {
                if let structure0 = structure0 {
                    standbyWorkspacesPropertiesDecoded0?.append(structure0)
                }
            }
        }
        standbyWorkspacesProperties = standbyWorkspacesPropertiesDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace.
    public struct Workspace: Swift.Equatable {
        /// The identifier of the bundle used to create the WorkSpace.
        public var bundleId: Swift.String?
        /// The name of the WorkSpace, as seen by the operating system. The format of this name varies. For more information, see [ Launch a WorkSpace](https://docs.aws.amazon.com/workspaces/latest/adminguide/launch-workspaces-tutorials.html).
        public var computerName: Swift.String?
        /// Indicates the settings of the data replication.
        public var dataReplicationSettings: WorkSpacesClientTypes.DataReplicationSettings?
        /// The identifier of the Directory Service directory for the WorkSpace.
        public var directoryId: Swift.String?
        /// The error code that is returned if the WorkSpace cannot be created.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the WorkSpace cannot be created.
        public var errorMessage: Swift.String?
        /// The IP address of the WorkSpace.
        public var ipAddress: Swift.String?
        /// The modification states of the WorkSpace.
        public var modificationStates: [WorkSpacesClientTypes.ModificationState]?
        /// The standby WorkSpace or primary WorkSpace related to the specified WorkSpace.
        public var relatedWorkspaces: [WorkSpacesClientTypes.RelatedWorkspaceProperties]?
        /// Indicates whether the data stored on the root volume is encrypted.
        public var rootVolumeEncryptionEnabled: Swift.Bool?
        /// The properties of the standby WorkSpace
        public var standbyWorkspacesProperties: [WorkSpacesClientTypes.StandbyWorkspacesProperties]?
        /// The operational state of the WorkSpace. After a WorkSpace is terminated, the TERMINATED state is returned only briefly before the WorkSpace directory metadata is cleaned up, so this state is rarely returned. To confirm that a WorkSpace is terminated, check for the WorkSpace ID by using [ DescribeWorkSpaces](https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html). If the WorkSpace ID isn't returned, then the WorkSpace has been successfully terminated.
        public var state: WorkSpacesClientTypes.WorkspaceState?
        /// The identifier of the subnet for the WorkSpace.
        public var subnetId: Swift.String?
        /// The user for the WorkSpace.
        public var userName: Swift.String?
        /// Indicates whether the data stored on the user volume is encrypted.
        public var userVolumeEncryptionEnabled: Swift.Bool?
        /// The ARN of the symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.
        public var volumeEncryptionKey: Swift.String?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?
        /// The properties of the WorkSpace.
        public var workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?

        public init(
            bundleId: Swift.String? = nil,
            computerName: Swift.String? = nil,
            dataReplicationSettings: WorkSpacesClientTypes.DataReplicationSettings? = nil,
            directoryId: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            modificationStates: [WorkSpacesClientTypes.ModificationState]? = nil,
            relatedWorkspaces: [WorkSpacesClientTypes.RelatedWorkspaceProperties]? = nil,
            rootVolumeEncryptionEnabled: Swift.Bool? = nil,
            standbyWorkspacesProperties: [WorkSpacesClientTypes.StandbyWorkspacesProperties]? = nil,
            state: WorkSpacesClientTypes.WorkspaceState? = nil,
            subnetId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userVolumeEncryptionEnabled: Swift.Bool? = nil,
            volumeEncryptionKey: Swift.String? = nil,
            workspaceId: Swift.String? = nil,
            workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties? = nil
        )
        {
            self.bundleId = bundleId
            self.computerName = computerName
            self.dataReplicationSettings = dataReplicationSettings
            self.directoryId = directoryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.ipAddress = ipAddress
            self.modificationStates = modificationStates
            self.relatedWorkspaces = relatedWorkspaces
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.standbyWorkspacesProperties = standbyWorkspacesProperties
            self.state = state
            self.subnetId = subnetId
            self.userName = userName
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.volumeEncryptionKey = volumeEncryptionKey
            self.workspaceId = workspaceId
            self.workspaceProperties = workspaceProperties
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceAccessProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceTypeAndroid = "DeviceTypeAndroid"
        case deviceTypeChromeOs = "DeviceTypeChromeOs"
        case deviceTypeIos = "DeviceTypeIos"
        case deviceTypeLinux = "DeviceTypeLinux"
        case deviceTypeOsx = "DeviceTypeOsx"
        case deviceTypeWeb = "DeviceTypeWeb"
        case deviceTypeWindows = "DeviceTypeWindows"
        case deviceTypeZeroClient = "DeviceTypeZeroClient"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceTypeAndroid = self.deviceTypeAndroid {
            try encodeContainer.encode(deviceTypeAndroid.rawValue, forKey: .deviceTypeAndroid)
        }
        if let deviceTypeChromeOs = self.deviceTypeChromeOs {
            try encodeContainer.encode(deviceTypeChromeOs.rawValue, forKey: .deviceTypeChromeOs)
        }
        if let deviceTypeIos = self.deviceTypeIos {
            try encodeContainer.encode(deviceTypeIos.rawValue, forKey: .deviceTypeIos)
        }
        if let deviceTypeLinux = self.deviceTypeLinux {
            try encodeContainer.encode(deviceTypeLinux.rawValue, forKey: .deviceTypeLinux)
        }
        if let deviceTypeOsx = self.deviceTypeOsx {
            try encodeContainer.encode(deviceTypeOsx.rawValue, forKey: .deviceTypeOsx)
        }
        if let deviceTypeWeb = self.deviceTypeWeb {
            try encodeContainer.encode(deviceTypeWeb.rawValue, forKey: .deviceTypeWeb)
        }
        if let deviceTypeWindows = self.deviceTypeWindows {
            try encodeContainer.encode(deviceTypeWindows.rawValue, forKey: .deviceTypeWindows)
        }
        if let deviceTypeZeroClient = self.deviceTypeZeroClient {
            try encodeContainer.encode(deviceTypeZeroClient.rawValue, forKey: .deviceTypeZeroClient)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTypeWindowsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeWindows)
        deviceTypeWindows = deviceTypeWindowsDecoded
        let deviceTypeOsxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeOsx)
        deviceTypeOsx = deviceTypeOsxDecoded
        let deviceTypeWebDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeWeb)
        deviceTypeWeb = deviceTypeWebDecoded
        let deviceTypeIosDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeIos)
        deviceTypeIos = deviceTypeIosDecoded
        let deviceTypeAndroidDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeAndroid)
        deviceTypeAndroid = deviceTypeAndroidDecoded
        let deviceTypeChromeOsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeChromeOs)
        deviceTypeChromeOs = deviceTypeChromeOsDecoded
        let deviceTypeZeroClientDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeZeroClient)
        deviceTypeZeroClient = deviceTypeZeroClientDecoded
        let deviceTypeLinuxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeLinux)
        deviceTypeLinux = deviceTypeLinuxDecoded
    }
}

extension WorkSpacesClientTypes {
    /// The device types and operating systems that can be used to access a WorkSpace. For more information, see [Amazon WorkSpaces Client Network Requirements](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-network-requirements.html).
    public struct WorkspaceAccessProperties: Swift.Equatable {
        /// Indicates whether users can use Android and Android-compatible Chrome OS devices to access their WorkSpaces.
        public var deviceTypeAndroid: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use Chromebooks to access their WorkSpaces.
        public var deviceTypeChromeOs: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use iOS devices to access their WorkSpaces.
        public var deviceTypeIos: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use Linux clients to access their WorkSpaces.
        public var deviceTypeLinux: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use macOS clients to access their WorkSpaces.
        public var deviceTypeOsx: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can access their WorkSpaces through a web browser.
        public var deviceTypeWeb: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use Windows clients to access their WorkSpaces.
        public var deviceTypeWindows: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use zero client devices to access their WorkSpaces.
        public var deviceTypeZeroClient: WorkSpacesClientTypes.AccessPropertyValue?

        public init(
            deviceTypeAndroid: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeChromeOs: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeIos: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeLinux: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeOsx: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeWeb: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeWindows: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeZeroClient: WorkSpacesClientTypes.AccessPropertyValue? = nil
        )
        {
            self.deviceTypeAndroid = deviceTypeAndroid
            self.deviceTypeChromeOs = deviceTypeChromeOs
            self.deviceTypeIos = deviceTypeIos
            self.deviceTypeLinux = deviceTypeLinux
            self.deviceTypeOsx = deviceTypeOsx
            self.deviceTypeWeb = deviceTypeWeb
            self.deviceTypeWindows = deviceTypeWindows
            self.deviceTypeZeroClient = deviceTypeZeroClient
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceBundle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case bundleType = "BundleType"
        case computeType = "ComputeType"
        case creationTime = "CreationTime"
        case description = "Description"
        case imageId = "ImageId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case owner = "Owner"
        case rootStorage = "RootStorage"
        case state = "State"
        case userStorage = "UserStorage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let bundleType = self.bundleType {
            try encodeContainer.encode(bundleType.rawValue, forKey: .bundleType)
        }
        if let computeType = self.computeType {
            try encodeContainer.encode(computeType, forKey: .computeType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let rootStorage = self.rootStorage {
            try encodeContainer.encode(rootStorage, forKey: .rootStorage)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userStorage = self.userStorage {
            try encodeContainer.encode(userStorage, forKey: .userStorage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let rootStorageDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.RootStorage.self, forKey: .rootStorage)
        rootStorage = rootStorageDecoded
        let userStorageDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.UserStorage.self, forKey: .userStorage)
        userStorage = userStorageDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceBundleState.self, forKey: .state)
        state = stateDecoded
        let bundleTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.BundleType.self, forKey: .bundleType)
        bundleType = bundleTypeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace bundle.
    public struct WorkspaceBundle: Swift.Equatable {
        /// The identifier of the bundle.
        public var bundleId: Swift.String?
        /// The type of WorkSpace bundle.
        public var bundleType: WorkSpacesClientTypes.BundleType?
        /// The compute type of the bundle. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles).
        public var computeType: WorkSpacesClientTypes.ComputeType?
        /// The time when the bundle was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the bundle.
        public var description: Swift.String?
        /// The identifier of the image that was used to create the bundle.
        public var imageId: Swift.String?
        /// The last time that the bundle was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the bundle.
        public var name: Swift.String?
        /// The owner of the bundle. This is the account identifier of the owner, or AMAZON if the bundle is provided by Amazon Web Services.
        public var owner: Swift.String?
        /// The size of the root volume.
        public var rootStorage: WorkSpacesClientTypes.RootStorage?
        /// The state of the WorkSpace bundle.
        public var state: WorkSpacesClientTypes.WorkspaceBundleState?
        /// The size of the user volume.
        public var userStorage: WorkSpacesClientTypes.UserStorage?

        public init(
            bundleId: Swift.String? = nil,
            bundleType: WorkSpacesClientTypes.BundleType? = nil,
            computeType: WorkSpacesClientTypes.ComputeType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            imageId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            rootStorage: WorkSpacesClientTypes.RootStorage? = nil,
            state: WorkSpacesClientTypes.WorkspaceBundleState? = nil,
            userStorage: WorkSpacesClientTypes.UserStorage? = nil
        )
        {
            self.bundleId = bundleId
            self.bundleType = bundleType
            self.computeType = computeType
            self.creationTime = creationTime
            self.description = description
            self.imageId = imageId
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.owner = owner
            self.rootStorage = rootStorage
            self.state = state
            self.userStorage = userStorage
        }
    }

}

extension WorkSpacesClientTypes {
    public enum WorkspaceBundleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case error
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceBundleState] {
            return [
                .available,
                .error,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceBundleState(rawValue: rawValue) ?? WorkspaceBundleState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.WorkspaceConnectionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionState = "ConnectionState"
        case connectionStateCheckTimestamp = "ConnectionStateCheckTimestamp"
        case lastKnownUserConnectionTimestamp = "LastKnownUserConnectionTimestamp"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionState = self.connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let connectionStateCheckTimestamp = self.connectionStateCheckTimestamp {
            try encodeContainer.encodeTimestamp(connectionStateCheckTimestamp, format: .epochSeconds, forKey: .connectionStateCheckTimestamp)
        }
        if let lastKnownUserConnectionTimestamp = self.lastKnownUserConnectionTimestamp {
            try encodeContainer.encodeTimestamp(lastKnownUserConnectionTimestamp, format: .epochSeconds, forKey: .lastKnownUserConnectionTimestamp)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let connectionStateCheckTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .connectionStateCheckTimestamp)
        connectionStateCheckTimestamp = connectionStateCheckTimestampDecoded
        let lastKnownUserConnectionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastKnownUserConnectionTimestamp)
        lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestampDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the connection status of a WorkSpace.
    public struct WorkspaceConnectionStatus: Swift.Equatable {
        /// The connection state of the WorkSpace. The connection state is unknown if the WorkSpace is stopped.
        public var connectionState: WorkSpacesClientTypes.ConnectionState?
        /// The timestamp of the connection status check.
        public var connectionStateCheckTimestamp: ClientRuntime.Date?
        /// The timestamp of the last known user connection.
        public var lastKnownUserConnectionTimestamp: ClientRuntime.Date?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            connectionState: WorkSpacesClientTypes.ConnectionState? = nil,
            connectionStateCheckTimestamp: ClientRuntime.Date? = nil,
            lastKnownUserConnectionTimestamp: ClientRuntime.Date? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.connectionState = connectionState
            self.connectionStateCheckTimestamp = connectionStateCheckTimestamp
            self.lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestamp
            self.workspaceId = workspaceId
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceCreationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customSecurityGroupId = "CustomSecurityGroupId"
        case defaultOu = "DefaultOu"
        case enableInternetAccess = "EnableInternetAccess"
        case enableMaintenanceMode = "EnableMaintenanceMode"
        case enableWorkDocs = "EnableWorkDocs"
        case userEnabledAsLocalAdministrator = "UserEnabledAsLocalAdministrator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customSecurityGroupId = self.customSecurityGroupId {
            try encodeContainer.encode(customSecurityGroupId, forKey: .customSecurityGroupId)
        }
        if let defaultOu = self.defaultOu {
            try encodeContainer.encode(defaultOu, forKey: .defaultOu)
        }
        if let enableInternetAccess = self.enableInternetAccess {
            try encodeContainer.encode(enableInternetAccess, forKey: .enableInternetAccess)
        }
        if let enableMaintenanceMode = self.enableMaintenanceMode {
            try encodeContainer.encode(enableMaintenanceMode, forKey: .enableMaintenanceMode)
        }
        if let enableWorkDocs = self.enableWorkDocs {
            try encodeContainer.encode(enableWorkDocs, forKey: .enableWorkDocs)
        }
        if let userEnabledAsLocalAdministrator = self.userEnabledAsLocalAdministrator {
            try encodeContainer.encode(userEnabledAsLocalAdministrator, forKey: .userEnabledAsLocalAdministrator)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableWorkDocsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWorkDocs)
        enableWorkDocs = enableWorkDocsDecoded
        let enableInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableInternetAccess)
        enableInternetAccess = enableInternetAccessDecoded
        let defaultOuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOu)
        defaultOu = defaultOuDecoded
        let customSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customSecurityGroupId)
        customSecurityGroupId = customSecurityGroupIdDecoded
        let userEnabledAsLocalAdministratorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userEnabledAsLocalAdministrator)
        userEnabledAsLocalAdministrator = userEnabledAsLocalAdministratorDecoded
        let enableMaintenanceModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMaintenanceMode)
        enableMaintenanceMode = enableMaintenanceModeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the default properties that are used for creating WorkSpaces. For more information, see [Update Directory Details for Your WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html).
    public struct WorkspaceCreationProperties: Swift.Equatable {
        /// The identifier of your custom security group.
        public var customSecurityGroupId: Swift.String?
        /// The default organizational unit (OU) for your WorkSpaces directories. This string must be the full Lightweight Directory Access Protocol (LDAP) distinguished name for the target domain and OU. It must be in the form "OU=value,DC=value,DC=value", where value is any string of characters, and the number of domain components (DCs) is two or more. For example, OU=WorkSpaces_machines,DC=machines,DC=example,DC=com.
        ///
        /// * To avoid errors, certain characters in the distinguished name must be escaped. For more information, see [ Distinguished Names](https://docs.microsoft.com/previous-versions/windows/desktop/ldap/distinguished-names) in the Microsoft documentation.
        ///
        /// * The API doesn't validate whether the OU exists.
        public var defaultOu: Swift.String?
        /// Indicates whether internet access is enabled for your WorkSpaces.
        public var enableInternetAccess: Swift.Bool?
        /// Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see [WorkSpace Maintenance](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html).
        public var enableMaintenanceMode: Swift.Bool?
        /// Indicates whether Amazon WorkDocs is enabled for your WorkSpaces. If WorkDocs is already enabled for a WorkSpaces directory and you disable it, new WorkSpaces launched in the directory will not have WorkDocs enabled. However, WorkDocs remains enabled for any existing WorkSpaces, unless you either disable users' access to WorkDocs or you delete the WorkDocs site. To disable users' access to WorkDocs, see [Disabling Users](https://docs.aws.amazon.com/workdocs/latest/adminguide/inactive-user.html) in the Amazon WorkDocs Administration Guide. To delete a WorkDocs site, see [Deleting a Site](https://docs.aws.amazon.com/workdocs/latest/adminguide/manage-sites.html) in the Amazon WorkDocs Administration Guide. If you enable WorkDocs on a directory that already has existing WorkSpaces, the existing WorkSpaces and any new WorkSpaces that are launched in the directory will have WorkDocs enabled.
        public var enableWorkDocs: Swift.Bool?
        /// Indicates whether users are local administrators of their WorkSpaces.
        public var userEnabledAsLocalAdministrator: Swift.Bool?

        public init(
            customSecurityGroupId: Swift.String? = nil,
            defaultOu: Swift.String? = nil,
            enableInternetAccess: Swift.Bool? = nil,
            enableMaintenanceMode: Swift.Bool? = nil,
            enableWorkDocs: Swift.Bool? = nil,
            userEnabledAsLocalAdministrator: Swift.Bool? = nil
        )
        {
            self.customSecurityGroupId = customSecurityGroupId
            self.defaultOu = defaultOu
            self.enableInternetAccess = enableInternetAccess
            self.enableMaintenanceMode = enableMaintenanceMode
            self.enableWorkDocs = enableWorkDocs
            self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceDirectory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case certificateBasedAuthProperties = "CertificateBasedAuthProperties"
        case customerUserName = "CustomerUserName"
        case directoryId = "DirectoryId"
        case directoryName = "DirectoryName"
        case directoryType = "DirectoryType"
        case dnsIpAddresses = "DnsIpAddresses"
        case iamRoleId = "IamRoleId"
        case registrationCode = "RegistrationCode"
        case samlProperties = "SamlProperties"
        case selfservicePermissions = "SelfservicePermissions"
        case state = "State"
        case subnetIds = "SubnetIds"
        case tenancy = "Tenancy"
        case workspaceAccessProperties = "WorkspaceAccessProperties"
        case workspaceCreationProperties = "WorkspaceCreationProperties"
        case workspaceSecurityGroupId = "WorkspaceSecurityGroupId"
        case ipGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let certificateBasedAuthProperties = self.certificateBasedAuthProperties {
            try encodeContainer.encode(certificateBasedAuthProperties, forKey: .certificateBasedAuthProperties)
        }
        if let customerUserName = self.customerUserName {
            try encodeContainer.encode(customerUserName, forKey: .customerUserName)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let directoryName = self.directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let directoryType = self.directoryType {
            try encodeContainer.encode(directoryType.rawValue, forKey: .directoryType)
        }
        if let dnsIpAddresses = dnsIpAddresses {
            var dnsIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddresses)
            for ipaddress0 in dnsIpAddresses {
                try dnsIpAddressesContainer.encode(ipaddress0)
            }
        }
        if let iamRoleId = self.iamRoleId {
            try encodeContainer.encode(iamRoleId, forKey: .iamRoleId)
        }
        if let registrationCode = self.registrationCode {
            try encodeContainer.encode(registrationCode, forKey: .registrationCode)
        }
        if let samlProperties = self.samlProperties {
            try encodeContainer.encode(samlProperties, forKey: .samlProperties)
        }
        if let selfservicePermissions = self.selfservicePermissions {
            try encodeContainer.encode(selfservicePermissions, forKey: .selfservicePermissions)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let tenancy = self.tenancy {
            try encodeContainer.encode(tenancy.rawValue, forKey: .tenancy)
        }
        if let workspaceAccessProperties = self.workspaceAccessProperties {
            try encodeContainer.encode(workspaceAccessProperties, forKey: .workspaceAccessProperties)
        }
        if let workspaceCreationProperties = self.workspaceCreationProperties {
            try encodeContainer.encode(workspaceCreationProperties, forKey: .workspaceCreationProperties)
        }
        if let workspaceSecurityGroupId = self.workspaceSecurityGroupId {
            try encodeContainer.encode(workspaceSecurityGroupId, forKey: .workspaceSecurityGroupId)
        }
        if let ipGroupIds = ipGroupIds {
            var ipGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipGroupIds)
            for ipgroupid0 in ipGroupIds {
                try ipGroupIdsContainer.encode(ipgroupid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let registrationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationCode)
        registrationCode = registrationCodeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let dnsIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIpAddresses)
        var dnsIpAddressesDecoded0:[Swift.String]? = nil
        if let dnsIpAddressesContainer = dnsIpAddressesContainer {
            dnsIpAddressesDecoded0 = [Swift.String]()
            for string0 in dnsIpAddressesContainer {
                if let string0 = string0 {
                    dnsIpAddressesDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddresses = dnsIpAddressesDecoded0
        let customerUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerUserName)
        customerUserName = customerUserNameDecoded
        let iamRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleId)
        iamRoleId = iamRoleIdDecoded
        let directoryTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceDirectoryType.self, forKey: .directoryType)
        directoryType = directoryTypeDecoded
        let workspaceSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceSecurityGroupId)
        workspaceSecurityGroupId = workspaceSecurityGroupIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceDirectoryState.self, forKey: .state)
        state = stateDecoded
        let workspaceCreationPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultWorkspaceCreationProperties.self, forKey: .workspaceCreationProperties)
        workspaceCreationProperties = workspaceCreationPropertiesDecoded
        let ipGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipGroupIds)
        var ipGroupIdsDecoded0:[Swift.String]? = nil
        if let ipGroupIdsContainer = ipGroupIdsContainer {
            ipGroupIdsDecoded0 = [Swift.String]()
            for string0 in ipGroupIdsContainer {
                if let string0 = string0 {
                    ipGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ipGroupIds = ipGroupIdsDecoded0
        let workspaceAccessPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceAccessProperties.self, forKey: .workspaceAccessProperties)
        workspaceAccessProperties = workspaceAccessPropertiesDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.Tenancy.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let selfservicePermissionsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.SelfservicePermissions.self, forKey: .selfservicePermissions)
        selfservicePermissions = selfservicePermissionsDecoded
        let samlPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.SamlProperties.self, forKey: .samlProperties)
        samlProperties = samlPropertiesDecoded
        let certificateBasedAuthPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.CertificateBasedAuthProperties.self, forKey: .certificateBasedAuthProperties)
        certificateBasedAuthProperties = certificateBasedAuthPropertiesDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a directory that is used with Amazon WorkSpaces.
    public struct WorkspaceDirectory: Swift.Equatable {
        /// The directory alias.
        public var alias: Swift.String?
        /// The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory for WorkSpaces login.
        public var certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties?
        /// The user name for the service account.
        public var customerUserName: Swift.String?
        /// The directory identifier.
        public var directoryId: Swift.String?
        /// The name of the directory.
        public var directoryName: Swift.String?
        /// The directory type.
        public var directoryType: WorkSpacesClientTypes.WorkspaceDirectoryType?
        /// The IP addresses of the DNS servers for the directory.
        public var dnsIpAddresses: [Swift.String]?
        /// The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.
        public var iamRoleId: Swift.String?
        /// The identifiers of the IP access control groups associated with the directory.
        public var ipGroupIds: [Swift.String]?
        /// The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.
        public var registrationCode: Swift.String?
        /// Describes the enablement status, user access URL, and relay state parameter name that are used for configuring federation with an SAML 2.0 identity provider.
        public var samlProperties: WorkSpacesClientTypes.SamlProperties?
        /// The default self-service permissions for WorkSpaces in the directory.
        public var selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions?
        /// The state of the directory's registration with Amazon WorkSpaces. After a directory is deregistered, the DEREGISTERED state is returned very briefly before the directory metadata is cleaned up, so this state is rarely returned. To confirm that a directory is deregistered, check for the directory ID by using [ DescribeWorkspaceDirectories](https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaceDirectories.html). If the directory ID isn't returned, then the directory has been successfully deregistered.
        public var state: WorkSpacesClientTypes.WorkspaceDirectoryState?
        /// The identifiers of the subnets used with the directory.
        public var subnetIds: [Swift.String]?
        /// Specifies whether the directory is dedicated or shared. To use Bring Your Own License (BYOL), this value must be set to DEDICATED. For more information, see [Bring Your Own Windows Desktop Images](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
        public var tenancy: WorkSpacesClientTypes.Tenancy?
        /// The devices and operating systems that users can use to access WorkSpaces.
        public var workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties?
        /// The default creation properties for all WorkSpaces in the directory.
        public var workspaceCreationProperties: WorkSpacesClientTypes.DefaultWorkspaceCreationProperties?
        /// The identifier of the security group that is assigned to new WorkSpaces.
        public var workspaceSecurityGroupId: Swift.String?

        public init(
            alias: Swift.String? = nil,
            certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties? = nil,
            customerUserName: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            directoryName: Swift.String? = nil,
            directoryType: WorkSpacesClientTypes.WorkspaceDirectoryType? = nil,
            dnsIpAddresses: [Swift.String]? = nil,
            iamRoleId: Swift.String? = nil,
            ipGroupIds: [Swift.String]? = nil,
            registrationCode: Swift.String? = nil,
            samlProperties: WorkSpacesClientTypes.SamlProperties? = nil,
            selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions? = nil,
            state: WorkSpacesClientTypes.WorkspaceDirectoryState? = nil,
            subnetIds: [Swift.String]? = nil,
            tenancy: WorkSpacesClientTypes.Tenancy? = nil,
            workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties? = nil,
            workspaceCreationProperties: WorkSpacesClientTypes.DefaultWorkspaceCreationProperties? = nil,
            workspaceSecurityGroupId: Swift.String? = nil
        )
        {
            self.alias = alias
            self.certificateBasedAuthProperties = certificateBasedAuthProperties
            self.customerUserName = customerUserName
            self.directoryId = directoryId
            self.directoryName = directoryName
            self.directoryType = directoryType
            self.dnsIpAddresses = dnsIpAddresses
            self.iamRoleId = iamRoleId
            self.ipGroupIds = ipGroupIds
            self.registrationCode = registrationCode
            self.samlProperties = samlProperties
            self.selfservicePermissions = selfservicePermissions
            self.state = state
            self.subnetIds = subnetIds
            self.tenancy = tenancy
            self.workspaceAccessProperties = workspaceAccessProperties
            self.workspaceCreationProperties = workspaceCreationProperties
            self.workspaceSecurityGroupId = workspaceSecurityGroupId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum WorkspaceDirectoryState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deregistered
        case deregistering
        case error
        case registered
        case registering
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceDirectoryState] {
            return [
                .deregistered,
                .deregistering,
                .error,
                .registered,
                .registering,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deregistered: return "DEREGISTERED"
            case .deregistering: return "DEREGISTERING"
            case .error: return "ERROR"
            case .registered: return "REGISTERED"
            case .registering: return "REGISTERING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceDirectoryState(rawValue: rawValue) ?? WorkspaceDirectoryState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum WorkspaceDirectoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adConnector
        case simpleAd
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceDirectoryType] {
            return [
                .adConnector,
                .simpleAd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adConnector: return "AD_CONNECTOR"
            case .simpleAd: return "SIMPLE_AD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceDirectoryType(rawValue: rawValue) ?? WorkspaceDirectoryType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.WorkspaceImage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case description = "Description"
        case errorCode = "ErrorCode"
        case errorDetails = "ErrorDetails"
        case errorMessage = "ErrorMessage"
        case imageId = "ImageId"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case ownerAccountId = "OwnerAccountId"
        case requiredTenancy = "RequiredTenancy"
        case state = "State"
        case updates = "Updates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorDetails = errorDetails {
            var errorDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorDetails)
            for errordetails0 in errorDetails {
                try errorDetailsContainer.encode(errordetails0)
            }
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operatingSystem = self.operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let requiredTenancy = self.requiredTenancy {
            try encodeContainer.encode(requiredTenancy.rawValue, forKey: .requiredTenancy)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let updates = self.updates {
            try encodeContainer.encode(updates, forKey: .updates)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageState.self, forKey: .state)
        state = stateDecoded
        let requiredTenancyDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageRequiredTenancy.self, forKey: .requiredTenancy)
        requiredTenancy = requiredTenancyDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let updatesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.UpdateResult.self, forKey: .updates)
        updates = updatesDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ErrorDetails?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[WorkSpacesClientTypes.ErrorDetails]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [WorkSpacesClientTypes.ErrorDetails]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace image.
    public struct WorkspaceImage: Swift.Equatable {
        /// The date when the image was created. If the image has been shared, the Amazon Web Services account that the image has been shared with sees the original creation date of the image.
        public var created: ClientRuntime.Date?
        /// The description of the image.
        public var description: Swift.String?
        /// The error code that is returned for the image.
        public var errorCode: Swift.String?
        /// Additional details of the error returned for the image, including the possible causes of the errors and troubleshooting information.
        public var errorDetails: [WorkSpacesClientTypes.ErrorDetails]?
        /// The text of the error message that is returned for the image.
        public var errorMessage: Swift.String?
        /// The identifier of the image.
        public var imageId: Swift.String?
        /// The name of the image.
        public var name: Swift.String?
        /// The operating system that the image is running.
        public var operatingSystem: WorkSpacesClientTypes.OperatingSystem?
        /// The identifier of the Amazon Web Services account that owns the image.
        public var ownerAccountId: Swift.String?
        /// Specifies whether the image is running on dedicated hardware. When Bring Your Own License (BYOL) is enabled, this value is set to DEDICATED. For more information, see [Bring Your Own Windows Desktop Images](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
        public var requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy?
        /// The status of the image.
        public var state: WorkSpacesClientTypes.WorkspaceImageState?
        /// The updates (if any) that are available for the specified image.
        public var updates: WorkSpacesClientTypes.UpdateResult?

        public init(
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorDetails: [WorkSpacesClientTypes.ErrorDetails]? = nil,
            errorMessage: Swift.String? = nil,
            imageId: Swift.String? = nil,
            name: Swift.String? = nil,
            operatingSystem: WorkSpacesClientTypes.OperatingSystem? = nil,
            ownerAccountId: Swift.String? = nil,
            requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy? = nil,
            state: WorkSpacesClientTypes.WorkspaceImageState? = nil,
            updates: WorkSpacesClientTypes.UpdateResult? = nil
        )
        {
            self.created = created
            self.description = description
            self.errorCode = errorCode
            self.errorDetails = errorDetails
            self.errorMessage = errorMessage
            self.imageId = imageId
            self.name = name
            self.operatingSystem = operatingSystem
            self.ownerAccountId = ownerAccountId
            self.requiredTenancy = requiredTenancy
            self.state = state
            self.updates = updates
        }
    }

}

extension WorkSpacesClientTypes {
    public enum WorkspaceImageErrorDetailCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case additionalDrivesAttached
        case antiVirusInstalled
        case autoLogonEnabled
        case autoMountDisabled
        case azureDomainJoined
        case dhcpDisabled
        case diskFreeSpace
        case diskSizeExceeded
        case domainJoined
        case firewallEnabled
        case incompatiblePartitioning
        case inPlaceUpgrade
        case multipleBootPartition
        case officeInstalled
        case osNotSupported
        case outdatedPowershellVersion
        case pcoipAgentInstalled
        case pendingReboot
        case realtimeUniversalDisabled
        case sixtyFourBitOs
        case uefiNotSupported
        case vmwareToolsInstalled
        case windowsUpdatesEnabled
        case workspacesByolAccountDisabled
        case workspacesByolAccountNotFound
        case zeroRearmCount
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageErrorDetailCode] {
            return [
                .additionalDrivesAttached,
                .antiVirusInstalled,
                .autoLogonEnabled,
                .autoMountDisabled,
                .azureDomainJoined,
                .dhcpDisabled,
                .diskFreeSpace,
                .diskSizeExceeded,
                .domainJoined,
                .firewallEnabled,
                .incompatiblePartitioning,
                .inPlaceUpgrade,
                .multipleBootPartition,
                .officeInstalled,
                .osNotSupported,
                .outdatedPowershellVersion,
                .pcoipAgentInstalled,
                .pendingReboot,
                .realtimeUniversalDisabled,
                .sixtyFourBitOs,
                .uefiNotSupported,
                .vmwareToolsInstalled,
                .windowsUpdatesEnabled,
                .workspacesByolAccountDisabled,
                .workspacesByolAccountNotFound,
                .zeroRearmCount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .additionalDrivesAttached: return "AdditionalDrivesAttached"
            case .antiVirusInstalled: return "AntiVirusInstalled"
            case .autoLogonEnabled: return "AutoLogonEnabled"
            case .autoMountDisabled: return "AutoMountDisabled"
            case .azureDomainJoined: return "AzureDomainJoined"
            case .dhcpDisabled: return "DHCPDisabled"
            case .diskFreeSpace: return "DiskFreeSpace"
            case .diskSizeExceeded: return "DiskSizeExceeded"
            case .domainJoined: return "DomainJoined"
            case .firewallEnabled: return "FirewallEnabled"
            case .incompatiblePartitioning: return "IncompatiblePartitioning"
            case .inPlaceUpgrade: return "InPlaceUpgrade"
            case .multipleBootPartition: return "MultipleBootPartition"
            case .officeInstalled: return "OfficeInstalled"
            case .osNotSupported: return "OSNotSupported"
            case .outdatedPowershellVersion: return "OutdatedPowershellVersion"
            case .pcoipAgentInstalled: return "PCoIPAgentInstalled"
            case .pendingReboot: return "PendingReboot"
            case .realtimeUniversalDisabled: return "RealTimeUniversalDisabled"
            case .sixtyFourBitOs: return "Requires64BitOS"
            case .uefiNotSupported: return "UEFINotSupported"
            case .vmwareToolsInstalled: return "VMWareToolsInstalled"
            case .windowsUpdatesEnabled: return "WindowsUpdatesEnabled"
            case .workspacesByolAccountDisabled: return "WorkspacesBYOLAccountDisabled"
            case .workspacesByolAccountNotFound: return "WorkspacesBYOLAccountNotFound"
            case .zeroRearmCount: return "ZeroRearmCount"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceImageErrorDetailCode(rawValue: rawValue) ?? WorkspaceImageErrorDetailCode.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum WorkspaceImageIngestionProcess: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case byolGraphics
        case byolGraphicspro
        case byolGraphicsG4dn
        case byolGraphicsG4dnByop
        case byolRegular
        case byolRegularByop
        case byolRegularWsp
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageIngestionProcess] {
            return [
                .byolGraphics,
                .byolGraphicspro,
                .byolGraphicsG4dn,
                .byolGraphicsG4dnByop,
                .byolRegular,
                .byolRegularByop,
                .byolRegularWsp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .byolGraphics: return "BYOL_GRAPHICS"
            case .byolGraphicspro: return "BYOL_GRAPHICSPRO"
            case .byolGraphicsG4dn: return "BYOL_GRAPHICS_G4DN"
            case .byolGraphicsG4dnByop: return "BYOL_GRAPHICS_G4DN_BYOP"
            case .byolRegular: return "BYOL_REGULAR"
            case .byolRegularByop: return "BYOL_REGULAR_BYOP"
            case .byolRegularWsp: return "BYOL_REGULAR_WSP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceImageIngestionProcess(rawValue: rawValue) ?? WorkspaceImageIngestionProcess.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum WorkspaceImageRequiredTenancy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dedicated
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageRequiredTenancy] {
            return [
                .dedicated,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "DEDICATED"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceImageRequiredTenancy(rawValue: rawValue) ?? WorkspaceImageRequiredTenancy.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum WorkspaceImageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case error
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageState] {
            return [
                .available,
                .error,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceImageState(rawValue: rawValue) ?? WorkspaceImageState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.WorkspaceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeTypeName = "ComputeTypeName"
        case operatingSystemName = "OperatingSystemName"
        case protocols = "Protocols"
        case rootVolumeSizeGib = "RootVolumeSizeGib"
        case runningMode = "RunningMode"
        case runningModeAutoStopTimeoutInMinutes = "RunningModeAutoStopTimeoutInMinutes"
        case userVolumeSizeGib = "UserVolumeSizeGib"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeTypeName = self.computeTypeName {
            try encodeContainer.encode(computeTypeName.rawValue, forKey: .computeTypeName)
        }
        if let operatingSystemName = self.operatingSystemName {
            try encodeContainer.encode(operatingSystemName.rawValue, forKey: .operatingSystemName)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocol0 in protocols {
                try protocolsContainer.encode(protocol0.rawValue)
            }
        }
        if let rootVolumeSizeGib = self.rootVolumeSizeGib {
            try encodeContainer.encode(rootVolumeSizeGib, forKey: .rootVolumeSizeGib)
        }
        if let runningMode = self.runningMode {
            try encodeContainer.encode(runningMode.rawValue, forKey: .runningMode)
        }
        if let runningModeAutoStopTimeoutInMinutes = self.runningModeAutoStopTimeoutInMinutes {
            try encodeContainer.encode(runningModeAutoStopTimeoutInMinutes, forKey: .runningModeAutoStopTimeoutInMinutes)
        }
        if let userVolumeSizeGib = self.userVolumeSizeGib {
            try encodeContainer.encode(userVolumeSizeGib, forKey: .userVolumeSizeGib)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runningModeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.RunningMode.self, forKey: .runningMode)
        runningMode = runningModeDecoded
        let runningModeAutoStopTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .runningModeAutoStopTimeoutInMinutes)
        runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutesDecoded
        let rootVolumeSizeGibDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rootVolumeSizeGib)
        rootVolumeSizeGib = rootVolumeSizeGibDecoded
        let userVolumeSizeGibDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userVolumeSizeGib)
        userVolumeSizeGib = userVolumeSizeGibDecoded
        let computeTypeNameDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.Compute.self, forKey: .computeTypeName)
        computeTypeName = computeTypeNameDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[WorkSpacesClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [WorkSpacesClientTypes.ModelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let operatingSystemNameDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.OperatingSystemName.self, forKey: .operatingSystemName)
        operatingSystemName = operatingSystemNameDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace.
    public struct WorkspaceProperties: Swift.Equatable {
        /// The compute type. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles).
        public var computeTypeName: WorkSpacesClientTypes.Compute?
        /// The name of the operating system.
        public var operatingSystemName: WorkSpacesClientTypes.OperatingSystemName?
        /// The protocol. For more information, see [ Protocols for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-protocols.html).
        ///
        /// * Only available for WorkSpaces created with PCoIP bundles.
        ///
        /// * The Protocols property is case sensitive. Ensure you use PCOIP or WSP.
        ///
        /// * Unavailable for Windows 7 WorkSpaces and WorkSpaces using GPU-based bundles (Graphics, GraphicsPro, Graphics.g4dn, and GraphicsPro.g4dn).
        public var protocols: [WorkSpacesClientTypes.ModelProtocol]?
        /// The size of the root volume. For important information about how to modify the size of the root and user volumes, see [Modify a WorkSpace](https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html).
        public var rootVolumeSizeGib: Swift.Int?
        /// The running mode. For more information, see [Manage the WorkSpace Running Mode](https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html).
        ///
        /// * The MANUAL value is only supported by Amazon WorkSpaces Core. Contact your account team to be allow-listed to use this value. For more information, see [Amazon WorkSpaces Core](http://aws.amazon.com/workspaces/core/).
        ///
        /// * Ensure you review your running mode to ensure you are using a running mode that is optimal for your needs and budget. For more information on switching running modes, see [ Can I switch between hourly and monthly billing?](https://aws.amazon.com/workspaces/faqs/#:~:text=Q%3A%20Can%20I%20switch%20between%20hourly%20and%20monthly%20billing%3F)
        public var runningMode: WorkSpacesClientTypes.RunningMode?
        /// The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.
        public var runningModeAutoStopTimeoutInMinutes: Swift.Int?
        /// The size of the user storage. For important information about how to modify the size of the root and user volumes, see [Modify a WorkSpace](https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html).
        public var userVolumeSizeGib: Swift.Int?

        public init(
            computeTypeName: WorkSpacesClientTypes.Compute? = nil,
            operatingSystemName: WorkSpacesClientTypes.OperatingSystemName? = nil,
            protocols: [WorkSpacesClientTypes.ModelProtocol]? = nil,
            rootVolumeSizeGib: Swift.Int? = nil,
            runningMode: WorkSpacesClientTypes.RunningMode? = nil,
            runningModeAutoStopTimeoutInMinutes: Swift.Int? = nil,
            userVolumeSizeGib: Swift.Int? = nil
        )
        {
            self.computeTypeName = computeTypeName
            self.operatingSystemName = operatingSystemName
            self.protocols = protocols
            self.rootVolumeSizeGib = rootVolumeSizeGib
            self.runningMode = runningMode
            self.runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutes
            self.userVolumeSizeGib = userVolumeSizeGib
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case directoryId = "DirectoryId"
        case rootVolumeEncryptionEnabled = "RootVolumeEncryptionEnabled"
        case tags = "Tags"
        case userName = "UserName"
        case userVolumeEncryptionEnabled = "UserVolumeEncryptionEnabled"
        case volumeEncryptionKey = "VolumeEncryptionKey"
        case workspaceProperties = "WorkspaceProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let rootVolumeEncryptionEnabled = self.rootVolumeEncryptionEnabled {
            try encodeContainer.encode(rootVolumeEncryptionEnabled, forKey: .rootVolumeEncryptionEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userVolumeEncryptionEnabled = self.userVolumeEncryptionEnabled {
            try encodeContainer.encode(userVolumeEncryptionEnabled, forKey: .userVolumeEncryptionEnabled)
        }
        if let volumeEncryptionKey = self.volumeEncryptionKey {
            try encodeContainer.encode(volumeEncryptionKey, forKey: .volumeEncryptionKey)
        }
        if let workspaceProperties = self.workspaceProperties {
            try encodeContainer.encode(workspaceProperties, forKey: .workspaceProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let volumeEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeEncryptionKey)
        volumeEncryptionKey = volumeEncryptionKeyDecoded
        let userVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userVolumeEncryptionEnabled)
        userVolumeEncryptionEnabled = userVolumeEncryptionEnabledDecoded
        let rootVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rootVolumeEncryptionEnabled)
        rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabledDecoded
        let workspacePropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceProperties.self, forKey: .workspaceProperties)
        workspaceProperties = workspacePropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to create a WorkSpace.
    public struct WorkspaceRequest: Swift.Equatable {
        /// The identifier of the bundle for the WorkSpace. You can use [DescribeWorkspaceBundles] to list the available bundles.
        /// This member is required.
        public var bundleId: Swift.String?
        /// The identifier of the Directory Service directory for the WorkSpace. You can use [DescribeWorkspaceDirectories] to list the available directories.
        /// This member is required.
        public var directoryId: Swift.String?
        /// Indicates whether the data stored on the root volume is encrypted.
        public var rootVolumeEncryptionEnabled: Swift.Bool?
        /// The tags for the WorkSpace.
        public var tags: [WorkSpacesClientTypes.Tag]?
        /// The user name of the user for the WorkSpace. This user name must exist in the Directory Service directory for the WorkSpace.
        /// This member is required.
        public var userName: Swift.String?
        /// Indicates whether the data stored on the user volume is encrypted.
        public var userVolumeEncryptionEnabled: Swift.Bool?
        /// The ARN of the symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.
        public var volumeEncryptionKey: Swift.String?
        /// The WorkSpace properties.
        public var workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?

        public init(
            bundleId: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            rootVolumeEncryptionEnabled: Swift.Bool? = nil,
            tags: [WorkSpacesClientTypes.Tag]? = nil,
            userName: Swift.String? = nil,
            userVolumeEncryptionEnabled: Swift.Bool? = nil,
            volumeEncryptionKey: Swift.String? = nil,
            workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties? = nil
        )
        {
            self.bundleId = bundleId
            self.directoryId = directoryId
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.tags = tags
            self.userName = userName
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.volumeEncryptionKey = volumeEncryptionKey
            self.workspaceProperties = workspaceProperties
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceResourceAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceId = "AssociatedResourceId"
        case associatedResourceType = "AssociatedResourceType"
        case created = "Created"
        case lastUpdatedTime = "LastUpdatedTime"
        case state = "State"
        case stateReason = "StateReason"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedResourceId = self.associatedResourceId {
            try encodeContainer.encode(associatedResourceId, forKey: .associatedResourceId)
        }
        if let associatedResourceType = self.associatedResourceType {
            try encodeContainer.encode(associatedResourceType.rawValue, forKey: .associatedResourceType)
        }
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = self.stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedResourceId)
        associatedResourceId = associatedResourceIdDecoded
        let associatedResourceTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkSpaceAssociatedResourceType.self, forKey: .associatedResourceType)
        associatedResourceType = associatedResourceTypeDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AssociationState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AssociationStateReason.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the association between an application and a WorkSpace resource.
    public struct WorkspaceResourceAssociation: Swift.Equatable {
        /// The identifier of the associated resource.
        public var associatedResourceId: Swift.String?
        /// The resource types of the associated resource.
        public var associatedResourceType: WorkSpacesClientTypes.WorkSpaceAssociatedResourceType?
        /// The time the association is created.
        public var created: ClientRuntime.Date?
        /// The time the association status was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The status of the WorkSpace resource association.
        public var state: WorkSpacesClientTypes.AssociationState?
        /// The reason the association deployment failed.
        public var stateReason: WorkSpacesClientTypes.AssociationStateReason?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init(
            associatedResourceId: Swift.String? = nil,
            associatedResourceType: WorkSpacesClientTypes.WorkSpaceAssociatedResourceType? = nil,
            created: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            state: WorkSpacesClientTypes.AssociationState? = nil,
            stateReason: WorkSpacesClientTypes.AssociationStateReason? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.associatedResourceId = associatedResourceId
            self.associatedResourceType = associatedResourceType
            self.created = created
            self.lastUpdatedTime = lastUpdatedTime
            self.state = state
            self.stateReason = stateReason
            self.workspaceId = workspaceId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum WorkspaceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adminMaintenance
        case available
        case error
        case impaired
        case maintenance
        case pending
        case rebooting
        case rebuilding
        case restoring
        case starting
        case stopped
        case stopping
        case suspended
        case terminated
        case terminating
        case unhealthy
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceState] {
            return [
                .adminMaintenance,
                .available,
                .error,
                .impaired,
                .maintenance,
                .pending,
                .rebooting,
                .rebuilding,
                .restoring,
                .starting,
                .stopped,
                .stopping,
                .suspended,
                .terminated,
                .terminating,
                .unhealthy,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adminMaintenance: return "ADMIN_MAINTENANCE"
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .impaired: return "IMPAIRED"
            case .maintenance: return "MAINTENANCE"
            case .pending: return "PENDING"
            case .rebooting: return "REBOOTING"
            case .rebuilding: return "REBUILDING"
            case .restoring: return "RESTORING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .suspended: return "SUSPENDED"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case .unhealthy: return "UNHEALTHY"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceState(rawValue: rawValue) ?? WorkspaceState.sdkUnknown(rawValue)
        }
    }
}

extension WorkspacesDefaultRoleNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: WorkspacesDefaultRoleNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The workspaces_DefaultRole role could not be found. If this is the first time you are registering a directory, you will need to create the workspaces_DefaultRole role before you can register a directory. For more information, see [Creating the workspaces_DefaultRole Role](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-access-control.html#create-default-role).
public struct WorkspacesDefaultRoleNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "WorkspacesDefaultRoleNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct WorkspacesDefaultRoleNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension WorkspacesDefaultRoleNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesClientTypes.WorkspacesIpGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupDesc
        case groupId
        case groupName
        case userRules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupDesc = self.groupDesc {
            try encodeContainer.encode(groupDesc, forKey: .groupDesc)
        }
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for ipruleitem0 in userRules {
                try userRulesContainer.encode(ipruleitem0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDescDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupDesc)
        groupDesc = groupDescDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[WorkSpacesClientTypes.IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [WorkSpacesClientTypes.IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes an IP access control group.
    public struct WorkspacesIpGroup: Swift.Equatable {
        /// The description of the group.
        public var groupDesc: Swift.String?
        /// The identifier of the group.
        public var groupId: Swift.String?
        /// The name of the group.
        public var groupName: Swift.String?
        /// The rules.
        public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

        public init(
            groupDesc: Swift.String? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
        )
        {
            self.groupDesc = groupDesc
            self.groupId = groupId
            self.groupName = groupName
            self.userRules = userRules
        }
    }

}
