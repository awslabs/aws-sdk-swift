//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WisdomClientTypes {
    /// Configuration information for Amazon AppIntegrations to automatically ingest content.
    public struct AppIntegrationsConfiguration {
        /// The Amazon Resource Name (ARN) of the AppIntegrations DataIntegration to use for ingesting content.
        ///
        /// * For [ Salesforce](https://developer.salesforce.com/docs/atlas.en-us.knowledge_dev.meta/knowledge_dev/sforce_api_objects_knowledge__kav.htm), your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted as source fields.
        ///
        /// * For [ ServiceNow](https://developer.servicenow.com/dev.do#!/reference/api/rome/rest/knowledge-management-api), your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least number, short_description, sys_mod_count, workflow_state, and active as source fields.
        ///
        /// * For [ Zendesk](https://developer.zendesk.com/api-reference/help_center/help-center-api/articles/), your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least id, title, updated_at, and draft as source fields.
        ///
        /// * For [SharePoint](https://learn.microsoft.com/en-us/sharepoint/dev/sp-add-ins/sharepoint-net-server-csom-jsom-and-rest-api-index), your AppIntegrations DataIntegration must have a FileConfiguration, including only file extensions that are among docx, pdf, html, htm, and txt.
        ///
        /// * For [Amazon S3](https://aws.amazon.com/s3/), the ObjectConfiguration and FileConfiguration of your AppIntegrations DataIntegration must be null. The SourceURI of your DataIntegration must use the following format: s3://your_s3_bucket_name. The bucket policy of the corresponding S3 bucket must allow the Amazon Web Services principal app-integrations.amazonaws.com to perform s3:ListBucket, s3:GetObject, and s3:GetBucketLocation against the bucket.
        /// This member is required.
        public var appIntegrationArn: Swift.String?
        /// The fields from the source that are made available to your agents in Wisdom. Optional if ObjectConfiguration is included in the provided DataIntegration.
        ///
        /// * For [ Salesforce](https://developer.salesforce.com/docs/atlas.en-us.knowledge_dev.meta/knowledge_dev/sforce_api_objects_knowledge__kav.htm), you must include at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted.
        ///
        /// * For [ ServiceNow](https://developer.servicenow.com/dev.do#!/reference/api/rome/rest/knowledge-management-api), you must include at least number, short_description, sys_mod_count, workflow_state, and active.
        ///
        /// * For [ Zendesk](https://developer.zendesk.com/api-reference/help_center/help-center-api/articles/), you must include at least id, title, updated_at, and draft.
        ///
        ///
        /// Make sure to include additional fields. These fields are indexed and used to source recommendations.
        public var objectFields: [Swift.String]?

        public init(
            appIntegrationArn: Swift.String? = nil,
            objectFields: [Swift.String]? = nil
        )
        {
            self.appIntegrationArn = appIntegrationArn
            self.objectFields = objectFields
        }
    }

}

/// The request could not be processed because of conflict in the current state of the resource. For example, if you're using a Create API (such as CreateAssistant) that accepts name, a conflicting resource (usually with the same name) is being created or mutated.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The specified resource name.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

/// You've exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use service quotas to request a service quota increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints specified by a service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WisdomClientTypes {
    /// The data that is input into Wisdom as a result of the assistant association.
    public enum AssistantAssociationInputData {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.
        case knowledgebaseid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension WisdomClientTypes {

    public enum AssociationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationType] {
            return [
                .knowledgeBase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAssistantAssociationInput {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifier of the associated resource.
    /// This member is required.
    public var association: WisdomClientTypes.AssistantAssociationInputData?
    /// The type of association.
    /// This member is required.
    public var associationType: WisdomClientTypes.AssociationType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        assistantId: Swift.String? = nil,
        association: WisdomClientTypes.AssistantAssociationInputData? = nil,
        associationType: WisdomClientTypes.AssociationType? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.assistantId = assistantId
        self.association = association
        self.associationType = associationType
        self.clientToken = clientToken
        self.tags = tags
    }
}

extension WisdomClientTypes {
    /// Association information about the knowledge base.
    public struct KnowledgeBaseAssociationData {
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.
        public var knowledgeBaseId: Swift.String?

        public init(
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil
        )
        {
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }
    }

}

extension WisdomClientTypes {
    /// The data that is output as a result of the assistant association.
    public enum AssistantAssociationOutputData {
        /// The knowledge base where output data is sent.
        case knowledgebaseassociation(WisdomClientTypes.KnowledgeBaseAssociationData)
        case sdkUnknown(Swift.String)
    }

}

extension WisdomClientTypes {
    /// Information about the assistant association.
    public struct AssistantAssociationData {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the assistant association.
        /// This member is required.
        public var assistantAssociationArn: Swift.String?
        /// The identifier of the assistant association.
        /// This member is required.
        public var assistantAssociationId: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// A union type that currently has a single argument, the knowledge base ID.
        /// This member is required.
        public var associationData: WisdomClientTypes.AssistantAssociationOutputData?
        /// The type of association.
        /// This member is required.
        public var associationType: WisdomClientTypes.AssociationType?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            assistantArn: Swift.String? = nil,
            assistantAssociationArn: Swift.String? = nil,
            assistantAssociationId: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            associationData: WisdomClientTypes.AssistantAssociationOutputData? = nil,
            associationType: WisdomClientTypes.AssociationType? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }
    }

}

public struct CreateAssistantAssociationOutput {
    /// The assistant association.
    public var assistantAssociation: WisdomClientTypes.AssistantAssociationData?

    public init(
        assistantAssociation: WisdomClientTypes.AssistantAssociationData? = nil
    )
    {
        self.assistantAssociation = assistantAssociation
    }
}

public struct DeleteAssistantAssociationInput {
    /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantAssociationId: Swift.String?
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        assistantAssociationId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    )
    {
        self.assistantAssociationId = assistantAssociationId
        self.assistantId = assistantId
    }
}

public struct DeleteAssistantAssociationOutput {

    public init() { }
}

public struct GetAssistantAssociationInput {
    /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantAssociationId: Swift.String?
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        assistantAssociationId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    )
    {
        self.assistantAssociationId = assistantAssociationId
        self.assistantId = assistantId
    }
}

public struct GetAssistantAssociationOutput {
    /// The assistant association.
    public var assistantAssociation: WisdomClientTypes.AssistantAssociationData?

    public init(
        assistantAssociation: WisdomClientTypes.AssistantAssociationData? = nil
    )
    {
        self.assistantAssociation = assistantAssociation
    }
}

public struct ListAssistantAssociationsInput {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WisdomClientTypes {
    /// Summary information about the assistant association.
    public struct AssistantAssociationSummary {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the assistant association.
        /// This member is required.
        public var assistantAssociationArn: Swift.String?
        /// The identifier of the assistant association.
        /// This member is required.
        public var assistantAssociationId: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The association data.
        /// This member is required.
        public var associationData: WisdomClientTypes.AssistantAssociationOutputData?
        /// The type of association.
        /// This member is required.
        public var associationType: WisdomClientTypes.AssociationType?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            assistantArn: Swift.String? = nil,
            assistantAssociationArn: Swift.String? = nil,
            assistantAssociationId: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            associationData: WisdomClientTypes.AssistantAssociationOutputData? = nil,
            associationType: WisdomClientTypes.AssociationType? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }
    }

}

public struct ListAssistantAssociationsOutput {
    /// Summary information about assistant associations.
    /// This member is required.
    public var assistantAssociationSummaries: [WisdomClientTypes.AssistantAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        assistantAssociationSummaries: [WisdomClientTypes.AssistantAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assistantAssociationSummaries = assistantAssociationSummaries
        self.nextToken = nextToken
    }
}

extension WisdomClientTypes {
    /// The configuration information for the customer managed key used for encryption.
    public struct ServerSideEncryptionConfiguration {
        /// The customer managed key used for encryption. For more information about setting up a customer managed key for Wisdom, see [Enable Amazon Connect Wisdom for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-wisdom.html). For information about valid ID values, see [Key identifiers (KeyId)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id).
        public var kmsKeyId: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension WisdomClientTypes {

    public enum AssistantType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agent
        case sdkUnknown(Swift.String)

        public static var allCases: [AssistantType] {
            return [
                .agent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAssistantInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description of the assistant.
    public var description: Swift.String?
    /// The name of the assistant.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration information for the customer managed key used for encryption. The customer managed key must have a policy that allows kms:CreateGrant,  kms:DescribeKey, and kms:Decrypt/kms:GenerateDataKey permissions to the IAM identity using the key to invoke Wisdom. To use Wisdom with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal. For more information about setting up a customer managed key for Wisdom, see [Enable Amazon Connect Wisdom for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-wisdom.html).
    public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The type of assistant.
    /// This member is required.
    public var type: WisdomClientTypes.AssistantType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: WisdomClientTypes.AssistantType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
        self.type = type
    }
}

extension WisdomClientTypes {
    /// The configuration information for the Wisdom assistant integration.
    public struct AssistantIntegrationConfiguration {
        /// The Amazon Resource Name (ARN) of the integrated Amazon SNS topic used for streaming chat messages.
        public var topicIntegrationArn: Swift.String?

        public init(
            topicIntegrationArn: Swift.String? = nil
        )
        {
            self.topicIntegrationArn = topicIntegrationArn
        }
    }

}

extension WisdomClientTypes {

    public enum AssistantStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AssistantStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// The assistant data.
    public struct AssistantData {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The description.
        public var description: Swift.String?
        /// The configuration information for the Wisdom assistant integration.
        public var integrationConfiguration: WisdomClientTypes.AssistantIntegrationConfiguration?
        /// The name.
        /// This member is required.
        public var name: Swift.String?
        /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, and kms:Decrypt/kms:GenerateDataKey permissions to the IAM identity using the key to invoke Wisdom. To use Wisdom with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal. For more information about setting up a customer managed key for Wisdom, see [Enable Amazon Connect Wisdom for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-wisdom.html).
        public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        /// This member is required.
        public var status: WisdomClientTypes.AssistantStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The type of assistant.
        /// This member is required.
        public var type: WisdomClientTypes.AssistantType?

        public init(
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            description: Swift.String? = nil,
            integrationConfiguration: WisdomClientTypes.AssistantIntegrationConfiguration? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: WisdomClientTypes.AssistantStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: WisdomClientTypes.AssistantType? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

public struct CreateAssistantOutput {
    /// Information about the assistant.
    public var assistant: WisdomClientTypes.AssistantData?

    public init(
        assistant: WisdomClientTypes.AssistantData? = nil
    )
    {
        self.assistant = assistant
    }
}

public struct DeleteAssistantInput {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        assistantId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
    }
}

public struct DeleteAssistantOutput {

    public init() { }
}

public struct GetAssistantInput {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init(
        assistantId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
    }
}

public struct GetAssistantOutput {
    /// Information about the assistant.
    public var assistant: WisdomClientTypes.AssistantData?

    public init(
        assistant: WisdomClientTypes.AssistantData? = nil
    )
    {
        self.assistant = assistant
    }
}

public struct GetRecommendationsInput {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The duration (in seconds) for which the call waits for a recommendation to be made available before returning. If a recommendation is available, the call returns sooner than WaitTimeSeconds. If no messages are available and the wait time expires, the call returns successfully with an empty list.
    public var waitTimeSeconds: Swift.Int

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        sessionId: Swift.String? = nil,
        waitTimeSeconds: Swift.Int = 0
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.sessionId = sessionId
        self.waitTimeSeconds = waitTimeSeconds
    }
}

extension WisdomClientTypes {
    /// Reference information about the content.
    public struct ContentReference {
        /// The Amazon Resource Name (ARN) of the content.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        public var contentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.
        public var knowledgeBaseId: Swift.String?

        public init(
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil
        )
        {
            self.contentArn = contentArn
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }
    }

}

extension WisdomClientTypes {
    /// Offset specification to describe highlighting of document excerpts for rendering search results and recommendations.
    public struct Highlight {
        /// The offset for the start of the highlight.
        public var beginOffsetInclusive: Swift.Int
        /// The offset for the end of the highlight.
        public var endOffsetExclusive: Swift.Int

        public init(
            beginOffsetInclusive: Swift.Int = 0,
            endOffsetExclusive: Swift.Int = 0
        )
        {
            self.beginOffsetInclusive = beginOffsetInclusive
            self.endOffsetExclusive = endOffsetExclusive
        }
    }

}

extension WisdomClientTypes {
    /// The text of the document.
    public struct DocumentText {
        /// Highlights in the document text.
        public var highlights: [WisdomClientTypes.Highlight]?
        /// Text in the document.
        public var text: Swift.String?

        public init(
            highlights: [WisdomClientTypes.Highlight]? = nil,
            text: Swift.String? = nil
        )
        {
            self.highlights = highlights
            self.text = text
        }
    }

}

extension WisdomClientTypes.DocumentText: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentText(highlights: \(Swift.String(describing: highlights)), text: \"CONTENT_REDACTED\")"}
}

extension WisdomClientTypes {
    /// The document.
    public struct Document {
        /// A reference to the content resource.
        /// This member is required.
        public var contentReference: WisdomClientTypes.ContentReference?
        /// The excerpt from the document.
        public var excerpt: WisdomClientTypes.DocumentText?
        /// The title of the document.
        public var title: WisdomClientTypes.DocumentText?

        public init(
            contentReference: WisdomClientTypes.ContentReference? = nil,
            excerpt: WisdomClientTypes.DocumentText? = nil,
            title: WisdomClientTypes.DocumentText? = nil
        )
        {
            self.contentReference = contentReference
            self.excerpt = excerpt
            self.title = title
        }
    }

}

extension WisdomClientTypes {

    public enum RelevanceLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [RelevanceLevel] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {

    public enum RecommendationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case knowledgeContent
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationType] {
            return [
                .knowledgeContent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .knowledgeContent: return "KNOWLEDGE_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// Information about the recommendation.
    public struct RecommendationData {
        /// The recommended document.
        /// This member is required.
        public var document: WisdomClientTypes.Document?
        /// The identifier of the recommendation.
        /// This member is required.
        public var recommendationId: Swift.String?
        /// The relevance level of the recommendation.
        public var relevanceLevel: WisdomClientTypes.RelevanceLevel?
        /// The relevance score of the recommendation.
        public var relevanceScore: Swift.Double
        /// The type of recommendation.
        public var type: WisdomClientTypes.RecommendationType?

        public init(
            document: WisdomClientTypes.Document? = nil,
            recommendationId: Swift.String? = nil,
            relevanceLevel: WisdomClientTypes.RelevanceLevel? = nil,
            relevanceScore: Swift.Double = 0.0,
            type: WisdomClientTypes.RecommendationType? = nil
        )
        {
            self.document = document
            self.recommendationId = recommendationId
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
            self.type = type
        }
    }

}

extension WisdomClientTypes {
    /// Data associated with the QUERY RecommendationTriggerType.
    public struct QueryRecommendationTriggerData {
        /// The text associated with the recommendation trigger.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension WisdomClientTypes.QueryRecommendationTriggerData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryRecommendationTriggerData(text: \"CONTENT_REDACTED\")"}
}

extension WisdomClientTypes {
    /// A union type containing information related to the trigger.
    public enum RecommendationTriggerData {
        /// Data associated with the QUERY RecommendationTriggerType.
        case query(WisdomClientTypes.QueryRecommendationTriggerData)
        case sdkUnknown(Swift.String)
    }

}

extension WisdomClientTypes {

    public enum RecommendationSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case issueDetection
        case other
        case ruleEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationSourceType] {
            return [
                .issueDetection,
                .other,
                .ruleEvaluation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .issueDetection: return "ISSUE_DETECTION"
            case .other: return "OTHER"
            case .ruleEvaluation: return "RULE_EVALUATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {

    public enum RecommendationTriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case query
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationTriggerType] {
            return [
                .query
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .query: return "QUERY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// A recommendation trigger provides context on the event that produced the referenced recommendations. Recommendations are only referenced in recommendationIds by a single RecommendationTrigger.
    public struct RecommendationTrigger {
        /// A union type containing information related to the trigger.
        /// This member is required.
        public var data: WisdomClientTypes.RecommendationTriggerData?
        /// The identifier of the recommendation trigger.
        /// This member is required.
        public var id: Swift.String?
        /// The identifiers of the recommendations.
        /// This member is required.
        public var recommendationIds: [Swift.String]?
        /// The source of the recommendation trigger.
        ///
        /// * ISSUE_DETECTION: The corresponding recommendations were triggered by a Contact Lens issue.
        ///
        /// * RULE_EVALUATION: The corresponding recommendations were triggered by a Contact Lens rule.
        /// This member is required.
        public var source: WisdomClientTypes.RecommendationSourceType?
        /// The type of recommendation trigger.
        /// This member is required.
        public var type: WisdomClientTypes.RecommendationTriggerType?

        public init(
            data: WisdomClientTypes.RecommendationTriggerData? = nil,
            id: Swift.String? = nil,
            recommendationIds: [Swift.String]? = nil,
            source: WisdomClientTypes.RecommendationSourceType? = nil,
            type: WisdomClientTypes.RecommendationTriggerType? = nil
        )
        {
            self.data = data
            self.id = id
            self.recommendationIds = recommendationIds
            self.source = source
            self.type = type
        }
    }

}

public struct GetRecommendationsOutput {
    /// The recommendations.
    /// This member is required.
    public var recommendations: [WisdomClientTypes.RecommendationData]?
    /// The triggers corresponding to recommendations.
    public var triggers: [WisdomClientTypes.RecommendationTrigger]?

    public init(
        recommendations: [WisdomClientTypes.RecommendationData]? = nil,
        triggers: [WisdomClientTypes.RecommendationTrigger]? = nil
    )
    {
        self.recommendations = recommendations
        self.triggers = triggers
    }
}

public struct ListAssistantsInput {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WisdomClientTypes {
    /// Summary information about the assistant.
    public struct AssistantSummary {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The description of the assistant.
        public var description: Swift.String?
        /// The configuration information for the Wisdom assistant integration.
        public var integrationConfiguration: WisdomClientTypes.AssistantIntegrationConfiguration?
        /// The name of the assistant.
        /// This member is required.
        public var name: Swift.String?
        /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, and kms:Decrypt/kms:GenerateDataKey permissions to the IAM identity using the key to invoke Wisdom. To use Wisdom with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal. For more information about setting up a customer managed key for Wisdom, see [Enable Amazon Connect Wisdom for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-wisdom.html).
        public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        /// This member is required.
        public var status: WisdomClientTypes.AssistantStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The type of the assistant.
        /// This member is required.
        public var type: WisdomClientTypes.AssistantType?

        public init(
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            description: Swift.String? = nil,
            integrationConfiguration: WisdomClientTypes.AssistantIntegrationConfiguration? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: WisdomClientTypes.AssistantStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: WisdomClientTypes.AssistantType? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

public struct ListAssistantsOutput {
    /// Information about the assistants.
    /// This member is required.
    public var assistantSummaries: [WisdomClientTypes.AssistantSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        assistantSummaries: [WisdomClientTypes.AssistantSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assistantSummaries = assistantSummaries
        self.nextToken = nextToken
    }
}

public struct NotifyRecommendationsReceivedInput {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifiers of the recommendations.
    /// This member is required.
    public var recommendationIds: [Swift.String]?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        recommendationIds: [Swift.String]? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.recommendationIds = recommendationIds
        self.sessionId = sessionId
    }
}

extension WisdomClientTypes {
    /// An error occurred when creating a recommendation.
    public struct NotifyRecommendationsReceivedError {
        /// A recommendation is causing an error.
        public var message: Swift.String?
        /// The identifier of the recommendation that is in error.
        public var recommendationId: Swift.String?

        public init(
            message: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.message = message
            self.recommendationId = recommendationId
        }
    }

}

public struct NotifyRecommendationsReceivedOutput {
    /// The identifiers of recommendations that are causing errors.
    public var errors: [WisdomClientTypes.NotifyRecommendationsReceivedError]?
    /// The identifiers of the recommendations.
    public var recommendationIds: [Swift.String]?

    public init(
        errors: [WisdomClientTypes.NotifyRecommendationsReceivedError]? = nil,
        recommendationIds: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.recommendationIds = recommendationIds
    }
}

/// The request reached the service more than 15 minutes after the date stamp on the request or more than 15 minutes after the request expiration date (such as for pre-signed URLs), or the date stamp on the request is more than 15 minutes in the future.
public struct RequestTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct QueryAssistantInput {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The text to search for.
    /// This member is required.
    public var queryText: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryText = queryText
    }
}

extension QueryAssistantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryAssistantInput(assistantId: \(Swift.String(describing: assistantId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), queryText: \"CONTENT_REDACTED\")"}
}

extension WisdomClientTypes {
    /// Information about the result.
    public struct ResultData {
        /// The document.
        /// This member is required.
        public var document: WisdomClientTypes.Document?
        /// The relevance score of the results.
        public var relevanceScore: Swift.Double
        /// The identifier of the result data.
        /// This member is required.
        public var resultId: Swift.String?

        public init(
            document: WisdomClientTypes.Document? = nil,
            relevanceScore: Swift.Double = 0.0,
            resultId: Swift.String? = nil
        )
        {
            self.document = document
            self.relevanceScore = relevanceScore
            self.resultId = resultId
        }
    }

}

public struct QueryAssistantOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The results of the query.
    /// This member is required.
    public var results: [WisdomClientTypes.ResultData]?

    public init(
        nextToken: Swift.String? = nil,
        results: [WisdomClientTypes.ResultData]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

extension WisdomClientTypes {

    public enum FilterField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterField] {
            return [
                .name
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {

    public enum FilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperator] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// A search filter.
    public struct Filter {
        /// The field on which to filter.
        /// This member is required.
        public var field: WisdomClientTypes.FilterField?
        /// The operator to use for comparing the field’s value with the provided value.
        /// This member is required.
        public var `operator`: WisdomClientTypes.FilterOperator?
        /// The desired field value on which to filter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            field: WisdomClientTypes.FilterField? = nil,
            `operator`: WisdomClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.field = field
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension WisdomClientTypes {
    /// The search expression.
    public struct SearchExpression {
        /// The search expression filters.
        /// This member is required.
        public var filters: [WisdomClientTypes.Filter]?

        public init(
            filters: [WisdomClientTypes.Filter]? = nil
        )
        {
            self.filters = filters
        }
    }

}

public struct SearchSessionsInput {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression to filter results.
    /// This member is required.
    public var searchExpression: WisdomClientTypes.SearchExpression?

    public init(
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: WisdomClientTypes.SearchExpression? = nil
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

extension WisdomClientTypes {
    /// Summary information about the session.
    public struct SessionSummary {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The Amazon Resource Name (ARN) of the session.
        /// This member is required.
        public var sessionArn: Swift.String?
        /// The identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?

        public init(
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            sessionArn: Swift.String? = nil,
            sessionId: Swift.String? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }
    }

}

public struct SearchSessionsOutput {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Summary information about the sessions.
    /// This member is required.
    public var sessionSummaries: [WisdomClientTypes.SessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessionSummaries: [WisdomClientTypes.SessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessionSummaries = sessionSummaries
    }
}

public struct CreateSessionInput {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The name of the session.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

extension WisdomClientTypes {
    /// The configuration information for the session integration.
    public struct SessionIntegrationConfiguration {
        /// The Amazon Resource Name (ARN) of the integrated Amazon SNS topic used for streaming chat messages.
        public var topicIntegrationArn: Swift.String?

        public init(
            topicIntegrationArn: Swift.String? = nil
        )
        {
            self.topicIntegrationArn = topicIntegrationArn
        }
    }

}

extension WisdomClientTypes {
    /// Information about the session.
    public struct SessionData {
        /// The description of the session.
        public var description: Swift.String?
        /// The configuration information for the session integration.
        public var integrationConfiguration: WisdomClientTypes.SessionIntegrationConfiguration?
        /// The name of the session.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the session.
        /// This member is required.
        public var sessionArn: Swift.String?
        /// The identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            description: Swift.String? = nil,
            integrationConfiguration: WisdomClientTypes.SessionIntegrationConfiguration? = nil,
            name: Swift.String? = nil,
            sessionArn: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.tags = tags
        }
    }

}

public struct CreateSessionOutput {
    /// The session.
    public var session: WisdomClientTypes.SessionData?

    public init(
        session: WisdomClientTypes.SessionData? = nil
    )
    {
        self.session = session
    }
}

public struct GetSessionInput {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        assistantId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.sessionId = sessionId
    }
}

public struct GetSessionOutput {
    /// The session.
    public var session: WisdomClientTypes.SessionData?

    public init(
        session: WisdomClientTypes.SessionData? = nil
    )
    {
        self.session = session
    }
}

extension WisdomClientTypes {
    /// The configuration information of the Amazon Connect data source.
    public struct ConnectConfiguration {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public var instanceId: Swift.String?

        public init(
            instanceId: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
        }
    }

}

extension WisdomClientTypes {
    /// The configuration information of the external data source.
    public enum Configuration {
        /// The configuration information of the Amazon Connect data source.
        case connectconfiguration(WisdomClientTypes.ConnectConfiguration)
        case sdkUnknown(Swift.String)
    }

}

public struct CreateContentInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
    public var metadata: [Swift.String: Swift.String]?
    /// The name of the content. Each piece of content in a knowledge base must have a unique name. You can retrieve a piece of content using only its knowledge base and its name with the [SearchContent](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_SearchContent.html) API.
    /// This member is required.
    public var name: Swift.String?
    /// The URI you want to use for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content.
    public var overrideLinkOutUri: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The title of the content. If not set, the title is equal to the name.
    public var title: Swift.String?
    /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String: Swift.String]? = nil,
        name: Swift.String? = nil,
        overrideLinkOutUri: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        title: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.name = name
        self.overrideLinkOutUri = overrideLinkOutUri
        self.tags = tags
        self.title = title
        self.uploadId = uploadId
    }
}

extension WisdomClientTypes {

    public enum ContentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case updateFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// Information about the content.
    public struct ContentData {
        /// The Amazon Resource Name (ARN) of the content.
        /// This member is required.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        /// This member is required.
        public var contentId: Swift.String?
        /// The media type of the content.
        /// This member is required.
        public var contentType: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The URI of the content.
        public var linkOutUri: Swift.String?
        /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        /// This member is required.
        public var metadata: [Swift.String: Swift.String]?
        /// The name of the content.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the content revision.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The status of the content.
        /// This member is required.
        public var status: WisdomClientTypes.ContentStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The title of the content.
        /// This member is required.
        public var title: Swift.String?
        /// The URL of the content.
        /// This member is required.
        public var url: Swift.String?
        /// The expiration time of the URL as an epoch timestamp.
        /// This member is required.
        public var urlExpiry: Foundation.Date?

        public init(
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            linkOutUri: Swift.String? = nil,
            metadata: [Swift.String: Swift.String]? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            status: WisdomClientTypes.ContentStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil,
            urlExpiry: Foundation.Date? = nil
        )
        {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.linkOutUri = linkOutUri
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }

}

extension WisdomClientTypes.ContentData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentData(contentArn: \(Swift.String(describing: contentArn)), contentId: \(Swift.String(describing: contentId)), contentType: \(Swift.String(describing: contentType)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), linkOutUri: \(Swift.String(describing: linkOutUri)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), title: \(Swift.String(describing: title)), urlExpiry: \(Swift.String(describing: urlExpiry)), url: \"CONTENT_REDACTED\")"}
}

public struct CreateContentOutput {
    /// The content.
    public var content: WisdomClientTypes.ContentData?

    public init(
        content: WisdomClientTypes.ContentData? = nil
    )
    {
        self.content = content
    }
}

public struct DeleteContentInput {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct DeleteContentOutput {

    public init() { }
}

public struct GetContentInput {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct GetContentOutput {
    /// The content.
    public var content: WisdomClientTypes.ContentData?

    public init(
        content: WisdomClientTypes.ContentData? = nil
    )
    {
        self.content = content
    }
}

public struct GetContentSummaryInput {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension WisdomClientTypes {
    /// Summary information about the content.
    public struct ContentSummary {
        /// The Amazon Resource Name (ARN) of the content.
        /// This member is required.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        /// This member is required.
        public var contentId: Swift.String?
        /// The media type of the content.
        /// This member is required.
        public var contentType: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        /// This member is required.
        public var metadata: [Swift.String: Swift.String]?
        /// The name of the content.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the revision of the content.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The status of the content.
        /// This member is required.
        public var status: WisdomClientTypes.ContentStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The title of the content.
        /// This member is required.
        public var title: Swift.String?

        public init(
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            metadata: [Swift.String: Swift.String]? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            status: WisdomClientTypes.ContentStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            title: Swift.String? = nil
        )
        {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
        }
    }

}

public struct GetContentSummaryOutput {
    /// The content summary.
    public var contentSummary: WisdomClientTypes.ContentSummary?

    public init(
        contentSummary: WisdomClientTypes.ContentSummary? = nil
    )
    {
        self.contentSummary = contentSummary
    }
}

public struct ListContentsInput {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListContentsOutput {
    /// Information about the content.
    /// This member is required.
    public var contentSummaries: [WisdomClientTypes.ContentSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        contentSummaries: [WisdomClientTypes.ContentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contentSummaries = contentSummaries
        self.nextToken = nextToken
    }
}

/// The provided revisionId does not match, indicating the content has been modified since it was last read.
public struct PreconditionFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdateContentInput {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
    public var metadata: [Swift.String: Swift.String]?
    /// The URI for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content. To remove an existing overrideLinkOurUri, exclude this argument and set removeOverrideLinkOutUri to true.
    public var overrideLinkOutUri: Swift.String?
    /// Unset the existing overrideLinkOutUri if it exists.
    public var removeOverrideLinkOutUri: Swift.Bool?
    /// The revisionId of the content resource to update, taken from an earlier call to GetContent, GetContentSummary, SearchContent, or ListContents. If included, this argument acts as an optimistic lock to ensure content was not modified since it was last read. If it has been modified, this API throws a PreconditionFailedException.
    public var revisionId: Swift.String?
    /// The title of the content.
    public var title: Swift.String?
    /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
    public var uploadId: Swift.String?

    public init(
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String: Swift.String]? = nil,
        overrideLinkOutUri: Swift.String? = nil,
        removeOverrideLinkOutUri: Swift.Bool? = nil,
        revisionId: Swift.String? = nil,
        title: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.overrideLinkOutUri = overrideLinkOutUri
        self.removeOverrideLinkOutUri = removeOverrideLinkOutUri
        self.revisionId = revisionId
        self.title = title
        self.uploadId = uploadId
    }
}

public struct UpdateContentOutput {
    /// The content.
    public var content: WisdomClientTypes.ContentData?

    public init(
        content: WisdomClientTypes.ContentData? = nil
    )
    {
        self.content = content
    }
}

extension WisdomClientTypes {

    public enum KnowledgeBaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case external
        case quickResponses
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseType] {
            return [
                .custom,
                .external,
                .quickResponses
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .external: return "EXTERNAL"
            case .quickResponses: return "QUICK_RESPONSES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// Information about how to render the content.
    public struct RenderingConfiguration {
        /// A URI template containing exactly one variable in ${variableName} format. This can only be set for EXTERNAL knowledge bases. For Salesforce, ServiceNow, and Zendesk, the variable must be one of the following:
        ///
        /// * Salesforce: Id, ArticleNumber, VersionNumber, Title, PublishStatus, or IsDeleted
        ///
        /// * ServiceNow: number, short_description, sys_mod_count, workflow_state, or active
        ///
        /// * Zendesk: id, title, updated_at, or draft
        ///
        ///
        /// The variable is replaced with the actual value for a piece of content when calling [GetContent](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_GetContent.html).
        public var templateUri: Swift.String?

        public init(
            templateUri: Swift.String? = nil
        )
        {
            self.templateUri = templateUri
        }
    }

}

extension WisdomClientTypes {
    /// Configuration information about the external data source.
    public enum SourceConfiguration {
        /// Configuration information for Amazon AppIntegrations to automatically ingest content.
        case appintegrations(WisdomClientTypes.AppIntegrationsConfiguration)
        case sdkUnknown(Swift.String)
    }

}

public struct CreateKnowledgeBaseInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The type of knowledge base. Only CUSTOM knowledge bases allow you to upload your own content. EXTERNAL knowledge bases support integrations with third-party systems whose content is synchronized automatically.
    /// This member is required.
    public var knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType?
    /// The name of the knowledge base.
    /// This member is required.
    public var name: Swift.String?
    /// Information about how to render the content.
    public var renderingConfiguration: WisdomClientTypes.RenderingConfiguration?
    /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, and kms:Decrypt/kms:GenerateDataKey permissions to the IAM identity using the key to invoke Wisdom. For more information about setting up a customer managed key for Wisdom, see [Enable Amazon Connect Wisdom for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-wisdom.html).
    public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
    /// The source of the knowledge base content. Only set this argument for EXTERNAL knowledge bases.
    public var sourceConfiguration: WisdomClientTypes.SourceConfiguration?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType? = nil,
        name: Swift.String? = nil,
        renderingConfiguration: WisdomClientTypes.RenderingConfiguration? = nil,
        serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
        sourceConfiguration: WisdomClientTypes.SourceConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.knowledgeBaseType = knowledgeBaseType
        self.name = name
        self.renderingConfiguration = renderingConfiguration
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.sourceConfiguration = sourceConfiguration
        self.tags = tags
    }
}

extension WisdomClientTypes {

    public enum KnowledgeBaseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// Information about the knowledge base.
    public struct KnowledgeBaseData {
        /// The description.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The type of knowledge base.
        /// This member is required.
        public var knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType?
        /// An epoch timestamp indicating the most recent content modification inside the knowledge base. If no content exists in a knowledge base, this value is unset.
        public var lastContentModificationTime: Foundation.Date?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// Information about how to render the content.
        public var renderingConfiguration: WisdomClientTypes.RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, and kms:Decrypt/kms:GenerateDataKey permissions to the IAM identity using the key to invoke Wisdom. For more information about setting up a customer managed key for Wisdom, see [Enable Amazon Connect Wisdom for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-wisdom.html).
        public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
        /// Source configuration information about the knowledge base.
        public var sourceConfiguration: WisdomClientTypes.SourceConfiguration?
        /// The status of the knowledge base.
        /// This member is required.
        public var status: WisdomClientTypes.KnowledgeBaseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType? = nil,
            lastContentModificationTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            renderingConfiguration: WisdomClientTypes.RenderingConfiguration? = nil,
            serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
            sourceConfiguration: WisdomClientTypes.SourceConfiguration? = nil,
            status: WisdomClientTypes.KnowledgeBaseStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.lastContentModificationTime = lastContentModificationTime
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
        }
    }

}

public struct CreateKnowledgeBaseOutput {
    /// The knowledge base.
    public var knowledgeBase: WisdomClientTypes.KnowledgeBaseData?

    public init(
        knowledgeBase: WisdomClientTypes.KnowledgeBaseData? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

extension WisdomClientTypes {
    /// The container of quick response data.
    public enum QuickResponseDataProvider {
        /// The content of the quick response.
        case content(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension WisdomClientTypes {
    /// The configuration information of the grouping of Wisdom users.
    public struct GroupingConfiguration {
        /// The criteria used for grouping Wisdom users. The following is the list of supported criteria values.
        ///
        /// * RoutingProfileArn: Grouping the users by their [Amazon Connect routing profile ARN](https://docs.aws.amazon.com/connect/latest/APIReference/API_RoutingProfile.html). User should have [SearchRoutingProfile](https://docs.aws.amazon.com/connect/latest/APIReference/API_SearchRoutingProfiles.html) and [DescribeRoutingProfile](https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribeRoutingProfile.html) permissions when setting criteria to this value.
        public var criteria: Swift.String?
        /// The list of values that define different groups of Wisdom users.
        ///
        /// * When setting criteria to RoutingProfileArn, you need to provide a list of ARNs of [Amazon Connect routing profiles](https://docs.aws.amazon.com/connect/latest/APIReference/API_RoutingProfile.html) as values of this parameter.
        public var values: [Swift.String]?

        public init(
            criteria: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.criteria = criteria
            self.values = values
        }
    }

}

extension WisdomClientTypes.GroupingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GroupingConfiguration(criteria: \"CONTENT_REDACTED\", values: \"CONTENT_REDACTED\")"}
}

public struct CreateQuickResponseInput {
    /// The Amazon Connect channels this quick response applies to.
    public var channels: [Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The content of the quick response.
    /// This member is required.
    public var content: WisdomClientTypes.QuickResponseDataProvider?
    /// The media type of the quick response content.
    ///
    /// * Use application/x.quickresponse;format=plain for a quick response written in plain text.
    ///
    /// * Use application/x.quickresponse;format=markdown for a quick response written in richtext.
    public var contentType: Swift.String?
    /// The description of the quick response.
    public var description: Swift.String?
    /// The configuration information of the user groups that the quick response is accessible to.
    public var groupingConfiguration: WisdomClientTypes.GroupingConfiguration?
    /// Whether the quick response is active.
    public var isActive: Swift.Bool?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
    public var language: Swift.String?
    /// The name of the quick response.
    /// This member is required.
    public var name: Swift.String?
    /// The shortcut key of the quick response. The value should be unique across the knowledge base.
    public var shortcutKey: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        channels: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        content: WisdomClientTypes.QuickResponseDataProvider? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        groupingConfiguration: WisdomClientTypes.GroupingConfiguration? = nil,
        isActive: Swift.Bool? = nil,
        knowledgeBaseId: Swift.String? = nil,
        language: Swift.String? = nil,
        name: Swift.String? = nil,
        shortcutKey: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.channels = channels
        self.clientToken = clientToken
        self.content = content
        self.contentType = contentType
        self.description = description
        self.groupingConfiguration = groupingConfiguration
        self.isActive = isActive
        self.knowledgeBaseId = knowledgeBaseId
        self.language = language
        self.name = name
        self.shortcutKey = shortcutKey
        self.tags = tags
    }
}

extension CreateQuickResponseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateQuickResponseInput(clientToken: \(Swift.String(describing: clientToken)), content: \(Swift.String(describing: content)), contentType: \(Swift.String(describing: contentType)), description: \(Swift.String(describing: description)), groupingConfiguration: \(Swift.String(describing: groupingConfiguration)), isActive: \(Swift.String(describing: isActive)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), language: \(Swift.String(describing: language)), name: \(Swift.String(describing: name)), shortcutKey: \(Swift.String(describing: shortcutKey)), tags: \(Swift.String(describing: tags)), channels: \"CONTENT_REDACTED\")"}
}

extension WisdomClientTypes {
    /// The container quick response content.
    public enum QuickResponseContentProvider {
        /// The content of the quick response.
        case content(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension WisdomClientTypes {
    /// The content of the quick response stored in different media types.
    public struct QuickResponseContents {
        /// The container quick response content.
        public var markdown: WisdomClientTypes.QuickResponseContentProvider?
        /// The container quick response content.
        public var plainText: WisdomClientTypes.QuickResponseContentProvider?

        public init(
            markdown: WisdomClientTypes.QuickResponseContentProvider? = nil,
            plainText: WisdomClientTypes.QuickResponseContentProvider? = nil
        )
        {
            self.markdown = markdown
            self.plainText = plainText
        }
    }

}

extension WisdomClientTypes {

    public enum QuickResponseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [QuickResponseStatus] {
            return [
                .created,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// Information about the quick response.
    public struct QuickResponseData {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public var channels: [Swift.String]?
        /// The media type of the quick response content.
        ///
        /// * Use application/x.quickresponse;format=plain for quick response written in plain text.
        ///
        /// * Use application/x.quickresponse;format=markdown for quick response written in richtext.
        /// This member is required.
        public var contentType: Swift.String?
        /// The contents of the quick response.
        public var contents: WisdomClientTypes.QuickResponseContents?
        /// The timestamp when the quick response was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the quick response.
        public var description: Swift.String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public var groupingConfiguration: WisdomClientTypes.GroupingConfiguration?
        /// Whether the quick response is active.
        public var isActive: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The language code value for the language in which the quick response is written.
        public var language: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response data.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the quick response data was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the quick response.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the quick response.
        /// This member is required.
        public var quickResponseArn: Swift.String?
        /// The identifier of the quick response.
        /// This member is required.
        public var quickResponseId: Swift.String?
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public var shortcutKey: Swift.String?
        /// The status of the quick response data.
        /// This member is required.
        public var status: WisdomClientTypes.QuickResponseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            channels: [Swift.String]? = nil,
            contentType: Swift.String? = nil,
            contents: WisdomClientTypes.QuickResponseContents? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            groupingConfiguration: WisdomClientTypes.GroupingConfiguration? = nil,
            isActive: Swift.Bool? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            language: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            quickResponseArn: Swift.String? = nil,
            quickResponseId: Swift.String? = nil,
            shortcutKey: Swift.String? = nil,
            status: WisdomClientTypes.QuickResponseStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.channels = channels
            self.contentType = contentType
            self.contents = contents
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.shortcutKey = shortcutKey
            self.status = status
            self.tags = tags
        }
    }

}

extension WisdomClientTypes.QuickResponseData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QuickResponseData(contentType: \(Swift.String(describing: contentType)), contents: \(Swift.String(describing: contents)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), groupingConfiguration: \(Swift.String(describing: groupingConfiguration)), isActive: \(Swift.String(describing: isActive)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), language: \(Swift.String(describing: language)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), quickResponseArn: \(Swift.String(describing: quickResponseArn)), quickResponseId: \(Swift.String(describing: quickResponseId)), shortcutKey: \(Swift.String(describing: shortcutKey)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), channels: \"CONTENT_REDACTED\")"}
}

public struct CreateQuickResponseOutput {
    /// The quick response.
    public var quickResponse: WisdomClientTypes.QuickResponseData?

    public init(
        quickResponse: WisdomClientTypes.QuickResponseData? = nil
    )
    {
        self.quickResponse = quickResponse
    }
}

public struct DeleteImportJobInput {
    /// The identifier of the import job to be deleted.
    /// This member is required.
    public var importJobId: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        importJobId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.importJobId = importJobId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct DeleteImportJobOutput {

    public init() { }
}

public struct DeleteKnowledgeBaseInput {
    /// The knowledge base to delete content from. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct DeleteKnowledgeBaseOutput {

    public init() { }
}

public struct DeleteQuickResponseInput {
    /// The knowledge base from which the quick response is deleted. The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the quick response to delete.
    /// This member is required.
    public var quickResponseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        quickResponseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.quickResponseId = quickResponseId
    }
}

public struct DeleteQuickResponseOutput {

    public init() { }
}

extension WisdomClientTypes {

    public enum ExternalSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonConnect
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalSource] {
            return [
                .amazonConnect
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonConnect: return "AMAZON_CONNECT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// The configuration information of the external data source.
    public struct ExternalSourceConfiguration {
        /// The configuration information of the external data source.
        /// This member is required.
        public var configuration: WisdomClientTypes.Configuration?
        /// The type of the external data source.
        /// This member is required.
        public var source: WisdomClientTypes.ExternalSource?

        public init(
            configuration: WisdomClientTypes.Configuration? = nil,
            source: WisdomClientTypes.ExternalSource? = nil
        )
        {
            self.configuration = configuration
            self.source = source
        }
    }

}

public struct GetImportJobInput {
    /// The identifier of the import job to retrieve.
    /// This member is required.
    public var importJobId: Swift.String?
    /// The identifier of the knowledge base that the import job belongs to.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        importJobId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.importJobId = importJobId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension WisdomClientTypes {

    public enum ImportJobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case quickResponses
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportJobType] {
            return [
                .quickResponses
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .quickResponses: return "QUICK_RESPONSES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {

    public enum ImportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case deleted
        case deleteFailed
        case deleteInProgress
        case failed
        case startInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportJobStatus] {
            return [
                .complete,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .failed,
                .startInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .failed: return "FAILED"
            case .startInProgress: return "START_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// Summary information about the import job.
    public struct ImportJobData {
        /// The timestamp when the import job was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The configuration information of the external data source.
        public var externalSourceConfiguration: WisdomClientTypes.ExternalSourceConfiguration?
        /// The link to donwload the information of resource data that failed to be imported.
        public var failedRecordReport: Swift.String?
        /// The identifier of the import job.
        /// This member is required.
        public var importJobId: Swift.String?
        /// The type of the import job.
        /// This member is required.
        public var importJobType: WisdomClientTypes.ImportJobType?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The timestamp when the import job data was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The metadata fields of the imported Wisdom resources.
        public var metadata: [Swift.String: Swift.String]?
        /// The status of the import job.
        /// This member is required.
        public var status: WisdomClientTypes.ImportJobStatus?
        /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
        /// This member is required.
        public var uploadId: Swift.String?
        /// The download link to the resource file that is uploaded to the import job.
        /// This member is required.
        public var url: Swift.String?
        /// The expiration time of the URL as an epoch timestamp.
        /// This member is required.
        public var urlExpiry: Foundation.Date?

        public init(
            createdTime: Foundation.Date? = nil,
            externalSourceConfiguration: WisdomClientTypes.ExternalSourceConfiguration? = nil,
            failedRecordReport: Swift.String? = nil,
            importJobId: Swift.String? = nil,
            importJobType: WisdomClientTypes.ImportJobType? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            metadata: [Swift.String: Swift.String]? = nil,
            status: WisdomClientTypes.ImportJobStatus? = nil,
            uploadId: Swift.String? = nil,
            url: Swift.String? = nil,
            urlExpiry: Foundation.Date? = nil
        )
        {
            self.createdTime = createdTime
            self.externalSourceConfiguration = externalSourceConfiguration
            self.failedRecordReport = failedRecordReport
            self.importJobId = importJobId
            self.importJobType = importJobType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.status = status
            self.uploadId = uploadId
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }

}

extension WisdomClientTypes.ImportJobData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportJobData(createdTime: \(Swift.String(describing: createdTime)), externalSourceConfiguration: \(Swift.String(describing: externalSourceConfiguration)), importJobId: \(Swift.String(describing: importJobId)), importJobType: \(Swift.String(describing: importJobType)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), metadata: \(Swift.String(describing: metadata)), status: \(Swift.String(describing: status)), uploadId: \(Swift.String(describing: uploadId)), urlExpiry: \(Swift.String(describing: urlExpiry)), failedRecordReport: \"CONTENT_REDACTED\", url: \"CONTENT_REDACTED\")"}
}

public struct GetImportJobOutput {
    /// The import job.
    public var importJob: WisdomClientTypes.ImportJobData?

    public init(
        importJob: WisdomClientTypes.ImportJobData? = nil
    )
    {
        self.importJob = importJob
    }
}

public struct GetKnowledgeBaseInput {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct GetKnowledgeBaseOutput {
    /// The knowledge base.
    public var knowledgeBase: WisdomClientTypes.KnowledgeBaseData?

    public init(
        knowledgeBase: WisdomClientTypes.KnowledgeBaseData? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

public struct GetQuickResponseInput {
    /// The identifier of the knowledge base. This should be a QUICK_RESPONSES type knowledge base.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The identifier of the quick response.
    /// This member is required.
    public var quickResponseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        quickResponseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.quickResponseId = quickResponseId
    }
}

public struct GetQuickResponseOutput {
    /// The quick response.
    public var quickResponse: WisdomClientTypes.QuickResponseData?

    public init(
        quickResponse: WisdomClientTypes.QuickResponseData? = nil
    )
    {
        self.quickResponse = quickResponse
    }
}

extension WisdomClientTypes {
    /// Summary information about the import job.
    public struct ImportJobSummary {
        /// The timestamp when the import job was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The configuration information of the external source that the resource data are imported from.
        public var externalSourceConfiguration: WisdomClientTypes.ExternalSourceConfiguration?
        /// The identifier of the import job.
        /// This member is required.
        public var importJobId: Swift.String?
        /// The type of import job.
        /// This member is required.
        public var importJobType: WisdomClientTypes.ImportJobType?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The timestamp when the import job was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The metadata fields of the imported Wisdom resources.
        public var metadata: [Swift.String: Swift.String]?
        /// The status of the import job.
        /// This member is required.
        public var status: WisdomClientTypes.ImportJobStatus?
        /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
        /// This member is required.
        public var uploadId: Swift.String?

        public init(
            createdTime: Foundation.Date? = nil,
            externalSourceConfiguration: WisdomClientTypes.ExternalSourceConfiguration? = nil,
            importJobId: Swift.String? = nil,
            importJobType: WisdomClientTypes.ImportJobType? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            metadata: [Swift.String: Swift.String]? = nil,
            status: WisdomClientTypes.ImportJobStatus? = nil,
            uploadId: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.externalSourceConfiguration = externalSourceConfiguration
            self.importJobId = importJobId
            self.importJobType = importJobType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.status = status
            self.uploadId = uploadId
        }
    }

}

public struct ListImportJobsInput {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListImportJobsOutput {
    /// Summary information about the import jobs.
    /// This member is required.
    public var importJobSummaries: [WisdomClientTypes.ImportJobSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        importJobSummaries: [WisdomClientTypes.ImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importJobSummaries = importJobSummaries
        self.nextToken = nextToken
    }
}

public struct ListKnowledgeBasesInput {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WisdomClientTypes {
    /// Summary information about the knowledge base.
    public struct KnowledgeBaseSummary {
        /// The description of the knowledge base.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The type of knowledge base.
        /// This member is required.
        public var knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// Information about how to render the content.
        public var renderingConfiguration: WisdomClientTypes.RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption. This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, kms:Decrypt/kms:GenerateDataKey permissions to the IAM identity using the key to invoke Wisdom. For more information about setting up a customer managed key for Wisdom, see [Enable Amazon Connect Wisdom for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-wisdom.html).
        public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
        /// Configuration information about the external data source.
        public var sourceConfiguration: WisdomClientTypes.SourceConfiguration?
        /// The status of the knowledge base summary.
        /// This member is required.
        public var status: WisdomClientTypes.KnowledgeBaseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType? = nil,
            name: Swift.String? = nil,
            renderingConfiguration: WisdomClientTypes.RenderingConfiguration? = nil,
            serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
            sourceConfiguration: WisdomClientTypes.SourceConfiguration? = nil,
            status: WisdomClientTypes.KnowledgeBaseStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
        }
    }

}

public struct ListKnowledgeBasesOutput {
    /// Information about the knowledge bases.
    /// This member is required.
    public var knowledgeBaseSummaries: [WisdomClientTypes.KnowledgeBaseSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseSummaries: [WisdomClientTypes.KnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseSummaries = knowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

public struct ListQuickResponsesInput {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WisdomClientTypes {
    /// The summary information about the quick response.
    public struct QuickResponseSummary {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public var channels: [Swift.String]?
        /// The media type of the quick response content.
        ///
        /// * Use application/x.quickresponse;format=plain for quick response written in plain text.
        ///
        /// * Use application/x.quickresponse;format=markdown for quick response written in richtext.
        /// This member is required.
        public var contentType: Swift.String?
        /// The timestamp when the quick response was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the quick response.
        public var description: Swift.String?
        /// Whether the quick response is active.
        public var isActive: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response data.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the quick response summary was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the quick response.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the quick response.
        /// This member is required.
        public var quickResponseArn: Swift.String?
        /// The identifier of the quick response.
        /// This member is required.
        public var quickResponseId: Swift.String?
        /// The resource status of the quick response.
        /// This member is required.
        public var status: WisdomClientTypes.QuickResponseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            channels: [Swift.String]? = nil,
            contentType: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            isActive: Swift.Bool? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            quickResponseArn: Swift.String? = nil,
            quickResponseId: Swift.String? = nil,
            status: WisdomClientTypes.QuickResponseStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.channels = channels
            self.contentType = contentType
            self.createdTime = createdTime
            self.description = description
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.status = status
            self.tags = tags
        }
    }

}

extension WisdomClientTypes.QuickResponseSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QuickResponseSummary(contentType: \(Swift.String(describing: contentType)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), isActive: \(Swift.String(describing: isActive)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), quickResponseArn: \(Swift.String(describing: quickResponseArn)), quickResponseId: \(Swift.String(describing: quickResponseId)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), channels: \"CONTENT_REDACTED\")"}
}

public struct ListQuickResponsesOutput {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Summary information about the quick responses.
    /// This member is required.
    public var quickResponseSummaries: [WisdomClientTypes.QuickResponseSummary]?

    public init(
        nextToken: Swift.String? = nil,
        quickResponseSummaries: [WisdomClientTypes.QuickResponseSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.quickResponseSummaries = quickResponseSummaries
    }
}

public struct UpdateQuickResponseInput {
    /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
    public var channels: [Swift.String]?
    /// The updated content of the quick response.
    public var content: WisdomClientTypes.QuickResponseDataProvider?
    /// The media type of the quick response content.
    ///
    /// * Use application/x.quickresponse;format=plain for quick response written in plain text.
    ///
    /// * Use application/x.quickresponse;format=markdown for quick response written in richtext.
    public var contentType: Swift.String?
    /// The updated description of the quick response.
    public var description: Swift.String?
    /// The updated grouping configuration of the quick response.
    public var groupingConfiguration: WisdomClientTypes.GroupingConfiguration?
    /// Whether the quick response is active.
    public var isActive: Swift.Bool?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
    public var language: Swift.String?
    /// The name of the quick response.
    public var name: Swift.String?
    /// The identifier of the quick response.
    /// This member is required.
    public var quickResponseId: Swift.String?
    /// Whether to remove the description from the quick response.
    public var removeDescription: Swift.Bool?
    /// Whether to remove the grouping configuration of the quick response.
    public var removeGroupingConfiguration: Swift.Bool?
    /// Whether to remove the shortcut key of the quick response.
    public var removeShortcutKey: Swift.Bool?
    /// The shortcut key of the quick response. The value should be unique across the knowledge base.
    public var shortcutKey: Swift.String?

    public init(
        channels: [Swift.String]? = nil,
        content: WisdomClientTypes.QuickResponseDataProvider? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        groupingConfiguration: WisdomClientTypes.GroupingConfiguration? = nil,
        isActive: Swift.Bool? = nil,
        knowledgeBaseId: Swift.String? = nil,
        language: Swift.String? = nil,
        name: Swift.String? = nil,
        quickResponseId: Swift.String? = nil,
        removeDescription: Swift.Bool? = nil,
        removeGroupingConfiguration: Swift.Bool? = nil,
        removeShortcutKey: Swift.Bool? = nil,
        shortcutKey: Swift.String? = nil
    )
    {
        self.channels = channels
        self.content = content
        self.contentType = contentType
        self.description = description
        self.groupingConfiguration = groupingConfiguration
        self.isActive = isActive
        self.knowledgeBaseId = knowledgeBaseId
        self.language = language
        self.name = name
        self.quickResponseId = quickResponseId
        self.removeDescription = removeDescription
        self.removeGroupingConfiguration = removeGroupingConfiguration
        self.removeShortcutKey = removeShortcutKey
        self.shortcutKey = shortcutKey
    }
}

extension UpdateQuickResponseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateQuickResponseInput(content: \(Swift.String(describing: content)), contentType: \(Swift.String(describing: contentType)), description: \(Swift.String(describing: description)), groupingConfiguration: \(Swift.String(describing: groupingConfiguration)), isActive: \(Swift.String(describing: isActive)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), language: \(Swift.String(describing: language)), name: \(Swift.String(describing: name)), quickResponseId: \(Swift.String(describing: quickResponseId)), removeDescription: \(Swift.String(describing: removeDescription)), removeGroupingConfiguration: \(Swift.String(describing: removeGroupingConfiguration)), removeShortcutKey: \(Swift.String(describing: removeShortcutKey)), shortcutKey: \(Swift.String(describing: shortcutKey)), channels: \"CONTENT_REDACTED\")"}
}

public struct UpdateQuickResponseOutput {
    /// The quick response.
    public var quickResponse: WisdomClientTypes.QuickResponseData?

    public init(
        quickResponse: WisdomClientTypes.QuickResponseData? = nil
    )
    {
        self.quickResponse = quickResponse
    }
}

public struct RemoveKnowledgeBaseTemplateUriInput {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct RemoveKnowledgeBaseTemplateUriOutput {

    public init() { }
}

public struct SearchContentInput {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression to filter results.
    /// This member is required.
    public var searchExpression: WisdomClientTypes.SearchExpression?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: WisdomClientTypes.SearchExpression? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

public struct SearchContentOutput {
    /// Summary information about the content.
    /// This member is required.
    public var contentSummaries: [WisdomClientTypes.ContentSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        contentSummaries: [WisdomClientTypes.ContentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contentSummaries = contentSummaries
        self.nextToken = nextToken
    }
}

extension WisdomClientTypes {

    public enum QuickResponseFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case `prefix`
        case sdkUnknown(Swift.String)

        public static var allCases: [QuickResponseFilterOperator] {
            return [
                .equals,
                .prefix
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .prefix: return "PREFIX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// The quick response fields to filter the quick response query results by. The following is the list of supported field names.
    ///
    /// * name
    ///
    /// * description
    ///
    /// * shortcutKey
    ///
    /// * isActive
    ///
    /// * channels
    ///
    /// * language
    ///
    /// * contentType
    ///
    /// * createdTime
    ///
    /// * lastModifiedTime
    ///
    /// * lastModifiedBy
    ///
    /// * groupingConfiguration.criteria
    ///
    /// * groupingConfiguration.values
    public struct QuickResponseFilterField {
        /// Whether to treat null value as a match for the attribute field.
        public var includeNoExistence: Swift.Bool?
        /// The name of the attribute field to filter the quick responses by.
        /// This member is required.
        public var name: Swift.String?
        /// The operator to use for filtering.
        /// This member is required.
        public var `operator`: WisdomClientTypes.QuickResponseFilterOperator?
        /// The values of attribute field to filter the quick response by.
        public var values: [Swift.String]?

        public init(
            includeNoExistence: Swift.Bool? = nil,
            name: Swift.String? = nil,
            `operator`: WisdomClientTypes.QuickResponseFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.includeNoExistence = includeNoExistence
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension WisdomClientTypes {

    public enum Order: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [Order] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// The quick response fields to order the quick response query results by. The following is the list of supported field names.
    ///
    /// * name
    ///
    /// * description
    ///
    /// * shortcutKey
    ///
    /// * isActive
    ///
    /// * channels
    ///
    /// * language
    ///
    /// * contentType
    ///
    /// * createdTime
    ///
    /// * lastModifiedTime
    ///
    /// * lastModifiedBy
    ///
    /// * groupingConfiguration.criteria
    ///
    /// * groupingConfiguration.values
    public struct QuickResponseOrderField {
        /// The name of the attribute to order the quick response query results by.
        /// This member is required.
        public var name: Swift.String?
        /// The order at which the quick responses are sorted by.
        public var order: WisdomClientTypes.Order?

        public init(
            name: Swift.String? = nil,
            order: WisdomClientTypes.Order? = nil
        )
        {
            self.name = name
            self.order = order
        }
    }

}

extension WisdomClientTypes {

    public enum QuickResponseQueryOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case containsAndPrefix
        case sdkUnknown(Swift.String)

        public static var allCases: [QuickResponseQueryOperator] {
            return [
                .contains,
                .containsAndPrefix
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .containsAndPrefix: return "CONTAINS_AND_PREFIX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {

    public enum Priority: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [Priority] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WisdomClientTypes {
    /// The quick response fields to query quick responses by. The following is the list of supported field names.
    ///
    /// * content
    ///
    /// * name
    ///
    /// * description
    ///
    /// * shortcutKey
    public struct QuickResponseQueryField {
        /// Whether the query expects only exact matches on the attribute field values. The results of the query will only include exact matches if this parameter is set to false.
        public var allowFuzziness: Swift.Bool?
        /// The name of the attribute to query the quick responses by.
        /// This member is required.
        public var name: Swift.String?
        /// The operator to use for matching attribute field values in the query.
        /// This member is required.
        public var `operator`: WisdomClientTypes.QuickResponseQueryOperator?
        /// The importance of the attribute field when calculating query result relevancy scores. The value set for this parameter affects the ordering of search results.
        public var priority: WisdomClientTypes.Priority?
        /// The values of the attribute to query the quick responses by.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            allowFuzziness: Swift.Bool? = nil,
            name: Swift.String? = nil,
            `operator`: WisdomClientTypes.QuickResponseQueryOperator? = nil,
            priority: WisdomClientTypes.Priority? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.allowFuzziness = allowFuzziness
            self.name = name
            self.`operator` = `operator`
            self.priority = priority
            self.values = values
        }
    }

}

extension WisdomClientTypes {
    /// Information about the import job.
    public struct QuickResponseSearchExpression {
        /// The configuration of filtering rules applied to quick response query results.
        public var filters: [WisdomClientTypes.QuickResponseFilterField]?
        /// The quick response attribute fields on which the query results are ordered.
        public var orderOnField: WisdomClientTypes.QuickResponseOrderField?
        /// The quick response query expressions.
        public var queries: [WisdomClientTypes.QuickResponseQueryField]?

        public init(
            filters: [WisdomClientTypes.QuickResponseFilterField]? = nil,
            orderOnField: WisdomClientTypes.QuickResponseOrderField? = nil,
            queries: [WisdomClientTypes.QuickResponseQueryField]? = nil
        )
        {
            self.filters = filters
            self.orderOnField = orderOnField
            self.queries = queries
        }
    }

}

public struct SearchQuickResponsesInput {
    /// The [user-defined Amazon Connect contact attributes](https://docs.aws.amazon.com/connect/latest/adminguide/connect-attrib-list.html#user-defined-attributes) to be resolved when search results are returned.
    public var attributes: [Swift.String: Swift.String]?
    /// The identifier of the knowledge base. This should be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression for querying the quick response.
    /// This member is required.
    public var searchExpression: WisdomClientTypes.QuickResponseSearchExpression?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: WisdomClientTypes.QuickResponseSearchExpression? = nil
    )
    {
        self.attributes = attributes
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

extension SearchQuickResponsesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchQuickResponsesInput(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), searchExpression: \(Swift.String(describing: searchExpression)), attributes: \"CONTENT_REDACTED\")"}
}

extension WisdomClientTypes {
    /// The result of quick response search.
    public struct QuickResponseSearchResultData {
        /// The user defined contact attributes that are resolved when the search result is returned.
        public var attributesInterpolated: [Swift.String]?
        /// The user defined contact attributes that are not resolved when the search result is returned.
        public var attributesNotInterpolated: [Swift.String]?
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public var channels: [Swift.String]?
        /// The media type of the quick response content.
        ///
        /// * Use application/x.quickresponse;format=plain for quick response written in plain text.
        ///
        /// * Use application/x.quickresponse;format=markdown for quick response written in richtext.
        /// This member is required.
        public var contentType: Swift.String?
        /// The contents of the quick response.
        /// This member is required.
        public var contents: WisdomClientTypes.QuickResponseContents?
        /// The timestamp when the quick response was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the quick response.
        public var description: Swift.String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public var groupingConfiguration: WisdomClientTypes.GroupingConfiguration?
        /// Whether the quick response is active.
        /// This member is required.
        public var isActive: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The language code value for the language in which the quick response is written.
        public var language: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response search result data.
        public var lastModifiedBy: Swift.String?
        /// The timestamp when the quick response search result data was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the quick response.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the quick response.
        /// This member is required.
        public var quickResponseArn: Swift.String?
        /// The identifier of the quick response.
        /// This member is required.
        public var quickResponseId: Swift.String?
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public var shortcutKey: Swift.String?
        /// The resource status of the quick response.
        /// This member is required.
        public var status: WisdomClientTypes.QuickResponseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            attributesInterpolated: [Swift.String]? = nil,
            attributesNotInterpolated: [Swift.String]? = nil,
            channels: [Swift.String]? = nil,
            contentType: Swift.String? = nil,
            contents: WisdomClientTypes.QuickResponseContents? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            groupingConfiguration: WisdomClientTypes.GroupingConfiguration? = nil,
            isActive: Swift.Bool? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            language: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            quickResponseArn: Swift.String? = nil,
            quickResponseId: Swift.String? = nil,
            shortcutKey: Swift.String? = nil,
            status: WisdomClientTypes.QuickResponseStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.attributesInterpolated = attributesInterpolated
            self.attributesNotInterpolated = attributesNotInterpolated
            self.channels = channels
            self.contentType = contentType
            self.contents = contents
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.shortcutKey = shortcutKey
            self.status = status
            self.tags = tags
        }
    }

}

extension WisdomClientTypes.QuickResponseSearchResultData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QuickResponseSearchResultData(contentType: \(Swift.String(describing: contentType)), contents: \(Swift.String(describing: contents)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), groupingConfiguration: \(Swift.String(describing: groupingConfiguration)), isActive: \(Swift.String(describing: isActive)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), language: \(Swift.String(describing: language)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)), quickResponseArn: \(Swift.String(describing: quickResponseArn)), quickResponseId: \(Swift.String(describing: quickResponseId)), shortcutKey: \(Swift.String(describing: shortcutKey)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), attributesInterpolated: \"CONTENT_REDACTED\", attributesNotInterpolated: \"CONTENT_REDACTED\", channels: \"CONTENT_REDACTED\")"}
}

public struct SearchQuickResponsesOutput {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The results of the quick response search.
    /// This member is required.
    public var results: [WisdomClientTypes.QuickResponseSearchResultData]?

    public init(
        nextToken: Swift.String? = nil,
        results: [WisdomClientTypes.QuickResponseSearchResultData]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

public struct StartContentUploadInput {
    /// The type of content to upload.
    /// This member is required.
    public var contentType: Swift.String?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The expected expiration time of the generated presigned URL, specified in minutes.
    public var presignedUrlTimeToLive: Swift.Int?

    public init(
        contentType: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        presignedUrlTimeToLive: Swift.Int? = nil
    )
    {
        self.contentType = contentType
        self.knowledgeBaseId = knowledgeBaseId
        self.presignedUrlTimeToLive = presignedUrlTimeToLive
    }
}

public struct StartContentUploadOutput {
    /// The headers to include in the upload.
    /// This member is required.
    public var headersToInclude: [Swift.String: Swift.String]?
    /// The identifier of the upload.
    /// This member is required.
    public var uploadId: Swift.String?
    /// The URL of the upload.
    /// This member is required.
    public var url: Swift.String?
    /// The expiration time of the URL as an epoch timestamp.
    /// This member is required.
    public var urlExpiry: Foundation.Date?

    public init(
        headersToInclude: [Swift.String: Swift.String]? = nil,
        uploadId: Swift.String? = nil,
        url: Swift.String? = nil,
        urlExpiry: Foundation.Date? = nil
    )
    {
        self.headersToInclude = headersToInclude
        self.uploadId = uploadId
        self.url = url
        self.urlExpiry = urlExpiry
    }
}

extension StartContentUploadOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartContentUploadOutput(headersToInclude: \(Swift.String(describing: headersToInclude)), uploadId: \(Swift.String(describing: uploadId)), urlExpiry: \(Swift.String(describing: urlExpiry)), url: \"CONTENT_REDACTED\")"}
}

public struct StartImportJobInput {
    /// The tags used to organize, track, or control access for this resource.
    public var clientToken: Swift.String?
    /// The configuration information of the external source that the resource data are imported from.
    public var externalSourceConfiguration: WisdomClientTypes.ExternalSourceConfiguration?
    /// The type of the import job.
    ///
    /// * For importing quick response resource, set the value to QUICK_RESPONSES.
    /// This member is required.
    public var importJobType: WisdomClientTypes.ImportJobType?
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    ///
    /// * For importing Wisdom quick responses, this should be a QUICK_RESPONSES type knowledge base.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The metadata fields of the imported Wisdom resources.
    public var metadata: [Swift.String: Swift.String]?
    /// A pointer to the uploaded asset. This value is returned by [StartContentUpload](https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html).
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        externalSourceConfiguration: WisdomClientTypes.ExternalSourceConfiguration? = nil,
        importJobType: WisdomClientTypes.ImportJobType? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String: Swift.String]? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.externalSourceConfiguration = externalSourceConfiguration
        self.importJobType = importJobType
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.uploadId = uploadId
    }
}

public struct StartImportJobOutput {
    /// The import job.
    public var importJob: WisdomClientTypes.ImportJobData?

    public init(
        importJob: WisdomClientTypes.ImportJobData? = nil
    )
    {
        self.importJob = importJob
    }
}

public struct UpdateKnowledgeBaseTemplateUriInput {
    /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The template URI to update.
    /// This member is required.
    public var templateUri: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        templateUri: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.templateUri = templateUri
    }
}

public struct UpdateKnowledgeBaseTemplateUriOutput {
    /// The knowledge base to update.
    public var knowledgeBase: WisdomClientTypes.KnowledgeBaseData?

    public init(
        knowledgeBase: WisdomClientTypes.KnowledgeBaseData? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

/// Amazon Connect Wisdom throws this exception if you have too many tags in your tag set.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The specified resource name.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension CreateAssistantInput {

    static func urlPathProvider(_ value: CreateAssistantInput) -> Swift.String? {
        return "/assistants"
    }
}

extension CreateAssistantAssociationInput {

    static func urlPathProvider(_ value: CreateAssistantAssociationInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations"
    }
}

extension CreateContentInput {

    static func urlPathProvider(_ value: CreateContentInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents"
    }
}

extension CreateKnowledgeBaseInput {

    static func urlPathProvider(_ value: CreateKnowledgeBaseInput) -> Swift.String? {
        return "/knowledgeBases"
    }
}

extension CreateQuickResponseInput {

    static func urlPathProvider(_ value: CreateQuickResponseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses"
    }
}

extension CreateSessionInput {

    static func urlPathProvider(_ value: CreateSessionInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions"
    }
}

extension DeleteAssistantInput {

    static func urlPathProvider(_ value: DeleteAssistantInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())"
    }
}

extension DeleteAssistantAssociationInput {

    static func urlPathProvider(_ value: DeleteAssistantAssociationInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let assistantAssociationId = value.assistantAssociationId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations/\(assistantAssociationId.urlPercentEncoding())"
    }
}

extension DeleteContentInput {

    static func urlPathProvider(_ value: DeleteContentInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let contentId = value.contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
    }
}

extension DeleteImportJobInput {

    static func urlPathProvider(_ value: DeleteImportJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let importJobId = value.importJobId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/importJobs/\(importJobId.urlPercentEncoding())"
    }
}

extension DeleteKnowledgeBaseInput {

    static func urlPathProvider(_ value: DeleteKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

extension DeleteQuickResponseInput {

    static func urlPathProvider(_ value: DeleteQuickResponseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let quickResponseId = value.quickResponseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses/\(quickResponseId.urlPercentEncoding())"
    }
}

extension GetAssistantInput {

    static func urlPathProvider(_ value: GetAssistantInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())"
    }
}

extension GetAssistantAssociationInput {

    static func urlPathProvider(_ value: GetAssistantAssociationInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let assistantAssociationId = value.assistantAssociationId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations/\(assistantAssociationId.urlPercentEncoding())"
    }
}

extension GetContentInput {

    static func urlPathProvider(_ value: GetContentInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let contentId = value.contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
    }
}

extension GetContentSummaryInput {

    static func urlPathProvider(_ value: GetContentSummaryInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let contentId = value.contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())/summary"
    }
}

extension GetImportJobInput {

    static func urlPathProvider(_ value: GetImportJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let importJobId = value.importJobId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/importJobs/\(importJobId.urlPercentEncoding())"
    }
}

extension GetKnowledgeBaseInput {

    static func urlPathProvider(_ value: GetKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

extension GetQuickResponseInput {

    static func urlPathProvider(_ value: GetQuickResponseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let quickResponseId = value.quickResponseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses/\(quickResponseId.urlPercentEncoding())"
    }
}

extension GetRecommendationsInput {

    static func urlPathProvider(_ value: GetRecommendationsInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/recommendations"
    }
}

extension GetRecommendationsInput {

    static func queryItemProvider(_ value: GetRecommendationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if value.waitTimeSeconds != 0 {
            let waitTimeSecondsQueryItem = Smithy.URIQueryItem(name: "waitTimeSeconds".urlPercentEncoding(), value: Swift.String(value.waitTimeSeconds).urlPercentEncoding())
            items.append(waitTimeSecondsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetSessionInput {

    static func urlPathProvider(_ value: GetSessionInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

extension ListAssistantAssociationsInput {

    static func urlPathProvider(_ value: ListAssistantAssociationsInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/associations"
    }
}

extension ListAssistantAssociationsInput {

    static func queryItemProvider(_ value: ListAssistantAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAssistantsInput {

    static func urlPathProvider(_ value: ListAssistantsInput) -> Swift.String? {
        return "/assistants"
    }
}

extension ListAssistantsInput {

    static func queryItemProvider(_ value: ListAssistantsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListContentsInput {

    static func urlPathProvider(_ value: ListContentsInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents"
    }
}

extension ListContentsInput {

    static func queryItemProvider(_ value: ListContentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListImportJobsInput {

    static func urlPathProvider(_ value: ListImportJobsInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/importJobs"
    }
}

extension ListImportJobsInput {

    static func queryItemProvider(_ value: ListImportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListKnowledgeBasesInput {

    static func urlPathProvider(_ value: ListKnowledgeBasesInput) -> Swift.String? {
        return "/knowledgeBases"
    }
}

extension ListKnowledgeBasesInput {

    static func queryItemProvider(_ value: ListKnowledgeBasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListQuickResponsesInput {

    static func urlPathProvider(_ value: ListQuickResponsesInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses"
    }
}

extension ListQuickResponsesInput {

    static func queryItemProvider(_ value: ListQuickResponsesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension NotifyRecommendationsReceivedInput {

    static func urlPathProvider(_ value: NotifyRecommendationsReceivedInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/recommendations/notify"
    }
}

extension QueryAssistantInput {

    static func urlPathProvider(_ value: QueryAssistantInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/query"
    }
}

extension RemoveKnowledgeBaseTemplateUriInput {

    static func urlPathProvider(_ value: RemoveKnowledgeBaseTemplateUriInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/templateUri"
    }
}

extension SearchContentInput {

    static func urlPathProvider(_ value: SearchContentInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/search"
    }
}

extension SearchContentInput {

    static func queryItemProvider(_ value: SearchContentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension SearchQuickResponsesInput {

    static func urlPathProvider(_ value: SearchQuickResponsesInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/search/quickResponses"
    }
}

extension SearchQuickResponsesInput {

    static func queryItemProvider(_ value: SearchQuickResponsesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension SearchSessionsInput {

    static func urlPathProvider(_ value: SearchSessionsInput) -> Swift.String? {
        guard let assistantId = value.assistantId else {
            return nil
        }
        return "/assistants/\(assistantId.urlPercentEncoding())/searchSessions"
    }
}

extension SearchSessionsInput {

    static func queryItemProvider(_ value: SearchSessionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension StartContentUploadInput {

    static func urlPathProvider(_ value: StartContentUploadInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/upload"
    }
}

extension StartImportJobInput {

    static func urlPathProvider(_ value: StartImportJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/importJobs"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateContentInput {

    static func urlPathProvider(_ value: UpdateContentInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let contentId = value.contentId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
    }
}

extension UpdateKnowledgeBaseTemplateUriInput {

    static func urlPathProvider(_ value: UpdateKnowledgeBaseTemplateUriInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/templateUri"
    }
}

extension UpdateQuickResponseInput {

    static func urlPathProvider(_ value: UpdateQuickResponseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let quickResponseId = value.quickResponseId else {
            return nil
        }
        return "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/quickResponses/\(quickResponseId.urlPercentEncoding())"
    }
}

extension CreateAssistantInput {

    static func write(value: CreateAssistantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["serverSideEncryptionConfiguration"].write(value.serverSideEncryptionConfiguration, with: WisdomClientTypes.ServerSideEncryptionConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateAssistantAssociationInput {

    static func write(value: CreateAssistantAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["association"].write(value.association, with: WisdomClientTypes.AssistantAssociationInputData.write(value:to:))
        try writer["associationType"].write(value.associationType)
        try writer["clientToken"].write(value.clientToken)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateContentInput {

    static func write(value: CreateContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["metadata"].writeMap(value.metadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["overrideLinkOutUri"].write(value.overrideLinkOutUri)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["title"].write(value.title)
        try writer["uploadId"].write(value.uploadId)
    }
}

extension CreateKnowledgeBaseInput {

    static func write(value: CreateKnowledgeBaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["knowledgeBaseType"].write(value.knowledgeBaseType)
        try writer["name"].write(value.name)
        try writer["renderingConfiguration"].write(value.renderingConfiguration, with: WisdomClientTypes.RenderingConfiguration.write(value:to:))
        try writer["serverSideEncryptionConfiguration"].write(value.serverSideEncryptionConfiguration, with: WisdomClientTypes.ServerSideEncryptionConfiguration.write(value:to:))
        try writer["sourceConfiguration"].write(value.sourceConfiguration, with: WisdomClientTypes.SourceConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateQuickResponseInput {

    static func write(value: CreateQuickResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channels"].writeList(value.channels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["content"].write(value.content, with: WisdomClientTypes.QuickResponseDataProvider.write(value:to:))
        try writer["contentType"].write(value.contentType)
        try writer["description"].write(value.description)
        try writer["groupingConfiguration"].write(value.groupingConfiguration, with: WisdomClientTypes.GroupingConfiguration.write(value:to:))
        try writer["isActive"].write(value.isActive)
        try writer["language"].write(value.language)
        try writer["name"].write(value.name)
        try writer["shortcutKey"].write(value.shortcutKey)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSessionInput {

    static func write(value: CreateSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension NotifyRecommendationsReceivedInput {

    static func write(value: NotifyRecommendationsReceivedInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recommendationIds"].writeList(value.recommendationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QueryAssistantInput {

    static func write(value: QueryAssistantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["queryText"].write(value.queryText)
    }
}

extension SearchContentInput {

    static func write(value: SearchContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["searchExpression"].write(value.searchExpression, with: WisdomClientTypes.SearchExpression.write(value:to:))
    }
}

extension SearchQuickResponsesInput {

    static func write(value: SearchQuickResponsesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["searchExpression"].write(value.searchExpression, with: WisdomClientTypes.QuickResponseSearchExpression.write(value:to:))
    }
}

extension SearchSessionsInput {

    static func write(value: SearchSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["searchExpression"].write(value.searchExpression, with: WisdomClientTypes.SearchExpression.write(value:to:))
    }
}

extension StartContentUploadInput {

    static func write(value: StartContentUploadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["presignedUrlTimeToLive"].write(value.presignedUrlTimeToLive)
    }
}

extension StartImportJobInput {

    static func write(value: StartImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["externalSourceConfiguration"].write(value.externalSourceConfiguration, with: WisdomClientTypes.ExternalSourceConfiguration.write(value:to:))
        try writer["importJobType"].write(value.importJobType)
        try writer["metadata"].writeMap(value.metadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["uploadId"].write(value.uploadId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateContentInput {

    static func write(value: UpdateContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadata"].writeMap(value.metadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["overrideLinkOutUri"].write(value.overrideLinkOutUri)
        try writer["removeOverrideLinkOutUri"].write(value.removeOverrideLinkOutUri)
        try writer["revisionId"].write(value.revisionId)
        try writer["title"].write(value.title)
        try writer["uploadId"].write(value.uploadId)
    }
}

extension UpdateKnowledgeBaseTemplateUriInput {

    static func write(value: UpdateKnowledgeBaseTemplateUriInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["templateUri"].write(value.templateUri)
    }
}

extension UpdateQuickResponseInput {

    static func write(value: UpdateQuickResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channels"].writeList(value.channels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["content"].write(value.content, with: WisdomClientTypes.QuickResponseDataProvider.write(value:to:))
        try writer["contentType"].write(value.contentType)
        try writer["description"].write(value.description)
        try writer["groupingConfiguration"].write(value.groupingConfiguration, with: WisdomClientTypes.GroupingConfiguration.write(value:to:))
        try writer["isActive"].write(value.isActive)
        try writer["language"].write(value.language)
        try writer["name"].write(value.name)
        try writer["removeDescription"].write(value.removeDescription)
        try writer["removeGroupingConfiguration"].write(value.removeGroupingConfiguration)
        try writer["removeShortcutKey"].write(value.removeShortcutKey)
        try writer["shortcutKey"].write(value.shortcutKey)
    }
}

extension CreateAssistantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssistantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssistantOutput()
        value.assistant = try reader["assistant"].readIfPresent(with: WisdomClientTypes.AssistantData.read(from:))
        return value
    }
}

extension CreateAssistantAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssistantAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssistantAssociationOutput()
        value.assistantAssociation = try reader["assistantAssociation"].readIfPresent(with: WisdomClientTypes.AssistantAssociationData.read(from:))
        return value
    }
}

extension CreateContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateContentOutput()
        value.content = try reader["content"].readIfPresent(with: WisdomClientTypes.ContentData.read(from:))
        return value
    }
}

extension CreateKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKnowledgeBaseOutput()
        value.knowledgeBase = try reader["knowledgeBase"].readIfPresent(with: WisdomClientTypes.KnowledgeBaseData.read(from:))
        return value
    }
}

extension CreateQuickResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateQuickResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateQuickResponseOutput()
        value.quickResponse = try reader["quickResponse"].readIfPresent(with: WisdomClientTypes.QuickResponseData.read(from:))
        return value
    }
}

extension CreateSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSessionOutput()
        value.session = try reader["session"].readIfPresent(with: WisdomClientTypes.SessionData.read(from:))
        return value
    }
}

extension DeleteAssistantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssistantOutput {
        return DeleteAssistantOutput()
    }
}

extension DeleteAssistantAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssistantAssociationOutput {
        return DeleteAssistantAssociationOutput()
    }
}

extension DeleteContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteContentOutput {
        return DeleteContentOutput()
    }
}

extension DeleteImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImportJobOutput {
        return DeleteImportJobOutput()
    }
}

extension DeleteKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKnowledgeBaseOutput {
        return DeleteKnowledgeBaseOutput()
    }
}

extension DeleteQuickResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteQuickResponseOutput {
        return DeleteQuickResponseOutput()
    }
}

extension GetAssistantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssistantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssistantOutput()
        value.assistant = try reader["assistant"].readIfPresent(with: WisdomClientTypes.AssistantData.read(from:))
        return value
    }
}

extension GetAssistantAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssistantAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssistantAssociationOutput()
        value.assistantAssociation = try reader["assistantAssociation"].readIfPresent(with: WisdomClientTypes.AssistantAssociationData.read(from:))
        return value
    }
}

extension GetContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContentOutput()
        value.content = try reader["content"].readIfPresent(with: WisdomClientTypes.ContentData.read(from:))
        return value
    }
}

extension GetContentSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContentSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContentSummaryOutput()
        value.contentSummary = try reader["contentSummary"].readIfPresent(with: WisdomClientTypes.ContentSummary.read(from:))
        return value
    }
}

extension GetImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImportJobOutput()
        value.importJob = try reader["importJob"].readIfPresent(with: WisdomClientTypes.ImportJobData.read(from:))
        return value
    }
}

extension GetKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKnowledgeBaseOutput()
        value.knowledgeBase = try reader["knowledgeBase"].readIfPresent(with: WisdomClientTypes.KnowledgeBaseData.read(from:))
        return value
    }
}

extension GetQuickResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQuickResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQuickResponseOutput()
        value.quickResponse = try reader["quickResponse"].readIfPresent(with: WisdomClientTypes.QuickResponseData.read(from:))
        return value
    }
}

extension GetRecommendationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRecommendationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRecommendationsOutput()
        value.recommendations = try reader["recommendations"].readListIfPresent(memberReadingClosure: WisdomClientTypes.RecommendationData.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.triggers = try reader["triggers"].readListIfPresent(memberReadingClosure: WisdomClientTypes.RecommendationTrigger.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionOutput()
        value.session = try reader["session"].readIfPresent(with: WisdomClientTypes.SessionData.read(from:))
        return value
    }
}

extension ListAssistantAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssistantAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssistantAssociationsOutput()
        value.assistantAssociationSummaries = try reader["assistantAssociationSummaries"].readListIfPresent(memberReadingClosure: WisdomClientTypes.AssistantAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssistantsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssistantsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssistantsOutput()
        value.assistantSummaries = try reader["assistantSummaries"].readListIfPresent(memberReadingClosure: WisdomClientTypes.AssistantSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListContentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListContentsOutput()
        value.contentSummaries = try reader["contentSummaries"].readListIfPresent(memberReadingClosure: WisdomClientTypes.ContentSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImportJobsOutput()
        value.importJobSummaries = try reader["importJobSummaries"].readListIfPresent(memberReadingClosure: WisdomClientTypes.ImportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListKnowledgeBasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKnowledgeBasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKnowledgeBasesOutput()
        value.knowledgeBaseSummaries = try reader["knowledgeBaseSummaries"].readListIfPresent(memberReadingClosure: WisdomClientTypes.KnowledgeBaseSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListQuickResponsesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQuickResponsesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQuickResponsesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.quickResponseSummaries = try reader["quickResponseSummaries"].readListIfPresent(memberReadingClosure: WisdomClientTypes.QuickResponseSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension NotifyRecommendationsReceivedOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> NotifyRecommendationsReceivedOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = NotifyRecommendationsReceivedOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: WisdomClientTypes.NotifyRecommendationsReceivedError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.recommendationIds = try reader["recommendationIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QueryAssistantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> QueryAssistantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = QueryAssistantOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.results = try reader["results"].readListIfPresent(memberReadingClosure: WisdomClientTypes.ResultData.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension RemoveKnowledgeBaseTemplateUriOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveKnowledgeBaseTemplateUriOutput {
        return RemoveKnowledgeBaseTemplateUriOutput()
    }
}

extension SearchContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchContentOutput()
        value.contentSummaries = try reader["contentSummaries"].readListIfPresent(memberReadingClosure: WisdomClientTypes.ContentSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension SearchQuickResponsesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchQuickResponsesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchQuickResponsesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.results = try reader["results"].readListIfPresent(memberReadingClosure: WisdomClientTypes.QuickResponseSearchResultData.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SearchSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sessionSummaries = try reader["sessionSummaries"].readListIfPresent(memberReadingClosure: WisdomClientTypes.SessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension StartContentUploadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartContentUploadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartContentUploadOutput()
        value.headersToInclude = try reader["headersToInclude"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.uploadId = try reader["uploadId"].readIfPresent() ?? ""
        value.url = try reader["url"].readIfPresent() ?? ""
        value.urlExpiry = try reader["urlExpiry"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension StartImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartImportJobOutput()
        value.importJob = try reader["importJob"].readIfPresent(with: WisdomClientTypes.ImportJobData.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateContentOutput()
        value.content = try reader["content"].readIfPresent(with: WisdomClientTypes.ContentData.read(from:))
        return value
    }
}

extension UpdateKnowledgeBaseTemplateUriOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKnowledgeBaseTemplateUriOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKnowledgeBaseTemplateUriOutput()
        value.knowledgeBase = try reader["knowledgeBase"].readIfPresent(with: WisdomClientTypes.KnowledgeBaseData.read(from:))
        return value
    }
}

extension UpdateQuickResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQuickResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateQuickResponseOutput()
        value.quickResponse = try reader["quickResponse"].readIfPresent(with: WisdomClientTypes.QuickResponseData.read(from:))
        return value
    }
}

enum CreateAssistantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssistantAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateQuickResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssistantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssistantAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteQuickResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssistantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssistantAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContentSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQuickResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRecommendationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssistantAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssistantsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKnowledgeBasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQuickResponsesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum NotifyRecommendationsReceivedOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum QueryAssistantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveKnowledgeBaseTemplateUriOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchQuickResponsesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartContentUploadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKnowledgeBaseTemplateUriOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQuickResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RequestTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RequestTimeoutException {
        let reader = baseError.errorBodyReader
        var value = RequestTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PreconditionFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PreconditionFailedException {
        let reader = baseError.errorBodyReader
        var value = PreconditionFailedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WisdomClientTypes.AssistantData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.AssistantData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.AssistantData()
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.serverSideEncryptionConfiguration = try reader["serverSideEncryptionConfiguration"].readIfPresent(with: WisdomClientTypes.ServerSideEncryptionConfiguration.read(from:))
        value.integrationConfiguration = try reader["integrationConfiguration"].readIfPresent(with: WisdomClientTypes.AssistantIntegrationConfiguration.read(from:))
        return value
    }
}

extension WisdomClientTypes.AssistantIntegrationConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.AssistantIntegrationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.AssistantIntegrationConfiguration()
        value.topicIntegrationArn = try reader["topicIntegrationArn"].readIfPresent()
        return value
    }
}

extension WisdomClientTypes.ServerSideEncryptionConfiguration {

    static func write(value: WisdomClientTypes.ServerSideEncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyId"].write(value.kmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.ServerSideEncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.ServerSideEncryptionConfiguration()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        return value
    }
}

extension WisdomClientTypes.AssistantAssociationData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.AssistantAssociationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.AssistantAssociationData()
        value.assistantAssociationId = try reader["assistantAssociationId"].readIfPresent() ?? ""
        value.assistantAssociationArn = try reader["assistantAssociationArn"].readIfPresent() ?? ""
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.associationType = try reader["associationType"].readIfPresent() ?? .sdkUnknown("")
        value.associationData = try reader["associationData"].readIfPresent(with: WisdomClientTypes.AssistantAssociationOutputData.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WisdomClientTypes.AssistantAssociationOutputData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.AssistantAssociationOutputData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "knowledgeBaseAssociation":
                return .knowledgebaseassociation(try reader["knowledgeBaseAssociation"].read(with: WisdomClientTypes.KnowledgeBaseAssociationData.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension WisdomClientTypes.KnowledgeBaseAssociationData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.KnowledgeBaseAssociationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.KnowledgeBaseAssociationData()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent()
        return value
    }
}

extension WisdomClientTypes.ContentData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.ContentData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.ContentData()
        value.contentArn = try reader["contentArn"].readIfPresent() ?? ""
        value.contentId = try reader["contentId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.revisionId = try reader["revisionId"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.linkOutUri = try reader["linkOutUri"].readIfPresent()
        value.url = try reader["url"].readIfPresent() ?? ""
        value.urlExpiry = try reader["urlExpiry"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension WisdomClientTypes.KnowledgeBaseData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.KnowledgeBaseData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.KnowledgeBaseData()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.knowledgeBaseType = try reader["knowledgeBaseType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.lastContentModificationTime = try reader["lastContentModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceConfiguration = try reader["sourceConfiguration"].readIfPresent(with: WisdomClientTypes.SourceConfiguration.read(from:))
        value.renderingConfiguration = try reader["renderingConfiguration"].readIfPresent(with: WisdomClientTypes.RenderingConfiguration.read(from:))
        value.serverSideEncryptionConfiguration = try reader["serverSideEncryptionConfiguration"].readIfPresent(with: WisdomClientTypes.ServerSideEncryptionConfiguration.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WisdomClientTypes.RenderingConfiguration {

    static func write(value: WisdomClientTypes.RenderingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["templateUri"].write(value.templateUri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.RenderingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.RenderingConfiguration()
        value.templateUri = try reader["templateUri"].readIfPresent()
        return value
    }
}

extension WisdomClientTypes.SourceConfiguration {

    static func write(value: WisdomClientTypes.SourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .appintegrations(appintegrations):
                try writer["appIntegrations"].write(appintegrations, with: WisdomClientTypes.AppIntegrationsConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.SourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "appIntegrations":
                return .appintegrations(try reader["appIntegrations"].read(with: WisdomClientTypes.AppIntegrationsConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension WisdomClientTypes.AppIntegrationsConfiguration {

    static func write(value: WisdomClientTypes.AppIntegrationsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appIntegrationArn"].write(value.appIntegrationArn)
        try writer["objectFields"].writeList(value.objectFields, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.AppIntegrationsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.AppIntegrationsConfiguration()
        value.appIntegrationArn = try reader["appIntegrationArn"].readIfPresent() ?? ""
        value.objectFields = try reader["objectFields"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WisdomClientTypes.QuickResponseData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.QuickResponseData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.QuickResponseData()
        value.quickResponseArn = try reader["quickResponseArn"].readIfPresent() ?? ""
        value.quickResponseId = try reader["quickResponseId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.contents = try reader["contents"].readIfPresent(with: WisdomClientTypes.QuickResponseContents.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.groupingConfiguration = try reader["groupingConfiguration"].readIfPresent(with: WisdomClientTypes.GroupingConfiguration.read(from:))
        value.shortcutKey = try reader["shortcutKey"].readIfPresent()
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent()
        value.isActive = try reader["isActive"].readIfPresent()
        value.channels = try reader["channels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.language = try reader["language"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WisdomClientTypes.GroupingConfiguration {

    static func write(value: WisdomClientTypes.GroupingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["criteria"].write(value.criteria)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.GroupingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.GroupingConfiguration()
        value.criteria = try reader["criteria"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WisdomClientTypes.QuickResponseContents {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.QuickResponseContents {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.QuickResponseContents()
        value.plainText = try reader["plainText"].readIfPresent(with: WisdomClientTypes.QuickResponseContentProvider.read(from:))
        value.markdown = try reader["markdown"].readIfPresent(with: WisdomClientTypes.QuickResponseContentProvider.read(from:))
        return value
    }
}

extension WisdomClientTypes.QuickResponseContentProvider {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.QuickResponseContentProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "content":
                return .content(try reader["content"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension WisdomClientTypes.SessionData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.SessionData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.SessionData()
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.integrationConfiguration = try reader["integrationConfiguration"].readIfPresent(with: WisdomClientTypes.SessionIntegrationConfiguration.read(from:))
        return value
    }
}

extension WisdomClientTypes.SessionIntegrationConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.SessionIntegrationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.SessionIntegrationConfiguration()
        value.topicIntegrationArn = try reader["topicIntegrationArn"].readIfPresent()
        return value
    }
}

extension WisdomClientTypes.ContentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.ContentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.ContentSummary()
        value.contentArn = try reader["contentArn"].readIfPresent() ?? ""
        value.contentId = try reader["contentId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.revisionId = try reader["revisionId"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WisdomClientTypes.ImportJobData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.ImportJobData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.ImportJobData()
        value.importJobId = try reader["importJobId"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.uploadId = try reader["uploadId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.importJobType = try reader["importJobType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.url = try reader["url"].readIfPresent() ?? ""
        value.failedRecordReport = try reader["failedRecordReport"].readIfPresent()
        value.urlExpiry = try reader["urlExpiry"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.externalSourceConfiguration = try reader["externalSourceConfiguration"].readIfPresent(with: WisdomClientTypes.ExternalSourceConfiguration.read(from:))
        return value
    }
}

extension WisdomClientTypes.ExternalSourceConfiguration {

    static func write(value: WisdomClientTypes.ExternalSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: WisdomClientTypes.Configuration.write(value:to:))
        try writer["source"].write(value.source)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.ExternalSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.ExternalSourceConfiguration()
        value.source = try reader["source"].readIfPresent() ?? .sdkUnknown("")
        value.configuration = try reader["configuration"].readIfPresent(with: WisdomClientTypes.Configuration.read(from:))
        return value
    }
}

extension WisdomClientTypes.Configuration {

    static func write(value: WisdomClientTypes.Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .connectconfiguration(connectconfiguration):
                try writer["connectConfiguration"].write(connectconfiguration, with: WisdomClientTypes.ConnectConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "connectConfiguration":
                return .connectconfiguration(try reader["connectConfiguration"].read(with: WisdomClientTypes.ConnectConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension WisdomClientTypes.ConnectConfiguration {

    static func write(value: WisdomClientTypes.ConnectConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceId"].write(value.instanceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.ConnectConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.ConnectConfiguration()
        value.instanceId = try reader["instanceId"].readIfPresent()
        return value
    }
}

extension WisdomClientTypes.RecommendationData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.RecommendationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.RecommendationData()
        value.recommendationId = try reader["recommendationId"].readIfPresent() ?? ""
        value.document = try reader["document"].readIfPresent(with: WisdomClientTypes.Document.read(from:))
        value.relevanceScore = try reader["relevanceScore"].readIfPresent() ?? 0
        value.relevanceLevel = try reader["relevanceLevel"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension WisdomClientTypes.Document {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.Document {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.Document()
        value.contentReference = try reader["contentReference"].readIfPresent(with: WisdomClientTypes.ContentReference.read(from:))
        value.title = try reader["title"].readIfPresent(with: WisdomClientTypes.DocumentText.read(from:))
        value.excerpt = try reader["excerpt"].readIfPresent(with: WisdomClientTypes.DocumentText.read(from:))
        return value
    }
}

extension WisdomClientTypes.DocumentText {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.DocumentText {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.DocumentText()
        value.text = try reader["text"].readIfPresent()
        value.highlights = try reader["highlights"].readListIfPresent(memberReadingClosure: WisdomClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WisdomClientTypes.Highlight {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.Highlight {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.Highlight()
        value.beginOffsetInclusive = try reader["beginOffsetInclusive"].readIfPresent() ?? 0
        value.endOffsetExclusive = try reader["endOffsetExclusive"].readIfPresent() ?? 0
        return value
    }
}

extension WisdomClientTypes.ContentReference {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.ContentReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.ContentReference()
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.contentArn = try reader["contentArn"].readIfPresent()
        value.contentId = try reader["contentId"].readIfPresent()
        return value
    }
}

extension WisdomClientTypes.RecommendationTrigger {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.RecommendationTrigger {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.RecommendationTrigger()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.source = try reader["source"].readIfPresent() ?? .sdkUnknown("")
        value.data = try reader["data"].readIfPresent(with: WisdomClientTypes.RecommendationTriggerData.read(from:))
        value.recommendationIds = try reader["recommendationIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension WisdomClientTypes.RecommendationTriggerData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.RecommendationTriggerData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "query":
                return .query(try reader["query"].read(with: WisdomClientTypes.QueryRecommendationTriggerData.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension WisdomClientTypes.QueryRecommendationTriggerData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.QueryRecommendationTriggerData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.QueryRecommendationTriggerData()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension WisdomClientTypes.AssistantAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.AssistantAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.AssistantAssociationSummary()
        value.assistantAssociationId = try reader["assistantAssociationId"].readIfPresent() ?? ""
        value.assistantAssociationArn = try reader["assistantAssociationArn"].readIfPresent() ?? ""
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.associationType = try reader["associationType"].readIfPresent() ?? .sdkUnknown("")
        value.associationData = try reader["associationData"].readIfPresent(with: WisdomClientTypes.AssistantAssociationOutputData.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WisdomClientTypes.AssistantSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.AssistantSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.AssistantSummary()
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.serverSideEncryptionConfiguration = try reader["serverSideEncryptionConfiguration"].readIfPresent(with: WisdomClientTypes.ServerSideEncryptionConfiguration.read(from:))
        value.integrationConfiguration = try reader["integrationConfiguration"].readIfPresent(with: WisdomClientTypes.AssistantIntegrationConfiguration.read(from:))
        return value
    }
}

extension WisdomClientTypes.ImportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.ImportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.ImportJobSummary()
        value.importJobId = try reader["importJobId"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.uploadId = try reader["uploadId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.importJobType = try reader["importJobType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.externalSourceConfiguration = try reader["externalSourceConfiguration"].readIfPresent(with: WisdomClientTypes.ExternalSourceConfiguration.read(from:))
        return value
    }
}

extension WisdomClientTypes.KnowledgeBaseSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.KnowledgeBaseSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.KnowledgeBaseSummary()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.knowledgeBaseType = try reader["knowledgeBaseType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.sourceConfiguration = try reader["sourceConfiguration"].readIfPresent(with: WisdomClientTypes.SourceConfiguration.read(from:))
        value.renderingConfiguration = try reader["renderingConfiguration"].readIfPresent(with: WisdomClientTypes.RenderingConfiguration.read(from:))
        value.serverSideEncryptionConfiguration = try reader["serverSideEncryptionConfiguration"].readIfPresent(with: WisdomClientTypes.ServerSideEncryptionConfiguration.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WisdomClientTypes.QuickResponseSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.QuickResponseSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.QuickResponseSummary()
        value.quickResponseArn = try reader["quickResponseArn"].readIfPresent() ?? ""
        value.quickResponseId = try reader["quickResponseId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent()
        value.isActive = try reader["isActive"].readIfPresent()
        value.channels = try reader["channels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WisdomClientTypes.NotifyRecommendationsReceivedError {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.NotifyRecommendationsReceivedError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.NotifyRecommendationsReceivedError()
        value.recommendationId = try reader["recommendationId"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension WisdomClientTypes.ResultData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.ResultData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.ResultData()
        value.resultId = try reader["resultId"].readIfPresent() ?? ""
        value.document = try reader["document"].readIfPresent(with: WisdomClientTypes.Document.read(from:))
        value.relevanceScore = try reader["relevanceScore"].readIfPresent() ?? 0
        return value
    }
}

extension WisdomClientTypes.QuickResponseSearchResultData {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.QuickResponseSearchResultData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.QuickResponseSearchResultData()
        value.quickResponseArn = try reader["quickResponseArn"].readIfPresent() ?? ""
        value.quickResponseId = try reader["quickResponseId"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.contents = try reader["contents"].readIfPresent(with: WisdomClientTypes.QuickResponseContents.read(from:))
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.isActive = try reader["isActive"].readIfPresent() ?? false
        value.description = try reader["description"].readIfPresent()
        value.groupingConfiguration = try reader["groupingConfiguration"].readIfPresent(with: WisdomClientTypes.GroupingConfiguration.read(from:))
        value.shortcutKey = try reader["shortcutKey"].readIfPresent()
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent()
        value.channels = try reader["channels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.language = try reader["language"].readIfPresent()
        value.attributesNotInterpolated = try reader["attributesNotInterpolated"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.attributesInterpolated = try reader["attributesInterpolated"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WisdomClientTypes.SessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WisdomClientTypes.SessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WisdomClientTypes.SessionSummary()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.assistantId = try reader["assistantId"].readIfPresent() ?? ""
        value.assistantArn = try reader["assistantArn"].readIfPresent() ?? ""
        return value
    }
}

extension WisdomClientTypes.AssistantAssociationInputData {

    static func write(value: WisdomClientTypes.AssistantAssociationInputData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .knowledgebaseid(knowledgebaseid):
                try writer["knowledgeBaseId"].write(knowledgebaseid)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension WisdomClientTypes.QuickResponseDataProvider {

    static func write(value: WisdomClientTypes.QuickResponseDataProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .content(content):
                try writer["content"].write(content)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension WisdomClientTypes.SearchExpression {

    static func write(value: WisdomClientTypes.SearchExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: WisdomClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension WisdomClientTypes.Filter {

    static func write(value: WisdomClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["field"].write(value.field)
        try writer["operator"].write(value.`operator`)
        try writer["value"].write(value.value)
    }
}

extension WisdomClientTypes.QuickResponseSearchExpression {

    static func write(value: WisdomClientTypes.QuickResponseSearchExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: WisdomClientTypes.QuickResponseFilterField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["orderOnField"].write(value.orderOnField, with: WisdomClientTypes.QuickResponseOrderField.write(value:to:))
        try writer["queries"].writeList(value.queries, memberWritingClosure: WisdomClientTypes.QuickResponseQueryField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension WisdomClientTypes.QuickResponseOrderField {

    static func write(value: WisdomClientTypes.QuickResponseOrderField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["order"].write(value.order)
    }
}

extension WisdomClientTypes.QuickResponseFilterField {

    static func write(value: WisdomClientTypes.QuickResponseFilterField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeNoExistence"].write(value.includeNoExistence)
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension WisdomClientTypes.QuickResponseQueryField {

    static func write(value: WisdomClientTypes.QuickResponseQueryField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowFuzziness"].write(value.allowFuzziness)
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
        try writer["priority"].write(value.priority)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum WisdomClientTypes {}
