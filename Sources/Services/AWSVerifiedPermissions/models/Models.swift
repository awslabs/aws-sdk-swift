// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VerifiedPermissionsClientTypes.ActionIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case actionType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType, forKey: .actionType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

extension VerifiedPermissionsClientTypes.ActionIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionIdentifier(actionId: \"CONTENT_REDACTED\", actionType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about an action for a request for which an authorization decision is made. This data type is used as an request parameter to the [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html) and [IsAuthorizedWithToken](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorizedWithToken.html) operations. Example: { "actionId": "<action name>", "actionType": "Action" }
    public struct ActionIdentifier: Swift.Equatable {
        /// The ID of an action.
        /// This member is required.
        public var actionId: Swift.String?
        /// The type of an action.
        /// This member is required.
        public var actionType: Swift.String?

        public init(
            actionId: Swift.String? = nil,
            actionType: Swift.String? = nil
        )
        {
            self.actionId = actionId
            self.actionType = actionType
        }
    }

}

extension VerifiedPermissionsClientTypes.AttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case boolean
        case entityidentifier = "entityIdentifier"
        case long
        case record
        case sdkUnknown
        case `set` = "set"
        case string
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .boolean(boolean):
                try container.encode(boolean, forKey: .boolean)
            case let .entityidentifier(entityidentifier):
                try container.encode(entityidentifier, forKey: .entityidentifier)
            case let .long(long):
                try container.encode(long, forKey: .long)
            case let .record(record):
                var recordContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .record)
                for (dictKey0, recordAttribute0) in record {
                    try recordContainer.encode(recordAttribute0, forKey: ClientRuntime.Key(stringValue: dictKey0))
                }
            case let .`set`(`set`):
                var setContainer = container.nestedUnkeyedContainer(forKey: .`set`)
                for attributevalue0 in `set` {
                    try setContainer.encode(attributevalue0)
                }
            case let .string(string):
                try container.encode(string, forKey: .string)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let booleanDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .boolean)
        if let boolean = booleanDecoded {
            self = .boolean(boolean)
            return
        }
        let entityidentifierDecoded = try values.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .entityidentifier)
        if let entityidentifier = entityidentifierDecoded {
            self = .entityidentifier(entityidentifier)
            return
        }
        let longDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .long)
        if let long = longDecoded {
            self = .long(long)
            return
        }
        let stringDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .string)
        if let string = stringDecoded {
            self = .string(string)
            return
        }
        let setContainer = try values.decodeIfPresent([VerifiedPermissionsClientTypes.AttributeValue?].self, forKey: .`set`)
        var setDecoded0:[VerifiedPermissionsClientTypes.AttributeValue]? = nil
        if let setContainer = setContainer {
            setDecoded0 = [VerifiedPermissionsClientTypes.AttributeValue]()
            for union0 in setContainer {
                if let union0 = union0 {
                    setDecoded0?.append(union0)
                }
            }
        }
        if let `set` = setDecoded0 {
            self = .`set`(`set`)
            return
        }
        let recordContainer = try values.decodeIfPresent([Swift.String: VerifiedPermissionsClientTypes.AttributeValue?].self, forKey: .record)
        var recordDecoded0: [Swift.String:VerifiedPermissionsClientTypes.AttributeValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [Swift.String:VerifiedPermissionsClientTypes.AttributeValue]()
            for (key0, attributevalue0) in recordContainer {
                if let attributevalue0 = attributevalue0 {
                    recordDecoded0?[key0] = attributevalue0
                }
            }
        }
        if let record = recordDecoded0 {
            self = .record(record)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VerifiedPermissionsClientTypes {
    /// The value of an attribute. Contains information about the runtime context for a request for which an authorization decision is made. This data type is used as a member of the [ContextDefinition](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ContextDefinition.html) structure which is uses as a request parameter for the [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html) and [IsAuthorizedWithToken](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorizedWithToken.html) operations.
    public enum AttributeValue: Swift.Equatable {
        /// An attribute value of [Boolean](https://docs.cedarpolicy.com/syntax-datatypes.html#boolean) type. Example: {"boolean": true}
        case boolean(Swift.Bool)
        /// An attribute value of type [EntityIdentifier](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_EntityIdentifier.html). Example: "entityIdentifier": { "entityId": "<id>", "entityType": "<entity type>"}
        case entityidentifier(VerifiedPermissionsClientTypes.EntityIdentifier)
        /// An attribute value of [Long](https://docs.cedarpolicy.com/syntax-datatypes.html#long) type. Example: {"long": 0}
        case long(Swift.Int)
        /// An attribute value of [String](https://docs.cedarpolicy.com/syntax-datatypes.html#string) type. Example: {"string": "abc"}
        case string(Swift.String)
        /// An attribute value of [Set](https://docs.cedarpolicy.com/syntax-datatypes.html#set) type. Example: {"set": [ {} ] }
        case `set`([VerifiedPermissionsClientTypes.AttributeValue])
        /// An attribute value of [Record](https://docs.cedarpolicy.com/syntax-datatypes.html#record) type. Example: {"record": { "keyName": {} } }
        case record([Swift.String:VerifiedPermissionsClientTypes.AttributeValue])
        case sdkUnknown(Swift.String)
    }

}

extension VerifiedPermissionsClientTypes.CognitoUserPoolConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIds
        case userPoolArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIds = clientIds {
            var clientIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientIds)
            for clientid0 in clientIds {
                try clientIdsContainer.encode(clientid0)
            }
        }
        if let userPoolArn = self.userPoolArn {
            try encodeContainer.encode(userPoolArn, forKey: .userPoolArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolArn)
        userPoolArn = userPoolArnDecoded
        let clientIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientIds)
        var clientIdsDecoded0:[Swift.String]? = nil
        if let clientIdsContainer = clientIdsContainer {
            clientIdsDecoded0 = [Swift.String]()
            for string0 in clientIdsContainer {
                if let string0 = string0 {
                    clientIdsDecoded0?.append(string0)
                }
            }
        }
        clientIds = clientIdsDecoded0
    }
}

extension VerifiedPermissionsClientTypes {
    /// The configuration for an identity source that represents a connection to an Amazon Cognito user pool used as an identity provider for Verified Permissions. This data type is used as a field that is part of an [Configuration](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_Configuration.html) structure that is used as a parameter to the [Configuration](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_Configuration.html). Example:"CognitoUserPoolConfiguration":{"UserPoolArn":"arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_1a2b3c4d5","ClientIds": ["a1b2c3d4e5f6g7h8i9j0kalbmc"]}
    public struct CognitoUserPoolConfiguration: Swift.Equatable {
        /// The unique application client IDs that are associated with the specified Amazon Cognito user pool. Example: "ClientIds": ["&ExampleCogClientId;"]
        public var clientIds: [Swift.String]?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Amazon Cognito user pool that contains the identities to be authorized. Example: "UserPoolArn": "arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_1a2b3c4d5"
        /// This member is required.
        public var userPoolArn: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            userPoolArn: Swift.String? = nil
        )
        {
            self.clientIds = clientIds
            self.userPoolArn = userPoolArn
        }
    }

}

extension VerifiedPermissionsClientTypes.Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitouserpoolconfiguration = "cognitoUserPoolConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .cognitouserpoolconfiguration(cognitouserpoolconfiguration):
                try container.encode(cognitouserpoolconfiguration, forKey: .cognitouserpoolconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let cognitouserpoolconfigurationDecoded = try values.decodeIfPresent(VerifiedPermissionsClientTypes.CognitoUserPoolConfiguration.self, forKey: .cognitouserpoolconfiguration)
        if let cognitouserpoolconfiguration = cognitouserpoolconfigurationDecoded {
            self = .cognitouserpoolconfiguration(cognitouserpoolconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains configuration information used when creating a new identity source. At this time, the only valid member of this structure is a Amazon Cognito user pool configuration. You must specify a userPoolArn, and optionally, a ClientId. This data type is used as a request parameter for the [CreateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreateIdentitySource.html) operation.
    public enum Configuration: Swift.Equatable {
        /// Contains configuration details of a Amazon Cognito user pool that Verified Permissions can use as a source of authenticated identities as entities. It specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a Amazon Cognito user pool and one or more application client IDs. Example: "configuration":{"cognitoUserPoolConfiguration":{"userPoolArn":"arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_1a2b3c4d5","clientIds": ["a1b2c3d4e5f6g7h8i9j0kalbmc"]}}
        case cognitouserpoolconfiguration(VerifiedPermissionsClientTypes.CognitoUserPoolConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resources = output.resources
        } else {
            self.properties.message = nil
            self.properties.resources = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because another request to modify a resource occurred at the same.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The list of resources referenced with this failed request.
        /// This member is required.
        public internal(set) var resources: [VerifiedPermissionsClientTypes.ResourceConflict]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resources: [VerifiedPermissionsClientTypes.ResourceConflict]? = nil
    )
    {
        self.properties.message = message
        self.properties.resources = resources
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resources: [VerifiedPermissionsClientTypes.ResourceConflict]?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([VerifiedPermissionsClientTypes.ResourceConflict?].self, forKey: .resources)
        var resourcesDecoded0:[VerifiedPermissionsClientTypes.ResourceConflict]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [VerifiedPermissionsClientTypes.ResourceConflict]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension VerifiedPermissionsClientTypes.ContextDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextmap = "contextMap"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .contextmap(contextmap):
                var contextmapContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .contextmap)
                for (dictKey0, contextMap0) in contextmap {
                    try contextmapContainer.encode(contextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let contextmapContainer = try values.decodeIfPresent([Swift.String: VerifiedPermissionsClientTypes.AttributeValue?].self, forKey: .contextmap)
        var contextmapDecoded0: [Swift.String:VerifiedPermissionsClientTypes.AttributeValue]? = nil
        if let contextmapContainer = contextmapContainer {
            contextmapDecoded0 = [Swift.String:VerifiedPermissionsClientTypes.AttributeValue]()
            for (key0, attributevalue0) in contextmapContainer {
                if let attributevalue0 = attributevalue0 {
                    contextmapDecoded0?[key0] = attributevalue0
                }
            }
        }
        if let contextmap = contextmapDecoded0 {
            self = .contextmap(contextmap)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains additional details about the context of the request. Verified Permissions evaluates this information in an authorization request as part of the when and unless clauses in a policy. This data type is used as a request parameter for the [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html) and [IsAuthorizedWithToken](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorizedWithToken.html) operations. Example: "context":{"Context":{"<KeyName1>":{"boolean":true},"<KeyName2>":{"long":1234}}}
    public enum ContextDefinition: Swift.Equatable {
        /// An list of attributes that are needed to successfully evaluate an authorization request. Each attribute in this array must include a map of a data type and its value. Example: "Context":{"<KeyName1>":{"boolean":true},"<KeyName2>":{"long":1234}}
        case contextmap([Swift.String:VerifiedPermissionsClientTypes.AttributeValue])
        case sdkUnknown(Swift.String)
    }

}

extension CreateIdentitySourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIdentitySourceInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), policyStoreId: \(Swift.String(describing: policyStoreId)), principalEntityType: \"CONTENT_REDACTED\")"}
}

extension CreateIdentitySourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configuration
        case policyStoreId
        case principalEntityType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
        if let principalEntityType = self.principalEntityType {
            try encodeContainer.encode(principalEntityType, forKey: .principalEntityType)
        }
    }
}

extension CreateIdentitySourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateIdentitySourceInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the details required to communicate with the identity provider (IdP) associated with this identity source. At this time, the only valid member of this structure is a Amazon Cognito user pool configuration. You must specify a UserPoolArn, and optionally, a ClientId.
    /// This member is required.
    public var configuration: VerifiedPermissionsClientTypes.Configuration?
    /// Specifies the ID of the policy store in which you want to store this identity source. Only policies and requests made using this policy store can reference identities from the identity provider configured in the new identity source.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the namespace and data type of the principals generated for identities authenticated by the new identity source.
    public var principalEntityType: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        configuration: VerifiedPermissionsClientTypes.Configuration? = nil,
        policyStoreId: Swift.String? = nil,
        principalEntityType: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.policyStoreId = policyStoreId
        self.principalEntityType = principalEntityType
    }
}

struct CreateIdentitySourceInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let policyStoreId: Swift.String?
    let configuration: VerifiedPermissionsClientTypes.Configuration?
    let principalEntityType: Swift.String?
}

extension CreateIdentitySourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configuration
        case policyStoreId
        case principalEntityType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.Configuration.self, forKey: .configuration)
        configuration = configurationDecoded
        let principalEntityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalEntityType)
        principalEntityType = principalEntityTypeDecoded
    }
}

extension CreateIdentitySourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIdentitySourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.identitySourceId = output.identitySourceId
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyStoreId = output.policyStoreId
        } else {
            self.createdDate = nil
            self.identitySourceId = nil
            self.lastUpdatedDate = nil
            self.policyStoreId = nil
        }
    }
}

public struct CreateIdentitySourceOutput: Swift.Equatable {
    /// The date and time the identity source was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The unique ID of the new identity source.
    /// This member is required.
    public var identitySourceId: Swift.String?
    /// The date and time the identity source was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The ID of the policy store that contains the identity source.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        identitySourceId: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.identitySourceId = identitySourceId
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
    }
}

struct CreateIdentitySourceOutputBody: Swift.Equatable {
    let createdDate: ClientRuntime.Date?
    let identitySourceId: Swift.String?
    let lastUpdatedDate: ClientRuntime.Date?
    let policyStoreId: Swift.String?
}

extension CreateIdentitySourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case identitySourceId
        case lastUpdatedDate
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let identitySourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySourceId)
        identitySourceId = identitySourceIdDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
    }
}

enum CreateIdentitySourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case definition
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension CreatePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePolicyInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// A structure that specifies the policy type and content to use for the new policy. You must include either a static or a templateLinked element. The policy content must be written in the Cedar policy language.
    /// This member is required.
    public var definition: VerifiedPermissionsClientTypes.PolicyDefinition?
    /// Specifies the PolicyStoreId of the policy store you want to store the policy in.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        definition: VerifiedPermissionsClientTypes.PolicyDefinition? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.definition = definition
        self.policyStoreId = policyStoreId
    }
}

struct CreatePolicyInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let policyStoreId: Swift.String?
    let definition: VerifiedPermissionsClientTypes.PolicyDefinition?
}

extension CreatePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case definition
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.PolicyDefinition.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension CreatePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyId = output.policyId
            self.policyStoreId = output.policyStoreId
            self.policyType = output.policyType
            self.principal = output.principal
            self.resource = output.resource
        } else {
            self.createdDate = nil
            self.lastUpdatedDate = nil
            self.policyId = nil
            self.policyStoreId = nil
            self.policyType = nil
            self.principal = nil
            self.resource = nil
        }
    }
}

public struct CreatePolicyOutput: Swift.Equatable {
    /// The date and time the policy was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The date and time the policy was last updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The unique ID of the new policy.
    /// This member is required.
    public var policyId: Swift.String?
    /// The ID of the policy store that contains the new policy.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The policy type of the new policy.
    /// This member is required.
    public var policyType: VerifiedPermissionsClientTypes.PolicyType?
    /// The principal specified in the new policy's scope. This response element isn't present when principal isn't specified in the policy content.
    public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    /// The resource specified in the new policy's scope. This response element isn't present when the resource isn't specified in the policy content.
    public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        policyType: VerifiedPermissionsClientTypes.PolicyType? = nil,
        principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
        resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
    )
    {
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.policyId = policyId
        self.policyStoreId = policyStoreId
        self.policyType = policyType
        self.principal = principal
        self.resource = resource
    }
}

struct CreatePolicyOutputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let policyId: Swift.String?
    let policyType: VerifiedPermissionsClientTypes.PolicyType?
    let principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    let resource: VerifiedPermissionsClientTypes.EntityIdentifier?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension CreatePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case lastUpdatedDate
        case policyId
        case policyStoreId
        case policyType
        case principal
        case resource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.PolicyType.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let principalDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .resource)
        resource = resourceDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum CreatePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePolicyStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case validationSettings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let validationSettings = self.validationSettings {
            try encodeContainer.encode(validationSettings, forKey: .validationSettings)
        }
    }
}

extension CreatePolicyStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePolicyStoreInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the validation setting for this policy store. Currently, the only valid and required value is Mode. We recommend that you turn on STRICT mode only after you define a schema. If a schema doesn't exist, then STRICT mode causes any policy to fail validation, and Verified Permissions rejects the policy. You can turn off validation by using the [UpdatePolicyStore](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicyStore). Then, when you have a schema defined, use [UpdatePolicyStore](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicyStore) again to turn validation back on.
    /// This member is required.
    public var validationSettings: VerifiedPermissionsClientTypes.ValidationSettings?

    public init(
        clientToken: Swift.String? = nil,
        validationSettings: VerifiedPermissionsClientTypes.ValidationSettings? = nil
    )
    {
        self.clientToken = clientToken
        self.validationSettings = validationSettings
    }
}

struct CreatePolicyStoreInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let validationSettings: VerifiedPermissionsClientTypes.ValidationSettings?
}

extension CreatePolicyStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case validationSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let validationSettingsDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.ValidationSettings.self, forKey: .validationSettings)
        validationSettings = validationSettingsDecoded
    }
}

extension CreatePolicyStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePolicyStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdDate = output.createdDate
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyStoreId = output.policyStoreId
        } else {
            self.arn = nil
            self.createdDate = nil
            self.lastUpdatedDate = nil
            self.policyStoreId = nil
        }
    }
}

public struct CreatePolicyStoreOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new policy store.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time the policy store was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The date and time the policy store was last updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The unique ID of the new policy store.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
    }
}

struct CreatePolicyStoreOutputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let arn: Swift.String?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension CreatePolicyStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdDate
        case lastUpdatedDate
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum CreatePolicyStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePolicyTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePolicyTemplateInput(clientToken: \(Swift.String(describing: clientToken)), policyStoreId: \(Swift.String(describing: policyStoreId)), description: \"CONTENT_REDACTED\", statement: \"CONTENT_REDACTED\")"}
}

extension CreatePolicyTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case policyStoreId
        case statement
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
        if let statement = self.statement {
            try encodeContainer.encode(statement, forKey: .statement)
        }
    }
}

extension CreatePolicyTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePolicyTemplateInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies a description for the policy template.
    public var description: Swift.String?
    /// The ID of the policy store in which to create the policy template.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the content that you want to use for the new policy template, written in the Cedar policy language.
    /// This member is required.
    public var statement: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        statement: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.policyStoreId = policyStoreId
        self.statement = statement
    }
}

struct CreatePolicyTemplateInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let policyStoreId: Swift.String?
    let description: Swift.String?
    let statement: Swift.String?
}

extension CreatePolicyTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case policyStoreId
        case statement
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
    }
}

extension CreatePolicyTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePolicyTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyStoreId = output.policyStoreId
            self.policyTemplateId = output.policyTemplateId
        } else {
            self.createdDate = nil
            self.lastUpdatedDate = nil
            self.policyStoreId = nil
            self.policyTemplateId = nil
        }
    }
}

public struct CreatePolicyTemplateOutput: Swift.Equatable {
    /// The date and time the policy template was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The date and time the policy template was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The ID of the policy store that contains the policy template.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The unique ID of the new policy template.
    /// This member is required.
    public var policyTemplateId: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyStoreId: Swift.String? = nil,
        policyTemplateId: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
        self.policyTemplateId = policyTemplateId
    }
}

struct CreatePolicyTemplateOutputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let policyTemplateId: Swift.String?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension CreatePolicyTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case lastUpdatedDate
        case policyStoreId
        case policyTemplateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplateId)
        policyTemplateId = policyTemplateIdDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum CreatePolicyTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VerifiedPermissionsClientTypes {
    public enum Decision: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [Decision] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Decision(rawValue: rawValue) ?? Decision.sdkUnknown(rawValue)
        }
    }
}

extension DeleteIdentitySourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identitySourceId
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identitySourceId = self.identitySourceId {
            try encodeContainer.encode(identitySourceId, forKey: .identitySourceId)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension DeleteIdentitySourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteIdentitySourceInput: Swift.Equatable {
    /// Specifies the ID of the identity source that you want to delete.
    /// This member is required.
    public var identitySourceId: Swift.String?
    /// Specifies the ID of the policy store that contains the identity source that you want to delete.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        identitySourceId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.identitySourceId = identitySourceId
        self.policyStoreId = policyStoreId
    }
}

struct DeleteIdentitySourceInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let identitySourceId: Swift.String?
}

extension DeleteIdentitySourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identitySourceId
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let identitySourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySourceId)
        identitySourceId = identitySourceIdDecoded
    }
}

extension DeleteIdentitySourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIdentitySourceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIdentitySourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension DeletePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePolicyInput: Swift.Equatable {
    /// Specifies the ID of the policy that you want to delete.
    /// This member is required.
    public var policyId: Swift.String?
    /// Specifies the ID of the policy store that contains the policy that you want to delete.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        policyId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.policyId = policyId
        self.policyStoreId = policyStoreId
    }
}

struct DeletePolicyInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let policyId: Swift.String?
}

extension DeletePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

extension DeletePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeletePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePolicyStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension DeletePolicyStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePolicyStoreInput: Swift.Equatable {
    /// Specifies the ID of the policy store that you want to delete.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        policyStoreId: Swift.String? = nil
    )
    {
        self.policyStoreId = policyStoreId
    }
}

struct DeletePolicyStoreInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
}

extension DeletePolicyStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
    }
}

extension DeletePolicyStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePolicyStoreOutput: Swift.Equatable {

    public init() { }
}

enum DeletePolicyStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePolicyTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStoreId
        case policyTemplateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
        if let policyTemplateId = self.policyTemplateId {
            try encodeContainer.encode(policyTemplateId, forKey: .policyTemplateId)
        }
    }
}

extension DeletePolicyTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePolicyTemplateInput: Swift.Equatable {
    /// Specifies the ID of the policy store that contains the policy template that you want to delete.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the ID of the policy template that you want to delete.
    /// This member is required.
    public var policyTemplateId: Swift.String?

    public init(
        policyStoreId: Swift.String? = nil,
        policyTemplateId: Swift.String? = nil
    )
    {
        self.policyStoreId = policyStoreId
        self.policyTemplateId = policyTemplateId
    }
}

struct DeletePolicyTemplateInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let policyTemplateId: Swift.String?
}

extension DeletePolicyTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStoreId
        case policyTemplateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplateId)
        policyTemplateId = policyTemplateIdDecoded
    }
}

extension DeletePolicyTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePolicyTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeletePolicyTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VerifiedPermissionsClientTypes.DeterminingPolicyItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about one of the policies that determined an authorization decision. This data type is used as an element in a response parameter for the [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html) and [IsAuthorizedWithToken](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorizedWithToken.html) operations. Example: "determiningPolicies":[{"policyId":"SPEXAMPLEabcdefg111111"}]
    public struct DeterminingPolicyItem: Swift.Equatable {
        /// The Id of a policy that determined to an authorization decision. Example: "policyId":"SPEXAMPLEabcdefg111111"
        /// This member is required.
        public var policyId: Swift.String?

        public init(
            policyId: Swift.String? = nil
        )
        {
            self.policyId = policyId
        }
    }

}

extension VerifiedPermissionsClientTypes.EntitiesDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitylist = "entityList"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .entitylist(entitylist):
                var entitylistContainer = container.nestedUnkeyedContainer(forKey: .entitylist)
                for entityitem0 in entitylist {
                    try entitylistContainer.encode(entityitem0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let entitylistContainer = try values.decodeIfPresent([VerifiedPermissionsClientTypes.EntityItem?].self, forKey: .entitylist)
        var entitylistDecoded0:[VerifiedPermissionsClientTypes.EntityItem]? = nil
        if let entitylistContainer = entitylistContainer {
            entitylistDecoded0 = [VerifiedPermissionsClientTypes.EntityItem]()
            for structure0 in entitylistContainer {
                if let structure0 = structure0 {
                    entitylistDecoded0?.append(structure0)
                }
            }
        }
        if let entitylist = entitylistDecoded0 {
            self = .entitylist(entitylist)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains the list of entities to be considered during an authorization request. This includes all principals, resources, and actions required to successfully evaluate the request. This data type is used as a field in the response parameter for the [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html) and [IsAuthorizedWithToken](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorizedWithToken.html) operations.
    public enum EntitiesDefinition: Swift.Equatable {
        /// An array of entities that are needed to successfully evaluate an authorization request. Each entity in this array must include an identifier for the entity, the attributes of the entity, and a list of any parent entities.
        case entitylist([VerifiedPermissionsClientTypes.EntityItem])
        case sdkUnknown(Swift.String)
    }

}

extension VerifiedPermissionsClientTypes.EntityIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case entityType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension VerifiedPermissionsClientTypes.EntityIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EntityIdentifier(entityId: \"CONTENT_REDACTED\", entityType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {
    /// Contains the identifier of an entity, including its ID and type. This data type is used as a request parameter for [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html) operation, and as a response parameter for the [CreatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html), [GetPolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetPolicy.html), and [UpdatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicy.html) operations. Example: {"entityId":"string","entityType":"string"}
    public struct EntityIdentifier: Swift.Equatable {
        /// The identifier of an entity. "entityId":"identifier"
        /// This member is required.
        public var entityId: Swift.String?
        /// The type of an entity. Example: "entityType":"typeName"
        /// This member is required.
        public var entityType: Swift.String?

        public init(
            entityId: Swift.String? = nil,
            entityType: Swift.String? = nil
        )
        {
            self.entityId = entityId
            self.entityType = entityType
        }
    }

}

extension VerifiedPermissionsClientTypes.EntityItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case identifier
        case parents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, entityAttributes0) in attributes {
                try attributesContainer.encode(entityAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let parents = parents {
            var parentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parents)
            for entityidentifier0 in parents {
                try parentsContainer.encode(entityidentifier0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .identifier)
        identifier = identifierDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: VerifiedPermissionsClientTypes.AttributeValue?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:VerifiedPermissionsClientTypes.AttributeValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:VerifiedPermissionsClientTypes.AttributeValue]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let parentsContainer = try containerValues.decodeIfPresent([VerifiedPermissionsClientTypes.EntityIdentifier?].self, forKey: .parents)
        var parentsDecoded0:[VerifiedPermissionsClientTypes.EntityIdentifier]? = nil
        if let parentsContainer = parentsContainer {
            parentsDecoded0 = [VerifiedPermissionsClientTypes.EntityIdentifier]()
            for structure0 in parentsContainer {
                if let structure0 = structure0 {
                    parentsDecoded0?.append(structure0)
                }
            }
        }
        parents = parentsDecoded0
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about an entity that can be referenced in a Cedar policy. This data type is used as one of the fields in the [EntitiesDefinition](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_EntitiesDefinition.html) structure. { "identifier": { "entityType": "Photo", "entityId": "VacationPhoto94.jpg" }, "attributes": {}, "parents": [ { "entityType": "Album", "entityId": "alice_folder" } ] }
    public struct EntityItem: Swift.Equatable {
        /// A list of attributes for the entity.
        public var attributes: [Swift.String:VerifiedPermissionsClientTypes.AttributeValue]?
        /// The identifier of the entity.
        /// This member is required.
        public var identifier: VerifiedPermissionsClientTypes.EntityIdentifier?
        /// The parents in the hierarchy that contains the entity.
        public var parents: [VerifiedPermissionsClientTypes.EntityIdentifier]?

        public init(
            attributes: [Swift.String:VerifiedPermissionsClientTypes.AttributeValue]? = nil,
            identifier: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
            parents: [VerifiedPermissionsClientTypes.EntityIdentifier]? = nil
        )
        {
            self.attributes = attributes
            self.identifier = identifier
            self.parents = parents
        }
    }

}

extension VerifiedPermissionsClientTypes.EntityReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case sdkUnknown
        case unspecified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .identifier(identifier):
                try container.encode(identifier, forKey: .identifier)
            case let .unspecified(unspecified):
                try container.encode(unspecified, forKey: .unspecified)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let unspecifiedDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .unspecified)
        if let unspecified = unspecifiedDecoded {
            self = .unspecified(unspecified)
            return
        }
        let identifierDecoded = try values.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .identifier)
        if let identifier = identifierDecoded {
            self = .identifier(identifier)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about a principal or resource that can be referenced in a Cedar policy. This data type is used as part of the [PolicyFilter](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_PolicyFilter.html) structure that is used as a request parameter for the [ListPolicies](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicies.html) operation..
    public enum EntityReference: Swift.Equatable {
        /// Used to indicate that a principal or resource is not specified. This can be used to search for policies that are not associated with a specific principal or resource.
        case unspecified(Swift.Bool)
        /// The identifier of the entity. It can consist of either an EntityType and EntityId, a principal, or a resource.
        case identifier(VerifiedPermissionsClientTypes.EntityIdentifier)
        case sdkUnknown(Swift.String)
    }

}

extension VerifiedPermissionsClientTypes.EvaluationErrorItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorDescription
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorDescription = self.errorDescription {
            try encodeContainer.encode(errorDescription, forKey: .errorDescription)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorDescription)
        errorDescription = errorDescriptionDecoded
    }
}

extension VerifiedPermissionsClientTypes.EvaluationErrorItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains a description of an evaluation error. This data type is used as a request parameter in the [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html) and [IsAuthorizedWithToken](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorizedWithToken.html) operations.
    public struct EvaluationErrorItem: Swift.Equatable {
        /// The error description.
        /// This member is required.
        public var errorDescription: Swift.String?

        public init(
            errorDescription: Swift.String? = nil
        )
        {
            self.errorDescription = errorDescription
        }
    }

}

extension GetIdentitySourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identitySourceId
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identitySourceId = self.identitySourceId {
            try encodeContainer.encode(identitySourceId, forKey: .identitySourceId)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension GetIdentitySourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetIdentitySourceInput: Swift.Equatable {
    /// Specifies the ID of the identity source you want information about.
    /// This member is required.
    public var identitySourceId: Swift.String?
    /// Specifies the ID of the policy store that contains the identity source you want information about.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        identitySourceId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.identitySourceId = identitySourceId
        self.policyStoreId = policyStoreId
    }
}

struct GetIdentitySourceInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let identitySourceId: Swift.String?
}

extension GetIdentitySourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identitySourceId
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let identitySourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySourceId)
        identitySourceId = identitySourceIdDecoded
    }
}

extension GetIdentitySourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIdentitySourceOutput(createdDate: \(Swift.String(describing: createdDate)), details: \(Swift.String(describing: details)), identitySourceId: \(Swift.String(describing: identitySourceId)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), principalEntityType: \"CONTENT_REDACTED\")"}
}

extension GetIdentitySourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIdentitySourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.details = output.details
            self.identitySourceId = output.identitySourceId
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyStoreId = output.policyStoreId
            self.principalEntityType = output.principalEntityType
        } else {
            self.createdDate = nil
            self.details = nil
            self.identitySourceId = nil
            self.lastUpdatedDate = nil
            self.policyStoreId = nil
            self.principalEntityType = nil
        }
    }
}

public struct GetIdentitySourceOutput: Swift.Equatable {
    /// The date and time that the identity source was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// A structure that describes the configuration of the identity source.
    /// This member is required.
    public var details: VerifiedPermissionsClientTypes.IdentitySourceDetails?
    /// The ID of the identity source.
    /// This member is required.
    public var identitySourceId: Swift.String?
    /// The date and time that the identity source was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The ID of the policy store that contains the identity source.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The data type of principals generated for identities authenticated by this identity source.
    /// This member is required.
    public var principalEntityType: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        details: VerifiedPermissionsClientTypes.IdentitySourceDetails? = nil,
        identitySourceId: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyStoreId: Swift.String? = nil,
        principalEntityType: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.details = details
        self.identitySourceId = identitySourceId
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
        self.principalEntityType = principalEntityType
    }
}

struct GetIdentitySourceOutputBody: Swift.Equatable {
    let createdDate: ClientRuntime.Date?
    let details: VerifiedPermissionsClientTypes.IdentitySourceDetails?
    let identitySourceId: Swift.String?
    let lastUpdatedDate: ClientRuntime.Date?
    let policyStoreId: Swift.String?
    let principalEntityType: Swift.String?
}

extension GetIdentitySourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case details
        case identitySourceId
        case lastUpdatedDate
        case policyStoreId
        case principalEntityType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.IdentitySourceDetails.self, forKey: .details)
        details = detailsDecoded
        let identitySourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySourceId)
        identitySourceId = identitySourceIdDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let principalEntityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalEntityType)
        principalEntityType = principalEntityTypeDecoded
    }
}

enum GetIdentitySourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension GetPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPolicyInput: Swift.Equatable {
    /// Specifies the ID of the policy you want information about.
    /// This member is required.
    public var policyId: Swift.String?
    /// Specifies the ID of the policy store that contains the policy that you want information about.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        policyId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.policyId = policyId
        self.policyStoreId = policyStoreId
    }
}

struct GetPolicyInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let policyId: Swift.String?
}

extension GetPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

extension GetPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.definition = output.definition
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyId = output.policyId
            self.policyStoreId = output.policyStoreId
            self.policyType = output.policyType
            self.principal = output.principal
            self.resource = output.resource
        } else {
            self.createdDate = nil
            self.definition = nil
            self.lastUpdatedDate = nil
            self.policyId = nil
            self.policyStoreId = nil
            self.policyType = nil
            self.principal = nil
            self.resource = nil
        }
    }
}

public struct GetPolicyOutput: Swift.Equatable {
    /// The date and time that the policy was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The definition of the requested policy.
    /// This member is required.
    public var definition: VerifiedPermissionsClientTypes.PolicyDefinitionDetail?
    /// The date and time that the policy was last updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The unique ID of the policy that you want information about.
    /// This member is required.
    public var policyId: Swift.String?
    /// The ID of the policy store that contains the policy that you want information about.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The type of the policy.
    /// This member is required.
    public var policyType: VerifiedPermissionsClientTypes.PolicyType?
    /// The principal specified in the policy's scope. This element isn't included in the response when Principal isn't present in the policy content.
    public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    /// The resource specified in the policy's scope. This element isn't included in the response when Resource isn't present in the policy content.
    public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        definition: VerifiedPermissionsClientTypes.PolicyDefinitionDetail? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        policyType: VerifiedPermissionsClientTypes.PolicyType? = nil,
        principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
        resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
    )
    {
        self.createdDate = createdDate
        self.definition = definition
        self.lastUpdatedDate = lastUpdatedDate
        self.policyId = policyId
        self.policyStoreId = policyStoreId
        self.policyType = policyType
        self.principal = principal
        self.resource = resource
    }
}

struct GetPolicyOutputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let policyId: Swift.String?
    let policyType: VerifiedPermissionsClientTypes.PolicyType?
    let principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    let resource: VerifiedPermissionsClientTypes.EntityIdentifier?
    let definition: VerifiedPermissionsClientTypes.PolicyDefinitionDetail?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension GetPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case definition
        case lastUpdatedDate
        case policyId
        case policyStoreId
        case policyType
        case principal
        case resource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.PolicyType.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let principalDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .resource)
        resource = resourceDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.PolicyDefinitionDetail.self, forKey: .definition)
        definition = definitionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum GetPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPolicyStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension GetPolicyStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPolicyStoreInput: Swift.Equatable {
    /// Specifies the ID of the policy store that you want information about.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        policyStoreId: Swift.String? = nil
    )
    {
        self.policyStoreId = policyStoreId
    }
}

struct GetPolicyStoreInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
}

extension GetPolicyStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
    }
}

extension GetPolicyStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPolicyStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdDate = output.createdDate
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyStoreId = output.policyStoreId
            self.validationSettings = output.validationSettings
        } else {
            self.arn = nil
            self.createdDate = nil
            self.lastUpdatedDate = nil
            self.policyStoreId = nil
            self.validationSettings = nil
        }
    }
}

public struct GetPolicyStoreOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the policy store.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time that the policy store was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The date and time that the policy store was last updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The ID of the policy store;
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The current validation settings for the policy store.
    /// This member is required.
    public var validationSettings: VerifiedPermissionsClientTypes.ValidationSettings?

    public init(
        arn: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyStoreId: Swift.String? = nil,
        validationSettings: VerifiedPermissionsClientTypes.ValidationSettings? = nil
    )
    {
        self.arn = arn
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
        self.validationSettings = validationSettings
    }
}

struct GetPolicyStoreOutputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let arn: Swift.String?
    let validationSettings: VerifiedPermissionsClientTypes.ValidationSettings?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension GetPolicyStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdDate
        case lastUpdatedDate
        case policyStoreId
        case validationSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let validationSettingsDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.ValidationSettings.self, forKey: .validationSettings)
        validationSettings = validationSettingsDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum GetPolicyStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPolicyTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStoreId
        case policyTemplateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
        if let policyTemplateId = self.policyTemplateId {
            try encodeContainer.encode(policyTemplateId, forKey: .policyTemplateId)
        }
    }
}

extension GetPolicyTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPolicyTemplateInput: Swift.Equatable {
    /// Specifies the ID of the policy store that contains the policy template that you want information about.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the ID of the policy template that you want information about.
    /// This member is required.
    public var policyTemplateId: Swift.String?

    public init(
        policyStoreId: Swift.String? = nil,
        policyTemplateId: Swift.String? = nil
    )
    {
        self.policyStoreId = policyStoreId
        self.policyTemplateId = policyTemplateId
    }
}

struct GetPolicyTemplateInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let policyTemplateId: Swift.String?
}

extension GetPolicyTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStoreId
        case policyTemplateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplateId)
        policyTemplateId = policyTemplateIdDecoded
    }
}

extension GetPolicyTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPolicyTemplateOutput(createdDate: \(Swift.String(describing: createdDate)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), policyTemplateId: \(Swift.String(describing: policyTemplateId)), description: \"CONTENT_REDACTED\", statement: \"CONTENT_REDACTED\")"}
}

extension GetPolicyTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPolicyTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.description = output.description
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyStoreId = output.policyStoreId
            self.policyTemplateId = output.policyTemplateId
            self.statement = output.statement
        } else {
            self.createdDate = nil
            self.description = nil
            self.lastUpdatedDate = nil
            self.policyStoreId = nil
            self.policyTemplateId = nil
            self.statement = nil
        }
    }
}

public struct GetPolicyTemplateOutput: Swift.Equatable {
    /// The date and time that the policy template was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The description of the policy template.
    public var description: Swift.String?
    /// The date and time that the policy template was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The ID of the policy store that contains the policy template.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The ID of the policy template.
    /// This member is required.
    public var policyTemplateId: Swift.String?
    /// The content of the body of the policy template written in the Cedar policy language.
    /// This member is required.
    public var statement: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyStoreId: Swift.String? = nil,
        policyTemplateId: Swift.String? = nil,
        statement: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
        self.policyTemplateId = policyTemplateId
        self.statement = statement
    }
}

struct GetPolicyTemplateOutputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let policyTemplateId: Swift.String?
    let description: Swift.String?
    let statement: Swift.String?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension GetPolicyTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case lastUpdatedDate
        case policyStoreId
        case policyTemplateId
        case statement
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplateId)
        policyTemplateId = policyTemplateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum GetPolicyTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension GetSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSchemaInput: Swift.Equatable {
    /// Specifies the ID of the policy store that contains the schema.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        policyStoreId: Swift.String? = nil
    )
    {
        self.policyStoreId = policyStoreId
    }
}

struct GetSchemaInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
}

extension GetSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
    }
}

extension GetSchemaOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSchemaOutput(createdDate: \(Swift.String(describing: createdDate)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), schema: \"CONTENT_REDACTED\")"}
}

extension GetSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyStoreId = output.policyStoreId
            self.schema = output.schema
        } else {
            self.createdDate = nil
            self.lastUpdatedDate = nil
            self.policyStoreId = nil
            self.schema = nil
        }
    }
}

public struct GetSchemaOutput: Swift.Equatable {
    /// The date and time that the schema was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The date and time that the schema was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The ID of the policy store that contains the schema.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The body of the schema, written in Cedar schema JSON.
    /// This member is required.
    public var schema: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyStoreId: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
        self.schema = schema
    }
}

struct GetSchemaOutputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let schema: Swift.String?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension GetSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case lastUpdatedDate
        case policyStoreId
        case schema
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum GetSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VerifiedPermissionsClientTypes.IdentitySourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIds
        case discoveryUrl
        case openIdIssuer
        case userPoolArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIds = clientIds {
            var clientIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientIds)
            for clientid0 in clientIds {
                try clientIdsContainer.encode(clientid0)
            }
        }
        if let discoveryUrl = self.discoveryUrl {
            try encodeContainer.encode(discoveryUrl, forKey: .discoveryUrl)
        }
        if let openIdIssuer = self.openIdIssuer {
            try encodeContainer.encode(openIdIssuer.rawValue, forKey: .openIdIssuer)
        }
        if let userPoolArn = self.userPoolArn {
            try encodeContainer.encode(userPoolArn, forKey: .userPoolArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientIds)
        var clientIdsDecoded0:[Swift.String]? = nil
        if let clientIdsContainer = clientIdsContainer {
            clientIdsDecoded0 = [Swift.String]()
            for string0 in clientIdsContainer {
                if let string0 = string0 {
                    clientIdsDecoded0?.append(string0)
                }
            }
        }
        clientIds = clientIdsDecoded0
        let userPoolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolArn)
        userPoolArn = userPoolArnDecoded
        let discoveryUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discoveryUrl)
        discoveryUrl = discoveryUrlDecoded
        let openIdIssuerDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.OpenIdIssuer.self, forKey: .openIdIssuer)
        openIdIssuer = openIdIssuerDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    /// A structure that contains configuration of the identity source. This data type is used as a response parameter for the [CreateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreateIdentitySource.html) operation.
    public struct IdentitySourceDetails: Swift.Equatable {
        /// The application client IDs associated with the specified Amazon Cognito user pool that are enabled for this identity source.
        public var clientIds: [Swift.String]?
        /// The well-known URL that points to this user pool's OIDC discovery endpoint. This is a URL string in the following format. This URL replaces the placeholders for both the Amazon Web Services Region and the user pool identifier with those appropriate for this user pool. https://cognito-idp.<region>.amazonaws.com/<user-pool-id>/.well-known/openid-configuration
        public var discoveryUrl: Swift.String?
        /// A string that identifies the type of OIDC service represented by this identity source. At this time, the only valid value is cognito.
        public var openIdIssuer: VerifiedPermissionsClientTypes.OpenIdIssuer?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Amazon Cognito user pool whose identities are accessible to this Verified Permissions policy store.
        public var userPoolArn: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            discoveryUrl: Swift.String? = nil,
            openIdIssuer: VerifiedPermissionsClientTypes.OpenIdIssuer? = nil,
            userPoolArn: Swift.String? = nil
        )
        {
            self.clientIds = clientIds
            self.discoveryUrl = discoveryUrl
            self.openIdIssuer = openIdIssuer
            self.userPoolArn = userPoolArn
        }
    }

}

extension VerifiedPermissionsClientTypes.IdentitySourceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principalEntityType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principalEntityType = self.principalEntityType {
            try encodeContainer.encode(principalEntityType, forKey: .principalEntityType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalEntityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalEntityType)
        principalEntityType = principalEntityTypeDecoded
    }
}

extension VerifiedPermissionsClientTypes.IdentitySourceFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentitySourceFilter(principalEntityType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {
    /// A structure that defines characteristics of an identity source that you can use to filter. This data type is used as a request parameter for the [ListIdentityStores](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListIdentityStores.html) operation.
    public struct IdentitySourceFilter: Swift.Equatable {
        /// The Cedar entity type of the principals returned by the identity provider (IdP) associated with this identity source.
        public var principalEntityType: Swift.String?

        public init(
            principalEntityType: Swift.String? = nil
        )
        {
            self.principalEntityType = principalEntityType
        }
    }

}

extension VerifiedPermissionsClientTypes.IdentitySourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case details
        case identitySourceId
        case lastUpdatedDate
        case policyStoreId
        case principalEntityType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .dateTime, forKey: .createdDate)
        }
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let identitySourceId = self.identitySourceId {
            try encodeContainer.encode(identitySourceId, forKey: .identitySourceId)
        }
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encodeTimestamp(lastUpdatedDate, format: .dateTime, forKey: .lastUpdatedDate)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
        if let principalEntityType = self.principalEntityType {
            try encodeContainer.encode(principalEntityType, forKey: .principalEntityType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.IdentitySourceItemDetails.self, forKey: .details)
        details = detailsDecoded
        let identitySourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySourceId)
        identitySourceId = identitySourceIdDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let principalEntityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalEntityType)
        principalEntityType = principalEntityTypeDecoded
    }
}

extension VerifiedPermissionsClientTypes.IdentitySourceItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentitySourceItem(createdDate: \(Swift.String(describing: createdDate)), details: \(Swift.String(describing: details)), identitySourceId: \(Swift.String(describing: identitySourceId)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), principalEntityType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {
    /// A structure that defines an identity source. This data type is used as a request parameter for the [ListIdentityStores](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListIdentityStores.html) operation.
    public struct IdentitySourceItem: Swift.Equatable {
        /// The date and time the identity source was originally created.
        /// This member is required.
        public var createdDate: ClientRuntime.Date?
        /// A structure that contains the details of the associated identity provider (IdP).
        /// This member is required.
        public var details: VerifiedPermissionsClientTypes.IdentitySourceItemDetails?
        /// The unique identifier of the identity source.
        /// This member is required.
        public var identitySourceId: Swift.String?
        /// The date and time the identity source was most recently updated.
        /// This member is required.
        public var lastUpdatedDate: ClientRuntime.Date?
        /// The identifier of the policy store that contains the identity source.
        /// This member is required.
        public var policyStoreId: Swift.String?
        /// The Cedar entity type of the principals returned from the IdP associated with this identity source.
        /// This member is required.
        public var principalEntityType: Swift.String?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            details: VerifiedPermissionsClientTypes.IdentitySourceItemDetails? = nil,
            identitySourceId: Swift.String? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            policyStoreId: Swift.String? = nil,
            principalEntityType: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.details = details
            self.identitySourceId = identitySourceId
            self.lastUpdatedDate = lastUpdatedDate
            self.policyStoreId = policyStoreId
            self.principalEntityType = principalEntityType
        }
    }

}

extension VerifiedPermissionsClientTypes.IdentitySourceItemDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIds
        case discoveryUrl
        case openIdIssuer
        case userPoolArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIds = clientIds {
            var clientIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientIds)
            for clientid0 in clientIds {
                try clientIdsContainer.encode(clientid0)
            }
        }
        if let discoveryUrl = self.discoveryUrl {
            try encodeContainer.encode(discoveryUrl, forKey: .discoveryUrl)
        }
        if let openIdIssuer = self.openIdIssuer {
            try encodeContainer.encode(openIdIssuer.rawValue, forKey: .openIdIssuer)
        }
        if let userPoolArn = self.userPoolArn {
            try encodeContainer.encode(userPoolArn, forKey: .userPoolArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientIds)
        var clientIdsDecoded0:[Swift.String]? = nil
        if let clientIdsContainer = clientIdsContainer {
            clientIdsDecoded0 = [Swift.String]()
            for string0 in clientIdsContainer {
                if let string0 = string0 {
                    clientIdsDecoded0?.append(string0)
                }
            }
        }
        clientIds = clientIdsDecoded0
        let userPoolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolArn)
        userPoolArn = userPoolArnDecoded
        let discoveryUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .discoveryUrl)
        discoveryUrl = discoveryUrlDecoded
        let openIdIssuerDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.OpenIdIssuer.self, forKey: .openIdIssuer)
        openIdIssuer = openIdIssuerDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    /// A structure that contains configuration of the identity source. This data type is used as a response parameter for the [CreateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreateIdentitySource.html) operation.
    public struct IdentitySourceItemDetails: Swift.Equatable {
        /// The application client IDs associated with the specified Amazon Cognito user pool that are enabled for this identity source.
        public var clientIds: [Swift.String]?
        /// The well-known URL that points to this user pool's OIDC discovery endpoint. This is a URL string in the following format. This URL replaces the placeholders for both the Amazon Web Services Region and the user pool identifier with those appropriate for this user pool. https://cognito-idp.<region>.amazonaws.com/<user-pool-id>/.well-known/openid-configuration
        public var discoveryUrl: Swift.String?
        /// A string that identifies the type of OIDC service represented by this identity source. At this time, the only valid value is cognito.
        public var openIdIssuer: VerifiedPermissionsClientTypes.OpenIdIssuer?
        /// The Amazon Cognito user pool whose identities are accessible to this Verified Permissions policy store.
        public var userPoolArn: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            discoveryUrl: Swift.String? = nil,
            openIdIssuer: VerifiedPermissionsClientTypes.OpenIdIssuer? = nil,
            userPoolArn: Swift.String? = nil
        )
        {
            self.clientIds = clientIds
            self.discoveryUrl = discoveryUrl
            self.openIdIssuer = openIdIssuer
            self.userPoolArn = userPoolArn
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because of an internal error. Try your request again later
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IsAuthorizedInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case context
        case entities
        case policyStoreId
        case principal
        case resource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let context = self.context {
            try encodeContainer.encode(context, forKey: .context)
        }
        if let entities = self.entities {
            try encodeContainer.encode(entities, forKey: .entities)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

extension IsAuthorizedInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct IsAuthorizedInput: Swift.Equatable {
    /// Specifies the requested action to be authorized. For example, is the principal authorized to perform this action on the resource?
    public var action: VerifiedPermissionsClientTypes.ActionIdentifier?
    /// Specifies additional context that can be used to make more granular authorization decisions.
    public var context: VerifiedPermissionsClientTypes.ContextDefinition?
    /// Specifies the list of resources and principals and their associated attributes that Verified Permissions can examine when evaluating the policies. You can include only principal and resource entities in this parameter; you can't include actions. You must specify actions in the schema.
    public var entities: VerifiedPermissionsClientTypes.EntitiesDefinition?
    /// Specifies the ID of the policy store. Policies in this policy store will be used to make an authorization decision for the input.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the principal for which the authorization decision is to be made.
    public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    /// Specifies the resource for which the authorization decision is to be made.
    public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

    public init(
        action: VerifiedPermissionsClientTypes.ActionIdentifier? = nil,
        context: VerifiedPermissionsClientTypes.ContextDefinition? = nil,
        entities: VerifiedPermissionsClientTypes.EntitiesDefinition? = nil,
        policyStoreId: Swift.String? = nil,
        principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
        resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
    )
    {
        self.action = action
        self.context = context
        self.entities = entities
        self.policyStoreId = policyStoreId
        self.principal = principal
        self.resource = resource
    }
}

struct IsAuthorizedInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    let action: VerifiedPermissionsClientTypes.ActionIdentifier?
    let resource: VerifiedPermissionsClientTypes.EntityIdentifier?
    let context: VerifiedPermissionsClientTypes.ContextDefinition?
    let entities: VerifiedPermissionsClientTypes.EntitiesDefinition?
}

extension IsAuthorizedInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case context
        case entities
        case policyStoreId
        case principal
        case resource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let principalDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .principal)
        principal = principalDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.ActionIdentifier.self, forKey: .action)
        action = actionDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .resource)
        resource = resourceDecoded
        let contextDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.ContextDefinition.self, forKey: .context)
        context = contextDecoded
        let entitiesDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntitiesDefinition.self, forKey: .entities)
        entities = entitiesDecoded
    }
}

extension IsAuthorizedOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IsAuthorizedOutputBody = try responseDecoder.decode(responseBody: data)
            self.decision = output.decision
            self.determiningPolicies = output.determiningPolicies
            self.errors = output.errors
        } else {
            self.decision = nil
            self.determiningPolicies = nil
            self.errors = nil
        }
    }
}

public struct IsAuthorizedOutput: Swift.Equatable {
    /// An authorization decision that indicates if the authorization request should be allowed or denied.
    /// This member is required.
    public var decision: VerifiedPermissionsClientTypes.Decision?
    /// The list of determining policies used to make the authorization decision. For example, if there are two matching policies, where one is a forbid and the other is a permit, then the forbid policy will be the determining policy. In the case of multiple matching permit policies then there would be multiple determining policies. In the case that no policies match, and hence the response is DENY, there would be no determining policies.
    /// This member is required.
    public var determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]?
    /// Errors that occurred while making an authorization decision, for example, a policy references an Entity or entity Attribute that does not exist in the slice.
    /// This member is required.
    public var errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]?

    public init(
        decision: VerifiedPermissionsClientTypes.Decision? = nil,
        determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]? = nil,
        errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]? = nil
    )
    {
        self.decision = decision
        self.determiningPolicies = determiningPolicies
        self.errors = errors
    }
}

struct IsAuthorizedOutputBody: Swift.Equatable {
    let decision: VerifiedPermissionsClientTypes.Decision?
    let determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]?
    let errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]?
}

extension IsAuthorizedOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decision
        case determiningPolicies
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decisionDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.Decision.self, forKey: .decision)
        decision = decisionDecoded
        let determiningPoliciesContainer = try containerValues.decodeIfPresent([VerifiedPermissionsClientTypes.DeterminingPolicyItem?].self, forKey: .determiningPolicies)
        var determiningPoliciesDecoded0:[VerifiedPermissionsClientTypes.DeterminingPolicyItem]? = nil
        if let determiningPoliciesContainer = determiningPoliciesContainer {
            determiningPoliciesDecoded0 = [VerifiedPermissionsClientTypes.DeterminingPolicyItem]()
            for structure0 in determiningPoliciesContainer {
                if let structure0 = structure0 {
                    determiningPoliciesDecoded0?.append(structure0)
                }
            }
        }
        determiningPolicies = determiningPoliciesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([VerifiedPermissionsClientTypes.EvaluationErrorItem?].self, forKey: .errors)
        var errorsDecoded0:[VerifiedPermissionsClientTypes.EvaluationErrorItem]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [VerifiedPermissionsClientTypes.EvaluationErrorItem]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum IsAuthorizedOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IsAuthorizedWithTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsAuthorizedWithTokenInput(action: \(Swift.String(describing: action)), context: \(Swift.String(describing: context)), entities: \(Swift.String(describing: entities)), policyStoreId: \(Swift.String(describing: policyStoreId)), resource: \(Swift.String(describing: resource)), accessToken: \"CONTENT_REDACTED\", identityToken: \"CONTENT_REDACTED\")"}
}

extension IsAuthorizedWithTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case action
        case context
        case entities
        case identityToken
        case policyStoreId
        case resource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let context = self.context {
            try encodeContainer.encode(context, forKey: .context)
        }
        if let entities = self.entities {
            try encodeContainer.encode(entities, forKey: .entities)
        }
        if let identityToken = self.identityToken {
            try encodeContainer.encode(identityToken, forKey: .identityToken)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }
}

extension IsAuthorizedWithTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct IsAuthorizedWithTokenInput: Swift.Equatable {
    /// Specifies an access token for the principal to be authorized. This token is provided to you by the identity provider (IdP) associated with the specified identity source. You must specify either an AccessToken, or an IdentityToken, or both.
    public var accessToken: Swift.String?
    /// Specifies the requested action to be authorized. Is the specified principal authorized to perform this action on the specified resource.
    public var action: VerifiedPermissionsClientTypes.ActionIdentifier?
    /// Specifies additional context that can be used to make more granular authorization decisions.
    public var context: VerifiedPermissionsClientTypes.ContextDefinition?
    /// Specifies the list of resources and their associated attributes that Verified Permissions can examine when evaluating the policies. You can include only resource and action entities in this parameter; you can't include principals.
    ///
    /// * The IsAuthorizedWithToken operation takes principal attributes from only the identityToken or accessToken passed to the operation.
    ///
    /// * For action entities, you can include only their Identifier and EntityType.
    public var entities: VerifiedPermissionsClientTypes.EntitiesDefinition?
    /// Specifies an identity token for the principal to be authorized. This token is provided to you by the identity provider (IdP) associated with the specified identity source. You must specify either an AccessToken or an IdentityToken, or both.
    public var identityToken: Swift.String?
    /// Specifies the ID of the policy store. Policies in this policy store will be used to make an authorization decision for the input.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the resource for which the authorization decision is made. For example, is the principal allowed to perform the action on the resource?
    public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

    public init(
        accessToken: Swift.String? = nil,
        action: VerifiedPermissionsClientTypes.ActionIdentifier? = nil,
        context: VerifiedPermissionsClientTypes.ContextDefinition? = nil,
        entities: VerifiedPermissionsClientTypes.EntitiesDefinition? = nil,
        identityToken: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
    )
    {
        self.accessToken = accessToken
        self.action = action
        self.context = context
        self.entities = entities
        self.identityToken = identityToken
        self.policyStoreId = policyStoreId
        self.resource = resource
    }
}

struct IsAuthorizedWithTokenInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let identityToken: Swift.String?
    let accessToken: Swift.String?
    let action: VerifiedPermissionsClientTypes.ActionIdentifier?
    let resource: VerifiedPermissionsClientTypes.EntityIdentifier?
    let context: VerifiedPermissionsClientTypes.ContextDefinition?
    let entities: VerifiedPermissionsClientTypes.EntitiesDefinition?
}

extension IsAuthorizedWithTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case action
        case context
        case entities
        case identityToken
        case policyStoreId
        case resource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let identityTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityToken)
        identityToken = identityTokenDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.ActionIdentifier.self, forKey: .action)
        action = actionDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .resource)
        resource = resourceDecoded
        let contextDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.ContextDefinition.self, forKey: .context)
        context = contextDecoded
        let entitiesDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntitiesDefinition.self, forKey: .entities)
        entities = entitiesDecoded
    }
}

extension IsAuthorizedWithTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IsAuthorizedWithTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.decision = output.decision
            self.determiningPolicies = output.determiningPolicies
            self.errors = output.errors
        } else {
            self.decision = nil
            self.determiningPolicies = nil
            self.errors = nil
        }
    }
}

public struct IsAuthorizedWithTokenOutput: Swift.Equatable {
    /// An authorization decision that indicates if the authorization request should be allowed or denied.
    /// This member is required.
    public var decision: VerifiedPermissionsClientTypes.Decision?
    /// The list of determining policies used to make the authorization decision. For example, if there are multiple matching policies, where at least one is a forbid policy, then because forbid always overrides permit the forbid policies are the determining policies. If all matching policies are permit policies, then those policies are the determining policies. When no policies match and the response is the default DENY, there are no determining policies.
    /// This member is required.
    public var determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]?
    /// Errors that occurred while making an authorization decision. For example, a policy references an entity or entity attribute that does not exist in the slice.
    /// This member is required.
    public var errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]?

    public init(
        decision: VerifiedPermissionsClientTypes.Decision? = nil,
        determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]? = nil,
        errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]? = nil
    )
    {
        self.decision = decision
        self.determiningPolicies = determiningPolicies
        self.errors = errors
    }
}

struct IsAuthorizedWithTokenOutputBody: Swift.Equatable {
    let decision: VerifiedPermissionsClientTypes.Decision?
    let determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]?
    let errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]?
}

extension IsAuthorizedWithTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decision
        case determiningPolicies
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decisionDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.Decision.self, forKey: .decision)
        decision = decisionDecoded
        let determiningPoliciesContainer = try containerValues.decodeIfPresent([VerifiedPermissionsClientTypes.DeterminingPolicyItem?].self, forKey: .determiningPolicies)
        var determiningPoliciesDecoded0:[VerifiedPermissionsClientTypes.DeterminingPolicyItem]? = nil
        if let determiningPoliciesContainer = determiningPoliciesContainer {
            determiningPoliciesDecoded0 = [VerifiedPermissionsClientTypes.DeterminingPolicyItem]()
            for structure0 in determiningPoliciesContainer {
                if let structure0 = structure0 {
                    determiningPoliciesDecoded0?.append(structure0)
                }
            }
        }
        determiningPolicies = determiningPoliciesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([VerifiedPermissionsClientTypes.EvaluationErrorItem?].self, forKey: .errors)
        var errorsDecoded0:[VerifiedPermissionsClientTypes.EvaluationErrorItem]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [VerifiedPermissionsClientTypes.EvaluationErrorItem]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum IsAuthorizedWithTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIdentitySourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for identitysourcefilter0 in filters {
                try filtersContainer.encode(identitysourcefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension ListIdentitySourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListIdentitySourcesInput: Swift.Equatable {
    /// Specifies characteristics of an identity source that you can use to limit the output to matching identity sources.
    public var filters: [VerifiedPermissionsClientTypes.IdentitySourceFilter]?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 identity sources per response. You can specify a maximum of 200 identity sources per response.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the ID of the policy store that contains the identity sources that you want to list.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        filters: [VerifiedPermissionsClientTypes.IdentitySourceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyStoreId = policyStoreId
    }
}

struct ListIdentitySourcesInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [VerifiedPermissionsClientTypes.IdentitySourceFilter]?
}

extension ListIdentitySourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([VerifiedPermissionsClientTypes.IdentitySourceFilter?].self, forKey: .filters)
        var filtersDecoded0:[VerifiedPermissionsClientTypes.IdentitySourceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [VerifiedPermissionsClientTypes.IdentitySourceFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListIdentitySourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdentitySourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.identitySources = output.identitySources
            self.nextToken = output.nextToken
        } else {
            self.identitySources = nil
            self.nextToken = nil
        }
    }
}

public struct ListIdentitySourcesOutput: Swift.Equatable {
    /// The list of identity sources stored in the specified policy store.
    /// This member is required.
    public var identitySources: [VerifiedPermissionsClientTypes.IdentitySourceItem]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        identitySources: [VerifiedPermissionsClientTypes.IdentitySourceItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identitySources = identitySources
        self.nextToken = nextToken
    }
}

struct ListIdentitySourcesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let identitySources: [VerifiedPermissionsClientTypes.IdentitySourceItem]?
}

extension ListIdentitySourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identitySources
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let identitySourcesContainer = try containerValues.decodeIfPresent([VerifiedPermissionsClientTypes.IdentitySourceItem?].self, forKey: .identitySources)
        var identitySourcesDecoded0:[VerifiedPermissionsClientTypes.IdentitySourceItem]? = nil
        if let identitySourcesContainer = identitySourcesContainer {
            identitySourcesDecoded0 = [VerifiedPermissionsClientTypes.IdentitySourceItem]()
            for structure0 in identitySourcesContainer {
                if let structure0 = structure0 {
                    identitySourcesDecoded0?.append(structure0)
                }
            }
        }
        identitySources = identitySourcesDecoded0
    }
}

enum ListIdentitySourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension ListPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPoliciesInput: Swift.Equatable {
    /// Specifies a filter that limits the response to only policies that match the specified criteria. For example, you list only the policies that reference a specified principal.
    public var filter: VerifiedPermissionsClientTypes.PolicyFilter?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 policies per response. You can specify a maximum of 50 policies per response.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the ID of the policy store you want to list policies from.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        filter: VerifiedPermissionsClientTypes.PolicyFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyStoreId = policyStoreId
    }
}

struct ListPoliciesInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filter: VerifiedPermissionsClientTypes.PolicyFilter?
}

extension ListPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.PolicyFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policies = output.policies
        } else {
            self.nextToken = nil
            self.policies = nil
        }
    }
}

public struct ListPoliciesOutput: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// Lists all policies that are available in the specified policy store.
    /// This member is required.
    public var policies: [VerifiedPermissionsClientTypes.PolicyItem]?

    public init(
        nextToken: Swift.String? = nil,
        policies: [VerifiedPermissionsClientTypes.PolicyItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.policies = policies
    }
}

struct ListPoliciesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let policies: [VerifiedPermissionsClientTypes.PolicyItem]?
}

extension ListPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case policies
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let policiesContainer = try containerValues.decodeIfPresent([VerifiedPermissionsClientTypes.PolicyItem?].self, forKey: .policies)
        var policiesDecoded0:[VerifiedPermissionsClientTypes.PolicyItem]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [VerifiedPermissionsClientTypes.PolicyItem]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

enum ListPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPolicyStoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPolicyStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPolicyStoresInput: Swift.Equatable {
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 policy stores per response. You can specify a maximum of 50 policy stores per response.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPolicyStoresInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPolicyStoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPolicyStoresOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPolicyStoresOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policyStores = output.policyStores
        } else {
            self.nextToken = nil
            self.policyStores = nil
        }
    }
}

public struct ListPolicyStoresOutput: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// The list of policy stores in the account.
    /// This member is required.
    public var policyStores: [VerifiedPermissionsClientTypes.PolicyStoreItem]?

    public init(
        nextToken: Swift.String? = nil,
        policyStores: [VerifiedPermissionsClientTypes.PolicyStoreItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyStores = policyStores
    }
}

struct ListPolicyStoresOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let policyStores: [VerifiedPermissionsClientTypes.PolicyStoreItem]?
}

extension ListPolicyStoresOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case policyStores
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let policyStoresContainer = try containerValues.decodeIfPresent([VerifiedPermissionsClientTypes.PolicyStoreItem?].self, forKey: .policyStores)
        var policyStoresDecoded0:[VerifiedPermissionsClientTypes.PolicyStoreItem]? = nil
        if let policyStoresContainer = policyStoresContainer {
            policyStoresDecoded0 = [VerifiedPermissionsClientTypes.PolicyStoreItem]()
            for structure0 in policyStoresContainer {
                if let structure0 = structure0 {
                    policyStoresDecoded0?.append(structure0)
                }
            }
        }
        policyStores = policyStoresDecoded0
    }
}

enum ListPolicyStoresOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPolicyTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension ListPolicyTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPolicyTemplatesInput: Swift.Equatable {
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 policy templates per response. You can specify a maximum of 50 policy templates per response.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the ID of the policy store that contains the policy templates you want to list.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyStoreId = policyStoreId
    }
}

struct ListPolicyTemplatesInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPolicyTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPolicyTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPolicyTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policyTemplates = output.policyTemplates
        } else {
            self.nextToken = nil
            self.policyTemplates = nil
        }
    }
}

public struct ListPolicyTemplatesOutput: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// The list of the policy templates in the specified policy store.
    /// This member is required.
    public var policyTemplates: [VerifiedPermissionsClientTypes.PolicyTemplateItem]?

    public init(
        nextToken: Swift.String? = nil,
        policyTemplates: [VerifiedPermissionsClientTypes.PolicyTemplateItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyTemplates = policyTemplates
    }
}

struct ListPolicyTemplatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let policyTemplates: [VerifiedPermissionsClientTypes.PolicyTemplateItem]?
}

extension ListPolicyTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case policyTemplates
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let policyTemplatesContainer = try containerValues.decodeIfPresent([VerifiedPermissionsClientTypes.PolicyTemplateItem?].self, forKey: .policyTemplates)
        var policyTemplatesDecoded0:[VerifiedPermissionsClientTypes.PolicyTemplateItem]? = nil
        if let policyTemplatesContainer = policyTemplatesContainer {
            policyTemplatesDecoded0 = [VerifiedPermissionsClientTypes.PolicyTemplateItem]()
            for structure0 in policyTemplatesContainer {
                if let structure0 = structure0 {
                    policyTemplatesDecoded0?.append(structure0)
                }
            }
        }
        policyTemplates = policyTemplatesDecoded0
    }
}

enum ListPolicyTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VerifiedPermissionsClientTypes {
    public enum OpenIdIssuer: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cognito
        case sdkUnknown(Swift.String)

        public static var allCases: [OpenIdIssuer] {
            return [
                .cognito,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cognito: return "COGNITO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpenIdIssuer(rawValue: rawValue) ?? OpenIdIssuer.sdkUnknown(rawValue)
        }
    }
}

extension VerifiedPermissionsClientTypes.PolicyDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case `static` = "static"
        case templatelinked = "templateLinked"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .`static`(`static`):
                try container.encode(`static`, forKey: .`static`)
            case let .templatelinked(templatelinked):
                try container.encode(templatelinked, forKey: .templatelinked)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let staticDecoded = try values.decodeIfPresent(VerifiedPermissionsClientTypes.StaticPolicyDefinition.self, forKey: .static)
        if let `static` = staticDecoded {
            self = .`static`(`static`)
            return
        }
        let templatelinkedDecoded = try values.decodeIfPresent(VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinition.self, forKey: .templatelinked)
        if let templatelinked = templatelinkedDecoded {
            self = .templatelinked(templatelinked)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VerifiedPermissionsClientTypes {
    /// A structure that contains the details for a Cedar policy definition. It includes the policy type, a description, and a policy body. This is a top level data type used to create a policy. This data type is used as a request parameter for the [CreatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html) operation. This structure must always have either an static or a templateLinked element.
    public enum PolicyDefinition: Swift.Equatable {
        /// A structure that describes a static policy. An static policy doesn't use a template or allow placeholders for entities.
        case `static`(VerifiedPermissionsClientTypes.StaticPolicyDefinition)
        /// A structure that describes a policy that was instantiated from a template. The template can specify placeholders for principal and resource. When you use [CreatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html) to create a policy from a template, you specify the exact principal and resource to use for the instantiated policy.
        case templatelinked(VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinition)
        case sdkUnknown(Swift.String)
    }

}

extension VerifiedPermissionsClientTypes.PolicyDefinitionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case `static` = "static"
        case templatelinked = "templateLinked"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .`static`(`static`):
                try container.encode(`static`, forKey: .`static`)
            case let .templatelinked(templatelinked):
                try container.encode(templatelinked, forKey: .templatelinked)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let staticDecoded = try values.decodeIfPresent(VerifiedPermissionsClientTypes.StaticPolicyDefinitionDetail.self, forKey: .static)
        if let `static` = staticDecoded {
            self = .`static`(`static`)
            return
        }
        let templatelinkedDecoded = try values.decodeIfPresent(VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionDetail.self, forKey: .templatelinked)
        if let templatelinked = templatelinkedDecoded {
            self = .templatelinked(templatelinked)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VerifiedPermissionsClientTypes {
    /// A structure that describes a policy definition. It must always have either an static or a templateLinked element. This data type is used as a response parameter for the [GetPolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetPolicy.html) operation.
    public enum PolicyDefinitionDetail: Swift.Equatable {
        /// Information about a static policy that wasn't created with a policy template.
        case `static`(VerifiedPermissionsClientTypes.StaticPolicyDefinitionDetail)
        /// Information about a template-linked policy that was created by instantiating a policy template.
        case templatelinked(VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionDetail)
        case sdkUnknown(Swift.String)
    }

}

extension VerifiedPermissionsClientTypes.PolicyDefinitionItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case `static` = "static"
        case templatelinked = "templateLinked"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .`static`(`static`):
                try container.encode(`static`, forKey: .`static`)
            case let .templatelinked(templatelinked):
                try container.encode(templatelinked, forKey: .templatelinked)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let staticDecoded = try values.decodeIfPresent(VerifiedPermissionsClientTypes.StaticPolicyDefinitionItem.self, forKey: .static)
        if let `static` = staticDecoded {
            self = .`static`(`static`)
            return
        }
        let templatelinkedDecoded = try values.decodeIfPresent(VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionItem.self, forKey: .templatelinked)
        if let templatelinked = templatelinkedDecoded {
            self = .templatelinked(templatelinked)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VerifiedPermissionsClientTypes {
    /// A structure that describes a [PolicyDefinintion](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_PolicyDefinintion.html). It will always have either an StaticPolicy or a TemplateLinkedPolicy element. This data type is used as a response parameter for the [CreatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html) and [ListPolicies](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicies.html) operations.
    public enum PolicyDefinitionItem: Swift.Equatable {
        /// Information about a static policy that wasn't created with a policy template.
        case `static`(VerifiedPermissionsClientTypes.StaticPolicyDefinitionItem)
        /// Information about a template-linked policy that was created by instantiating a policy template.
        case templatelinked(VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionItem)
        case sdkUnknown(Swift.String)
    }

}

extension VerifiedPermissionsClientTypes.PolicyFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyTemplateId
        case policyType
        case principal
        case resource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyTemplateId = self.policyTemplateId {
            try encodeContainer.encode(policyTemplateId, forKey: .policyTemplateId)
        }
        if let policyType = self.policyType {
            try encodeContainer.encode(policyType.rawValue, forKey: .policyType)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityReference.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityReference.self, forKey: .resource)
        resource = resourceDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.PolicyType.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let policyTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplateId)
        policyTemplateId = policyTemplateIdDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about a filter to refine policies returned in a query. This data type is used as a response parameter for the [ListPolicies](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicies.html) operation.
    public struct PolicyFilter: Swift.Equatable {
        /// Filters the output to only template-linked policies that were instantiated from the specified policy template.
        public var policyTemplateId: Swift.String?
        /// Filters the output to only policies of the specified type.
        public var policyType: VerifiedPermissionsClientTypes.PolicyType?
        /// Filters the output to only policies that reference the specified principal.
        public var principal: VerifiedPermissionsClientTypes.EntityReference?
        /// Filters the output to only policies that reference the specified resource.
        public var resource: VerifiedPermissionsClientTypes.EntityReference?

        public init(
            policyTemplateId: Swift.String? = nil,
            policyType: VerifiedPermissionsClientTypes.PolicyType? = nil,
            principal: VerifiedPermissionsClientTypes.EntityReference? = nil,
            resource: VerifiedPermissionsClientTypes.EntityReference? = nil
        )
        {
            self.policyTemplateId = policyTemplateId
            self.policyType = policyType
            self.principal = principal
            self.resource = resource
        }
    }

}

extension VerifiedPermissionsClientTypes.PolicyItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case definition
        case lastUpdatedDate
        case policyId
        case policyStoreId
        case policyType
        case principal
        case resource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .dateTime, forKey: .createdDate)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encodeTimestamp(lastUpdatedDate, format: .dateTime, forKey: .lastUpdatedDate)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
        if let policyType = self.policyType {
            try encodeContainer.encode(policyType.rawValue, forKey: .policyType)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.PolicyType.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let principalDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .resource)
        resource = resourceDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.PolicyDefinitionItem.self, forKey: .definition)
        definition = definitionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about a policy. This data type is used as a response parameter for the [ListPolicies](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicies.html) operation.
    public struct PolicyItem: Swift.Equatable {
        /// The date and time the policy was created.
        /// This member is required.
        public var createdDate: ClientRuntime.Date?
        /// The policy definition of an item in the list of policies returned.
        /// This member is required.
        public var definition: VerifiedPermissionsClientTypes.PolicyDefinitionItem?
        /// The date and time the policy was most recently updated.
        /// This member is required.
        public var lastUpdatedDate: ClientRuntime.Date?
        /// The identifier of the policy you want information about.
        /// This member is required.
        public var policyId: Swift.String?
        /// The identifier of the PolicyStore where the policy you want information about is stored.
        /// This member is required.
        public var policyStoreId: Swift.String?
        /// The type of the policy. This is one of the following values:
        ///
        /// * static
        ///
        /// * templateLinked
        /// This member is required.
        public var policyType: VerifiedPermissionsClientTypes.PolicyType?
        /// The principal associated with the policy.
        public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
        /// The resource associated with the policy.
        public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            definition: VerifiedPermissionsClientTypes.PolicyDefinitionItem? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            policyId: Swift.String? = nil,
            policyStoreId: Swift.String? = nil,
            policyType: VerifiedPermissionsClientTypes.PolicyType? = nil,
            principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
            resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
        )
        {
            self.createdDate = createdDate
            self.definition = definition
            self.lastUpdatedDate = lastUpdatedDate
            self.policyId = policyId
            self.policyStoreId = policyStoreId
            self.policyType = policyType
            self.principal = principal
            self.resource = resource
        }
    }

}

extension VerifiedPermissionsClientTypes.PolicyStoreItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdDate
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .dateTime, forKey: .createdDate)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about a policy store. This data type is used as a response parameter for the [ListPolicyStores](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicyStores.html) operation.
    public struct PolicyStoreItem: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the policy store.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time the policy was created.
        /// This member is required.
        public var createdDate: ClientRuntime.Date?
        /// The unique identifier of the policy store.
        /// This member is required.
        public var policyStoreId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            policyStoreId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.policyStoreId = policyStoreId
        }
    }

}

extension VerifiedPermissionsClientTypes.PolicyTemplateItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case lastUpdatedDate
        case policyStoreId
        case policyTemplateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .dateTime, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encodeTimestamp(lastUpdatedDate, format: .dateTime, forKey: .lastUpdatedDate)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
        if let policyTemplateId = self.policyTemplateId {
            try encodeContainer.encode(policyTemplateId, forKey: .policyTemplateId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplateId)
        policyTemplateId = policyTemplateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

extension VerifiedPermissionsClientTypes.PolicyTemplateItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyTemplateItem(createdDate: \(Swift.String(describing: createdDate)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), policyTemplateId: \(Swift.String(describing: policyTemplateId)), description: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {
    /// Contains details about a policy template This data type is used as a response parameter for the [ListPolicyTemplates](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicyTemplates.html) operation.
    public struct PolicyTemplateItem: Swift.Equatable {
        /// The date and time that the policy template was created.
        /// This member is required.
        public var createdDate: ClientRuntime.Date?
        /// The description attached to the policy template.
        public var description: Swift.String?
        /// The date and time that the policy template was most recently updated.
        /// This member is required.
        public var lastUpdatedDate: ClientRuntime.Date?
        /// The unique identifier of the policy store that contains the template.
        /// This member is required.
        public var policyStoreId: Swift.String?
        /// The unique identifier of the policy template.
        /// This member is required.
        public var policyTemplateId: Swift.String?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            policyStoreId: Swift.String? = nil,
            policyTemplateId: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastUpdatedDate = lastUpdatedDate
            self.policyStoreId = policyStoreId
            self.policyTemplateId = policyTemplateId
        }
    }

}

extension VerifiedPermissionsClientTypes {
    public enum PolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `static`
        case templateLinked
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyType] {
            return [
                .static,
                .templateLinked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .static: return "STATIC"
            case .templateLinked: return "TEMPLATE_LINKED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyType(rawValue: rawValue) ?? PolicyType.sdkUnknown(rawValue)
        }
    }
}

extension PutSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension PutSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutSchemaInput: Swift.Equatable {
    /// Specifies the definition of the schema to be stored. The schema definition must be written in Cedar schema JSON.
    /// This member is required.
    public var definition: VerifiedPermissionsClientTypes.SchemaDefinition?
    /// Specifies the ID of the policy store in which to place the schema.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        definition: VerifiedPermissionsClientTypes.SchemaDefinition? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.definition = definition
        self.policyStoreId = policyStoreId
    }
}

struct PutSchemaInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let definition: VerifiedPermissionsClientTypes.SchemaDefinition?
}

extension PutSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.SchemaDefinition.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension PutSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.lastUpdatedDate = output.lastUpdatedDate
            self.namespaces = output.namespaces
            self.policyStoreId = output.policyStoreId
        } else {
            self.createdDate = nil
            self.lastUpdatedDate = nil
            self.namespaces = nil
            self.policyStoreId = nil
        }
    }
}

public struct PutSchemaOutput: Swift.Equatable {
    /// The date and time that the schema was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The date and time that the schema was last updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// Identifies the namespaces of the entities referenced by this schema.
    /// This member is required.
    public var namespaces: [Swift.String]?
    /// The unique ID of the policy store that contains the schema.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        namespaces: [Swift.String]? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.namespaces = namespaces
        self.policyStoreId = policyStoreId
    }
}

struct PutSchemaOutputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let namespaces: [Swift.String]?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension PutSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case lastUpdatedDate
        case namespaces
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let namespacesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .namespaces)
        var namespacesDecoded0:[Swift.String]? = nil
        if let namespacesContainer = namespacesContainer {
            namespacesDecoded0 = [Swift.String]()
            for string0 in namespacesContainer {
                if let string0 = string0 {
                    namespacesDecoded0?.append(string0)
                }
            }
        }
        namespaces = namespacesDecoded0
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum PutSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VerifiedPermissionsClientTypes.ResourceConflict: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about a resource conflict.
    public struct ResourceConflict: Swift.Equatable {
        /// The unique identifier of the resource involved in a conflict.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The type of the resource involved in a conflict.
        /// This member is required.
        public var resourceType: VerifiedPermissionsClientTypes.ResourceType?

        public init(
            resourceId: Swift.String? = nil,
            resourceType: VerifiedPermissionsClientTypes.ResourceType? = nil
        )
        {
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because it references a resource that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique ID of the resource referenced in the failed request.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type of the resource referenced in the failed request.
        /// This member is required.
        public internal(set) var resourceType: VerifiedPermissionsClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: VerifiedPermissionsClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: VerifiedPermissionsClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case identitySource
        case policy
        case policyStore
        case policyTemplate
        case schema
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .identitySource,
                .policy,
                .policyStore,
                .policyTemplate,
                .schema,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .identitySource: return "IDENTITY_SOURCE"
            case .policy: return "POLICY"
            case .policyStore: return "POLICY_STORE"
            case .policyTemplate: return "POLICY_TEMPLATE"
            case .schema: return "SCHEMA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension VerifiedPermissionsClientTypes.SchemaDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cedarjson = "cedarJson"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .cedarjson(cedarjson):
                try container.encode(cedarjson, forKey: .cedarjson)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let cedarjsonDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .cedarjson)
        if let cedarjson = cedarjsonDecoded {
            self = .cedarjson(cedarjson)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains a list of principal types, resource types, and actions that can be specified in policies stored in the same policy store. If the validation mode for the policy store is set to STRICT, then policies that can't be validated by this schema are rejected by Verified Permissions and can't be stored in the policy store.
    public enum SchemaDefinition: Swift.Equatable {
        /// A JSON string representation of the schema supported by applications that use this policy store. For more information, see [Policy store schema](https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/schema.html) in the Amazon Verified Permissions User Guide.
        case cedarjson(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because it would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code recognized by the Amazon Web Services Service Quotas service.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The unique ID of the resource referenced in the failed request.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type of the resource referenced in the failed request.
        /// This member is required.
        public internal(set) var resourceType: VerifiedPermissionsClientTypes.ResourceType? = nil
        /// The code for the Amazon Web Service that owns the quota.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: VerifiedPermissionsClientTypes.ResourceType? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: VerifiedPermissionsClientTypes.ResourceType?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension VerifiedPermissionsClientTypes.StaticPolicyDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case statement
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let statement = self.statement {
            try encodeContainer.encode(statement, forKey: .statement)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
    }
}

extension VerifiedPermissionsClientTypes.StaticPolicyDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StaticPolicyDefinition(description: \"CONTENT_REDACTED\", statement: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about a static policy. This data type is used as a field that is part of the [PolicyDefinitionDetail](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_PolicyDefinitionDetail.html) type.
    public struct StaticPolicyDefinition: Swift.Equatable {
        /// The description of the static policy.
        public var description: Swift.String?
        /// The policy content of the static policy, written in the Cedar policy language.
        /// This member is required.
        public var statement: Swift.String?

        public init(
            description: Swift.String? = nil,
            statement: Swift.String? = nil
        )
        {
            self.description = description
            self.statement = statement
        }
    }

}

extension VerifiedPermissionsClientTypes.StaticPolicyDefinitionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case statement
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let statement = self.statement {
            try encodeContainer.encode(statement, forKey: .statement)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
    }
}

extension VerifiedPermissionsClientTypes.StaticPolicyDefinitionDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StaticPolicyDefinitionDetail(description: \"CONTENT_REDACTED\", statement: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {
    /// A structure that contains details about a static policy. It includes the description and policy body. This data type is used within a [PolicyDefinition](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_PolicyDefinition.html) structure as part of a request parameter for the [CreatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html) operation.
    public struct StaticPolicyDefinitionDetail: Swift.Equatable {
        /// A description of the static policy.
        public var description: Swift.String?
        /// The content of the static policy written in the Cedar policy language.
        /// This member is required.
        public var statement: Swift.String?

        public init(
            description: Swift.String? = nil,
            statement: Swift.String? = nil
        )
        {
            self.description = description
            self.statement = statement
        }
    }

}

extension VerifiedPermissionsClientTypes.StaticPolicyDefinitionItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension VerifiedPermissionsClientTypes.StaticPolicyDefinitionItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StaticPolicyDefinitionItem(description: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {
    /// A structure that contains details about a static policy. It includes the description and policy statement. This data type is used within a [PolicyDefinition](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_PolicyDefinition.html) structure as part of a request parameter for the [CreatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html) operation.
    public struct StaticPolicyDefinitionItem: Swift.Equatable {
        /// A description of the static policy.
        public var description: Swift.String?

        public init(
            description: Swift.String? = nil
        )
        {
            self.description = description
        }
    }

}

extension VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyTemplateId
        case principal
        case resource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyTemplateId = self.policyTemplateId {
            try encodeContainer.encode(policyTemplateId, forKey: .policyTemplateId)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplateId)
        policyTemplateId = policyTemplateIdDecoded
        let principalDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about a policy created by instantiating a policy template.
    public struct TemplateLinkedPolicyDefinition: Swift.Equatable {
        /// The unique identifier of the policy template used to create this policy.
        /// This member is required.
        public var policyTemplateId: Swift.String?
        /// The principal associated with this template-linked policy. Verified Permissions substitutes this principal for the ?principal placeholder in the policy template when it evaluates an authorization request.
        public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
        /// The resource associated with this template-linked policy. Verified Permissions substitutes this resource for the ?resource placeholder in the policy template when it evaluates an authorization request.
        public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

        public init(
            policyTemplateId: Swift.String? = nil,
            principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
            resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
        )
        {
            self.policyTemplateId = policyTemplateId
            self.principal = principal
            self.resource = resource
        }
    }

}

extension VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyTemplateId
        case principal
        case resource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyTemplateId = self.policyTemplateId {
            try encodeContainer.encode(policyTemplateId, forKey: .policyTemplateId)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplateId)
        policyTemplateId = policyTemplateIdDecoded
        let principalDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about a policy that was created by instantiating a policy template. This
    public struct TemplateLinkedPolicyDefinitionDetail: Swift.Equatable {
        /// The unique identifier of the policy template used to create this policy.
        /// This member is required.
        public var policyTemplateId: Swift.String?
        /// The principal associated with this template-linked policy. Verified Permissions substitutes this principal for the ?principal placeholder in the policy template when it evaluates an authorization request.
        public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
        /// The resource associated with this template-linked policy. Verified Permissions substitutes this resource for the ?resource placeholder in the policy template when it evaluates an authorization request.
        public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

        public init(
            policyTemplateId: Swift.String? = nil,
            principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
            resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
        )
        {
            self.policyTemplateId = policyTemplateId
            self.principal = principal
            self.resource = resource
        }
    }

}

extension VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyTemplateId
        case principal
        case resource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyTemplateId = self.policyTemplateId {
            try encodeContainer.encode(policyTemplateId, forKey: .policyTemplateId)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplateId)
        policyTemplateId = policyTemplateIdDecoded
        let principalDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about a policy created by instantiating a policy template. This
    public struct TemplateLinkedPolicyDefinitionItem: Swift.Equatable {
        /// The unique identifier of the policy template used to create this policy.
        /// This member is required.
        public var policyTemplateId: Swift.String?
        /// The principal associated with this template-linked policy. Verified Permissions substitutes this principal for the ?principal placeholder in the policy template when it evaluates an authorization request.
        public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
        /// The resource associated with this template-linked policy. Verified Permissions substitutes this resource for the ?resource placeholder in the policy template when it evaluates an authorization request.
        public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

        public init(
            policyTemplateId: Swift.String? = nil,
            principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
            resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
        )
        {
            self.policyTemplateId = policyTemplateId
            self.principal = principal
            self.resource = resource
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because it exceeded a throttling quota.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code recognized by the Amazon Web Services Service Quotas service.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The code for the Amazon Web Service that owns the quota.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension VerifiedPermissionsClientTypes.UpdateCognitoUserPoolConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIds
        case userPoolArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIds = clientIds {
            var clientIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clientIds)
            for clientid0 in clientIds {
                try clientIdsContainer.encode(clientid0)
            }
        }
        if let userPoolArn = self.userPoolArn {
            try encodeContainer.encode(userPoolArn, forKey: .userPoolArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolArn)
        userPoolArn = userPoolArnDecoded
        let clientIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientIds)
        var clientIdsDecoded0:[Swift.String]? = nil
        if let clientIdsContainer = clientIdsContainer {
            clientIdsDecoded0 = [Swift.String]()
            for string0 in clientIdsContainer {
                if let string0 = string0 {
                    clientIdsDecoded0?.append(string0)
                }
            }
        }
        clientIds = clientIdsDecoded0
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains configuration details of a Amazon Cognito user pool for use with an identity source.
    public struct UpdateCognitoUserPoolConfiguration: Swift.Equatable {
        /// The client ID of an app client that is configured for the specified Amazon Cognito user pool.
        public var clientIds: [Swift.String]?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Amazon Cognito user pool associated with this identity source.
        /// This member is required.
        public var userPoolArn: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            userPoolArn: Swift.String? = nil
        )
        {
            self.clientIds = clientIds
            self.userPoolArn = userPoolArn
        }
    }

}

extension VerifiedPermissionsClientTypes.UpdateConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitouserpoolconfiguration = "cognitoUserPoolConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .cognitouserpoolconfiguration(cognitouserpoolconfiguration):
                try container.encode(cognitouserpoolconfiguration, forKey: .cognitouserpoolconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let cognitouserpoolconfigurationDecoded = try values.decodeIfPresent(VerifiedPermissionsClientTypes.UpdateCognitoUserPoolConfiguration.self, forKey: .cognitouserpoolconfiguration)
        if let cognitouserpoolconfiguration = cognitouserpoolconfigurationDecoded {
            self = .cognitouserpoolconfiguration(cognitouserpoolconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains an updated configuration to replace the configuration in an existing identity source. At this time, the only valid member of this structure is a Amazon Cognito user pool configuration. You must specify a userPoolArn, and optionally, a ClientId.
    public enum UpdateConfiguration: Swift.Equatable {
        /// Contains configuration details of a Amazon Cognito user pool.
        case cognitouserpoolconfiguration(VerifiedPermissionsClientTypes.UpdateCognitoUserPoolConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension UpdateIdentitySourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIdentitySourceInput(identitySourceId: \(Swift.String(describing: identitySourceId)), policyStoreId: \(Swift.String(describing: policyStoreId)), updateConfiguration: \(Swift.String(describing: updateConfiguration)), principalEntityType: \"CONTENT_REDACTED\")"}
}

extension UpdateIdentitySourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identitySourceId
        case policyStoreId
        case principalEntityType
        case updateConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identitySourceId = self.identitySourceId {
            try encodeContainer.encode(identitySourceId, forKey: .identitySourceId)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
        if let principalEntityType = self.principalEntityType {
            try encodeContainer.encode(principalEntityType, forKey: .principalEntityType)
        }
        if let updateConfiguration = self.updateConfiguration {
            try encodeContainer.encode(updateConfiguration, forKey: .updateConfiguration)
        }
    }
}

extension UpdateIdentitySourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateIdentitySourceInput: Swift.Equatable {
    /// Specifies the ID of the identity source that you want to update.
    /// This member is required.
    public var identitySourceId: Swift.String?
    /// Specifies the ID of the policy store that contains the identity source that you want to update.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the data type of principals generated for identities authenticated by the identity source.
    public var principalEntityType: Swift.String?
    /// Specifies the details required to communicate with the identity provider (IdP) associated with this identity source. At this time, the only valid member of this structure is a Amazon Cognito user pool configuration. You must specify a userPoolArn, and optionally, a ClientId.
    /// This member is required.
    public var updateConfiguration: VerifiedPermissionsClientTypes.UpdateConfiguration?

    public init(
        identitySourceId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        principalEntityType: Swift.String? = nil,
        updateConfiguration: VerifiedPermissionsClientTypes.UpdateConfiguration? = nil
    )
    {
        self.identitySourceId = identitySourceId
        self.policyStoreId = policyStoreId
        self.principalEntityType = principalEntityType
        self.updateConfiguration = updateConfiguration
    }
}

struct UpdateIdentitySourceInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let identitySourceId: Swift.String?
    let updateConfiguration: VerifiedPermissionsClientTypes.UpdateConfiguration?
    let principalEntityType: Swift.String?
}

extension UpdateIdentitySourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identitySourceId
        case policyStoreId
        case principalEntityType
        case updateConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let identitySourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySourceId)
        identitySourceId = identitySourceIdDecoded
        let updateConfigurationDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.UpdateConfiguration.self, forKey: .updateConfiguration)
        updateConfiguration = updateConfigurationDecoded
        let principalEntityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalEntityType)
        principalEntityType = principalEntityTypeDecoded
    }
}

extension UpdateIdentitySourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIdentitySourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.identitySourceId = output.identitySourceId
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyStoreId = output.policyStoreId
        } else {
            self.createdDate = nil
            self.identitySourceId = nil
            self.lastUpdatedDate = nil
            self.policyStoreId = nil
        }
    }
}

public struct UpdateIdentitySourceOutput: Swift.Equatable {
    /// The date and time that the updated identity source was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The ID of the updated identity source.
    /// This member is required.
    public var identitySourceId: Swift.String?
    /// The date and time that the identity source was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The ID of the policy store that contains the updated identity source.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        identitySourceId: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.identitySourceId = identitySourceId
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
    }
}

struct UpdateIdentitySourceOutputBody: Swift.Equatable {
    let createdDate: ClientRuntime.Date?
    let identitySourceId: Swift.String?
    let lastUpdatedDate: ClientRuntime.Date?
    let policyStoreId: Swift.String?
}

extension UpdateIdentitySourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case identitySourceId
        case lastUpdatedDate
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let identitySourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySourceId)
        identitySourceId = identitySourceIdDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
    }
}

enum UpdateIdentitySourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdatePolicyDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case `static` = "static"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .`static`(`static`):
                try container.encode(`static`, forKey: .`static`)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let staticDecoded = try values.decodeIfPresent(VerifiedPermissionsClientTypes.UpdateStaticPolicyDefinition.self, forKey: .static)
        if let `static` = staticDecoded {
            self = .`static`(`static`)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about updates to be applied to a policy. This data type is used as a request parameter in the [UpdatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicy.html) operation.
    public enum UpdatePolicyDefinition: Swift.Equatable {
        /// Contains details about the updates to be applied to a static policy.
        case `static`(VerifiedPermissionsClientTypes.UpdateStaticPolicyDefinition)
        case sdkUnknown(Swift.String)
    }

}

extension UpdatePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case policyId
        case policyStoreId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
    }
}

extension UpdatePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePolicyInput: Swift.Equatable {
    /// Specifies the updated policy content that you want to replace on the specified policy. The content must be valid Cedar policy language text. You can change only the following elements from the policy definition:
    ///
    /// * The action referenced by the policy.
    ///
    /// * Any conditional clauses, such as when or unless clauses.
    ///
    ///
    /// You can't change the following elements:
    ///
    /// * Changing from static to templateLinked.
    ///
    /// * Changing the effect of the policy from permit or forbid.
    ///
    /// * The principal referenced by the policy.
    ///
    /// * The resource referenced by the policy.
    /// This member is required.
    public var definition: VerifiedPermissionsClientTypes.UpdatePolicyDefinition?
    /// Specifies the ID of the policy that you want to update. To find this value, you can use [ListPolicies](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicies.html).
    /// This member is required.
    public var policyId: Swift.String?
    /// Specifies the ID of the policy store that contains the policy that you want to update.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        definition: VerifiedPermissionsClientTypes.UpdatePolicyDefinition? = nil,
        policyId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.definition = definition
        self.policyId = policyId
        self.policyStoreId = policyStoreId
    }
}

struct UpdatePolicyInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let policyId: Swift.String?
    let definition: VerifiedPermissionsClientTypes.UpdatePolicyDefinition?
}

extension UpdatePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case policyId
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.UpdatePolicyDefinition.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension UpdatePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyId = output.policyId
            self.policyStoreId = output.policyStoreId
            self.policyType = output.policyType
            self.principal = output.principal
            self.resource = output.resource
        } else {
            self.createdDate = nil
            self.lastUpdatedDate = nil
            self.policyId = nil
            self.policyStoreId = nil
            self.policyType = nil
            self.principal = nil
            self.resource = nil
        }
    }
}

public struct UpdatePolicyOutput: Swift.Equatable {
    /// The date and time that the policy was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The date and time that the policy was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The ID of the policy that was updated.
    /// This member is required.
    public var policyId: Swift.String?
    /// The ID of the policy store that contains the policy that was updated.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The type of the policy that was updated.
    /// This member is required.
    public var policyType: VerifiedPermissionsClientTypes.PolicyType?
    /// The principal specified in the policy's scope. This element isn't included in the response when Principal isn't present in the policy content.
    public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    /// The resource specified in the policy's scope. This element isn't included in the response when Resource isn't present in the policy content.
    public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        policyType: VerifiedPermissionsClientTypes.PolicyType? = nil,
        principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
        resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
    )
    {
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.policyId = policyId
        self.policyStoreId = policyStoreId
        self.policyType = policyType
        self.principal = principal
        self.resource = resource
    }
}

struct UpdatePolicyOutputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let policyId: Swift.String?
    let policyType: VerifiedPermissionsClientTypes.PolicyType?
    let principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    let resource: VerifiedPermissionsClientTypes.EntityIdentifier?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension UpdatePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case lastUpdatedDate
        case policyId
        case policyStoreId
        case policyType
        case principal
        case resource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.PolicyType.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let principalDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .principal)
        principal = principalDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.EntityIdentifier.self, forKey: .resource)
        resource = resourceDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum UpdatePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePolicyStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStoreId
        case validationSettings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
        if let validationSettings = self.validationSettings {
            try encodeContainer.encode(validationSettings, forKey: .validationSettings)
        }
    }
}

extension UpdatePolicyStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePolicyStoreInput: Swift.Equatable {
    /// Specifies the ID of the policy store that you want to update
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// A structure that defines the validation settings that want to enable for the policy store.
    /// This member is required.
    public var validationSettings: VerifiedPermissionsClientTypes.ValidationSettings?

    public init(
        policyStoreId: Swift.String? = nil,
        validationSettings: VerifiedPermissionsClientTypes.ValidationSettings? = nil
    )
    {
        self.policyStoreId = policyStoreId
        self.validationSettings = validationSettings
    }
}

struct UpdatePolicyStoreInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let validationSettings: VerifiedPermissionsClientTypes.ValidationSettings?
}

extension UpdatePolicyStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyStoreId
        case validationSettings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let validationSettingsDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.ValidationSettings.self, forKey: .validationSettings)
        validationSettings = validationSettingsDecoded
    }
}

extension UpdatePolicyStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePolicyStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdDate = output.createdDate
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyStoreId = output.policyStoreId
        } else {
            self.arn = nil
            self.createdDate = nil
            self.lastUpdatedDate = nil
            self.policyStoreId = nil
        }
    }
}

public struct UpdatePolicyStoreOutput: Swift.Equatable {
    /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the updated policy store.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time that the policy store was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The date and time that the policy store was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The ID of the updated policy store.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
    }
}

struct UpdatePolicyStoreOutputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let arn: Swift.String?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension UpdatePolicyStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdDate
        case lastUpdatedDate
        case policyStoreId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum UpdatePolicyStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePolicyTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePolicyTemplateInput(policyStoreId: \(Swift.String(describing: policyStoreId)), policyTemplateId: \(Swift.String(describing: policyTemplateId)), description: \"CONTENT_REDACTED\", statement: \"CONTENT_REDACTED\")"}
}

extension UpdatePolicyTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case policyStoreId
        case policyTemplateId
        case statement
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let policyStoreId = self.policyStoreId {
            try encodeContainer.encode(policyStoreId, forKey: .policyStoreId)
        }
        if let policyTemplateId = self.policyTemplateId {
            try encodeContainer.encode(policyTemplateId, forKey: .policyTemplateId)
        }
        if let statement = self.statement {
            try encodeContainer.encode(statement, forKey: .statement)
        }
    }
}

extension UpdatePolicyTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePolicyTemplateInput: Swift.Equatable {
    /// Specifies a new description to apply to the policy template.
    public var description: Swift.String?
    /// Specifies the ID of the policy store that contains the policy template that you want to update.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the ID of the policy template that you want to update.
    /// This member is required.
    public var policyTemplateId: Swift.String?
    /// Specifies new statement content written in Cedar policy language to replace the current body of the policy template. You can change only the following elements of the policy body:
    ///
    /// * The action referenced by the policy template.
    ///
    /// * Any conditional clauses, such as when or unless clauses.
    ///
    ///
    /// You can't change the following elements:
    ///
    /// * The effect (permit or forbid) of the policy template.
    ///
    /// * The principal referenced by the policy template.
    ///
    /// * The resource referenced by the policy template.
    /// This member is required.
    public var statement: Swift.String?

    public init(
        description: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        policyTemplateId: Swift.String? = nil,
        statement: Swift.String? = nil
    )
    {
        self.description = description
        self.policyStoreId = policyStoreId
        self.policyTemplateId = policyTemplateId
        self.statement = statement
    }
}

struct UpdatePolicyTemplateInputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let policyTemplateId: Swift.String?
    let description: Swift.String?
    let statement: Swift.String?
}

extension UpdatePolicyTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case policyStoreId
        case policyTemplateId
        case statement
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplateId)
        policyTemplateId = policyTemplateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
    }
}

extension UpdatePolicyTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePolicyTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.lastUpdatedDate = output.lastUpdatedDate
            self.policyStoreId = output.policyStoreId
            self.policyTemplateId = output.policyTemplateId
        } else {
            self.createdDate = nil
            self.lastUpdatedDate = nil
            self.policyStoreId = nil
            self.policyTemplateId = nil
        }
    }
}

public struct UpdatePolicyTemplateOutput: Swift.Equatable {
    /// The date and time that the policy template was originally created.
    /// This member is required.
    public var createdDate: ClientRuntime.Date?
    /// The date and time that the policy template was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The ID of the policy store that contains the updated policy template.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The ID of the updated policy template.
    /// This member is required.
    public var policyTemplateId: Swift.String?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        policyStoreId: Swift.String? = nil,
        policyTemplateId: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
        self.policyTemplateId = policyTemplateId
    }
}

struct UpdatePolicyTemplateOutputBody: Swift.Equatable {
    let policyStoreId: Swift.String?
    let policyTemplateId: Swift.String?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension UpdatePolicyTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case lastUpdatedDate
        case policyStoreId
        case policyTemplateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStoreId)
        policyStoreId = policyStoreIdDecoded
        let policyTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplateId)
        policyTemplateId = policyTemplateIdDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

enum UpdatePolicyTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await VerifiedPermissionsClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdateStaticPolicyDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case statement
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let statement = self.statement {
            try encodeContainer.encode(statement, forKey: .statement)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
    }
}

extension VerifiedPermissionsClientTypes.UpdateStaticPolicyDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStaticPolicyDefinition(description: \"CONTENT_REDACTED\", statement: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {
    /// Contains information about an update to a static policy.
    public struct UpdateStaticPolicyDefinition: Swift.Equatable {
        /// Specifies the description to be added to or replaced on the static policy.
        public var description: Swift.String?
        /// Specifies the Cedar policy language text to be added to or replaced on the static policy. You can change only the following elements from the original content:
        ///
        /// * The action referenced by the policy.
        ///
        /// * Any conditional clauses, such as when or unless clauses.
        ///
        ///
        /// You can't change the following elements:
        ///
        /// * Changing from StaticPolicy to TemplateLinkedPolicy.
        ///
        /// * The effect (permit or forbid) of the policy.
        ///
        /// * The principal referenced by the policy.
        ///
        /// * The resource referenced by the policy.
        /// This member is required.
        public var statement: Swift.String?

        public init(
            description: Swift.String? = nil,
            statement: Swift.String? = nil
        )
        {
            self.description = description
            self.statement = statement
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because one or more input parameters don't satisfy their constraint requirements. The output is provided as a list of fields and a reason for each field that isn't valid. The possible reasons include the following:
///
/// * UnrecognizedEntityType The policy includes an entity type that isn't found in the schema.
///
/// * UnrecognizedActionId The policy includes an action id that isn't found in the schema.
///
/// * InvalidActionApplication The policy includes an action that, according to the schema, doesn't support the specified principal and resource.
///
/// * UnexpectedType The policy included an operand that isn't a valid type for the specified operation.
///
/// * IncompatibleTypes The types of elements included in a set, or the types of expressions used in an if...then...else clause aren't compatible in this context.
///
/// * MissingAttribute The policy attempts to access a record or entity attribute that isn't specified in the schema. Test for the existence of the attribute first before attempting to access its value. For more information, see the [has (presence of attribute test) operator](https://docs.cedarpolicy.com/syntax-operators.html#has-presence-of-attribute-test) in the Cedar Policy Language Guide.
///
/// * UnsafeOptionalAttributeAccess The policy attempts to access a record or entity attribute that is optional and isn't guaranteed to be present. Test for the existence of the attribute first before attempting to access its value. For more information, see the [has (presence of attribute test) operator](https://docs.cedarpolicy.com/syntax-operators.html#has-presence-of-attribute-test) in the Cedar Policy Language Guide.
///
/// * ImpossiblePolicy Cedar has determined that a policy condition always evaluates to false. If the policy is always false, it can never apply to any query, and so it can never affect an authorization decision.
///
/// * WrongNumberArguments The policy references an extension type with the wrong number of arguments.
///
/// * FunctionArgumentValidationError Cedar couldn't parse the argument passed to an extension type. For example, a string that is to be parsed as an IPv4 address can contain only digits and the period character.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that aren't valid.
        public internal(set) var fieldList: [VerifiedPermissionsClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [VerifiedPermissionsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let fieldList: [VerifiedPermissionsClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([VerifiedPermissionsClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[VerifiedPermissionsClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [VerifiedPermissionsClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension VerifiedPermissionsClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    /// Details about a field that failed policy validation.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Describes the policy validation error.
        /// This member is required.
        public var message: Swift.String?
        /// The path to the specific element that Verified Permissions found to be not valid.
        /// This member is required.
        public var path: Swift.String?

        public init(
            message: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.message = message
            self.path = path
        }
    }

}

extension VerifiedPermissionsClientTypes {
    public enum ValidationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case strict
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationMode] {
            return [
                .off,
                .strict,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .strict: return "STRICT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationMode(rawValue: rawValue) ?? ValidationMode.sdkUnknown(rawValue)
        }
    }
}

extension VerifiedPermissionsClientTypes.ValidationSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(VerifiedPermissionsClientTypes.ValidationMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension VerifiedPermissionsClientTypes {
    /// A structure that contains Cedar policy validation settings for the policy store. The validation mode determines which validation failures that Cedar considers serious enough to block acceptance of a new or edited static policy or policy template. This data type is used as a request parameter in the [CreatePolicyStore](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicyStore.html) and [UpdatePolicyStore](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicyStore.html) operations.
    public struct ValidationSettings: Swift.Equatable {
        /// The validation mode currently configured for this policy store. The valid values are:
        ///
        /// * OFF  Neither Verified Permissions nor Cedar perform any validation on policies. No validation errors are reported by either service.
        ///
        /// * STRICT  Requires a schema to be present in the policy store. Cedar performs validation on all submitted new or updated static policies and policy templates. Any that fail validation are rejected and Cedar doesn't store them in the policy store.
        ///
        ///
        /// If Mode=STRICT and the policy store doesn't contain a schema, Verified Permissions rejects all static policies and policy templates because there is no schema to validate against. To submit a static policy or policy template without a schema, you must turn off validation.
        /// This member is required.
        public var mode: VerifiedPermissionsClientTypes.ValidationMode?

        public init(
            mode: VerifiedPermissionsClientTypes.ValidationMode? = nil
        )
        {
            self.mode = mode
        }
    }

}

extension VerifiedPermissionsClientTypes {
    static func makeServiceError(_ httpResponse: ClientRuntime.HttpResponse, _ decoder: ClientRuntime.ResponseDecoder? = nil, _ error: AWSClientRuntime.RestJSONError, _ id: String?) async throws -> Swift.Error? {
        switch error.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            default: return nil
        }
    }
}
