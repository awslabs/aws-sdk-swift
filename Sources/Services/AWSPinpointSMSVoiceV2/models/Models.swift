// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because you don't have sufficient permissions to access the resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: PinpointSMSVoiceV2ClientTypes.AccessDeniedExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PinpointSMSVoiceV2ClientTypes.AccessDeniedExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: PinpointSMSVoiceV2ClientTypes.AccessDeniedExceptionReason?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.AccessDeniedExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum AccessDeniedExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountDisabled
        case insufficientAccountReputation
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessDeniedExceptionReason] {
            return [
                .accountDisabled,
                .insufficientAccountReputation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountDisabled: return "ACCOUNT_DISABLED"
            case .insufficientAccountReputation: return "INSUFFICIENT_ACCOUNT_REPUTATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessDeniedExceptionReason(rawValue: rawValue) ?? AccessDeniedExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.AccountAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.AccountAttributeName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Displays the attributes associated with a single Amazon Web Services account.
    public struct AccountAttribute: Swift.Equatable {
        /// The name of the account attribute.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.AccountAttributeName?
        /// The value associated with the account attribute name.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.AccountAttributeName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum AccountAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountTier
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountAttributeName] {
            return [
                .accountTier,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountTier: return "ACCOUNT_TIER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountAttributeName(rawValue: rawValue) ?? AccountAttributeName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.AccountLimit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case name = "Name"
        case used = "Used"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if used != 0 {
            try encodeContainer.encode(used, forKey: .used)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.AccountLimitName.self, forKey: .name)
        name = nameDecoded
        let usedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .used) ?? 0
        used = usedDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max) ?? 0
        max = maxDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The current resource quotas associated with an Amazon Web Services account.
    public struct AccountLimit: Swift.Equatable {
        /// The Amazon Web Services set limit for that resource type, in US dollars.
        /// This member is required.
        public var max: Swift.Int
        /// The name of the attribute to apply the account limit to.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.AccountLimitName?
        /// The current amount that has been spent, in US dollars.
        /// This member is required.
        public var used: Swift.Int

        public init(
            max: Swift.Int = 0,
            name: PinpointSMSVoiceV2ClientTypes.AccountLimitName? = nil,
            used: Swift.Int = 0
        )
        {
            self.max = max
            self.name = name
            self.used = used
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum AccountLimitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configurationSets
        case optOutLists
        case phoneNumbers
        case pools
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountLimitName] {
            return [
                .configurationSets,
                .optOutLists,
                .phoneNumbers,
                .pools,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configurationSets: return "CONFIGURATION_SETS"
            case .optOutLists: return "OPT_OUT_LISTS"
            case .phoneNumbers: return "PHONE_NUMBERS"
            case .pools: return "POOLS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountLimitName(rawValue: rawValue) ?? AccountLimitName.sdkUnknown(rawValue)
        }
    }
}

extension AssociateOriginationIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case isoCountryCode = "IsoCountryCode"
        case originationIdentity = "OriginationIdentity"
        case poolId = "PoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
    }
}

extension AssociateOriginationIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateOriginationIdentityInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The new two-character code, in ISO 3166-1 alpha-2 format, for the country or region of the origination identity.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The origination identity to use, such as PhoneNumberId, PhoneNumberArn, SenderId, or SenderIdArn. You can use [DescribePhoneNumbers] to find the values for PhoneNumberId and PhoneNumberArn, while [DescribeSenderIds] can be used to get the values for SenderId and SenderIdArn.
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// The pool to update with the new Identity. This value can be either the PoolId or PoolArn, and you can find these values using [DescribePools].
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        isoCountryCode: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.isoCountryCode = isoCountryCode
        self.originationIdentity = originationIdentity
        self.poolId = poolId
    }
}

struct AssociateOriginationIdentityInputBody: Swift.Equatable {
    let poolId: Swift.String?
    let originationIdentity: Swift.String?
    let isoCountryCode: Swift.String?
    let clientToken: Swift.String?
}

extension AssociateOriginationIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case isoCountryCode = "IsoCountryCode"
        case originationIdentity = "OriginationIdentity"
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateOriginationIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateOriginationIdentityOutputBody = try responseDecoder.decode(responseBody: data)
            self.isoCountryCode = output.isoCountryCode
            self.originationIdentity = output.originationIdentity
            self.originationIdentityArn = output.originationIdentityArn
            self.poolArn = output.poolArn
            self.poolId = output.poolId
        } else {
            self.isoCountryCode = nil
            self.originationIdentity = nil
            self.originationIdentityArn = nil
            self.poolArn = nil
            self.poolId = nil
        }
    }
}

public struct AssociateOriginationIdentityOutput: Swift.Equatable {
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The PhoneNumberId or SenderId of the origination identity.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or SenderIdArn of the origination identity.
    public var originationIdentityArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the pool that is now associated with the origination identity.
    public var poolArn: Swift.String?
    /// The PoolId of the pool that is now associated with the origination identity.
    public var poolId: Swift.String?

    public init(
        isoCountryCode: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
        self.poolArn = poolArn
        self.poolId = poolId
    }
}

struct AssociateOriginationIdentityOutputBody: Swift.Equatable {
    let poolArn: Swift.String?
    let poolId: Swift.String?
    let originationIdentityArn: Swift.String?
    let originationIdentity: Swift.String?
    let isoCountryCode: Swift.String?
}

extension AssociateOriginationIdentityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case originationIdentity = "OriginationIdentity"
        case originationIdentityArn = "OriginationIdentityArn"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let originationIdentityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentityArn)
        originationIdentityArn = originationIdentityArnDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
    }
}

enum AssociateOriginationIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRoleArn = "IamRoleArn"
        case logGroupArn = "LogGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Contains the destination configuration to use when publishing message sending events.
    public struct CloudWatchLogsDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon Identity and Access Management (IAM) role that is able to write event data to an Amazon CloudWatch destination.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// The name of the Amazon CloudWatch log group that you want to record events in.
        /// This member is required.
        public var logGroupArn: Swift.String?

        public init(
            iamRoleArn: Swift.String? = nil,
            logGroupArn: Swift.String? = nil
        )
        {
            self.iamRoleArn = iamRoleArn
            self.logGroupArn = logGroupArn
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for configuration sets that meet a specified criteria.
    public struct ConfigurationSetFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum ConfigurationSetFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case defaultMessageType
        case defaultSenderId
        case eventDestinationName
        case matchingEventTypes
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationSetFilterName] {
            return [
                .defaultMessageType,
                .defaultSenderId,
                .eventDestinationName,
                .matchingEventTypes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .defaultMessageType: return "default-message-type"
            case .defaultSenderId: return "default-sender-id"
            case .eventDestinationName: return "event-destination-name"
            case .matchingEventTypes: return "matching-event-types"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationSetFilterName(rawValue: rawValue) ?? ConfigurationSetFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case createdTimestamp = "CreatedTimestamp"
        case defaultMessageType = "DefaultMessageType"
        case defaultSenderId = "DefaultSenderId"
        case eventDestinations = "EventDestinations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetArn = self.configurationSetArn {
            try encodeContainer.encode(configurationSetArn, forKey: .configurationSetArn)
        }
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let defaultMessageType = self.defaultMessageType {
            try encodeContainer.encode(defaultMessageType.rawValue, forKey: .defaultMessageType)
        }
        if let defaultSenderId = self.defaultSenderId {
            try encodeContainer.encode(defaultSenderId, forKey: .defaultSenderId)
        }
        if let eventDestinations = eventDestinations {
            var eventDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventDestinations)
            for eventdestination0 in eventDestinations {
                try eventDestinationsContainer.encode(eventdestination0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.EventDestination?].self, forKey: .eventDestinations)
        var eventDestinationsDecoded0:[PinpointSMSVoiceV2ClientTypes.EventDestination]? = nil
        if let eventDestinationsContainer = eventDestinationsContainer {
            eventDestinationsDecoded0 = [PinpointSMSVoiceV2ClientTypes.EventDestination]()
            for structure0 in eventDestinationsContainer {
                if let structure0 = structure0 {
                    eventDestinationsDecoded0?.append(structure0)
                }
            }
        }
        eventDestinations = eventDestinationsDecoded0
        let defaultMessageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .defaultMessageType)
        defaultMessageType = defaultMessageTypeDecoded
        let defaultSenderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSenderId)
        defaultSenderId = defaultSenderIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Information related to a given configuration set in your Amazon Web Services account.
    public struct ConfigurationSetInformation: Swift.Equatable {
        /// The Resource Name (ARN) of the ConfigurationSet.
        /// This member is required.
        public var configurationSetArn: Swift.String?
        /// The name of the ConfigurationSet.
        /// This member is required.
        public var configurationSetName: Swift.String?
        /// The time when the ConfigurationSet was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: ClientRuntime.Date?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public var defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType?
        /// The default sender ID used by the ConfigurationSet.
        public var defaultSenderId: Swift.String?
        /// An array of EventDestination objects that describe any events to log and where to log them.
        /// This member is required.
        public var eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]?

        public init(
            configurationSetArn: Swift.String? = nil,
            configurationSetName: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
            defaultSenderId: Swift.String? = nil,
            eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]? = nil
        )
        {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.createdTimestamp = createdTimestamp
            self.defaultMessageType = defaultMessageType
            self.defaultSenderId = defaultSenderId
            self.eventDestinations = eventDestinations
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.reason = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time or it could be that the requested action isn't valid for the current state or configuration of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: PinpointSMSVoiceV2ClientTypes.ConflictExceptionReason? = nil
        /// The unique identifier of the request.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that caused the exception.
        public internal(set) var resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PinpointSMSVoiceV2ClientTypes.ConflictExceptionReason? = nil,
        resourceId: Swift.String? = nil,
        resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: PinpointSMSVoiceV2ClientTypes.ConflictExceptionReason?
    let resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType?
    let resourceId: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deletionProtectionEnabled
        case destinationPhoneNumberNotVerified
        case destinationPhoneNumberOptedOut
        case eventDestinationMismatch
        case keywordMismatch
        case lastPhoneNumber
        case messageTypeMismatch
        case noOriginationIdentitiesFound
        case optOutListMismatch
        case phoneNumberAssociatedToPool
        case phoneNumberNotAssociatedToPool
        case phoneNumberNotInRegistrationRegion
        case resourceAlreadyExists
        case resourceDeletionNotAllowed
        case resourceModificationNotAllowed
        case resourceNotActive
        case resourceNotEmpty
        case selfManagedOptOutsMismatch
        case twoWayConfigMismatch
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .deletionProtectionEnabled,
                .destinationPhoneNumberNotVerified,
                .destinationPhoneNumberOptedOut,
                .eventDestinationMismatch,
                .keywordMismatch,
                .lastPhoneNumber,
                .messageTypeMismatch,
                .noOriginationIdentitiesFound,
                .optOutListMismatch,
                .phoneNumberAssociatedToPool,
                .phoneNumberNotAssociatedToPool,
                .phoneNumberNotInRegistrationRegion,
                .resourceAlreadyExists,
                .resourceDeletionNotAllowed,
                .resourceModificationNotAllowed,
                .resourceNotActive,
                .resourceNotEmpty,
                .selfManagedOptOutsMismatch,
                .twoWayConfigMismatch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deletionProtectionEnabled: return "DELETION_PROTECTION_ENABLED"
            case .destinationPhoneNumberNotVerified: return "DESTINATION_PHONE_NUMBER_NOT_VERIFIED"
            case .destinationPhoneNumberOptedOut: return "DESTINATION_PHONE_NUMBER_OPTED_OUT"
            case .eventDestinationMismatch: return "EVENT_DESTINATION_MISMATCH"
            case .keywordMismatch: return "KEYWORD_MISMATCH"
            case .lastPhoneNumber: return "LAST_PHONE_NUMBER"
            case .messageTypeMismatch: return "MESSAGE_TYPE_MISMATCH"
            case .noOriginationIdentitiesFound: return "NO_ORIGINATION_IDENTITIES_FOUND"
            case .optOutListMismatch: return "OPT_OUT_LIST_MISMATCH"
            case .phoneNumberAssociatedToPool: return "PHONE_NUMBER_ASSOCIATED_TO_POOL"
            case .phoneNumberNotAssociatedToPool: return "PHONE_NUMBER_NOT_ASSOCIATED_TO_POOL"
            case .phoneNumberNotInRegistrationRegion: return "PHONE_NUMBER_NOT_IN_REGISTRATION_REGION"
            case .resourceAlreadyExists: return "RESOURCE_ALREADY_EXISTS"
            case .resourceDeletionNotAllowed: return "RESOURCE_DELETION_NOT_ALLOWED"
            case .resourceModificationNotAllowed: return "RESOURCE_MODIFICATION_NOT_ALLOWED"
            case .resourceNotActive: return "RESOURCE_NOT_ACTIVE"
            case .resourceNotEmpty: return "RESOURCE_NOT_EMPTY"
            case .selfManagedOptOutsMismatch: return "SELF_MANAGED_OPT_OUTS_MISMATCH"
            case .twoWayConfigMismatch: return "TWO_WAY_CONFIG_MISMATCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CreateConfigurationSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case configurationSetName = "ConfigurationSetName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateConfigurationSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConfigurationSetInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The name to use for the new configuration set.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// An array of key and value pair tags that's associated with the new configuration set.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.configurationSetName = configurationSetName
        self.tags = tags
    }
}

struct CreateConfigurationSetInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateConfigurationSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case configurationSetName = "ConfigurationSetName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateConfigurationSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConfigurationSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.createdTimestamp = output.createdTimestamp
            self.tags = output.tags
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.createdTimestamp = nil
            self.tags = nil
        }
    }
}

public struct CreateConfigurationSetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the newly created configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the new configuration set.
    public var configurationSetName: Swift.String?
    /// The time when the configuration set was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// An array of key and value pair tags that's associated with the configuration set.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.createdTimestamp = createdTimestamp
        self.tags = tags
    }
}

struct CreateConfigurationSetOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
}

extension CreateConfigurationSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case createdTimestamp = "CreatedTimestamp"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum CreateConfigurationSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEventDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let cloudWatchLogsDestination = self.cloudWatchLogsDestination {
            try encodeContainer.encode(cloudWatchLogsDestination, forKey: .cloudWatchLogsDestination)
        }
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let eventDestinationName = self.eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
        if let kinesisFirehoseDestination = self.kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtype0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtype0.rawValue)
            }
        }
        if let snsDestination = self.snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }
}

extension CreateEventDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEventDestinationInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// An object that contains information about an event destination for logging to Amazon CloudWatch logs.
    public var cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
    /// Either the name of the configuration set or the configuration set ARN to apply event logging to. The ConfigurateSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The name that identifies the event destination.
    /// This member is required.
    public var eventDestinationName: Swift.String?
    /// An object that contains information about an event destination for logging to Amazon Kinesis Data Firehose.
    public var kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
    /// An array of event types that determine which events to log. If "ALL" is used, then Amazon Pinpoint logs every event type.
    /// This member is required.
    public var matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
    /// An object that contains information about an event destination for logging to Amazon SNS.
    public var snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?

    public init(
        clientToken: Swift.String? = nil,
        cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination? = nil,
        configurationSetName: Swift.String? = nil,
        eventDestinationName: Swift.String? = nil,
        kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination? = nil,
        matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]? = nil,
        snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination? = nil
    )
    {
        self.clientToken = clientToken
        self.cloudWatchLogsDestination = cloudWatchLogsDestination
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.snsDestination = snsDestination
    }
}

struct CreateEventDestinationInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
    let eventDestinationName: Swift.String?
    let matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
    let cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
    let kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
    let snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?
    let clientToken: Swift.String?
}

extension CreateEventDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[PinpointSMSVoiceV2ClientTypes.EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [PinpointSMSVoiceV2ClientTypes.EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let cloudWatchLogsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination.self, forKey: .cloudWatchLogsDestination)
        cloudWatchLogsDestination = cloudWatchLogsDestinationDecoded
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateEventDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEventDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.eventDestination = output.eventDestination
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.eventDestination = nil
        }
    }
}

public struct CreateEventDestinationOutput: Swift.Equatable {
    /// The ARN of the configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set.
    public var configurationSetName: Swift.String?
    /// The details of the destination where events are logged.
    public var eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
    }
}

struct CreateEventDestinationOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?
}

extension CreateEventDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case eventDestination = "EventDestination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.EventDestination.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

enum CreateEventDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateOptOutListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case optOutListName = "OptOutListName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateOptOutListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateOptOutListInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The name of the new OptOutList.
    /// This member is required.
    public var optOutListName: Swift.String?
    /// An array of tags (key and value pairs) to associate with the new OptOutList.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.optOutListName = optOutListName
        self.tags = tags
    }
}

struct CreateOptOutListInputBody: Swift.Equatable {
    let optOutListName: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateOptOutListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case optOutListName = "OptOutListName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateOptOutListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateOptOutListOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.optOutListArn = output.optOutListArn
            self.optOutListName = output.optOutListName
            self.tags = output.tags
        } else {
            self.createdTimestamp = nil
            self.optOutListArn = nil
            self.optOutListName = nil
            self.tags = nil
        }
    }
}

public struct CreateOptOutListOutput: Swift.Equatable {
    /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the OptOutList.
    public var optOutListArn: Swift.String?
    /// The name of the new OptOutList.
    public var optOutListName: Swift.String?
    /// An array of tags (key and value pairs) associated with the new OptOutList.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
        self.tags = tags
    }
}

struct CreateOptOutListOutputBody: Swift.Equatable {
    let optOutListArn: Swift.String?
    let optOutListName: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
}

extension CreateOptOutListOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case optOutListArn = "OptOutListArn"
        case optOutListName = "OptOutListName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListArn)
        optOutListArn = optOutListArnDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum CreateOptOutListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case originationIdentity = "OriginationIdentity"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deletionProtectionEnabled = self.deletionProtectionEnabled {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePoolInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// By default this is set to false. When set to true the pool can't be deleted. You can change this value using the [UpdatePool] action.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The new two-character code, in ISO 3166-1 alpha-2 format, for the country or region of the new pool.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use [DescribePhoneNumbers] to find the values for PhoneNumberId and PhoneNumberArn while [DescribeSenderIds] can be used to get the values for SenderId and SenderIdArn.
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// An array of tags (key and value pairs) associated with the pool.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        deletionProtectionEnabled: Swift.Bool? = nil,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        originationIdentity: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.originationIdentity = originationIdentity
        self.tags = tags
    }
}

struct CreatePoolInputBody: Swift.Equatable {
    let originationIdentity: Swift.String?
    let isoCountryCode: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let deletionProtectionEnabled: Swift.Bool?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreatePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case originationIdentity = "OriginationIdentity"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled)
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePoolOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.deletionProtectionEnabled = output.deletionProtectionEnabled
            self.messageType = output.messageType
            self.optOutListName = output.optOutListName
            self.poolArn = output.poolArn
            self.poolId = output.poolId
            self.selfManagedOptOutsEnabled = output.selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = output.sharedRoutesEnabled
            self.status = output.status
            self.tags = output.tags
            self.twoWayChannelArn = output.twoWayChannelArn
            self.twoWayEnabled = output.twoWayEnabled
        } else {
            self.createdTimestamp = nil
            self.deletionProtectionEnabled = false
            self.messageType = nil
            self.optOutListName = nil
            self.poolArn = nil
            self.poolId = nil
            self.selfManagedOptOutsEnabled = false
            self.sharedRoutesEnabled = false
            self.status = nil
            self.tags = nil
            self.twoWayChannelArn = nil
            self.twoWayEnabled = false
        }
    }
}

public struct CreatePoolOutput: Swift.Equatable {
    /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// When set to true deletion protection is enabled. By default this is set to false.
    public var deletionProtectionEnabled: Swift.Bool
    /// The type of message for the pool to use.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The name of the OptOutList associated with the pool.
    public var optOutListName: Swift.String?
    /// The Amazon Resource Name (ARN) for the pool.
    public var poolArn: Swift.String?
    /// The unique identifier for the pool.
    public var poolId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// Indicates whether shared routes are enabled for the pool.
    public var sharedRoutesEnabled: Swift.Bool
    /// The current status of the pool.
    ///
    /// * CREATING: The pool is currently being created and isn't yet available for use.
    ///
    /// * ACTIVE: The pool is active and available for use.
    ///
    /// * DELETING: The pool is being deleted.
    public var status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    /// An array of tags (key and value pairs) associated with the pool.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        optOutListName: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        sharedRoutesEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.PoolStatus? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.messageType = messageType
        self.optOutListName = optOutListName
        self.poolArn = poolArn
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.sharedRoutesEnabled = sharedRoutesEnabled
        self.status = status
        self.tags = tags
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayEnabled = twoWayEnabled
    }
}

struct CreatePoolOutputBody: Swift.Equatable {
    let poolArn: Swift.String?
    let poolId: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let twoWayEnabled: Swift.Bool
    let twoWayChannelArn: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool
    let optOutListName: Swift.String?
    let sharedRoutesEnabled: Swift.Bool
    let deletionProtectionEnabled: Swift.Bool
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
}

extension CreatePoolOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case messageType = "MessageType"
        case optOutListName = "OptOutListName"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case sharedRoutesEnabled = "SharedRoutesEnabled"
        case status = "Status"
        case tags = "Tags"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PoolStatus.self, forKey: .status)
        status = statusDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let sharedRoutesEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharedRoutesEnabled) ?? false
        sharedRoutesEnabled = sharedRoutesEnabledDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum CreatePoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConfigurationSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
    }
}

extension DeleteConfigurationSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConfigurationSetInput: Swift.Equatable {
    /// The name of the configuration set or the configuration set ARN that you want to delete. The ConfigurationSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct DeleteConfigurationSetInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
}

extension DeleteConfigurationSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension DeleteConfigurationSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteConfigurationSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.createdTimestamp = output.createdTimestamp
            self.defaultMessageType = output.defaultMessageType
            self.defaultSenderId = output.defaultSenderId
            self.eventDestinations = output.eventDestinations
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.createdTimestamp = nil
            self.defaultMessageType = nil
            self.defaultSenderId = nil
            self.eventDestinations = nil
        }
    }
}

public struct DeleteConfigurationSetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the deleted configuration set.
    public var configurationSetName: Swift.String?
    /// The time that the deleted configuration set was created in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The default message type of the configuration set that was deleted.
    public var defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The default Sender ID of the configuration set that was deleted.
    public var defaultSenderId: Swift.String?
    /// An array of any EventDestination objects that were associated with the deleted configuration set.
    public var eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        defaultSenderId: Swift.String? = nil,
        eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.createdTimestamp = createdTimestamp
        self.defaultMessageType = defaultMessageType
        self.defaultSenderId = defaultSenderId
        self.eventDestinations = eventDestinations
    }
}

struct DeleteConfigurationSetOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]?
    let defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let defaultSenderId: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
}

extension DeleteConfigurationSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case createdTimestamp = "CreatedTimestamp"
        case defaultMessageType = "DefaultMessageType"
        case defaultSenderId = "DefaultSenderId"
        case eventDestinations = "EventDestinations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.EventDestination?].self, forKey: .eventDestinations)
        var eventDestinationsDecoded0:[PinpointSMSVoiceV2ClientTypes.EventDestination]? = nil
        if let eventDestinationsContainer = eventDestinationsContainer {
            eventDestinationsDecoded0 = [PinpointSMSVoiceV2ClientTypes.EventDestination]()
            for structure0 in eventDestinationsContainer {
                if let structure0 = structure0 {
                    eventDestinationsDecoded0?.append(structure0)
                }
            }
        }
        eventDestinations = eventDestinationsDecoded0
        let defaultMessageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .defaultMessageType)
        defaultMessageType = defaultMessageTypeDecoded
        let defaultSenderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSenderId)
        defaultSenderId = defaultSenderIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum DeleteConfigurationSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDefaultMessageTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
    }
}

extension DeleteDefaultMessageTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDefaultMessageTypeInput: Swift.Equatable {
    /// The name of the configuration set or the configuration set Amazon Resource Name (ARN) to delete the default message type from. The ConfigurationSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct DeleteDefaultMessageTypeInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
}

extension DeleteDefaultMessageTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension DeleteDefaultMessageTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDefaultMessageTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.messageType = output.messageType
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.messageType = nil
        }
    }
}

public struct DeleteDefaultMessageTypeOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set.
    public var configurationSetName: Swift.String?
    /// The current message type for the configuration set.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.messageType = messageType
    }
}

struct DeleteDefaultMessageTypeOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
}

extension DeleteDefaultMessageTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case messageType = "MessageType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
    }
}

enum DeleteDefaultMessageTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDefaultSenderIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
    }
}

extension DeleteDefaultSenderIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDefaultSenderIdInput: Swift.Equatable {
    /// The name of the configuration set or the configuration set Amazon Resource Name (ARN) to delete the default sender ID from. The ConfigurationSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct DeleteDefaultSenderIdInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
}

extension DeleteDefaultSenderIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension DeleteDefaultSenderIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDefaultSenderIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.senderId = output.senderId
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.senderId = nil
        }
    }
}

public struct DeleteDefaultSenderIdOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set.
    public var configurationSetName: Swift.String?
    /// The current sender ID for the configuration set.
    public var senderId: Swift.String?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.senderId = senderId
    }
}

struct DeleteDefaultSenderIdOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let senderId: Swift.String?
}

extension DeleteDefaultSenderIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case senderId = "SenderId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
    }
}

enum DeleteDefaultSenderIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let eventDestinationName = self.eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
    }
}

extension DeleteEventDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEventDestinationInput: Swift.Equatable {
    /// The name of the configuration set or the configuration set's Amazon Resource Name (ARN) to remove the event destination from. The ConfigurateSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The name of the event destination to delete.
    /// This member is required.
    public var eventDestinationName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        eventDestinationName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
    }
}

struct DeleteEventDestinationInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
    let eventDestinationName: Swift.String?
}

extension DeleteEventDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
    }
}

extension DeleteEventDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEventDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.eventDestination = output.eventDestination
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.eventDestination = nil
        }
    }
}

public struct DeleteEventDestinationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set the event destination was deleted from.
    public var configurationSetName: Swift.String?
    /// The event destination object that was deleted.
    public var eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
    }
}

struct DeleteEventDestinationOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?
}

extension DeleteEventDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case eventDestination = "EventDestination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.EventDestination.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

enum DeleteEventDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKeywordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case originationIdentity = "OriginationIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyword = self.keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
    }
}

extension DeleteKeywordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteKeywordInput: Swift.Equatable {
    /// The keyword to delete.
    /// This member is required.
    public var keyword: Swift.String?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, PoolId or PoolArn. You can use [DescribePhoneNumbers] to find the values for PhoneNumberId and PhoneNumberArn and [DescribePools] to find the values of PoolId and PoolArn.
    /// This member is required.
    public var originationIdentity: Swift.String?

    public init(
        keyword: Swift.String? = nil,
        originationIdentity: Swift.String? = nil
    )
    {
        self.keyword = keyword
        self.originationIdentity = originationIdentity
    }
}

struct DeleteKeywordInputBody: Swift.Equatable {
    let originationIdentity: Swift.String?
    let keyword: Swift.String?
}

extension DeleteKeywordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case originationIdentity = "OriginationIdentity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
    }
}

extension DeleteKeywordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteKeywordOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyword = output.keyword
            self.keywordAction = output.keywordAction
            self.keywordMessage = output.keywordMessage
            self.originationIdentity = output.originationIdentity
            self.originationIdentityArn = output.originationIdentityArn
        } else {
            self.keyword = nil
            self.keywordAction = nil
            self.keywordMessage = nil
            self.originationIdentity = nil
            self.originationIdentityArn = nil
        }
    }
}

public struct DeleteKeywordOutput: Swift.Equatable {
    /// The keyword that was deleted.
    public var keyword: Swift.String?
    /// The action that was associated with the deleted keyword.
    public var keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
    /// The message that was associated with the deleted keyword.
    public var keywordMessage: Swift.String?
    /// The PhoneNumberId or PoolId that the keyword was associated with.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or PoolArn that the keyword was associated with.
    public var originationIdentityArn: Swift.String?

    public init(
        keyword: Swift.String? = nil,
        keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction? = nil,
        keywordMessage: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil
    )
    {
        self.keyword = keyword
        self.keywordAction = keywordAction
        self.keywordMessage = keywordMessage
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
    }
}

struct DeleteKeywordOutputBody: Swift.Equatable {
    let originationIdentityArn: Swift.String?
    let originationIdentity: Swift.String?
    let keyword: Swift.String?
    let keywordMessage: Swift.String?
    let keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
}

extension DeleteKeywordOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case keywordAction = "KeywordAction"
        case keywordMessage = "KeywordMessage"
        case originationIdentity = "OriginationIdentity"
        case originationIdentityArn = "OriginationIdentityArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentityArn)
        originationIdentityArn = originationIdentityArnDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
        let keywordMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywordMessage)
        keywordMessage = keywordMessageDecoded
        let keywordActionDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KeywordAction.self, forKey: .keywordAction)
        keywordAction = keywordActionDecoded
    }
}

enum DeleteKeywordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteOptOutListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optOutListName = "OptOutListName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
    }
}

extension DeleteOptOutListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOptOutListInput: Swift.Equatable {
    /// The OptOutListName or OptOutListArn of the OptOutList to delete. You can use [DescribeOptOutLists] to find the values for OptOutListName and OptOutListArn.
    /// This member is required.
    public var optOutListName: Swift.String?

    public init(
        optOutListName: Swift.String? = nil
    )
    {
        self.optOutListName = optOutListName
    }
}

struct DeleteOptOutListInputBody: Swift.Equatable {
    let optOutListName: Swift.String?
}

extension DeleteOptOutListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optOutListName = "OptOutListName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
    }
}

extension DeleteOptOutListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteOptOutListOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.optOutListArn = output.optOutListArn
            self.optOutListName = output.optOutListName
        } else {
            self.createdTimestamp = nil
            self.optOutListArn = nil
            self.optOutListName = nil
        }
    }
}

public struct DeleteOptOutListOutput: Swift.Equatable {
    /// The time when the OptOutList was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the OptOutList that was removed.
    public var optOutListArn: Swift.String?
    /// The name of the OptOutList that was removed.
    public var optOutListName: Swift.String?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
    }
}

struct DeleteOptOutListOutputBody: Swift.Equatable {
    let optOutListArn: Swift.String?
    let optOutListName: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
}

extension DeleteOptOutListOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case optOutListArn = "OptOutListArn"
        case optOutListName = "OptOutListName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListArn)
        optOutListArn = optOutListArnDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum DeleteOptOutListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteOptedOutNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optOutListName = "OptOutListName"
        case optedOutNumber = "OptedOutNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let optedOutNumber = self.optedOutNumber {
            try encodeContainer.encode(optedOutNumber, forKey: .optedOutNumber)
        }
    }
}

extension DeleteOptedOutNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOptedOutNumberInput: Swift.Equatable {
    /// The OptOutListName or OptOutListArn to remove the phone number from.
    /// This member is required.
    public var optOutListName: Swift.String?
    /// The phone number, in E.164 format, to remove from the OptOutList.
    /// This member is required.
    public var optedOutNumber: Swift.String?

    public init(
        optOutListName: Swift.String? = nil,
        optedOutNumber: Swift.String? = nil
    )
    {
        self.optOutListName = optOutListName
        self.optedOutNumber = optedOutNumber
    }
}

struct DeleteOptedOutNumberInputBody: Swift.Equatable {
    let optOutListName: Swift.String?
    let optedOutNumber: Swift.String?
}

extension DeleteOptedOutNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optOutListName = "OptOutListName"
        case optedOutNumber = "OptedOutNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let optedOutNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optedOutNumber)
        optedOutNumber = optedOutNumberDecoded
    }
}

extension DeleteOptedOutNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteOptedOutNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.endUserOptedOut = output.endUserOptedOut
            self.optOutListArn = output.optOutListArn
            self.optOutListName = output.optOutListName
            self.optedOutNumber = output.optedOutNumber
            self.optedOutTimestamp = output.optedOutTimestamp
        } else {
            self.endUserOptedOut = false
            self.optOutListArn = nil
            self.optOutListName = nil
            self.optedOutNumber = nil
            self.optedOutTimestamp = nil
        }
    }
}

public struct DeleteOptedOutNumberOutput: Swift.Equatable {
    /// This is true if it was the end user who requested their phone number be removed.
    public var endUserOptedOut: Swift.Bool
    /// The OptOutListArn that the phone number was removed from.
    public var optOutListArn: Swift.String?
    /// The OptOutListName that the phone number was removed from.
    public var optOutListName: Swift.String?
    /// The phone number that was removed from the OptOutList.
    public var optedOutNumber: Swift.String?
    /// The time that the number was removed at, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var optedOutTimestamp: ClientRuntime.Date?

    public init(
        endUserOptedOut: Swift.Bool = false,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        optedOutNumber: Swift.String? = nil,
        optedOutTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.endUserOptedOut = endUserOptedOut
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
        self.optedOutNumber = optedOutNumber
        self.optedOutTimestamp = optedOutTimestamp
    }
}

struct DeleteOptedOutNumberOutputBody: Swift.Equatable {
    let optOutListArn: Swift.String?
    let optOutListName: Swift.String?
    let optedOutNumber: Swift.String?
    let optedOutTimestamp: ClientRuntime.Date?
    let endUserOptedOut: Swift.Bool
}

extension DeleteOptedOutNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endUserOptedOut = "EndUserOptedOut"
        case optOutListArn = "OptOutListArn"
        case optOutListName = "OptOutListName"
        case optedOutNumber = "OptedOutNumber"
        case optedOutTimestamp = "OptedOutTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListArn)
        optOutListArn = optOutListArnDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let optedOutNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optedOutNumber)
        optedOutNumber = optedOutNumberDecoded
        let optedOutTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .optedOutTimestamp)
        optedOutTimestamp = optedOutTimestampDecoded
        let endUserOptedOutDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .endUserOptedOut) ?? false
        endUserOptedOut = endUserOptedOutDecoded
    }
}

enum DeleteOptedOutNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolId = "PoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
    }
}

extension DeletePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePoolInput: Swift.Equatable {
    /// The PoolId or PoolArn of the pool to delete. You can use [DescribePools] to find the values for PoolId and PoolArn .
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        poolId: Swift.String? = nil
    )
    {
        self.poolId = poolId
    }
}

struct DeletePoolInputBody: Swift.Equatable {
    let poolId: Swift.String?
}

extension DeletePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
    }
}

extension DeletePoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePoolOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.messageType = output.messageType
            self.optOutListName = output.optOutListName
            self.poolArn = output.poolArn
            self.poolId = output.poolId
            self.selfManagedOptOutsEnabled = output.selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = output.sharedRoutesEnabled
            self.status = output.status
            self.twoWayChannelArn = output.twoWayChannelArn
            self.twoWayEnabled = output.twoWayEnabled
        } else {
            self.createdTimestamp = nil
            self.messageType = nil
            self.optOutListName = nil
            self.poolArn = nil
            self.poolId = nil
            self.selfManagedOptOutsEnabled = false
            self.sharedRoutesEnabled = false
            self.status = nil
            self.twoWayChannelArn = nil
            self.twoWayEnabled = false
        }
    }
}

public struct DeletePoolOutput: Swift.Equatable {
    /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The message type that was associated with the deleted pool.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The name of the OptOutList that was associated with the deleted pool.
    public var optOutListName: Swift.String?
    /// The Amazon Resource Name (ARN) of the pool that was deleted.
    public var poolArn: Swift.String?
    /// The PoolId of the pool that was deleted.
    public var poolId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// Indicates whether shared routes are enabled for the pool.
    public var sharedRoutesEnabled: Swift.Bool
    /// The current status of the pool.
    ///
    /// * CREATING: The pool is currently being created and isn't yet available for use.
    ///
    /// * ACTIVE: The pool is active and available for use.
    ///
    /// * DELETING: The pool is being deleted.
    public var status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    /// The Amazon Resource Name (ARN) of the TwoWayChannel.
    public var twoWayChannelArn: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        optOutListName: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        sharedRoutesEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.PoolStatus? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.messageType = messageType
        self.optOutListName = optOutListName
        self.poolArn = poolArn
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.sharedRoutesEnabled = sharedRoutesEnabled
        self.status = status
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayEnabled = twoWayEnabled
    }
}

struct DeletePoolOutputBody: Swift.Equatable {
    let poolArn: Swift.String?
    let poolId: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let twoWayEnabled: Swift.Bool
    let twoWayChannelArn: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool
    let optOutListName: Swift.String?
    let sharedRoutesEnabled: Swift.Bool
    let createdTimestamp: ClientRuntime.Date?
}

extension DeletePoolOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case messageType = "MessageType"
        case optOutListName = "OptOutListName"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case sharedRoutesEnabled = "SharedRoutesEnabled"
        case status = "Status"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PoolStatus.self, forKey: .status)
        status = statusDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let sharedRoutesEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharedRoutesEnabled) ?? false
        sharedRoutesEnabled = sharedRoutesEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum DeletePoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTextMessageSpendLimitOverrideInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteTextMessageSpendLimitOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTextMessageSpendLimitOverrideInput: Swift.Equatable {

    public init() { }
}

struct DeleteTextMessageSpendLimitOverrideInputBody: Swift.Equatable {
}

extension DeleteTextMessageSpendLimitOverrideInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTextMessageSpendLimitOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteTextMessageSpendLimitOverrideOutputBody = try responseDecoder.decode(responseBody: data)
            self.monthlyLimit = output.monthlyLimit
        } else {
            self.monthlyLimit = nil
        }
    }
}

public struct DeleteTextMessageSpendLimitOverrideOutput: Swift.Equatable {
    /// The current monthly limit, in US dollars.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

struct DeleteTextMessageSpendLimitOverrideOutputBody: Swift.Equatable {
    let monthlyLimit: Swift.Int?
}

extension DeleteTextMessageSpendLimitOverrideOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlyLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monthlyLimit)
        monthlyLimit = monthlyLimitDecoded
    }
}

enum DeleteTextMessageSpendLimitOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceMessageSpendLimitOverrideInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteVoiceMessageSpendLimitOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVoiceMessageSpendLimitOverrideInput: Swift.Equatable {

    public init() { }
}

struct DeleteVoiceMessageSpendLimitOverrideInputBody: Swift.Equatable {
}

extension DeleteVoiceMessageSpendLimitOverrideInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceMessageSpendLimitOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteVoiceMessageSpendLimitOverrideOutputBody = try responseDecoder.decode(responseBody: data)
            self.monthlyLimit = output.monthlyLimit
        } else {
            self.monthlyLimit = nil
        }
    }
}

public struct DeleteVoiceMessageSpendLimitOverrideOutput: Swift.Equatable {
    /// The current monthly limit, in US dollars.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

struct DeleteVoiceMessageSpendLimitOverrideOutputBody: Swift.Equatable {
    let monthlyLimit: Swift.Int?
}

extension DeleteVoiceMessageSpendLimitOverrideOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlyLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monthlyLimit)
        monthlyLimit = monthlyLimitDecoded
    }
}

enum DeleteVoiceMessageSpendLimitOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAccountAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountAttributesInput: Swift.Equatable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAccountAttributesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAccountAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAccountAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAttributes = output.accountAttributes
            self.nextToken = output.nextToken
        } else {
            self.accountAttributes = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAccountAttributesOutput: Swift.Equatable {
    /// An array of AccountAttributes objects.
    public var accountAttributes: [PinpointSMSVoiceV2ClientTypes.AccountAttribute]?
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?

    public init(
        accountAttributes: [PinpointSMSVoiceV2ClientTypes.AccountAttribute]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAttributes = accountAttributes
        self.nextToken = nextToken
    }
}

struct DescribeAccountAttributesOutputBody: Swift.Equatable {
    let accountAttributes: [PinpointSMSVoiceV2ClientTypes.AccountAttribute]?
    let nextToken: Swift.String?
}

extension DescribeAccountAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAttributes = "AccountAttributes"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAttributesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.AccountAttribute?].self, forKey: .accountAttributes)
        var accountAttributesDecoded0:[PinpointSMSVoiceV2ClientTypes.AccountAttribute]? = nil
        if let accountAttributesContainer = accountAttributesContainer {
            accountAttributesDecoded0 = [PinpointSMSVoiceV2ClientTypes.AccountAttribute]()
            for structure0 in accountAttributesContainer {
                if let structure0 = structure0 {
                    accountAttributesDecoded0?.append(structure0)
                }
            }
        }
        accountAttributes = accountAttributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAccountAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountLimitsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAccountLimitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountLimitsInput: Swift.Equatable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAccountLimitsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAccountLimitsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAccountLimitsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountLimitsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountLimits = output.accountLimits
            self.nextToken = output.nextToken
        } else {
            self.accountLimits = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAccountLimitsOutput: Swift.Equatable {
    /// An array of AccountLimit objects that show the current spend limits.
    public var accountLimits: [PinpointSMSVoiceV2ClientTypes.AccountLimit]?
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?

    public init(
        accountLimits: [PinpointSMSVoiceV2ClientTypes.AccountLimit]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountLimits = accountLimits
        self.nextToken = nextToken
    }
}

struct DescribeAccountLimitsOutputBody: Swift.Equatable {
    let accountLimits: [PinpointSMSVoiceV2ClientTypes.AccountLimit]?
    let nextToken: Swift.String?
}

extension DescribeAccountLimitsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLimits = "AccountLimits"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountLimitsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.AccountLimit?].self, forKey: .accountLimits)
        var accountLimitsDecoded0:[PinpointSMSVoiceV2ClientTypes.AccountLimit]? = nil
        if let accountLimitsContainer = accountLimitsContainer {
            accountLimitsDecoded0 = [PinpointSMSVoiceV2ClientTypes.AccountLimit]()
            for structure0 in accountLimitsContainer {
                if let structure0 = structure0 {
                    accountLimitsDecoded0?.append(structure0)
                }
            }
        }
        accountLimits = accountLimitsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAccountLimitsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConfigurationSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetNames = "ConfigurationSetNames"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetNames = configurationSetNames {
            var configurationSetNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationSetNames)
            for configurationsetnameorarn0 in configurationSetNames {
                try configurationSetNamesContainer.encode(configurationsetnameorarn0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for configurationsetfilter0 in filters {
                try filtersContainer.encode(configurationsetfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConfigurationSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConfigurationSetsInput: Swift.Equatable {
    /// An array of strings. Each element can be either a ConfigurationSetName or ConfigurationSetArn.
    public var configurationSetNames: [Swift.String]?
    /// An array of filters to apply to the results that are returned.
    public var filters: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?

    public init(
        configurationSetNames: [Swift.String]? = nil,
        filters: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationSetNames = configurationSetNames
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeConfigurationSetsInputBody: Swift.Equatable {
    let configurationSetNames: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeConfigurationSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetNames = "ConfigurationSetNames"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationSetNames)
        var configurationSetNamesDecoded0:[Swift.String]? = nil
        if let configurationSetNamesContainer = configurationSetNamesContainer {
            configurationSetNamesDecoded0 = [Swift.String]()
            for string0 in configurationSetNamesContainer {
                if let string0 = string0 {
                    configurationSetNamesDecoded0?.append(string0)
                }
            }
        }
        configurationSetNames = configurationSetNamesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeConfigurationSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConfigurationSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSets = output.configurationSets
            self.nextToken = output.nextToken
        } else {
            self.configurationSets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConfigurationSetsOutput: Swift.Equatable {
    /// An array of ConfigurationSets objects.
    public var configurationSets: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]?
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?

    public init(
        configurationSets: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationSets = configurationSets
        self.nextToken = nextToken
    }
}

struct DescribeConfigurationSetsOutputBody: Swift.Equatable {
    let configurationSets: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]?
    let nextToken: Swift.String?
}

extension DescribeConfigurationSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSets = "ConfigurationSets"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation?].self, forKey: .configurationSets)
        var configurationSetsDecoded0:[PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]? = nil
        if let configurationSetsContainer = configurationSetsContainer {
            configurationSetsDecoded0 = [PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]()
            for structure0 in configurationSetsContainer {
                if let structure0 = structure0 {
                    configurationSetsDecoded0?.append(structure0)
                }
            }
        }
        configurationSets = configurationSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeConfigurationSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeKeywordsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case keywords = "Keywords"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case originationIdentity = "OriginationIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for keywordfilter0 in filters {
                try filtersContainer.encode(keywordfilter0)
            }
        }
        if let keywords = keywords {
            var keywordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keywords)
            for keyword0 in keywords {
                try keywordsContainer.encode(keyword0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
    }
}

extension DescribeKeywordsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeKeywordsInput: Swift.Equatable {
    /// An array of keyword filters to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.KeywordFilter]?
    /// An array of keywords to search for.
    public var keywords: [Swift.String]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use [DescribePhoneNumbers] to find the values for PhoneNumberId and PhoneNumberArn while [DescribeSenderIds] can be used to get the values for SenderId and SenderIdArn.
    /// This member is required.
    public var originationIdentity: Swift.String?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.KeywordFilter]? = nil,
        keywords: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        originationIdentity: Swift.String? = nil
    )
    {
        self.filters = filters
        self.keywords = keywords
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.originationIdentity = originationIdentity
    }
}

struct DescribeKeywordsInputBody: Swift.Equatable {
    let originationIdentity: Swift.String?
    let keywords: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.KeywordFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeKeywordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case keywords = "Keywords"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case originationIdentity = "OriginationIdentity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let keywordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keywords)
        var keywordsDecoded0:[Swift.String]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [Swift.String]()
            for string0 in keywordsContainer {
                if let string0 = string0 {
                    keywordsDecoded0?.append(string0)
                }
            }
        }
        keywords = keywordsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.KeywordFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.KeywordFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.KeywordFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeKeywordsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeKeywordsOutputBody = try responseDecoder.decode(responseBody: data)
            self.keywords = output.keywords
            self.nextToken = output.nextToken
            self.originationIdentity = output.originationIdentity
            self.originationIdentityArn = output.originationIdentityArn
        } else {
            self.keywords = nil
            self.nextToken = nil
            self.originationIdentity = nil
            self.originationIdentityArn = nil
        }
    }
}

public struct DescribeKeywordsOutput: Swift.Equatable {
    /// An array of KeywordInformation objects that contain the results.
    public var keywords: [PinpointSMSVoiceV2ClientTypes.KeywordInformation]?
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// The PhoneNumberId or PoolId that is associated with the OriginationIdentity.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or PoolArn that is associated with the OriginationIdentity.
    public var originationIdentityArn: Swift.String?

    public init(
        keywords: [PinpointSMSVoiceV2ClientTypes.KeywordInformation]? = nil,
        nextToken: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil
    )
    {
        self.keywords = keywords
        self.nextToken = nextToken
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
    }
}

struct DescribeKeywordsOutputBody: Swift.Equatable {
    let originationIdentityArn: Swift.String?
    let originationIdentity: Swift.String?
    let keywords: [PinpointSMSVoiceV2ClientTypes.KeywordInformation]?
    let nextToken: Swift.String?
}

extension DescribeKeywordsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keywords = "Keywords"
        case nextToken = "NextToken"
        case originationIdentity = "OriginationIdentity"
        case originationIdentityArn = "OriginationIdentityArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentityArn)
        originationIdentityArn = originationIdentityArnDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let keywordsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.KeywordInformation?].self, forKey: .keywords)
        var keywordsDecoded0:[PinpointSMSVoiceV2ClientTypes.KeywordInformation]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [PinpointSMSVoiceV2ClientTypes.KeywordInformation]()
            for structure0 in keywordsContainer {
                if let structure0 = structure0 {
                    keywordsDecoded0?.append(structure0)
                }
            }
        }
        keywords = keywordsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeKeywordsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOptOutListsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case optOutListNames = "OptOutListNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let optOutListNames = optOutListNames {
            var optOutListNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .optOutListNames)
            for optoutlistnameorarn0 in optOutListNames {
                try optOutListNamesContainer.encode(optoutlistnameorarn0)
            }
        }
    }
}

extension DescribeOptOutListsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeOptOutListsInput: Swift.Equatable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The OptOutLists to show the details of. This is an array of strings that can be either the OptOutListName or OptOutListArn.
    public var optOutListNames: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        optOutListNames: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.optOutListNames = optOutListNames
    }
}

struct DescribeOptOutListsInputBody: Swift.Equatable {
    let optOutListNames: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeOptOutListsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case optOutListNames = "OptOutListNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .optOutListNames)
        var optOutListNamesDecoded0:[Swift.String]? = nil
        if let optOutListNamesContainer = optOutListNamesContainer {
            optOutListNamesDecoded0 = [Swift.String]()
            for string0 in optOutListNamesContainer {
                if let string0 = string0 {
                    optOutListNamesDecoded0?.append(string0)
                }
            }
        }
        optOutListNames = optOutListNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeOptOutListsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOptOutListsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.optOutLists = output.optOutLists
        } else {
            self.nextToken = nil
            self.optOutLists = nil
        }
    }
}

public struct DescribeOptOutListsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of OptOutListInformation objects that contain the details for the requested OptOutLists.
    public var optOutLists: [PinpointSMSVoiceV2ClientTypes.OptOutListInformation]?

    public init(
        nextToken: Swift.String? = nil,
        optOutLists: [PinpointSMSVoiceV2ClientTypes.OptOutListInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.optOutLists = optOutLists
    }
}

struct DescribeOptOutListsOutputBody: Swift.Equatable {
    let optOutLists: [PinpointSMSVoiceV2ClientTypes.OptOutListInformation]?
    let nextToken: Swift.String?
}

extension DescribeOptOutListsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case optOutLists = "OptOutLists"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.OptOutListInformation?].self, forKey: .optOutLists)
        var optOutListsDecoded0:[PinpointSMSVoiceV2ClientTypes.OptOutListInformation]? = nil
        if let optOutListsContainer = optOutListsContainer {
            optOutListsDecoded0 = [PinpointSMSVoiceV2ClientTypes.OptOutListInformation]()
            for structure0 in optOutListsContainer {
                if let structure0 = structure0 {
                    optOutListsDecoded0?.append(structure0)
                }
            }
        }
        optOutLists = optOutListsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeOptOutListsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOptedOutNumbersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case optOutListName = "OptOutListName"
        case optedOutNumbers = "OptedOutNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for optedoutfilter0 in filters {
                try filtersContainer.encode(optedoutfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let optedOutNumbers = optedOutNumbers {
            var optedOutNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .optedOutNumbers)
            for phonenumber0 in optedOutNumbers {
                try optedOutNumbersContainer.encode(phonenumber0)
            }
        }
    }
}

extension DescribeOptedOutNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeOptedOutNumbersInput: Swift.Equatable {
    /// An array of OptedOutFilter objects to filter the results on.
    public var filters: [PinpointSMSVoiceV2ClientTypes.OptedOutFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The OptOutListName or OptOutListArn of the OptOutList. You can use [DescribeOptOutLists] to find the values for OptOutListName and OptOutListArn.
    /// This member is required.
    public var optOutListName: Swift.String?
    /// An array of phone numbers to search for in the OptOutList.
    public var optedOutNumbers: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.OptedOutFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        optedOutNumbers: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.optOutListName = optOutListName
        self.optedOutNumbers = optedOutNumbers
    }
}

struct DescribeOptedOutNumbersInputBody: Swift.Equatable {
    let optOutListName: Swift.String?
    let optedOutNumbers: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.OptedOutFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeOptedOutNumbersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case optOutListName = "OptOutListName"
        case optedOutNumbers = "OptedOutNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let optedOutNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .optedOutNumbers)
        var optedOutNumbersDecoded0:[Swift.String]? = nil
        if let optedOutNumbersContainer = optedOutNumbersContainer {
            optedOutNumbersDecoded0 = [Swift.String]()
            for string0 in optedOutNumbersContainer {
                if let string0 = string0 {
                    optedOutNumbersDecoded0?.append(string0)
                }
            }
        }
        optedOutNumbers = optedOutNumbersDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.OptedOutFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.OptedOutFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.OptedOutFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeOptedOutNumbersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOptedOutNumbersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.optOutListArn = output.optOutListArn
            self.optOutListName = output.optOutListName
            self.optedOutNumbers = output.optedOutNumbers
        } else {
            self.nextToken = nil
            self.optOutListArn = nil
            self.optOutListName = nil
            self.optedOutNumbers = nil
        }
    }
}

public struct DescribeOptedOutNumbersOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the OptOutList.
    public var optOutListArn: Swift.String?
    /// The name of the OptOutList.
    public var optOutListName: Swift.String?
    /// An array of OptedOutNumbersInformation objects that provide information about the requested OptedOutNumbers.
    public var optedOutNumbers: [PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]?

    public init(
        nextToken: Swift.String? = nil,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        optedOutNumbers: [PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
        self.optedOutNumbers = optedOutNumbers
    }
}

struct DescribeOptedOutNumbersOutputBody: Swift.Equatable {
    let optOutListArn: Swift.String?
    let optOutListName: Swift.String?
    let optedOutNumbers: [PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]?
    let nextToken: Swift.String?
}

extension DescribeOptedOutNumbersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case optOutListArn = "OptOutListArn"
        case optOutListName = "OptOutListName"
        case optedOutNumbers = "OptedOutNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListArn)
        optOutListArn = optOutListArnDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let optedOutNumbersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation?].self, forKey: .optedOutNumbers)
        var optedOutNumbersDecoded0:[PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]? = nil
        if let optedOutNumbersContainer = optedOutNumbersContainer {
            optedOutNumbersDecoded0 = [PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]()
            for structure0 in optedOutNumbersContainer {
                if let structure0 = structure0 {
                    optedOutNumbersDecoded0?.append(structure0)
                }
            }
        }
        optedOutNumbers = optedOutNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeOptedOutNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePhoneNumbersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case phoneNumberIds = "PhoneNumberIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for phonenumberfilter0 in filters {
                try filtersContainer.encode(phonenumberfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let phoneNumberIds = phoneNumberIds {
            var phoneNumberIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberIds)
            for phonenumberidorarn0 in phoneNumberIds {
                try phoneNumberIdsContainer.encode(phonenumberidorarn0)
            }
        }
    }
}

extension DescribePhoneNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePhoneNumbersInput: Swift.Equatable {
    /// An array of PhoneNumberFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier of phone numbers to find information about. This is an array of strings that can be either the PhoneNumberId or PhoneNumberArn.
    public var phoneNumberIds: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberIds = phoneNumberIds
    }
}

struct DescribePhoneNumbersInputBody: Swift.Equatable {
    let phoneNumberIds: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribePhoneNumbersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case phoneNumberIds = "PhoneNumberIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberIds)
        var phoneNumberIdsDecoded0:[Swift.String]? = nil
        if let phoneNumberIdsContainer = phoneNumberIdsContainer {
            phoneNumberIdsDecoded0 = [Swift.String]()
            for string0 in phoneNumberIdsContainer {
                if let string0 = string0 {
                    phoneNumberIdsDecoded0?.append(string0)
                }
            }
        }
        phoneNumberIds = phoneNumberIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribePhoneNumbersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePhoneNumbersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct DescribePhoneNumbersOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of PhoneNumberInformation objects that contain the details for the requested phone numbers.
    public var phoneNumbers: [PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct DescribePhoneNumbersOutputBody: Swift.Equatable {
    let phoneNumbers: [PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]?
    let nextToken: Swift.String?
}

extension DescribePhoneNumbersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumbersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribePhoneNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePoolsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolIds = "PoolIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for poolfilter0 in filters {
                try filtersContainer.encode(poolfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let poolIds = poolIds {
            var poolIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .poolIds)
            for poolidorarn0 in poolIds {
                try poolIdsContainer.encode(poolidorarn0)
            }
        }
    }
}

extension DescribePoolsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePoolsInput: Swift.Equatable {
    /// An array of PoolFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.PoolFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier of pools to find. This is an array of strings that can be either the PoolId or PoolArn.
    public var poolIds: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.PoolFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        poolIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolIds = poolIds
    }
}

struct DescribePoolsInputBody: Swift.Equatable {
    let poolIds: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.PoolFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribePoolsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolIds = "PoolIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .poolIds)
        var poolIdsDecoded0:[Swift.String]? = nil
        if let poolIdsContainer = poolIdsContainer {
            poolIdsDecoded0 = [Swift.String]()
            for string0 in poolIdsContainer {
                if let string0 = string0 {
                    poolIdsDecoded0?.append(string0)
                }
            }
        }
        poolIds = poolIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.PoolFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.PoolFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.PoolFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribePoolsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePoolsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pools = output.pools
        } else {
            self.nextToken = nil
            self.pools = nil
        }
    }
}

public struct DescribePoolsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of PoolInformation objects that contain the details for the requested pools.
    public var pools: [PinpointSMSVoiceV2ClientTypes.PoolInformation]?

    public init(
        nextToken: Swift.String? = nil,
        pools: [PinpointSMSVoiceV2ClientTypes.PoolInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.pools = pools
    }
}

struct DescribePoolsOutputBody: Swift.Equatable {
    let pools: [PinpointSMSVoiceV2ClientTypes.PoolInformation]?
    let nextToken: Swift.String?
}

extension DescribePoolsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pools = "Pools"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.PoolInformation?].self, forKey: .pools)
        var poolsDecoded0:[PinpointSMSVoiceV2ClientTypes.PoolInformation]? = nil
        if let poolsContainer = poolsContainer {
            poolsDecoded0 = [PinpointSMSVoiceV2ClientTypes.PoolInformation]()
            for structure0 in poolsContainer {
                if let structure0 = structure0 {
                    poolsDecoded0?.append(structure0)
                }
            }
        }
        pools = poolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribePoolsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSenderIdsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case senderIds = "SenderIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for senderidfilter0 in filters {
                try filtersContainer.encode(senderidfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let senderIds = senderIds {
            var senderIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .senderIds)
            for senderidandcountry0 in senderIds {
                try senderIdsContainer.encode(senderidandcountry0)
            }
        }
    }
}

extension DescribeSenderIdsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSenderIdsInput: Swift.Equatable {
    /// An array of SenderIdFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.SenderIdFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of SenderIdAndCountry objects to search for.
    public var senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.SenderIdFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.senderIds = senderIds
    }
}

struct DescribeSenderIdsInputBody: Swift.Equatable {
    let senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry]?
    let filters: [PinpointSMSVoiceV2ClientTypes.SenderIdFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeSenderIdsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case senderIds = "SenderIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry?].self, forKey: .senderIds)
        var senderIdsDecoded0:[PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry]? = nil
        if let senderIdsContainer = senderIdsContainer {
            senderIdsDecoded0 = [PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry]()
            for structure0 in senderIdsContainer {
                if let structure0 = structure0 {
                    senderIdsDecoded0?.append(structure0)
                }
            }
        }
        senderIds = senderIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.SenderIdFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.SenderIdFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.SenderIdFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeSenderIdsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSenderIdsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.senderIds = output.senderIds
        } else {
            self.nextToken = nil
            self.senderIds = nil
        }
    }
}

public struct DescribeSenderIdsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of SernderIdInformation objects that contain the details for the requested SenderIds.
    public var senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdInformation]?

    public init(
        nextToken: Swift.String? = nil,
        senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.senderIds = senderIds
    }
}

struct DescribeSenderIdsOutputBody: Swift.Equatable {
    let senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdInformation]?
    let nextToken: Swift.String?
}

extension DescribeSenderIdsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case senderIds = "SenderIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.SenderIdInformation?].self, forKey: .senderIds)
        var senderIdsDecoded0:[PinpointSMSVoiceV2ClientTypes.SenderIdInformation]? = nil
        if let senderIdsContainer = senderIdsContainer {
            senderIdsDecoded0 = [PinpointSMSVoiceV2ClientTypes.SenderIdInformation]()
            for structure0 in senderIdsContainer {
                if let structure0 = structure0 {
                    senderIdsDecoded0?.append(structure0)
                }
            }
        }
        senderIds = senderIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSenderIdsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSpendLimitsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeSpendLimitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSpendLimitsInput: Swift.Equatable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeSpendLimitsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeSpendLimitsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeSpendLimitsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSpendLimitsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.spendLimits = output.spendLimits
        } else {
            self.nextToken = nil
            self.spendLimits = nil
        }
    }
}

public struct DescribeSpendLimitsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of SpendLimit objects that contain the details for the requested spend limits.
    public var spendLimits: [PinpointSMSVoiceV2ClientTypes.SpendLimit]?

    public init(
        nextToken: Swift.String? = nil,
        spendLimits: [PinpointSMSVoiceV2ClientTypes.SpendLimit]? = nil
    )
    {
        self.nextToken = nextToken
        self.spendLimits = spendLimits
    }
}

struct DescribeSpendLimitsOutputBody: Swift.Equatable {
    let spendLimits: [PinpointSMSVoiceV2ClientTypes.SpendLimit]?
    let nextToken: Swift.String?
}

extension DescribeSpendLimitsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case spendLimits = "SpendLimits"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spendLimitsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.SpendLimit?].self, forKey: .spendLimits)
        var spendLimitsDecoded0:[PinpointSMSVoiceV2ClientTypes.SpendLimit]? = nil
        if let spendLimitsContainer = spendLimitsContainer {
            spendLimitsDecoded0 = [PinpointSMSVoiceV2ClientTypes.SpendLimit]()
            for structure0 in spendLimitsContainer {
                if let structure0 = structure0 {
                    spendLimitsDecoded0?.append(structure0)
                }
            }
        }
        spendLimits = spendLimitsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSpendLimitsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum DestinationCountryParameterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inEntityId
        case inTemplateId
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationCountryParameterKey] {
            return [
                .inEntityId,
                .inTemplateId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inEntityId: return "IN_ENTITY_ID"
            case .inTemplateId: return "IN_TEMPLATE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationCountryParameterKey(rawValue: rawValue) ?? DestinationCountryParameterKey.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateOriginationIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case isoCountryCode = "IsoCountryCode"
        case originationIdentity = "OriginationIdentity"
        case poolId = "PoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
    }
}

extension DisassociateOriginationIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateOriginationIdentityInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use [DescribePhoneNumbers] find the values for PhoneNumberId and PhoneNumberArn, or use [DescribeSenderIds] to get the values for SenderId and SenderIdArn.
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// The unique identifier for the pool to disassociate with the origination identity. This value can be either the PoolId or PoolArn.
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        isoCountryCode: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.isoCountryCode = isoCountryCode
        self.originationIdentity = originationIdentity
        self.poolId = poolId
    }
}

struct DisassociateOriginationIdentityInputBody: Swift.Equatable {
    let poolId: Swift.String?
    let originationIdentity: Swift.String?
    let isoCountryCode: Swift.String?
    let clientToken: Swift.String?
}

extension DisassociateOriginationIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case isoCountryCode = "IsoCountryCode"
        case originationIdentity = "OriginationIdentity"
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateOriginationIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateOriginationIdentityOutputBody = try responseDecoder.decode(responseBody: data)
            self.isoCountryCode = output.isoCountryCode
            self.originationIdentity = output.originationIdentity
            self.originationIdentityArn = output.originationIdentityArn
            self.poolArn = output.poolArn
            self.poolId = output.poolId
        } else {
            self.isoCountryCode = nil
            self.originationIdentity = nil
            self.originationIdentityArn = nil
            self.poolArn = nil
            self.poolId = nil
        }
    }
}

public struct DisassociateOriginationIdentityOutput: Swift.Equatable {
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The PhoneNumberId or SenderId of the origination identity.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or SenderIdArn of the origination identity.
    public var originationIdentityArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the pool.
    public var poolArn: Swift.String?
    /// The PoolId of the pool no longer associated with the origination identity.
    public var poolId: Swift.String?

    public init(
        isoCountryCode: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
        self.poolArn = poolArn
        self.poolId = poolId
    }
}

struct DisassociateOriginationIdentityOutputBody: Swift.Equatable {
    let poolArn: Swift.String?
    let poolId: Swift.String?
    let originationIdentityArn: Swift.String?
    let originationIdentity: Swift.String?
    let isoCountryCode: Swift.String?
}

extension DisassociateOriginationIdentityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case originationIdentity = "OriginationIdentity"
        case originationIdentityArn = "OriginationIdentityArn"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let originationIdentityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentityArn)
        originationIdentityArn = originationIdentityArnDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
    }
}

enum DisassociateOriginationIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.EventDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case enabled = "Enabled"
        case eventDestinationName = "EventDestinationName"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsDestination = self.cloudWatchLogsDestination {
            try encodeContainer.encode(cloudWatchLogsDestination, forKey: .cloudWatchLogsDestination)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventDestinationName = self.eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
        if let kinesisFirehoseDestination = self.kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtype0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtype0.rawValue)
            }
        }
        if let snsDestination = self.snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[PinpointSMSVoiceV2ClientTypes.EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [PinpointSMSVoiceV2ClientTypes.EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let cloudWatchLogsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination.self, forKey: .cloudWatchLogsDestination)
        cloudWatchLogsDestination = cloudWatchLogsDestinationDecoded
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Contains information about an event destination. Event destinations are associated with configuration sets, which enable you to publish message sending events to Amazon CloudWatch, Amazon Kinesis Data Firehose, or Amazon SNS.
    public struct EventDestination: Swift.Equatable {
        /// An object that contains information about an event destination that sends logging events to Amazon CloudWatch logs.
        public var cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
        /// When set to true events will be logged.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The name of the EventDestination.
        /// This member is required.
        public var eventDestinationName: Swift.String?
        /// An object that contains information about an event destination for logging to Amazon Kinesis Data Firehose.
        public var kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
        /// An array of event types that determine which events to log.
        /// This member is required.
        public var matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
        /// An object that contains information about an event destination that sends logging events to Amazon SNS.
        public var snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?

        public init(
            cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination? = nil,
            enabled: Swift.Bool? = nil,
            eventDestinationName: Swift.String? = nil,
            kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination? = nil,
            matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]? = nil,
            snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination? = nil
        )
        {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.enabled = enabled
            self.eventDestinationName = eventDestinationName
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case textAll
        case textBlocked
        case textCarrierBlocked
        case textCarrierUnreachable
        case textDelivered
        case textInvalid
        case textInvalidMessage
        case textPending
        case textQueued
        case textSent
        case textSpam
        case textSuccessful
        case textTtlExpired
        case textUnknown
        case textUnreachable
        case voiceAll
        case voiceAnswered
        case voiceBusy
        case voiceCompleted
        case voiceFailed
        case voiceInitiated
        case voiceNoAnswer
        case voiceRinging
        case voiceTtlExpired
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .all,
                .textAll,
                .textBlocked,
                .textCarrierBlocked,
                .textCarrierUnreachable,
                .textDelivered,
                .textInvalid,
                .textInvalidMessage,
                .textPending,
                .textQueued,
                .textSent,
                .textSpam,
                .textSuccessful,
                .textTtlExpired,
                .textUnknown,
                .textUnreachable,
                .voiceAll,
                .voiceAnswered,
                .voiceBusy,
                .voiceCompleted,
                .voiceFailed,
                .voiceInitiated,
                .voiceNoAnswer,
                .voiceRinging,
                .voiceTtlExpired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .textAll: return "TEXT_ALL"
            case .textBlocked: return "TEXT_BLOCKED"
            case .textCarrierBlocked: return "TEXT_CARRIER_BLOCKED"
            case .textCarrierUnreachable: return "TEXT_CARRIER_UNREACHABLE"
            case .textDelivered: return "TEXT_DELIVERED"
            case .textInvalid: return "TEXT_INVALID"
            case .textInvalidMessage: return "TEXT_INVALID_MESSAGE"
            case .textPending: return "TEXT_PENDING"
            case .textQueued: return "TEXT_QUEUED"
            case .textSent: return "TEXT_SENT"
            case .textSpam: return "TEXT_SPAM"
            case .textSuccessful: return "TEXT_SUCCESSFUL"
            case .textTtlExpired: return "TEXT_TTL_EXPIRED"
            case .textUnknown: return "TEXT_UNKNOWN"
            case .textUnreachable: return "TEXT_UNREACHABLE"
            case .voiceAll: return "VOICE_ALL"
            case .voiceAnswered: return "VOICE_ANSWERED"
            case .voiceBusy: return "VOICE_BUSY"
            case .voiceCompleted: return "VOICE_COMPLETED"
            case .voiceFailed: return "VOICE_FAILED"
            case .voiceInitiated: return "VOICE_INITIATED"
            case .voiceNoAnswer: return "VOICE_NO_ANSWER"
            case .voiceRinging: return "VOICE_RINGING"
            case .voiceTtlExpired: return "VOICE_TTL_EXPIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The API encountered an unexpected error and couldn't complete the request. You might be able to successfully issue the request again in the future.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum KeywordAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automaticResponse
        case optIn
        case optOut
        case sdkUnknown(Swift.String)

        public static var allCases: [KeywordAction] {
            return [
                .automaticResponse,
                .optIn,
                .optOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automaticResponse: return "AUTOMATIC_RESPONSE"
            case .optIn: return "OPT_IN"
            case .optOut: return "OPT_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KeywordAction(rawValue: rawValue) ?? KeywordAction.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.KeywordFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KeywordFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for keywords that meet a specified criteria.
    public struct KeywordFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.KeywordFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.KeywordFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum KeywordFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case keywordAction
        case sdkUnknown(Swift.String)

        public static var allCases: [KeywordFilterName] {
            return [
                .keywordAction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .keywordAction: return "keyword-action"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KeywordFilterName(rawValue: rawValue) ?? KeywordFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.KeywordInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case keywordAction = "KeywordAction"
        case keywordMessage = "KeywordMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyword = self.keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let keywordAction = self.keywordAction {
            try encodeContainer.encode(keywordAction.rawValue, forKey: .keywordAction)
        }
        if let keywordMessage = self.keywordMessage {
            try encodeContainer.encode(keywordMessage, forKey: .keywordMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
        let keywordMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywordMessage)
        keywordMessage = keywordMessageDecoded
        let keywordActionDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KeywordAction.self, forKey: .keywordAction)
        keywordAction = keywordActionDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for all keywords in a pool.
    public struct KeywordInformation: Swift.Equatable {
        /// The keyword as a string.
        /// This member is required.
        public var keyword: Swift.String?
        /// The action to perform for the keyword.
        /// This member is required.
        public var keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
        /// A custom message that can be used with the keyword.
        /// This member is required.
        public var keywordMessage: Swift.String?

        public init(
            keyword: Swift.String? = nil,
            keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction? = nil,
            keywordMessage: Swift.String? = nil
        )
        {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStreamArn = "DeliveryStreamArn"
        case iamRoleArn = "IamRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamArn = self.deliveryStreamArn {
            try encodeContainer.encode(deliveryStreamArn, forKey: .deliveryStreamArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let deliveryStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStreamArn)
        deliveryStreamArn = deliveryStreamArnDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Contains the delivery stream Amazon Resource Name (ARN), and the ARN of the Identity and Access Management (IAM) role associated with an Kinesis Data Firehose event destination. Event destinations, such as Kinesis Data Firehose, are associated with configuration sets, which enable you to publish message sending events.
    public struct KinesisFirehoseDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        /// This member is required.
        public var deliveryStreamArn: Swift.String?
        /// The ARN of an Amazon Identity and Access Management (IAM) role that is able to write event data to an Amazon Firehose destination.
        /// This member is required.
        public var iamRoleArn: Swift.String?

        public init(
            deliveryStreamArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil
        )
        {
            self.deliveryStreamArn = deliveryStreamArn
            self.iamRoleArn = iamRoleArn
        }
    }

}

extension ListPoolOriginationIdentitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolId = "PoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for pooloriginationidentitiesfilter0 in filters {
                try filtersContainer.encode(pooloriginationidentitiesfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
    }
}

extension ListPoolOriginationIdentitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPoolOriginationIdentitiesInput: Swift.Equatable {
    /// An array of PoolOriginationIdentitiesFilter objects to filter the results..
    public var filters: [PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier for the pool. This value can be either the PoolId or PoolArn.
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolId = poolId
    }
}

struct ListPoolOriginationIdentitiesInputBody: Swift.Equatable {
    let poolId: Swift.String?
    let filters: [PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPoolOriginationIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPoolOriginationIdentitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPoolOriginationIdentitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.originationIdentities = output.originationIdentities
            self.poolArn = output.poolArn
            self.poolId = output.poolId
        } else {
            self.nextToken = nil
            self.originationIdentities = nil
            self.poolArn = nil
            self.poolId = nil
        }
    }
}

public struct ListPoolOriginationIdentitiesOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of any OriginationIdentityMetadata objects.
    public var originationIdentities: [PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]?
    /// The Amazon Resource Name (ARN) for the pool.
    public var poolArn: Swift.String?
    /// The unique PoolId of the pool.
    public var poolId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        originationIdentities: [PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.originationIdentities = originationIdentities
        self.poolArn = poolArn
        self.poolId = poolId
    }
}

struct ListPoolOriginationIdentitiesOutputBody: Swift.Equatable {
    let poolArn: Swift.String?
    let poolId: Swift.String?
    let originationIdentities: [PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]?
    let nextToken: Swift.String?
}

extension ListPoolOriginationIdentitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case originationIdentities = "OriginationIdentities"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let originationIdentitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata?].self, forKey: .originationIdentities)
        var originationIdentitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]? = nil
        if let originationIdentitiesContainer = originationIdentitiesContainer {
            originationIdentitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]()
            for structure0 in originationIdentitiesContainer {
                if let structure0 = structure0 {
                    originationIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        originationIdentities = originationIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPoolOriginationIdentitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to query for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.tags = output.tags
        } else {
            self.resourceArn = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The ARN of the resource.
    public var resourceArn: Swift.String?
    /// An array of key and value pair tags that are associated with the resource.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum MessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case promotional
        case transactional
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .promotional,
                .transactional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .promotional: return "PROMOTIONAL"
            case .transactional: return "TRANSACTIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum NumberCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberCapability] {
            return [
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberCapability(rawValue: rawValue) ?? NumberCapability.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum NumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case associating
        case deleted
        case disassociating
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberStatus] {
            return [
                .active,
                .associating,
                .deleted,
                .disassociating,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .associating: return "ASSOCIATING"
            case .deleted: return "DELETED"
            case .disassociating: return "DISASSOCIATING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberStatus(rawValue: rawValue) ?? NumberStatus.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum NumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case longCode
        case shortCode
        case tenDlc
        case tollFree
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberType] {
            return [
                .longCode,
                .shortCode,
                .tenDlc,
                .tollFree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .longCode: return "LONG_CODE"
            case .shortCode: return "SHORT_CODE"
            case .tenDlc: return "TEN_DLC"
            case .tollFree: return "TOLL_FREE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberType(rawValue: rawValue) ?? NumberType.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.OptOutListInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case optOutListArn = "OptOutListArn"
        case optOutListName = "OptOutListName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let optOutListArn = self.optOutListArn {
            try encodeContainer.encode(optOutListArn, forKey: .optOutListArn)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListArn)
        optOutListArn = optOutListArnDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for all OptOutList in an Amazon Web Services account.
    public struct OptOutListInformation: Swift.Equatable {
        /// The time when the OutOutList was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the OptOutList.
        /// This member is required.
        public var optOutListArn: Swift.String?
        /// The name of the OptOutList.
        /// This member is required.
        public var optOutListName: Swift.String?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            optOutListArn: Swift.String? = nil,
            optOutListName: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.OptedOutFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.OptedOutFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for opted out numbers that meet a specified criteria.
    public struct OptedOutFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.OptedOutFilterName?
        /// An array of values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.OptedOutFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum OptedOutFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case endUserOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [OptedOutFilterName] {
            return [
                .endUserOptedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .endUserOptedOut: return "end-user-opted-out"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptedOutFilterName(rawValue: rawValue) ?? OptedOutFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endUserOptedOut = "EndUserOptedOut"
        case optedOutNumber = "OptedOutNumber"
        case optedOutTimestamp = "OptedOutTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if endUserOptedOut != false {
            try encodeContainer.encode(endUserOptedOut, forKey: .endUserOptedOut)
        }
        if let optedOutNumber = self.optedOutNumber {
            try encodeContainer.encode(optedOutNumber, forKey: .optedOutNumber)
        }
        if let optedOutTimestamp = self.optedOutTimestamp {
            try encodeContainer.encodeTimestamp(optedOutTimestamp, format: .epochSeconds, forKey: .optedOutTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optedOutNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optedOutNumber)
        optedOutNumber = optedOutNumberDecoded
        let optedOutTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .optedOutTimestamp)
        optedOutTimestamp = optedOutTimestampDecoded
        let endUserOptedOutDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .endUserOptedOut) ?? false
        endUserOptedOut = endUserOptedOutDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for an opted out number in an Amazon Web Services account.
    public struct OptedOutNumberInformation: Swift.Equatable {
        /// This is set to true if it was the end recipient that opted out.
        /// This member is required.
        public var endUserOptedOut: Swift.Bool
        /// The phone number that is opted out.
        /// This member is required.
        public var optedOutNumber: Swift.String?
        /// The time that the op tout occurred, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var optedOutTimestamp: ClientRuntime.Date?

        public init(
            endUserOptedOut: Swift.Bool = false,
            optedOutNumber: Swift.String? = nil,
            optedOutTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.endUserOptedOut = endUserOptedOut
            self.optedOutNumber = optedOutNumber
            self.optedOutTimestamp = optedOutTimestamp
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case numberCapabilities = "NumberCapabilities"
        case originationIdentity = "OriginationIdentity"
        case originationIdentityArn = "OriginationIdentityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let numberCapabilities = numberCapabilities {
            var numberCapabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .numberCapabilities)
            for numbercapability0 in numberCapabilities {
                try numberCapabilitiesContainer.encode(numbercapability0.rawValue)
            }
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let originationIdentityArn = self.originationIdentityArn {
            try encodeContainer.encode(originationIdentityArn, forKey: .originationIdentityArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentityArn)
        originationIdentityArn = originationIdentityArnDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let numberCapabilitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.NumberCapability?].self, forKey: .numberCapabilities)
        var numberCapabilitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil
        if let numberCapabilitiesContainer = numberCapabilitiesContainer {
            numberCapabilitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.NumberCapability]()
            for string0 in numberCapabilitiesContainer {
                if let string0 = string0 {
                    numberCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        numberCapabilities = numberCapabilitiesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The metadata for an origination identity associated with a pool.
    public struct OriginationIdentityMetadata: Swift.Equatable {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        /// This member is required.
        public var isoCountryCode: Swift.String?
        /// Describes if the origination identity can be used for text messages, voice calls or both.
        /// This member is required.
        public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
        /// The unique identifier of the origination identity.
        /// This member is required.
        public var originationIdentity: Swift.String?
        /// The Amazon Resource Name (ARN) associated with the origination identity.
        /// This member is required.
        public var originationIdentityArn: Swift.String?

        public init(
            isoCountryCode: Swift.String? = nil,
            numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
            originationIdentity: Swift.String? = nil,
            originationIdentityArn: Swift.String? = nil
        )
        {
            self.isoCountryCode = isoCountryCode
            self.numberCapabilities = numberCapabilities
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PhoneNumberFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for a phone number that meets a specified criteria.
    public struct PhoneNumberFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.PhoneNumberFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.PhoneNumberFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum PhoneNumberFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deletionProtectionEnabled
        case isoCountryCode
        case messageType
        case numberCapability
        case numberType
        case optOutListName
        case selfManagedOptOutsEnabled
        case status
        case twoWayEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberFilterName] {
            return [
                .deletionProtectionEnabled,
                .isoCountryCode,
                .messageType,
                .numberCapability,
                .numberType,
                .optOutListName,
                .selfManagedOptOutsEnabled,
                .status,
                .twoWayEnabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deletionProtectionEnabled: return "deletion-protection-enabled"
            case .isoCountryCode: return "iso-country-code"
            case .messageType: return "message-type"
            case .numberCapability: return "number-capability"
            case .numberType: return "number-type"
            case .optOutListName: return "opt-out-list-name"
            case .selfManagedOptOutsEnabled: return "self-managed-opt-outs-enabled"
            case .status: return "status"
            case .twoWayEnabled: return "two-way-enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberFilterName(rawValue: rawValue) ?? PhoneNumberFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case numberCapabilities = "NumberCapabilities"
        case numberType = "NumberType"
        case optOutListName = "OptOutListName"
        case phoneNumber = "PhoneNumber"
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberId = "PhoneNumberId"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case status = "Status"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if deletionProtectionEnabled != false {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let monthlyLeasingPrice = self.monthlyLeasingPrice {
            try encodeContainer.encode(monthlyLeasingPrice, forKey: .monthlyLeasingPrice)
        }
        if let numberCapabilities = numberCapabilities {
            var numberCapabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .numberCapabilities)
            for numbercapability0 in numberCapabilities {
                try numberCapabilitiesContainer.encode(numbercapability0.rawValue)
            }
        }
        if let numberType = self.numberType {
            try encodeContainer.encode(numberType.rawValue, forKey: .numberType)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumberArn = self.phoneNumberArn {
            try encodeContainer.encode(phoneNumberArn, forKey: .phoneNumberArn)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if selfManagedOptOutsEnabled != false {
            try encodeContainer.encode(selfManagedOptOutsEnabled, forKey: .selfManagedOptOutsEnabled)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let twoWayChannelArn = self.twoWayChannelArn {
            try encodeContainer.encode(twoWayChannelArn, forKey: .twoWayChannelArn)
        }
        if twoWayEnabled != false {
            try encodeContainer.encode(twoWayEnabled, forKey: .twoWayEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberStatus.self, forKey: .status)
        status = statusDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let numberCapabilitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.NumberCapability?].self, forKey: .numberCapabilities)
        var numberCapabilitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil
        if let numberCapabilitiesContainer = numberCapabilitiesContainer {
            numberCapabilitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.NumberCapability]()
            for string0 in numberCapabilitiesContainer {
                if let string0 = string0 {
                    numberCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        numberCapabilities = numberCapabilitiesDecoded0
        let numberTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberType.self, forKey: .numberType)
        numberType = numberTypeDecoded
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for a phone number in an Amazon Web Services account.
    public struct PhoneNumberInformation: Swift.Equatable {
        /// The time when the phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: ClientRuntime.Date?
        /// When set to true the phone number can't be deleted.
        /// This member is required.
        public var deletionProtectionEnabled: Swift.Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        /// This member is required.
        public var isoCountryCode: Swift.String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        /// This member is required.
        public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
        /// The price, in US dollars, to lease the phone number.
        /// This member is required.
        public var monthlyLeasingPrice: Swift.String?
        /// Describes if the origination identity can be used for text messages, voice calls or both.
        /// This member is required.
        public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
        /// The type of phone number.
        /// This member is required.
        public var numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
        /// The name of the OptOutList associated with the phone number.
        /// This member is required.
        public var optOutListName: Swift.String?
        /// The phone number in E.164 format.
        /// This member is required.
        public var phoneNumber: Swift.String?
        /// The Amazon Resource Name (ARN) associated with the phone number.
        /// This member is required.
        public var phoneNumberArn: Swift.String?
        /// The unique identifier for the phone number.
        public var phoneNumberId: Swift.String?
        /// The unique identifier of the pool associated with the phone number.
        public var poolId: Swift.String?
        /// When set to false an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out request. For more information see [Self-managed opt-outs](https://docs.aws.amazon.com/pinpoint/latest/userguide/settings-sms-managing.html#settings-account-sms-self-managed-opt-out)
        /// This member is required.
        public var selfManagedOptOutsEnabled: Swift.Bool
        /// The current status of the phone number.
        /// This member is required.
        public var status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public var twoWayChannelArn: Swift.String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients using the TwoWayChannelArn.
        /// This member is required.
        public var twoWayEnabled: Swift.Bool

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            deletionProtectionEnabled: Swift.Bool = false,
            isoCountryCode: Swift.String? = nil,
            messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
            monthlyLeasingPrice: Swift.String? = nil,
            numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
            numberType: PinpointSMSVoiceV2ClientTypes.NumberType? = nil,
            optOutListName: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumberArn: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            poolId: Swift.String? = nil,
            selfManagedOptOutsEnabled: Swift.Bool = false,
            status: PinpointSMSVoiceV2ClientTypes.NumberStatus? = nil,
            twoWayChannelArn: Swift.String? = nil,
            twoWayEnabled: Swift.Bool = false
        )
        {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayEnabled = twoWayEnabled
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.PoolFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PoolFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for a pool that meets a specified criteria.
    public struct PoolFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.PoolFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.PoolFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum PoolFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deletionProtectionEnabled
        case messageType
        case optOutListName
        case selfManagedOptOutsEnabled
        case sharedRoutesEnabled
        case status
        case twoWayEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PoolFilterName] {
            return [
                .deletionProtectionEnabled,
                .messageType,
                .optOutListName,
                .selfManagedOptOutsEnabled,
                .sharedRoutesEnabled,
                .status,
                .twoWayEnabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deletionProtectionEnabled: return "deletion-protection-enabled"
            case .messageType: return "message-type"
            case .optOutListName: return "opt-out-list-name"
            case .selfManagedOptOutsEnabled: return "self-managed-opt-outs-enabled"
            case .sharedRoutesEnabled: return "shared-routes-enabled"
            case .status: return "status"
            case .twoWayEnabled: return "two-way-enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PoolFilterName(rawValue: rawValue) ?? PoolFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.PoolInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case messageType = "MessageType"
        case optOutListName = "OptOutListName"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case sharedRoutesEnabled = "SharedRoutesEnabled"
        case status = "Status"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if deletionProtectionEnabled != false {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let poolArn = self.poolArn {
            try encodeContainer.encode(poolArn, forKey: .poolArn)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if selfManagedOptOutsEnabled != false {
            try encodeContainer.encode(selfManagedOptOutsEnabled, forKey: .selfManagedOptOutsEnabled)
        }
        if sharedRoutesEnabled != false {
            try encodeContainer.encode(sharedRoutesEnabled, forKey: .sharedRoutesEnabled)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let twoWayChannelArn = self.twoWayChannelArn {
            try encodeContainer.encode(twoWayChannelArn, forKey: .twoWayChannelArn)
        }
        if twoWayEnabled != false {
            try encodeContainer.encode(twoWayEnabled, forKey: .twoWayEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PoolStatus.self, forKey: .status)
        status = statusDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let sharedRoutesEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharedRoutesEnabled) ?? false
        sharedRoutesEnabled = sharedRoutesEnabledDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for a pool in an Amazon Web Services account.
    public struct PoolInformation: Swift.Equatable {
        /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: ClientRuntime.Date?
        /// When set to true the pool can't be deleted.
        /// This member is required.
        public var deletionProtectionEnabled: Swift.Bool
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        /// This member is required.
        public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
        /// The name of the OptOutList associated with the pool.
        /// This member is required.
        public var optOutListName: Swift.String?
        /// The Amazon Resource Name (ARN) for the pool.
        /// This member is required.
        public var poolArn: Swift.String?
        /// The unique identifier for the pool.
        /// This member is required.
        public var poolId: Swift.String?
        /// When set to false, an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests. For more information see [Self-managed opt-outs](https://docs.aws.amazon.com/pinpoint/latest/userguide/settings-sms-managing.html#settings-account-sms-self-managed-opt-out)
        /// This member is required.
        public var selfManagedOptOutsEnabled: Swift.Bool
        /// Allows you to enable shared routes on your pool. By default, this is set to False. If you set this value to True, your messages are sent using phone numbers or sender IDs (depending on the country) that are shared with other Amazon Pinpoint users. In some countries, such as the United States, senders aren't allowed to use shared routes and must use a dedicated phone number or short code.
        /// This member is required.
        public var sharedRoutesEnabled: Swift.Bool
        /// The current status of the pool.
        /// This member is required.
        public var status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public var twoWayChannelArn: Swift.String?
        /// When set to true you can receive incoming text messages from your end recipients using the TwoWayChannelArn.
        /// This member is required.
        public var twoWayEnabled: Swift.Bool

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            deletionProtectionEnabled: Swift.Bool = false,
            messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
            optOutListName: Swift.String? = nil,
            poolArn: Swift.String? = nil,
            poolId: Swift.String? = nil,
            selfManagedOptOutsEnabled: Swift.Bool = false,
            sharedRoutesEnabled: Swift.Bool = false,
            status: PinpointSMSVoiceV2ClientTypes.PoolStatus? = nil,
            twoWayChannelArn: Swift.String? = nil,
            twoWayEnabled: Swift.Bool = false
        )
        {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayEnabled = twoWayEnabled
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Information about origination identities associated with a pool that meets a specified criteria.
    public struct PoolOriginationIdentitiesFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum PoolOriginationIdentitiesFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case isoCountryCode
        case numberCapability
        case sdkUnknown(Swift.String)

        public static var allCases: [PoolOriginationIdentitiesFilterName] {
            return [
                .isoCountryCode,
                .numberCapability,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .isoCountryCode: return "iso-country-code"
            case .numberCapability: return "number-capability"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PoolOriginationIdentitiesFilterName(rawValue: rawValue) ?? PoolOriginationIdentitiesFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum PoolStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [PoolStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PoolStatus(rawValue: rawValue) ?? PoolStatus.sdkUnknown(rawValue)
        }
    }
}

extension PutKeywordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case keywordAction = "KeywordAction"
        case keywordMessage = "KeywordMessage"
        case originationIdentity = "OriginationIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyword = self.keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let keywordAction = self.keywordAction {
            try encodeContainer.encode(keywordAction.rawValue, forKey: .keywordAction)
        }
        if let keywordMessage = self.keywordMessage {
            try encodeContainer.encode(keywordMessage, forKey: .keywordMessage)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
    }
}

extension PutKeywordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutKeywordInput: Swift.Equatable {
    /// The new keyword to add.
    /// This member is required.
    public var keyword: Swift.String?
    /// The action to perform for the new keyword when it is received.
    public var keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
    /// The message associated with the keyword.
    ///
    /// * AUTOMATIC_RESPONSE: A message is sent to the recipient.
    ///
    /// * OPT_OUT: Keeps the recipient from receiving future messages.
    ///
    /// * OPT_IN: The recipient wants to receive future messages.
    /// This member is required.
    public var keywordMessage: Swift.String?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use [DescribePhoneNumbers] get the values for PhoneNumberId and PhoneNumberArn while [DescribeSenderIds] can be used to get the values for SenderId and SenderIdArn.
    /// This member is required.
    public var originationIdentity: Swift.String?

    public init(
        keyword: Swift.String? = nil,
        keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction? = nil,
        keywordMessage: Swift.String? = nil,
        originationIdentity: Swift.String? = nil
    )
    {
        self.keyword = keyword
        self.keywordAction = keywordAction
        self.keywordMessage = keywordMessage
        self.originationIdentity = originationIdentity
    }
}

struct PutKeywordInputBody: Swift.Equatable {
    let originationIdentity: Swift.String?
    let keyword: Swift.String?
    let keywordMessage: Swift.String?
    let keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
}

extension PutKeywordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case keywordAction = "KeywordAction"
        case keywordMessage = "KeywordMessage"
        case originationIdentity = "OriginationIdentity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
        let keywordMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywordMessage)
        keywordMessage = keywordMessageDecoded
        let keywordActionDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KeywordAction.self, forKey: .keywordAction)
        keywordAction = keywordActionDecoded
    }
}

extension PutKeywordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutKeywordOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyword = output.keyword
            self.keywordAction = output.keywordAction
            self.keywordMessage = output.keywordMessage
            self.originationIdentity = output.originationIdentity
            self.originationIdentityArn = output.originationIdentityArn
        } else {
            self.keyword = nil
            self.keywordAction = nil
            self.keywordMessage = nil
            self.originationIdentity = nil
            self.originationIdentityArn = nil
        }
    }
}

public struct PutKeywordOutput: Swift.Equatable {
    /// The keyword that was added.
    public var keyword: Swift.String?
    /// The action to perform when the keyword is used.
    public var keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
    /// The message associated with the keyword.
    public var keywordMessage: Swift.String?
    /// The PhoneNumberId or PoolId that the keyword was associated with.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or PoolArn that the keyword was associated with.
    public var originationIdentityArn: Swift.String?

    public init(
        keyword: Swift.String? = nil,
        keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction? = nil,
        keywordMessage: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil
    )
    {
        self.keyword = keyword
        self.keywordAction = keywordAction
        self.keywordMessage = keywordMessage
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
    }
}

struct PutKeywordOutputBody: Swift.Equatable {
    let originationIdentityArn: Swift.String?
    let originationIdentity: Swift.String?
    let keyword: Swift.String?
    let keywordMessage: Swift.String?
    let keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
}

extension PutKeywordOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case keywordAction = "KeywordAction"
        case keywordMessage = "KeywordMessage"
        case originationIdentity = "OriginationIdentity"
        case originationIdentityArn = "OriginationIdentityArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentityArn)
        originationIdentityArn = originationIdentityArnDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
        let keywordMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywordMessage)
        keywordMessage = keywordMessageDecoded
        let keywordActionDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KeywordAction.self, forKey: .keywordAction)
        keywordAction = keywordActionDecoded
    }
}

enum PutKeywordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutOptedOutNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optOutListName = "OptOutListName"
        case optedOutNumber = "OptedOutNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let optedOutNumber = self.optedOutNumber {
            try encodeContainer.encode(optedOutNumber, forKey: .optedOutNumber)
        }
    }
}

extension PutOptedOutNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutOptedOutNumberInput: Swift.Equatable {
    /// The OptOutListName or OptOutListArn to add the phone number to.
    /// This member is required.
    public var optOutListName: Swift.String?
    /// The phone number to add to the OptOutList in E.164 format.
    /// This member is required.
    public var optedOutNumber: Swift.String?

    public init(
        optOutListName: Swift.String? = nil,
        optedOutNumber: Swift.String? = nil
    )
    {
        self.optOutListName = optOutListName
        self.optedOutNumber = optedOutNumber
    }
}

struct PutOptedOutNumberInputBody: Swift.Equatable {
    let optOutListName: Swift.String?
    let optedOutNumber: Swift.String?
}

extension PutOptedOutNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optOutListName = "OptOutListName"
        case optedOutNumber = "OptedOutNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let optedOutNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optedOutNumber)
        optedOutNumber = optedOutNumberDecoded
    }
}

extension PutOptedOutNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutOptedOutNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.endUserOptedOut = output.endUserOptedOut
            self.optOutListArn = output.optOutListArn
            self.optOutListName = output.optOutListName
            self.optedOutNumber = output.optedOutNumber
            self.optedOutTimestamp = output.optedOutTimestamp
        } else {
            self.endUserOptedOut = false
            self.optOutListArn = nil
            self.optOutListName = nil
            self.optedOutNumber = nil
            self.optedOutTimestamp = nil
        }
    }
}

public struct PutOptedOutNumberOutput: Swift.Equatable {
    /// This is true if it was the end user who requested their phone number be removed.
    public var endUserOptedOut: Swift.Bool
    /// The OptOutListArn that the phone number was removed from.
    public var optOutListArn: Swift.String?
    /// The OptOutListName that the phone number was removed from.
    public var optOutListName: Swift.String?
    /// The phone number that was added to the OptOutList.
    public var optedOutNumber: Swift.String?
    /// The time that the phone number was added to the OptOutList, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var optedOutTimestamp: ClientRuntime.Date?

    public init(
        endUserOptedOut: Swift.Bool = false,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        optedOutNumber: Swift.String? = nil,
        optedOutTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.endUserOptedOut = endUserOptedOut
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
        self.optedOutNumber = optedOutNumber
        self.optedOutTimestamp = optedOutTimestamp
    }
}

struct PutOptedOutNumberOutputBody: Swift.Equatable {
    let optOutListArn: Swift.String?
    let optOutListName: Swift.String?
    let optedOutNumber: Swift.String?
    let optedOutTimestamp: ClientRuntime.Date?
    let endUserOptedOut: Swift.Bool
}

extension PutOptedOutNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endUserOptedOut = "EndUserOptedOut"
        case optOutListArn = "OptOutListArn"
        case optOutListName = "OptOutListName"
        case optedOutNumber = "OptedOutNumber"
        case optedOutTimestamp = "OptedOutTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListArn)
        optOutListArn = optOutListArnDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let optedOutNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optedOutNumber)
        optedOutNumber = optedOutNumberDecoded
        let optedOutTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .optedOutTimestamp)
        optedOutTimestamp = optedOutTimestampDecoded
        let endUserOptedOutDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .endUserOptedOut) ?? false
        endUserOptedOut = endUserOptedOutDecoded
    }
}

enum PutOptedOutNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ReleasePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberId = "PhoneNumberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
    }
}

extension ReleasePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ReleasePhoneNumberInput: Swift.Equatable {
    /// The PhoneNumberId or PhoneNumberArn of the phone number to release. You can use [DescribePhoneNumbers] to get the values for PhoneNumberId and PhoneNumberArn.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct ReleasePhoneNumberInputBody: Swift.Equatable {
    let phoneNumberId: Swift.String?
}

extension ReleasePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberId = "PhoneNumberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
    }
}

extension ReleasePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReleasePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.isoCountryCode = output.isoCountryCode
            self.messageType = output.messageType
            self.monthlyLeasingPrice = output.monthlyLeasingPrice
            self.numberCapabilities = output.numberCapabilities
            self.numberType = output.numberType
            self.optOutListName = output.optOutListName
            self.phoneNumber = output.phoneNumber
            self.phoneNumberArn = output.phoneNumberArn
            self.phoneNumberId = output.phoneNumberId
            self.selfManagedOptOutsEnabled = output.selfManagedOptOutsEnabled
            self.status = output.status
            self.twoWayChannelArn = output.twoWayChannelArn
            self.twoWayEnabled = output.twoWayEnabled
        } else {
            self.createdTimestamp = nil
            self.isoCountryCode = nil
            self.messageType = nil
            self.monthlyLeasingPrice = nil
            self.numberCapabilities = nil
            self.numberType = nil
            self.optOutListName = nil
            self.phoneNumber = nil
            self.phoneNumberArn = nil
            self.phoneNumberId = nil
            self.selfManagedOptOutsEnabled = false
            self.status = nil
            self.twoWayChannelArn = nil
            self.twoWayEnabled = false
        }
    }
}

public struct ReleasePhoneNumberOutput: Swift.Equatable {
    /// The time when the phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The message type that was associated with the phone number.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The monthly price of the phone number, in US dollars.
    public var monthlyLeasingPrice: Swift.String?
    /// Specifies if the number could be used for text messages, voice, or both.
    public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    /// The type of number that was released.
    public var numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
    /// The name of the OptOutList that was associated with the phone number.
    public var optOutListName: Swift.String?
    /// The phone number that was released.
    public var phoneNumber: Swift.String?
    /// The PhoneNumberArn of the phone number that was released.
    public var phoneNumberArn: Swift.String?
    /// The PhoneNumberId of the phone number that was released.
    public var phoneNumberId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// The current status of the request.
    public var status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    /// The Amazon Resource Name (ARN) of the TwoWayChannel.
    public var twoWayChannelArn: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
        numberType: PinpointSMSVoiceV2ClientTypes.NumberType? = nil,
        optOutListName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.NumberStatus? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.numberCapabilities = numberCapabilities
        self.numberType = numberType
        self.optOutListName = optOutListName
        self.phoneNumber = phoneNumber
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.status = status
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayEnabled = twoWayEnabled
    }
}

struct ReleasePhoneNumberOutputBody: Swift.Equatable {
    let phoneNumberArn: Swift.String?
    let phoneNumberId: Swift.String?
    let phoneNumber: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    let isoCountryCode: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    let numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
    let monthlyLeasingPrice: Swift.String?
    let twoWayEnabled: Swift.Bool
    let twoWayChannelArn: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool
    let optOutListName: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
}

extension ReleasePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case numberCapabilities = "NumberCapabilities"
        case numberType = "NumberType"
        case optOutListName = "OptOutListName"
        case phoneNumber = "PhoneNumber"
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberId = "PhoneNumberId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case status = "Status"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberStatus.self, forKey: .status)
        status = statusDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let numberCapabilitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.NumberCapability?].self, forKey: .numberCapabilities)
        var numberCapabilitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil
        if let numberCapabilitiesContainer = numberCapabilitiesContainer {
            numberCapabilitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.NumberCapability]()
            for string0 in numberCapabilitiesContainer {
                if let string0 = string0 {
                    numberCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        numberCapabilities = numberCapabilitiesDecoded0
        let numberTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberType.self, forKey: .numberType)
        numberType = numberTypeDecoded
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum ReleasePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RequestPhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case numberCapabilities = "NumberCapabilities"
        case numberType = "NumberType"
        case optOutListName = "OptOutListName"
        case poolId = "PoolId"
        case registrationId = "RegistrationId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deletionProtectionEnabled = self.deletionProtectionEnabled {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let numberCapabilities = numberCapabilities {
            var numberCapabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .numberCapabilities)
            for numbercapability0 in numberCapabilities {
                try numberCapabilitiesContainer.encode(numbercapability0.rawValue)
            }
        }
        if let numberType = self.numberType {
            try encodeContainer.encode(numberType.rawValue, forKey: .numberType)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension RequestPhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RequestPhoneNumberInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// By default this is set to false. When set to true the phone number can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// Indicates if the phone number will be used for text messages, voice messages, or both.
    /// This member is required.
    public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    /// The type of phone number to request.
    /// This member is required.
    public var numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType?
    /// The name of the OptOutList to associate with the phone number. You can use the OutOutListName or OptPutListArn.
    public var optOutListName: Swift.String?
    /// The pool to associated with the phone number. You can use the PoolId or PoolArn.
    public var poolId: Swift.String?
    /// Use this field to attach your phone number for an external registration process.
    public var registrationId: Swift.String?
    /// An array of tags (key and value pairs) associate with the requested phone number.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        deletionProtectionEnabled: Swift.Bool? = nil,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
        numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType? = nil,
        optOutListName: Swift.String? = nil,
        poolId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.numberCapabilities = numberCapabilities
        self.numberType = numberType
        self.optOutListName = optOutListName
        self.poolId = poolId
        self.registrationId = registrationId
        self.tags = tags
    }
}

struct RequestPhoneNumberInputBody: Swift.Equatable {
    let isoCountryCode: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    let numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType?
    let optOutListName: Swift.String?
    let poolId: Swift.String?
    let registrationId: Swift.String?
    let deletionProtectionEnabled: Swift.Bool?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension RequestPhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case numberCapabilities = "NumberCapabilities"
        case numberType = "NumberType"
        case optOutListName = "OptOutListName"
        case poolId = "PoolId"
        case registrationId = "RegistrationId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let numberCapabilitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.NumberCapability?].self, forKey: .numberCapabilities)
        var numberCapabilitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil
        if let numberCapabilitiesContainer = numberCapabilitiesContainer {
            numberCapabilitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.NumberCapability]()
            for string0 in numberCapabilitiesContainer {
                if let string0 = string0 {
                    numberCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        numberCapabilities = numberCapabilitiesDecoded0
        let numberTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RequestableNumberType.self, forKey: .numberType)
        numberType = numberTypeDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled)
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RequestPhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestPhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.deletionProtectionEnabled = output.deletionProtectionEnabled
            self.isoCountryCode = output.isoCountryCode
            self.messageType = output.messageType
            self.monthlyLeasingPrice = output.monthlyLeasingPrice
            self.numberCapabilities = output.numberCapabilities
            self.numberType = output.numberType
            self.optOutListName = output.optOutListName
            self.phoneNumber = output.phoneNumber
            self.phoneNumberArn = output.phoneNumberArn
            self.phoneNumberId = output.phoneNumberId
            self.poolId = output.poolId
            self.selfManagedOptOutsEnabled = output.selfManagedOptOutsEnabled
            self.status = output.status
            self.tags = output.tags
            self.twoWayChannelArn = output.twoWayChannelArn
            self.twoWayEnabled = output.twoWayEnabled
        } else {
            self.createdTimestamp = nil
            self.deletionProtectionEnabled = false
            self.isoCountryCode = nil
            self.messageType = nil
            self.monthlyLeasingPrice = nil
            self.numberCapabilities = nil
            self.numberType = nil
            self.optOutListName = nil
            self.phoneNumber = nil
            self.phoneNumberArn = nil
            self.phoneNumberId = nil
            self.poolId = nil
            self.selfManagedOptOutsEnabled = false
            self.status = nil
            self.tags = nil
            self.twoWayChannelArn = nil
            self.twoWayEnabled = false
        }
    }
}

public struct RequestPhoneNumberOutput: Swift.Equatable {
    /// The time when the phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// By default this is set to false. When set to true the phone number can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The monthly price, in US dollars, to lease the phone number.
    public var monthlyLeasingPrice: Swift.String?
    /// Indicates if the phone number will be used for text messages, voice messages or both.
    public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    /// The type of number that was released.
    public var numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType?
    /// The name of the OptOutList that is associated with the requested phone number.
    public var optOutListName: Swift.String?
    /// The new phone number that was requested.
    public var phoneNumber: Swift.String?
    /// The Amazon Resource Name (ARN) of the requested phone number.
    public var phoneNumberArn: Swift.String?
    /// The unique identifier of the new phone number.
    public var phoneNumberId: Swift.String?
    /// The unique identifier of the pool associated with the phone number
    public var poolId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// The current status of the request.
    public var status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    /// An array of key and value pair tags that are associated with the phone number.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    /// The ARN used to identify the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
        numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType? = nil,
        optOutListName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.NumberStatus? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.numberCapabilities = numberCapabilities
        self.numberType = numberType
        self.optOutListName = optOutListName
        self.phoneNumber = phoneNumber
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.status = status
        self.tags = tags
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayEnabled = twoWayEnabled
    }
}

struct RequestPhoneNumberOutputBody: Swift.Equatable {
    let phoneNumberArn: Swift.String?
    let phoneNumberId: Swift.String?
    let phoneNumber: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    let isoCountryCode: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    let numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType?
    let monthlyLeasingPrice: Swift.String?
    let twoWayEnabled: Swift.Bool
    let twoWayChannelArn: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool
    let optOutListName: Swift.String?
    let deletionProtectionEnabled: Swift.Bool
    let poolId: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
}

extension RequestPhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case numberCapabilities = "NumberCapabilities"
        case numberType = "NumberType"
        case optOutListName = "OptOutListName"
        case phoneNumber = "PhoneNumber"
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberId = "PhoneNumberId"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case status = "Status"
        case tags = "Tags"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberStatus.self, forKey: .status)
        status = statusDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let numberCapabilitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.NumberCapability?].self, forKey: .numberCapabilities)
        var numberCapabilitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil
        if let numberCapabilitiesContainer = numberCapabilitiesContainer {
            numberCapabilitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.NumberCapability]()
            for string0 in numberCapabilitiesContainer {
                if let string0 = string0 {
                    numberCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        numberCapabilities = numberCapabilitiesDecoded0
        let numberTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RequestableNumberType.self, forKey: .numberType)
        numberType = numberTypeDecoded
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum RequestPhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum RequestableNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case longCode
        case tenDlc
        case tollFree
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestableNumberType] {
            return [
                .longCode,
                .tenDlc,
                .tollFree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .longCode: return "LONG_CODE"
            case .tenDlc: return "TEN_DLC"
            case .tollFree: return "TOLL_FREE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequestableNumberType(rawValue: rawValue) ?? RequestableNumberType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A requested resource couldn't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that caused the exception.
        public internal(set) var resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType?
    let resourceId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case configurationSet
        case eventDestination
        case keyword
        case optedOutNumber
        case optOutList
        case phoneNumber
        case pool
        case registration
        case senderId
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .account,
                .configurationSet,
                .eventDestination,
                .keyword,
                .optedOutNumber,
                .optOutList,
                .phoneNumber,
                .pool,
                .registration,
                .senderId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "account"
            case .configurationSet: return "configuration-set"
            case .eventDestination: return "event-destination"
            case .keyword: return "keyword"
            case .optedOutNumber: return "opted-out-number"
            case .optOutList: return "opt-out-list"
            case .phoneNumber: return "phone-number"
            case .pool: return "pool"
            case .registration: return "registration"
            case .senderId: return "sender-id"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension SendTextMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case context = "Context"
        case destinationCountryParameters = "DestinationCountryParameters"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case dryRun = "DryRun"
        case keyword = "Keyword"
        case maxPrice = "MaxPrice"
        case messageBody = "MessageBody"
        case messageType = "MessageType"
        case originationIdentity = "OriginationIdentity"
        case timeToLive = "TimeToLive"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .context)
            for (dictKey0, contextMap0) in context {
                try contextContainer.encode(contextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let destinationCountryParameters = destinationCountryParameters {
            var destinationCountryParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .destinationCountryParameters)
            for (dictKey0, destinationCountryParameters0) in destinationCountryParameters {
                try destinationCountryParametersContainer.encode(destinationCountryParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let destinationPhoneNumber = self.destinationPhoneNumber {
            try encodeContainer.encode(destinationPhoneNumber, forKey: .destinationPhoneNumber)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let keyword = self.keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let maxPrice = self.maxPrice {
            try encodeContainer.encode(maxPrice, forKey: .maxPrice)
        }
        if let messageBody = self.messageBody {
            try encodeContainer.encode(messageBody, forKey: .messageBody)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let timeToLive = self.timeToLive {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
    }
}

extension SendTextMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendTextMessageInput: Swift.Equatable {
    /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
    public var configurationSetName: Swift.String?
    /// You can specify custom data in this field. If you do, that data is logged to the event destination.
    public var context: [Swift.String:Swift.String]?
    /// This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see [Special requirements for sending SMS messages to recipients in India](https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html).
    public var destinationCountryParameters: [Swift.String:Swift.String]?
    /// The destination phone number in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// When set to true, the message is checked and validated, but isn't sent to the end recipient.
    public var dryRun: Swift.Bool
    /// When you register a short code in the US, you must specify a program name. If you dont have a US short code, omit this attribute.
    public var keyword: Swift.String?
    /// The maximum amount that you want to spend, in US dollars, per each text message part. A text message can contain multiple parts.
    public var maxPrice: Swift.String?
    /// The body of the text message.
    public var messageBody: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.
    public var originationIdentity: Swift.String?
    /// How long the text message is valid for. By default this is 72 hours.
    public var timeToLive: Swift.Int?

    public init(
        configurationSetName: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        destinationCountryParameters: [Swift.String:Swift.String]? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        dryRun: Swift.Bool = false,
        keyword: Swift.String? = nil,
        maxPrice: Swift.String? = nil,
        messageBody: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        originationIdentity: Swift.String? = nil,
        timeToLive: Swift.Int? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.context = context
        self.destinationCountryParameters = destinationCountryParameters
        self.destinationPhoneNumber = destinationPhoneNumber
        self.dryRun = dryRun
        self.keyword = keyword
        self.maxPrice = maxPrice
        self.messageBody = messageBody
        self.messageType = messageType
        self.originationIdentity = originationIdentity
        self.timeToLive = timeToLive
    }
}

struct SendTextMessageInputBody: Swift.Equatable {
    let destinationPhoneNumber: Swift.String?
    let originationIdentity: Swift.String?
    let messageBody: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let keyword: Swift.String?
    let configurationSetName: Swift.String?
    let maxPrice: Swift.String?
    let timeToLive: Swift.Int?
    let context: [Swift.String:Swift.String]?
    let destinationCountryParameters: [Swift.String:Swift.String]?
    let dryRun: Swift.Bool
}

extension SendTextMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case context = "Context"
        case destinationCountryParameters = "DestinationCountryParameters"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case dryRun = "DryRun"
        case keyword = "Keyword"
        case maxPrice = "MaxPrice"
        case messageBody = "MessageBody"
        case messageType = "MessageType"
        case originationIdentity = "OriginationIdentity"
        case timeToLive = "TimeToLive"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let messageBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let maxPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxPrice)
        maxPrice = maxPriceDecoded
        let timeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, contextvalue0) in contextContainer {
                if let contextvalue0 = contextvalue0 {
                    contextDecoded0?[key0] = contextvalue0
                }
            }
        }
        context = contextDecoded0
        let destinationCountryParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .destinationCountryParameters)
        var destinationCountryParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let destinationCountryParametersContainer = destinationCountryParametersContainer {
            destinationCountryParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, destinationcountryparametervalue0) in destinationCountryParametersContainer {
                if let destinationcountryparametervalue0 = destinationcountryparametervalue0 {
                    destinationCountryParametersDecoded0?[key0] = destinationcountryparametervalue0
                }
            }
        }
        destinationCountryParameters = destinationCountryParametersDecoded0
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun) ?? false
        dryRun = dryRunDecoded
    }
}

extension SendTextMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendTextMessageOutputBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendTextMessageOutput: Swift.Equatable {
    /// The unique identifier for the message.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendTextMessageOutputBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendTextMessageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

enum SendTextMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SendVoiceMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case context = "Context"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case dryRun = "DryRun"
        case maxPricePerMinute = "MaxPricePerMinute"
        case messageBody = "MessageBody"
        case messageBodyTextType = "MessageBodyTextType"
        case originationIdentity = "OriginationIdentity"
        case timeToLive = "TimeToLive"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .context)
            for (dictKey0, contextMap0) in context {
                try contextContainer.encode(contextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let destinationPhoneNumber = self.destinationPhoneNumber {
            try encodeContainer.encode(destinationPhoneNumber, forKey: .destinationPhoneNumber)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let maxPricePerMinute = self.maxPricePerMinute {
            try encodeContainer.encode(maxPricePerMinute, forKey: .maxPricePerMinute)
        }
        if let messageBody = self.messageBody {
            try encodeContainer.encode(messageBody, forKey: .messageBody)
        }
        if let messageBodyTextType = self.messageBodyTextType {
            try encodeContainer.encode(messageBodyTextType.rawValue, forKey: .messageBodyTextType)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let timeToLive = self.timeToLive {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
        if let voiceId = self.voiceId {
            try encodeContainer.encode(voiceId.rawValue, forKey: .voiceId)
        }
    }
}

extension SendVoiceMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendVoiceMessageInput: Swift.Equatable {
    /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
    public var configurationSetName: Swift.String?
    /// You can specify custom data in this field. If you do, that data is logged to the event destination.
    public var context: [Swift.String:Swift.String]?
    /// The destination phone number in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// When set to true, the message is checked and validated, but isn't sent to the end recipient.
    public var dryRun: Swift.Bool
    /// The maximum amount to spend per voice message, in US dollars.
    public var maxPricePerMinute: Swift.String?
    /// The text to convert to a voice message.
    public var messageBody: Swift.String?
    /// Specifies if the MessageBody field contains text or [speech synthesis markup language (SSML)](https://docs.aws.amazon.com/polly/latest/dg/what-is.html).
    ///
    /// * TEXT: This is the default value. When used the maximum character limit is 3000.
    ///
    /// * SSML: When used the maximum character limit is 6000 including SSML tagging.
    public var messageBodyTextType: PinpointSMSVoiceV2ClientTypes.VoiceMessageBodyTextType?
    /// The origination identity to use for the voice call. This can be the PhoneNumber, PhoneNumberId, PhoneNumberArn, PoolId, or PoolArn.
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// How long the voice message is valid for. By default this is 72 hours.
    public var timeToLive: Swift.Int?
    /// The voice for the [Amazon Polly](https://docs.aws.amazon.com/polly/latest/dg/what-is.html) service to use. By default this is set to "MATTHEW".
    public var voiceId: PinpointSMSVoiceV2ClientTypes.VoiceId?

    public init(
        configurationSetName: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        dryRun: Swift.Bool = false,
        maxPricePerMinute: Swift.String? = nil,
        messageBody: Swift.String? = nil,
        messageBodyTextType: PinpointSMSVoiceV2ClientTypes.VoiceMessageBodyTextType? = nil,
        originationIdentity: Swift.String? = nil,
        timeToLive: Swift.Int? = nil,
        voiceId: PinpointSMSVoiceV2ClientTypes.VoiceId? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.context = context
        self.destinationPhoneNumber = destinationPhoneNumber
        self.dryRun = dryRun
        self.maxPricePerMinute = maxPricePerMinute
        self.messageBody = messageBody
        self.messageBodyTextType = messageBodyTextType
        self.originationIdentity = originationIdentity
        self.timeToLive = timeToLive
        self.voiceId = voiceId
    }
}

struct SendVoiceMessageInputBody: Swift.Equatable {
    let destinationPhoneNumber: Swift.String?
    let originationIdentity: Swift.String?
    let messageBody: Swift.String?
    let messageBodyTextType: PinpointSMSVoiceV2ClientTypes.VoiceMessageBodyTextType?
    let voiceId: PinpointSMSVoiceV2ClientTypes.VoiceId?
    let configurationSetName: Swift.String?
    let maxPricePerMinute: Swift.String?
    let timeToLive: Swift.Int?
    let context: [Swift.String:Swift.String]?
    let dryRun: Swift.Bool
}

extension SendVoiceMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case context = "Context"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case dryRun = "DryRun"
        case maxPricePerMinute = "MaxPricePerMinute"
        case messageBody = "MessageBody"
        case messageBodyTextType = "MessageBodyTextType"
        case originationIdentity = "OriginationIdentity"
        case timeToLive = "TimeToLive"
        case voiceId = "VoiceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let messageBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
        let messageBodyTextTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.VoiceMessageBodyTextType.self, forKey: .messageBodyTextType)
        messageBodyTextType = messageBodyTextTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let maxPricePerMinuteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxPricePerMinute)
        maxPricePerMinute = maxPricePerMinuteDecoded
        let timeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, contextvalue0) in contextContainer {
                if let contextvalue0 = contextvalue0 {
                    contextDecoded0?[key0] = contextvalue0
                }
            }
        }
        context = contextDecoded0
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun) ?? false
        dryRun = dryRunDecoded
    }
}

extension SendVoiceMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendVoiceMessageOutputBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendVoiceMessageOutput: Swift.Equatable {
    /// The unique identifier for the message.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendVoiceMessageOutputBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendVoiceMessageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

enum SendVoiceMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case senderId = "SenderId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let senderId = self.senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The alphanumeric sender ID in a specific country that you want to describe. For more information on sender IDs see [Requesting sender IDs for SMS messaging with Amazon Pinpoint ](https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-awssupport-sender-id.html) in the Amazon Pinpoint User Guide.
    public struct SenderIdAndCountry: Swift.Equatable {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        /// This member is required.
        public var isoCountryCode: Swift.String?
        /// The unique identifier of the sender.
        /// This member is required.
        public var senderId: Swift.String?

        public init(
            isoCountryCode: Swift.String? = nil,
            senderId: Swift.String? = nil
        )
        {
            self.isoCountryCode = isoCountryCode
            self.senderId = senderId
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.SenderIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.SenderIdFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for a sender ID that meets a specified criteria.
    public struct SenderIdFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.SenderIdFilterName?
        /// An array of values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.SenderIdFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum SenderIdFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case isoCountryCode
        case messageType
        case senderId
        case sdkUnknown(Swift.String)

        public static var allCases: [SenderIdFilterName] {
            return [
                .isoCountryCode,
                .messageType,
                .senderId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .isoCountryCode: return "iso-country-code"
            case .messageType: return "message-type"
            case .senderId: return "sender-id"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SenderIdFilterName(rawValue: rawValue) ?? SenderIdFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.SenderIdInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case messageTypes = "MessageTypes"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case senderId = "SenderId"
        case senderIdArn = "SenderIdArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let messageTypes = messageTypes {
            var messageTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messageTypes)
            for messagetype0 in messageTypes {
                try messageTypesContainer.encode(messagetype0.rawValue)
            }
        }
        if let monthlyLeasingPrice = self.monthlyLeasingPrice {
            try encodeContainer.encode(monthlyLeasingPrice, forKey: .monthlyLeasingPrice)
        }
        if let senderId = self.senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
        if let senderIdArn = self.senderIdArn {
            try encodeContainer.encode(senderIdArn, forKey: .senderIdArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderIdArn)
        senderIdArn = senderIdArnDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.MessageType?].self, forKey: .messageTypes)
        var messageTypesDecoded0:[PinpointSMSVoiceV2ClientTypes.MessageType]? = nil
        if let messageTypesContainer = messageTypesContainer {
            messageTypesDecoded0 = [PinpointSMSVoiceV2ClientTypes.MessageType]()
            for string0 in messageTypesContainer {
                if let string0 = string0 {
                    messageTypesDecoded0?.append(string0)
                }
            }
        }
        messageTypes = messageTypesDecoded0
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for all SenderIds in an Amazon Web Services account.
    public struct SenderIdInformation: Swift.Equatable {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        /// This member is required.
        public var isoCountryCode: Swift.String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        /// This member is required.
        public var messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
        /// The monthly leasing price, in US dollars.
        /// This member is required.
        public var monthlyLeasingPrice: Swift.String?
        /// The alphanumeric sender ID in a specific country that you'd like to describe.
        /// This member is required.
        public var senderId: Swift.String?
        /// The Amazon Resource Name (ARN) associated with the SenderId.
        /// This member is required.
        public var senderIdArn: Swift.String?

        public init(
            isoCountryCode: Swift.String? = nil,
            messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]? = nil,
            monthlyLeasingPrice: Swift.String? = nil,
            senderId: Swift.String? = nil,
            senderIdArn: Swift.String? = nil
        )
        {
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.senderId = senderId
            self.senderIdArn = senderIdArn
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: PinpointSMSVoiceV2ClientTypes.ServiceQuotaExceededExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PinpointSMSVoiceV2ClientTypes.ServiceQuotaExceededExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: PinpointSMSVoiceV2ClientTypes.ServiceQuotaExceededExceptionReason?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.ServiceQuotaExceededExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum ServiceQuotaExceededExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configurationSetsPerAccount
        case dailyDestinationCallLimit
        case eventDestinationsPerConfigurationSet
        case keywordsPerPhoneNumber
        case keywordsPerPool
        case monthlySpendLimitReachedForText
        case monthlySpendLimitReachedForVoice
        case optOutListsPerAccount
        case originationIdentitiesPerPool
        case phoneNumbersPerAccount
        case phoneNumbersPerRegistration
        case poolsPerAccount
        case tagsPerResource
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaExceededExceptionReason] {
            return [
                .configurationSetsPerAccount,
                .dailyDestinationCallLimit,
                .eventDestinationsPerConfigurationSet,
                .keywordsPerPhoneNumber,
                .keywordsPerPool,
                .monthlySpendLimitReachedForText,
                .monthlySpendLimitReachedForVoice,
                .optOutListsPerAccount,
                .originationIdentitiesPerPool,
                .phoneNumbersPerAccount,
                .phoneNumbersPerRegistration,
                .poolsPerAccount,
                .tagsPerResource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configurationSetsPerAccount: return "CONFIGURATION_SETS_PER_ACCOUNT"
            case .dailyDestinationCallLimit: return "DAILY_DESTINATION_CALL_LIMIT"
            case .eventDestinationsPerConfigurationSet: return "EVENT_DESTINATIONS_PER_CONFIGURATION_SET"
            case .keywordsPerPhoneNumber: return "KEYWORDS_PER_PHONE_NUMBER"
            case .keywordsPerPool: return "KEYWORDS_PER_POOL"
            case .monthlySpendLimitReachedForText: return "MONTHLY_SPEND_LIMIT_REACHED_FOR_TEXT"
            case .monthlySpendLimitReachedForVoice: return "MONTHLY_SPEND_LIMIT_REACHED_FOR_VOICE"
            case .optOutListsPerAccount: return "OPT_OUT_LISTS_PER_ACCOUNT"
            case .originationIdentitiesPerPool: return "ORIGINATION_IDENTITIES_PER_POOL"
            case .phoneNumbersPerAccount: return "PHONE_NUMBERS_PER_ACCOUNT"
            case .phoneNumbersPerRegistration: return "PHONE_NUMBERS_PER_REGISTRATION"
            case .poolsPerAccount: return "POOLS_PER_ACCOUNT"
            case .tagsPerResource: return "TAGS_PER_RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceQuotaExceededExceptionReason(rawValue: rawValue) ?? ServiceQuotaExceededExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension SetDefaultMessageTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case messageType = "MessageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
    }
}

extension SetDefaultMessageTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetDefaultMessageTypeInput: Swift.Equatable {
    /// The configuration set to update with a new default message type. This field can be the ConsigurationSetName or ConfigurationSetArn.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?

    public init(
        configurationSetName: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.messageType = messageType
    }
}

struct SetDefaultMessageTypeInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
}

extension SetDefaultMessageTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case messageType = "MessageType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
    }
}

extension SetDefaultMessageTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetDefaultMessageTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.messageType = output.messageType
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.messageType = nil
        }
    }
}

public struct SetDefaultMessageTypeOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set that was updated.
    public var configurationSetName: Swift.String?
    /// The new default message type of the configuration set.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.messageType = messageType
    }
}

struct SetDefaultMessageTypeOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
}

extension SetDefaultMessageTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case messageType = "MessageType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
    }
}

enum SetDefaultMessageTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetDefaultSenderIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case senderId = "SenderId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let senderId = self.senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
    }
}

extension SetDefaultSenderIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetDefaultSenderIdInput: Swift.Equatable {
    /// The configuration set to updated with a new default SenderId. This field can be the ConsigurationSetName or ConfigurationSetArn.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The current sender ID for the configuration set. When sending a text message to a destination country which supports SenderIds, the default sender ID on the configuration set specified on [SendTextMessage] will be used if no dedicated origination phone numbers or registered SenderIds are available in your account, instead of a generic sender ID, such as 'NOTICE'.
    /// This member is required.
    public var senderId: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.senderId = senderId
    }
}

struct SetDefaultSenderIdInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
    let senderId: Swift.String?
}

extension SetDefaultSenderIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case senderId = "SenderId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
    }
}

extension SetDefaultSenderIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetDefaultSenderIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.senderId = output.senderId
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.senderId = nil
        }
    }
}

public struct SetDefaultSenderIdOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set that was updated.
    public var configurationSetName: Swift.String?
    /// The default sender ID to set for the ConfigurationSet.
    public var senderId: Swift.String?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.senderId = senderId
    }
}

struct SetDefaultSenderIdOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let senderId: Swift.String?
}

extension SetDefaultSenderIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case senderId = "SenderId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
    }
}

enum SetDefaultSenderIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetTextMessageSpendLimitOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monthlyLimit = self.monthlyLimit {
            try encodeContainer.encode(monthlyLimit, forKey: .monthlyLimit)
        }
    }
}

extension SetTextMessageSpendLimitOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetTextMessageSpendLimitOverrideInput: Swift.Equatable {
    /// The new monthly limit to enforce on text messages.
    /// This member is required.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

struct SetTextMessageSpendLimitOverrideInputBody: Swift.Equatable {
    let monthlyLimit: Swift.Int?
}

extension SetTextMessageSpendLimitOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlyLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monthlyLimit)
        monthlyLimit = monthlyLimitDecoded
    }
}

extension SetTextMessageSpendLimitOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetTextMessageSpendLimitOverrideOutputBody = try responseDecoder.decode(responseBody: data)
            self.monthlyLimit = output.monthlyLimit
        } else {
            self.monthlyLimit = nil
        }
    }
}

public struct SetTextMessageSpendLimitOverrideOutput: Swift.Equatable {
    /// The current monthly limit to enforce on sending text messages.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

struct SetTextMessageSpendLimitOverrideOutputBody: Swift.Equatable {
    let monthlyLimit: Swift.Int?
}

extension SetTextMessageSpendLimitOverrideOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlyLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monthlyLimit)
        monthlyLimit = monthlyLimitDecoded
    }
}

enum SetTextMessageSpendLimitOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetVoiceMessageSpendLimitOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monthlyLimit = self.monthlyLimit {
            try encodeContainer.encode(monthlyLimit, forKey: .monthlyLimit)
        }
    }
}

extension SetVoiceMessageSpendLimitOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetVoiceMessageSpendLimitOverrideInput: Swift.Equatable {
    /// The new monthly limit to enforce on voice messages.
    /// This member is required.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

struct SetVoiceMessageSpendLimitOverrideInputBody: Swift.Equatable {
    let monthlyLimit: Swift.Int?
}

extension SetVoiceMessageSpendLimitOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlyLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monthlyLimit)
        monthlyLimit = monthlyLimitDecoded
    }
}

extension SetVoiceMessageSpendLimitOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetVoiceMessageSpendLimitOverrideOutputBody = try responseDecoder.decode(responseBody: data)
            self.monthlyLimit = output.monthlyLimit
        } else {
            self.monthlyLimit = nil
        }
    }
}

public struct SetVoiceMessageSpendLimitOverrideOutput: Swift.Equatable {
    /// The current monthly limit to enforce on sending voice messages.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

struct SetVoiceMessageSpendLimitOverrideOutputBody: Swift.Equatable {
    let monthlyLimit: Swift.Int?
}

extension SetVoiceMessageSpendLimitOverrideOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlyLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monthlyLimit)
        monthlyLimit = monthlyLimitDecoded
    }
}

enum SetVoiceMessageSpendLimitOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.SnsDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = self.topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// An object that defines an Amazon SNS destination for events. You can use Amazon SNS to send notification when certain events occur.
    public struct SnsDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish events to.
        /// This member is required.
        public var topicArn: Swift.String?

        public init(
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.SpendLimit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforcedLimit = "EnforcedLimit"
        case maxLimit = "MaxLimit"
        case name = "Name"
        case overridden = "Overridden"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enforcedLimit != 0 {
            try encodeContainer.encode(enforcedLimit, forKey: .enforcedLimit)
        }
        if maxLimit != 0 {
            try encodeContainer.encode(maxLimit, forKey: .maxLimit)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if overridden != false {
            try encodeContainer.encode(overridden, forKey: .overridden)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.SpendLimitName.self, forKey: .name)
        name = nameDecoded
        let enforcedLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .enforcedLimit) ?? 0
        enforcedLimit = enforcedLimitDecoded
        let maxLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLimit) ?? 0
        maxLimit = maxLimitDecoded
        let overriddenDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overridden) ?? false
        overridden = overriddenDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Describes the current Amazon Pinpoint monthly spend limits for sending voice and text messages. For more information on increasing your monthly spend limit, see [ Requesting increases to your monthly SMS spending quota for Amazon Pinpoint ](https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-awssupport-spend-threshold.html) in the Amazon Pinpoint User Guide.
    public struct SpendLimit: Swift.Equatable {
        /// The maximum amount of money, in US dollars, that you want to be able to spend sending messages each month. This value has to be less than or equal to the amount in MaxLimit. To use this custom limit, Overridden must be set to true.
        /// This member is required.
        public var enforcedLimit: Swift.Int
        /// The maximum amount of money that you are able to spend to send messages each month, in US dollars.
        /// This member is required.
        public var maxLimit: Swift.Int
        /// The name for the SpendLimit.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.SpendLimitName?
        /// When set to True, the value that has been specified in the EnforcedLimit is used to determine the maximum amount in US dollars that can be spent to send messages each month, in US dollars.
        /// This member is required.
        public var overridden: Swift.Bool

        public init(
            enforcedLimit: Swift.Int = 0,
            maxLimit: Swift.Int = 0,
            name: PinpointSMSVoiceV2ClientTypes.SpendLimitName? = nil,
            overridden: Swift.Bool = false
        )
        {
            self.enforcedLimit = enforcedLimit
            self.maxLimit = maxLimit
            self.name = name
            self.overridden = overridden
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum SpendLimitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case textMessageMonthlySpendLimit
        case voiceMessageMonthlySpendLimit
        case sdkUnknown(Swift.String)

        public static var allCases: [SpendLimitName] {
            return [
                .textMessageMonthlySpendLimit,
                .voiceMessageMonthlySpendLimit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .textMessageMonthlySpendLimit: return "TEXT_MESSAGE_MONTHLY_SPEND_LIMIT"
            case .voiceMessageMonthlySpendLimit: return "VOICE_MESSAGE_MONTHLY_SPEND_LIMIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpendLimitName(rawValue: rawValue) ?? SpendLimitName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The list of tags to be added to the specified topic.
    public struct Tag: Swift.Equatable {
        /// The key identifier, or name, of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The string value associated with the key of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of key and value pair tags that are associated with the resource.
    /// This member is required.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error that occurred because too many requests were sent during a certain amount of time.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag key values to unassociate with the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEventDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case configurationSetName = "ConfigurationSetName"
        case enabled = "Enabled"
        case eventDestinationName = "EventDestinationName"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsDestination = self.cloudWatchLogsDestination {
            try encodeContainer.encode(cloudWatchLogsDestination, forKey: .cloudWatchLogsDestination)
        }
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventDestinationName = self.eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
        if let kinesisFirehoseDestination = self.kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtype0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtype0.rawValue)
            }
        }
        if let snsDestination = self.snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }
}

extension UpdateEventDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEventDestinationInput: Swift.Equatable {
    /// An object that contains information about an event destination that sends data to CloudWatch Logs.
    public var cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
    /// The configuration set to update with the new event destination. Valid values for this can be the ConfigurationSetName or ConfigurationSetArn.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// When set to true logging is enabled.
    public var enabled: Swift.Bool?
    /// The name to use for the event destination.
    /// This member is required.
    public var eventDestinationName: Swift.String?
    /// An object that contains information about an event destination for logging to Kinesis Data Firehose.
    public var kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
    /// An array of event types that determine which events to log.
    public var matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
    /// An object that contains information about an event destination that sends data to Amazon SNS.
    public var snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?

    public init(
        cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination? = nil,
        configurationSetName: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        eventDestinationName: Swift.String? = nil,
        kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination? = nil,
        matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]? = nil,
        snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination? = nil
    )
    {
        self.cloudWatchLogsDestination = cloudWatchLogsDestination
        self.configurationSetName = configurationSetName
        self.enabled = enabled
        self.eventDestinationName = eventDestinationName
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.snsDestination = snsDestination
    }
}

struct UpdateEventDestinationInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
    let eventDestinationName: Swift.String?
    let enabled: Swift.Bool?
    let matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
    let cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
    let kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
    let snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?
}

extension UpdateEventDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case configurationSetName = "ConfigurationSetName"
        case enabled = "Enabled"
        case eventDestinationName = "EventDestinationName"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[PinpointSMSVoiceV2ClientTypes.EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [PinpointSMSVoiceV2ClientTypes.EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let cloudWatchLogsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination.self, forKey: .cloudWatchLogsDestination)
        cloudWatchLogsDestination = cloudWatchLogsDestinationDecoded
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
    }
}

extension UpdateEventDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEventDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.eventDestination = output.eventDestination
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.eventDestination = nil
        }
    }
}

public struct UpdateEventDestinationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the ConfigurationSet that was updated.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set.
    public var configurationSetName: Swift.String?
    /// An EventDestination object containing the details of where events will be logged.
    public var eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
    }
}

struct UpdateEventDestinationOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?
}

extension UpdateEventDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case eventDestination = "EventDestination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.EventDestination.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

enum UpdateEventDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case optOutListName = "OptOutListName"
        case phoneNumberId = "PhoneNumberId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtectionEnabled = self.deletionProtectionEnabled {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let selfManagedOptOutsEnabled = self.selfManagedOptOutsEnabled {
            try encodeContainer.encode(selfManagedOptOutsEnabled, forKey: .selfManagedOptOutsEnabled)
        }
        if let twoWayChannelArn = self.twoWayChannelArn {
            try encodeContainer.encode(twoWayChannelArn, forKey: .twoWayChannelArn)
        }
        if let twoWayEnabled = self.twoWayEnabled {
            try encodeContainer.encode(twoWayEnabled, forKey: .twoWayEnabled)
        }
    }
}

extension UpdatePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePhoneNumberInput: Swift.Equatable {
    /// By default this is set to false. When set to true the phone number can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The OptOutList to add the phone number to. Valid values for this field can be either the OutOutListName or OutOutListArn.
    public var optOutListName: Swift.String?
    /// The unique identifier of the phone number. Valid values for this field can be either the PhoneNumberId or PhoneNumberArn.
    /// This member is required.
    public var phoneNumberId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool?

    public init(
        deletionProtectionEnabled: Swift.Bool? = nil,
        optOutListName: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayEnabled: Swift.Bool? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.optOutListName = optOutListName
        self.phoneNumberId = phoneNumberId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayEnabled = twoWayEnabled
    }
}

struct UpdatePhoneNumberInputBody: Swift.Equatable {
    let phoneNumberId: Swift.String?
    let twoWayEnabled: Swift.Bool?
    let twoWayChannelArn: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool?
    let optOutListName: Swift.String?
    let deletionProtectionEnabled: Swift.Bool?
}

extension UpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case optOutListName = "OptOutListName"
        case phoneNumberId = "PhoneNumberId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled)
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled)
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled)
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
    }
}

extension UpdatePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.deletionProtectionEnabled = output.deletionProtectionEnabled
            self.isoCountryCode = output.isoCountryCode
            self.messageType = output.messageType
            self.monthlyLeasingPrice = output.monthlyLeasingPrice
            self.numberCapabilities = output.numberCapabilities
            self.numberType = output.numberType
            self.optOutListName = output.optOutListName
            self.phoneNumber = output.phoneNumber
            self.phoneNumberArn = output.phoneNumberArn
            self.phoneNumberId = output.phoneNumberId
            self.selfManagedOptOutsEnabled = output.selfManagedOptOutsEnabled
            self.status = output.status
            self.twoWayChannelArn = output.twoWayChannelArn
            self.twoWayEnabled = output.twoWayEnabled
        } else {
            self.createdTimestamp = nil
            self.deletionProtectionEnabled = false
            self.isoCountryCode = nil
            self.messageType = nil
            self.monthlyLeasingPrice = nil
            self.numberCapabilities = nil
            self.numberType = nil
            self.optOutListName = nil
            self.phoneNumber = nil
            self.phoneNumberArn = nil
            self.phoneNumberId = nil
            self.selfManagedOptOutsEnabled = false
            self.status = nil
            self.twoWayChannelArn = nil
            self.twoWayEnabled = false
        }
    }
}

public struct UpdatePhoneNumberOutput: Swift.Equatable {
    /// The time when the phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// When set to true the phone number can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The monthly leasing price of the phone number, in US dollars.
    public var monthlyLeasingPrice: Swift.String?
    /// Specifies if the number could be used for text messages, voice or both.
    public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    /// The type of number that was requested.
    public var numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
    /// The name of the OptOutList associated with the phone number.
    public var optOutListName: Swift.String?
    /// The phone number that was updated.
    public var phoneNumber: Swift.String?
    /// The Amazon Resource Name (ARN) of the updated phone number.
    public var phoneNumberArn: Swift.String?
    /// The unique identifier of the phone number.
    public var phoneNumberId: Swift.String?
    /// This is true if self managed opt-out are enabled.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// The current status of the request.
    public var status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
        numberType: PinpointSMSVoiceV2ClientTypes.NumberType? = nil,
        optOutListName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.NumberStatus? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.numberCapabilities = numberCapabilities
        self.numberType = numberType
        self.optOutListName = optOutListName
        self.phoneNumber = phoneNumber
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.status = status
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayEnabled = twoWayEnabled
    }
}

struct UpdatePhoneNumberOutputBody: Swift.Equatable {
    let phoneNumberArn: Swift.String?
    let phoneNumberId: Swift.String?
    let phoneNumber: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    let isoCountryCode: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    let numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
    let monthlyLeasingPrice: Swift.String?
    let twoWayEnabled: Swift.Bool
    let twoWayChannelArn: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool
    let optOutListName: Swift.String?
    let deletionProtectionEnabled: Swift.Bool
    let createdTimestamp: ClientRuntime.Date?
}

extension UpdatePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case numberCapabilities = "NumberCapabilities"
        case numberType = "NumberType"
        case optOutListName = "OptOutListName"
        case phoneNumber = "PhoneNumber"
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberId = "PhoneNumberId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case status = "Status"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberStatus.self, forKey: .status)
        status = statusDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let numberCapabilitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.NumberCapability?].self, forKey: .numberCapabilities)
        var numberCapabilitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil
        if let numberCapabilitiesContainer = numberCapabilitiesContainer {
            numberCapabilitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.NumberCapability]()
            for string0 in numberCapabilitiesContainer {
                if let string0 = string0 {
                    numberCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        numberCapabilities = numberCapabilitiesDecoded0
        let numberTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberType.self, forKey: .numberType)
        numberType = numberTypeDecoded
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum UpdatePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case optOutListName = "OptOutListName"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case sharedRoutesEnabled = "SharedRoutesEnabled"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtectionEnabled = self.deletionProtectionEnabled {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let selfManagedOptOutsEnabled = self.selfManagedOptOutsEnabled {
            try encodeContainer.encode(selfManagedOptOutsEnabled, forKey: .selfManagedOptOutsEnabled)
        }
        if let sharedRoutesEnabled = self.sharedRoutesEnabled {
            try encodeContainer.encode(sharedRoutesEnabled, forKey: .sharedRoutesEnabled)
        }
        if let twoWayChannelArn = self.twoWayChannelArn {
            try encodeContainer.encode(twoWayChannelArn, forKey: .twoWayChannelArn)
        }
        if let twoWayEnabled = self.twoWayEnabled {
            try encodeContainer.encode(twoWayEnabled, forKey: .twoWayEnabled)
        }
    }
}

extension UpdatePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePoolInput: Swift.Equatable {
    /// When set to true the pool can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The OptOutList to associate with the pool. Valid values are either OptOutListName or OptOutListArn.
    public var optOutListName: Swift.String?
    /// The unique identifier of the pool to update. Valid values are either the PoolId or PoolArn.
    /// This member is required.
    public var poolId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool?
    /// Indicates whether shared routes are enabled for the pool.
    public var sharedRoutesEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool?

    public init(
        deletionProtectionEnabled: Swift.Bool? = nil,
        optOutListName: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool? = nil,
        sharedRoutesEnabled: Swift.Bool? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayEnabled: Swift.Bool? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.optOutListName = optOutListName
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.sharedRoutesEnabled = sharedRoutesEnabled
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayEnabled = twoWayEnabled
    }
}

struct UpdatePoolInputBody: Swift.Equatable {
    let poolId: Swift.String?
    let twoWayEnabled: Swift.Bool?
    let twoWayChannelArn: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool?
    let optOutListName: Swift.String?
    let sharedRoutesEnabled: Swift.Bool?
    let deletionProtectionEnabled: Swift.Bool?
}

extension UpdatePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case optOutListName = "OptOutListName"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case sharedRoutesEnabled = "SharedRoutesEnabled"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled)
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled)
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let sharedRoutesEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharedRoutesEnabled)
        sharedRoutesEnabled = sharedRoutesEnabledDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled)
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
    }
}

extension UpdatePoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePoolOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.deletionProtectionEnabled = output.deletionProtectionEnabled
            self.messageType = output.messageType
            self.optOutListName = output.optOutListName
            self.poolArn = output.poolArn
            self.poolId = output.poolId
            self.selfManagedOptOutsEnabled = output.selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = output.sharedRoutesEnabled
            self.status = output.status
            self.twoWayChannelArn = output.twoWayChannelArn
            self.twoWayEnabled = output.twoWayEnabled
        } else {
            self.createdTimestamp = nil
            self.deletionProtectionEnabled = false
            self.messageType = nil
            self.optOutListName = nil
            self.poolArn = nil
            self.poolId = nil
            self.selfManagedOptOutsEnabled = false
            self.sharedRoutesEnabled = false
            self.status = nil
            self.twoWayChannelArn = nil
            self.twoWayEnabled = false
        }
    }
}

public struct UpdatePoolOutput: Swift.Equatable {
    /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// When set to true the pool can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool
    /// The type of message for the pool to use.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The name of the OptOutList associated with the pool.
    public var optOutListName: Swift.String?
    /// The ARN of the pool.
    public var poolArn: Swift.String?
    /// The unique identifier of the pool.
    public var poolId: Swift.String?
    /// When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// Indicates whether shared routes are enabled for the pool.
    public var sharedRoutesEnabled: Swift.Bool
    /// The current status of the pool update request.
    public var status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        optOutListName: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        sharedRoutesEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.PoolStatus? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.messageType = messageType
        self.optOutListName = optOutListName
        self.poolArn = poolArn
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.sharedRoutesEnabled = sharedRoutesEnabled
        self.status = status
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayEnabled = twoWayEnabled
    }
}

struct UpdatePoolOutputBody: Swift.Equatable {
    let poolArn: Swift.String?
    let poolId: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let twoWayEnabled: Swift.Bool
    let twoWayChannelArn: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool
    let optOutListName: Swift.String?
    let sharedRoutesEnabled: Swift.Bool
    let deletionProtectionEnabled: Swift.Bool
    let createdTimestamp: ClientRuntime.Date?
}

extension UpdatePoolOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case messageType = "MessageType"
        case optOutListName = "OptOutListName"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case sharedRoutesEnabled = "SharedRoutesEnabled"
        case status = "Status"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PoolStatus.self, forKey: .status)
        status = statusDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let sharedRoutesEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharedRoutesEnabled) ?? false
        sharedRoutesEnabled = sharedRoutesEnabledDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum UpdatePoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A validation exception for a field.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field that failed validation.
        public internal(set) var fields: [PinpointSMSVoiceV2ClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: PinpointSMSVoiceV2ClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [PinpointSMSVoiceV2ClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: PinpointSMSVoiceV2ClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: PinpointSMSVoiceV2ClientTypes.ValidationExceptionReason?
    let fields: [PinpointSMSVoiceV2ClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[PinpointSMSVoiceV2ClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [PinpointSMSVoiceV2ClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The field associated with the validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message associated with the validation exception with information to help determine its cause.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotAddOptedOutNumber
        case cannotParse
        case countryCodeMismatch
        case destinationCountryBlocked
        case fieldValidationFailed
        case invalidArn
        case invalidFilterValues
        case invalidIdentityForDestinationCountry
        case invalidNextToken
        case invalidParameter
        case missingParameter
        case other
        case parametersCannotBeUsedTogether
        case phoneNumberCannotBeOptedIn
        case phoneNumberCannotBeReleased
        case priceOverThreshold
        case requestedSpendLimitHigherThanServiceLimit
        case senderIdNotRegistered
        case senderIdNotSupported
        case twoWayNotEnabled
        case twoWayNotSupportedInCountry
        case twoWayNotSupportedInRegion
        case twoWayTopicNotPresent
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotAddOptedOutNumber,
                .cannotParse,
                .countryCodeMismatch,
                .destinationCountryBlocked,
                .fieldValidationFailed,
                .invalidArn,
                .invalidFilterValues,
                .invalidIdentityForDestinationCountry,
                .invalidNextToken,
                .invalidParameter,
                .missingParameter,
                .other,
                .parametersCannotBeUsedTogether,
                .phoneNumberCannotBeOptedIn,
                .phoneNumberCannotBeReleased,
                .priceOverThreshold,
                .requestedSpendLimitHigherThanServiceLimit,
                .senderIdNotRegistered,
                .senderIdNotSupported,
                .twoWayNotEnabled,
                .twoWayNotSupportedInCountry,
                .twoWayNotSupportedInRegion,
                .twoWayTopicNotPresent,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotAddOptedOutNumber: return "CANNOT_ADD_OPTED_OUT_NUMBER"
            case .cannotParse: return "CANNOT_PARSE"
            case .countryCodeMismatch: return "COUNTRY_CODE_MISMATCH"
            case .destinationCountryBlocked: return "DESTINATION_COUNTRY_BLOCKED"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .invalidArn: return "INVALID_ARN"
            case .invalidFilterValues: return "INVALID_FILTER_VALUES"
            case .invalidIdentityForDestinationCountry: return "INVALID_IDENTITY_FOR_DESTINATION_COUNTRY"
            case .invalidNextToken: return "INVALID_NEXT_TOKEN"
            case .invalidParameter: return "INVALID_PARAMETER"
            case .missingParameter: return "MISSING_PARAMETER"
            case .other: return "OTHER"
            case .parametersCannotBeUsedTogether: return "PARAMETERS_CANNOT_BE_USED_TOGETHER"
            case .phoneNumberCannotBeOptedIn: return "PHONE_NUMBER_CANNOT_BE_OPTED_IN"
            case .phoneNumberCannotBeReleased: return "PHONE_NUMBER_CANNOT_BE_RELEASED"
            case .priceOverThreshold: return "PRICE_OVER_THRESHOLD"
            case .requestedSpendLimitHigherThanServiceLimit: return "REQUESTED_SPEND_LIMIT_HIGHER_THAN_SERVICE_LIMIT"
            case .senderIdNotRegistered: return "SENDER_ID_NOT_REGISTERED"
            case .senderIdNotSupported: return "SENDER_ID_NOT_SUPPORTED"
            case .twoWayNotEnabled: return "TWO_WAY_NOT_ENABLED"
            case .twoWayNotSupportedInCountry: return "TWO_WAY_NOT_SUPPORTED_IN_COUNTRY"
            case .twoWayNotSupportedInRegion: return "TWO_WAY_NOT_SUPPORTED_IN_REGION"
            case .twoWayTopicNotPresent: return "TWO_WAY_TOPIC_NOT_PRESENT"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum VoiceId: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amy
        case astrid
        case bianca
        case brian
        case camila
        case carla
        case carmen
        case celine
        case chantal
        case conchita
        case cristiano
        case dora
        case emma
        case enrique
        case ewa
        case filiz
        case geraint
        case giorgio
        case gwyneth
        case hans
        case ines
        case ivy
        case jacek
        case jan
        case joanna
        case joey
        case justin
        case karl
        case kendra
        case kimberly
        case lea
        case liv
        case lotte
        case lucia
        case lupe
        case mads
        case maja
        case marlene
        case mathieu
        case matthew
        case maxim
        case mia
        case miguel
        case mizuki
        case naja
        case nicole
        case penelope
        case raveena
        case ricardo
        case ruben
        case russell
        case salli
        case seoyeon
        case takumi
        case tatyana
        case vicki
        case vitoria
        case zeina
        case zhiyu
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceId] {
            return [
                .amy,
                .astrid,
                .bianca,
                .brian,
                .camila,
                .carla,
                .carmen,
                .celine,
                .chantal,
                .conchita,
                .cristiano,
                .dora,
                .emma,
                .enrique,
                .ewa,
                .filiz,
                .geraint,
                .giorgio,
                .gwyneth,
                .hans,
                .ines,
                .ivy,
                .jacek,
                .jan,
                .joanna,
                .joey,
                .justin,
                .karl,
                .kendra,
                .kimberly,
                .lea,
                .liv,
                .lotte,
                .lucia,
                .lupe,
                .mads,
                .maja,
                .marlene,
                .mathieu,
                .matthew,
                .maxim,
                .mia,
                .miguel,
                .mizuki,
                .naja,
                .nicole,
                .penelope,
                .raveena,
                .ricardo,
                .ruben,
                .russell,
                .salli,
                .seoyeon,
                .takumi,
                .tatyana,
                .vicki,
                .vitoria,
                .zeina,
                .zhiyu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amy: return "AMY"
            case .astrid: return "ASTRID"
            case .bianca: return "BIANCA"
            case .brian: return "BRIAN"
            case .camila: return "CAMILA"
            case .carla: return "CARLA"
            case .carmen: return "CARMEN"
            case .celine: return "CELINE"
            case .chantal: return "CHANTAL"
            case .conchita: return "CONCHITA"
            case .cristiano: return "CRISTIANO"
            case .dora: return "DORA"
            case .emma: return "EMMA"
            case .enrique: return "ENRIQUE"
            case .ewa: return "EWA"
            case .filiz: return "FILIZ"
            case .geraint: return "GERAINT"
            case .giorgio: return "GIORGIO"
            case .gwyneth: return "GWYNETH"
            case .hans: return "HANS"
            case .ines: return "INES"
            case .ivy: return "IVY"
            case .jacek: return "JACEK"
            case .jan: return "JAN"
            case .joanna: return "JOANNA"
            case .joey: return "JOEY"
            case .justin: return "JUSTIN"
            case .karl: return "KARL"
            case .kendra: return "KENDRA"
            case .kimberly: return "KIMBERLY"
            case .lea: return "LEA"
            case .liv: return "LIV"
            case .lotte: return "LOTTE"
            case .lucia: return "LUCIA"
            case .lupe: return "LUPE"
            case .mads: return "MADS"
            case .maja: return "MAJA"
            case .marlene: return "MARLENE"
            case .mathieu: return "MATHIEU"
            case .matthew: return "MATTHEW"
            case .maxim: return "MAXIM"
            case .mia: return "MIA"
            case .miguel: return "MIGUEL"
            case .mizuki: return "MIZUKI"
            case .naja: return "NAJA"
            case .nicole: return "NICOLE"
            case .penelope: return "PENELOPE"
            case .raveena: return "RAVEENA"
            case .ricardo: return "RICARDO"
            case .ruben: return "RUBEN"
            case .russell: return "RUSSELL"
            case .salli: return "SALLI"
            case .seoyeon: return "SEOYEON"
            case .takumi: return "TAKUMI"
            case .tatyana: return "TATYANA"
            case .vicki: return "VICKI"
            case .vitoria: return "VITORIA"
            case .zeina: return "ZEINA"
            case .zhiyu: return "ZHIYU"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceId(rawValue: rawValue) ?? VoiceId.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum VoiceMessageBodyTextType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssml
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceMessageBodyTextType] {
            return [
                .ssml,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssml: return "SSML"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceMessageBodyTextType(rawValue: rawValue) ?? VoiceMessageBodyTextType.sdkUnknown(rawValue)
        }
    }
}
