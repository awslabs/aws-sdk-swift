// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because you don't have sufficient permissions to access the resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: PinpointSMSVoiceV2ClientTypes.AccessDeniedExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PinpointSMSVoiceV2ClientTypes.AccessDeniedExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: PinpointSMSVoiceV2ClientTypes.AccessDeniedExceptionReason?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.AccessDeniedExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum AccessDeniedExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountDisabled
        case insufficientAccountReputation
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessDeniedExceptionReason] {
            return [
                .accountDisabled,
                .insufficientAccountReputation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountDisabled: return "ACCOUNT_DISABLED"
            case .insufficientAccountReputation: return "INSUFFICIENT_ACCOUNT_REPUTATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessDeniedExceptionReason(rawValue: rawValue) ?? AccessDeniedExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.AccountAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.AccountAttributeName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Displays the attributes associated with a single Amazon Web Services account.
    public struct AccountAttribute: Swift.Equatable {
        /// The name of the account attribute.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.AccountAttributeName?
        /// The value associated with the account attribute name.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.AccountAttributeName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum AccountAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountTier
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountAttributeName] {
            return [
                .accountTier,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountTier: return "ACCOUNT_TIER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountAttributeName(rawValue: rawValue) ?? AccountAttributeName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.AccountLimit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case name = "Name"
        case used = "Used"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if used != 0 {
            try encodeContainer.encode(used, forKey: .used)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.AccountLimitName.self, forKey: .name)
        name = nameDecoded
        let usedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .used) ?? 0
        used = usedDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max) ?? 0
        max = maxDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The current resource quotas associated with an Amazon Web Services account.
    public struct AccountLimit: Swift.Equatable {
        /// The Amazon Web Services set limit for that resource type, in US dollars.
        /// This member is required.
        public var max: Swift.Int
        /// The name of the attribute to apply the account limit to.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.AccountLimitName?
        /// The current amount that has been spent, in US dollars.
        /// This member is required.
        public var used: Swift.Int

        public init(
            max: Swift.Int = 0,
            name: PinpointSMSVoiceV2ClientTypes.AccountLimitName? = nil,
            used: Swift.Int = 0
        )
        {
            self.max = max
            self.name = name
            self.used = used
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum AccountLimitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configurationSets
        case optOutLists
        case phoneNumbers
        case pools
        case registrations
        case registrationAttachments
        case senderIds
        case verifiedDestinationNumbers
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountLimitName] {
            return [
                .configurationSets,
                .optOutLists,
                .phoneNumbers,
                .pools,
                .registrations,
                .registrationAttachments,
                .senderIds,
                .verifiedDestinationNumbers,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configurationSets: return "CONFIGURATION_SETS"
            case .optOutLists: return "OPT_OUT_LISTS"
            case .phoneNumbers: return "PHONE_NUMBERS"
            case .pools: return "POOLS"
            case .registrations: return "REGISTRATIONS"
            case .registrationAttachments: return "REGISTRATION_ATTACHMENTS"
            case .senderIds: return "SENDER_IDS"
            case .verifiedDestinationNumbers: return "VERIFIED_DESTINATION_NUMBERS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountLimitName(rawValue: rawValue) ?? AccountLimitName.sdkUnknown(rawValue)
        }
    }
}

extension AssociateOriginationIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case isoCountryCode = "IsoCountryCode"
        case originationIdentity = "OriginationIdentity"
        case poolId = "PoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
    }
}

extension AssociateOriginationIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateOriginationIdentityInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The new two-character code, in ISO 3166-1 alpha-2 format, for the country or region of the origination identity.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The origination identity to use, such as PhoneNumberId, PhoneNumberArn, SenderId, or SenderIdArn. You can use [DescribePhoneNumbers] to find the values for PhoneNumberId and PhoneNumberArn, while [DescribeSenderIds] can be used to get the values for SenderId and SenderIdArn.
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// The pool to update with the new Identity. This value can be either the PoolId or PoolArn, and you can find these values using [DescribePools].
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        isoCountryCode: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.isoCountryCode = isoCountryCode
        self.originationIdentity = originationIdentity
        self.poolId = poolId
    }
}

struct AssociateOriginationIdentityInputBody: Swift.Equatable {
    let poolId: Swift.String?
    let originationIdentity: Swift.String?
    let isoCountryCode: Swift.String?
    let clientToken: Swift.String?
}

extension AssociateOriginationIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case isoCountryCode = "IsoCountryCode"
        case originationIdentity = "OriginationIdentity"
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateOriginationIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateOriginationIdentityOutputBody = try responseDecoder.decode(responseBody: data)
            self.isoCountryCode = output.isoCountryCode
            self.originationIdentity = output.originationIdentity
            self.originationIdentityArn = output.originationIdentityArn
            self.poolArn = output.poolArn
            self.poolId = output.poolId
        } else {
            self.isoCountryCode = nil
            self.originationIdentity = nil
            self.originationIdentityArn = nil
            self.poolArn = nil
            self.poolId = nil
        }
    }
}

public struct AssociateOriginationIdentityOutput: Swift.Equatable {
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The PhoneNumberId or SenderId of the origination identity.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or SenderIdArn of the origination identity.
    public var originationIdentityArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the pool that is now associated with the origination identity.
    public var poolArn: Swift.String?
    /// The PoolId of the pool that is now associated with the origination identity.
    public var poolId: Swift.String?

    public init(
        isoCountryCode: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
        self.poolArn = poolArn
        self.poolId = poolId
    }
}

struct AssociateOriginationIdentityOutputBody: Swift.Equatable {
    let poolArn: Swift.String?
    let poolId: Swift.String?
    let originationIdentityArn: Swift.String?
    let originationIdentity: Swift.String?
    let isoCountryCode: Swift.String?
}

extension AssociateOriginationIdentityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case originationIdentity = "OriginationIdentity"
        case originationIdentityArn = "OriginationIdentityArn"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let originationIdentityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentityArn)
        originationIdentityArn = originationIdentityArnDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
    }
}

enum AssociateOriginationIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum AttachmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case uploadComplete
        case uploadFailed
        case uploadInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentStatus] {
            return [
                .deleted,
                .uploadComplete,
                .uploadFailed,
                .uploadInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .uploadComplete: return "UPLOAD_COMPLETE"
            case .uploadFailed: return "UPLOAD_FAILED"
            case .uploadInProgress: return "UPLOAD_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentStatus(rawValue: rawValue) ?? AttachmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum AttachmentUploadErrorReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentUploadErrorReason] {
            return [
                .internalError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentUploadErrorReason(rawValue: rawValue) ?? AttachmentUploadErrorReason.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRoleArn = "IamRoleArn"
        case logGroupArn = "LogGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Contains the destination configuration to use when publishing message sending events.
    public struct CloudWatchLogsDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon Identity and Access Management (IAM) role that is able to write event data to an Amazon CloudWatch destination.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// The name of the Amazon CloudWatch log group that you want to record events in.
        /// This member is required.
        public var logGroupArn: Swift.String?

        public init(
            iamRoleArn: Swift.String? = nil,
            logGroupArn: Swift.String? = nil
        )
        {
            self.iamRoleArn = iamRoleArn
            self.logGroupArn = logGroupArn
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for configuration sets that meet a specified criteria.
    public struct ConfigurationSetFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum ConfigurationSetFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case defaultMessageType
        case defaultSenderId
        case eventDestinationName
        case matchingEventTypes
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationSetFilterName] {
            return [
                .defaultMessageType,
                .defaultSenderId,
                .eventDestinationName,
                .matchingEventTypes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .defaultMessageType: return "default-message-type"
            case .defaultSenderId: return "default-sender-id"
            case .eventDestinationName: return "event-destination-name"
            case .matchingEventTypes: return "matching-event-types"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationSetFilterName(rawValue: rawValue) ?? ConfigurationSetFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case createdTimestamp = "CreatedTimestamp"
        case defaultMessageType = "DefaultMessageType"
        case defaultSenderId = "DefaultSenderId"
        case eventDestinations = "EventDestinations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetArn = self.configurationSetArn {
            try encodeContainer.encode(configurationSetArn, forKey: .configurationSetArn)
        }
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let defaultMessageType = self.defaultMessageType {
            try encodeContainer.encode(defaultMessageType.rawValue, forKey: .defaultMessageType)
        }
        if let defaultSenderId = self.defaultSenderId {
            try encodeContainer.encode(defaultSenderId, forKey: .defaultSenderId)
        }
        if let eventDestinations = eventDestinations {
            var eventDestinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventDestinations)
            for eventdestination0 in eventDestinations {
                try eventDestinationsContainer.encode(eventdestination0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.EventDestination?].self, forKey: .eventDestinations)
        var eventDestinationsDecoded0:[PinpointSMSVoiceV2ClientTypes.EventDestination]? = nil
        if let eventDestinationsContainer = eventDestinationsContainer {
            eventDestinationsDecoded0 = [PinpointSMSVoiceV2ClientTypes.EventDestination]()
            for structure0 in eventDestinationsContainer {
                if let structure0 = structure0 {
                    eventDestinationsDecoded0?.append(structure0)
                }
            }
        }
        eventDestinations = eventDestinationsDecoded0
        let defaultMessageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .defaultMessageType)
        defaultMessageType = defaultMessageTypeDecoded
        let defaultSenderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSenderId)
        defaultSenderId = defaultSenderIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Information related to a given configuration set in your Amazon Web Services account.
    public struct ConfigurationSetInformation: Swift.Equatable {
        /// The Resource Name (ARN) of the ConfigurationSet.
        /// This member is required.
        public var configurationSetArn: Swift.String?
        /// The name of the ConfigurationSet.
        /// This member is required.
        public var configurationSetName: Swift.String?
        /// The time when the ConfigurationSet was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: ClientRuntime.Date?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public var defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType?
        /// The default sender ID used by the ConfigurationSet.
        public var defaultSenderId: Swift.String?
        /// An array of EventDestination objects that describe any events to log and where to log them.
        /// This member is required.
        public var eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]?

        public init(
            configurationSetArn: Swift.String? = nil,
            configurationSetName: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
            defaultSenderId: Swift.String? = nil,
            eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]? = nil
        )
        {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.createdTimestamp = createdTimestamp
            self.defaultMessageType = defaultMessageType
            self.defaultSenderId = defaultSenderId
            self.eventDestinations = eventDestinations
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.reason = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time or it could be that the requested action isn't valid for the current state or configuration of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: PinpointSMSVoiceV2ClientTypes.ConflictExceptionReason? = nil
        /// The unique identifier of the request.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that caused the exception.
        public internal(set) var resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PinpointSMSVoiceV2ClientTypes.ConflictExceptionReason? = nil,
        resourceId: Swift.String? = nil,
        resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: PinpointSMSVoiceV2ClientTypes.ConflictExceptionReason?
    let resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType?
    let resourceId: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createRegistrationVersionNotAllowed
        case deletionProtectionEnabled
        case destinationPhoneNumberNotVerified
        case destinationPhoneNumberOptedOut
        case disassociateRegistrationNotAllowed
        case discardRegistrationVersionNotAllowed
        case editRegistrationFieldValuesNotAllowed
        case eventDestinationMismatch
        case keywordMismatch
        case lastPhoneNumber
        case messageTypeMismatch
        case noOriginationIdentitiesFound
        case numberCapabilitiesMismatch
        case optOutListMismatch
        case phoneNumberAssociatedToPool
        case phoneNumberAssociatedToRegistration
        case phoneNumberNotAssociatedToPool
        case phoneNumberNotInRegistrationRegion
        case registrationAlreadySubmitted
        case registrationNotComplete
        case resourceAlreadyExists
        case resourceDeletionNotAllowed
        case resourceModificationNotAllowed
        case resourceNotActive
        case resourceNotEmpty
        case selfManagedOptOutsMismatch
        case senderIdAssociatedToPool
        case submitRegistrationVersionNotAllowed
        case twoWayConfigMismatch
        case verificationAlreadyComplete
        case verificationCodeExpired
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .createRegistrationVersionNotAllowed,
                .deletionProtectionEnabled,
                .destinationPhoneNumberNotVerified,
                .destinationPhoneNumberOptedOut,
                .disassociateRegistrationNotAllowed,
                .discardRegistrationVersionNotAllowed,
                .editRegistrationFieldValuesNotAllowed,
                .eventDestinationMismatch,
                .keywordMismatch,
                .lastPhoneNumber,
                .messageTypeMismatch,
                .noOriginationIdentitiesFound,
                .numberCapabilitiesMismatch,
                .optOutListMismatch,
                .phoneNumberAssociatedToPool,
                .phoneNumberAssociatedToRegistration,
                .phoneNumberNotAssociatedToPool,
                .phoneNumberNotInRegistrationRegion,
                .registrationAlreadySubmitted,
                .registrationNotComplete,
                .resourceAlreadyExists,
                .resourceDeletionNotAllowed,
                .resourceModificationNotAllowed,
                .resourceNotActive,
                .resourceNotEmpty,
                .selfManagedOptOutsMismatch,
                .senderIdAssociatedToPool,
                .submitRegistrationVersionNotAllowed,
                .twoWayConfigMismatch,
                .verificationAlreadyComplete,
                .verificationCodeExpired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createRegistrationVersionNotAllowed: return "CREATE_REGISTRATION_VERSION_NOT_ALLOWED"
            case .deletionProtectionEnabled: return "DELETION_PROTECTION_ENABLED"
            case .destinationPhoneNumberNotVerified: return "DESTINATION_PHONE_NUMBER_NOT_VERIFIED"
            case .destinationPhoneNumberOptedOut: return "DESTINATION_PHONE_NUMBER_OPTED_OUT"
            case .disassociateRegistrationNotAllowed: return "DISASSOCIATE_REGISTRATION_NOT_ALLOWED"
            case .discardRegistrationVersionNotAllowed: return "DISCARD_REGISTRATION_VERSION_NOT_ALLOWED"
            case .editRegistrationFieldValuesNotAllowed: return "EDIT_REGISTRATION_FIELD_VALUES_NOT_ALLOWED"
            case .eventDestinationMismatch: return "EVENT_DESTINATION_MISMATCH"
            case .keywordMismatch: return "KEYWORD_MISMATCH"
            case .lastPhoneNumber: return "LAST_PHONE_NUMBER"
            case .messageTypeMismatch: return "MESSAGE_TYPE_MISMATCH"
            case .noOriginationIdentitiesFound: return "NO_ORIGINATION_IDENTITIES_FOUND"
            case .numberCapabilitiesMismatch: return "NUMBER_CAPABILITIES_MISMATCH"
            case .optOutListMismatch: return "OPT_OUT_LIST_MISMATCH"
            case .phoneNumberAssociatedToPool: return "PHONE_NUMBER_ASSOCIATED_TO_POOL"
            case .phoneNumberAssociatedToRegistration: return "PHONE_NUMBER_ASSOCIATED_TO_REGISTRATION"
            case .phoneNumberNotAssociatedToPool: return "PHONE_NUMBER_NOT_ASSOCIATED_TO_POOL"
            case .phoneNumberNotInRegistrationRegion: return "PHONE_NUMBER_NOT_IN_REGISTRATION_REGION"
            case .registrationAlreadySubmitted: return "REGISTRATION_ALREADY_SUBMITTED"
            case .registrationNotComplete: return "REGISTRATION_NOT_COMPLETE"
            case .resourceAlreadyExists: return "RESOURCE_ALREADY_EXISTS"
            case .resourceDeletionNotAllowed: return "RESOURCE_DELETION_NOT_ALLOWED"
            case .resourceModificationNotAllowed: return "RESOURCE_MODIFICATION_NOT_ALLOWED"
            case .resourceNotActive: return "RESOURCE_NOT_ACTIVE"
            case .resourceNotEmpty: return "RESOURCE_NOT_EMPTY"
            case .selfManagedOptOutsMismatch: return "SELF_MANAGED_OPT_OUTS_MISMATCH"
            case .senderIdAssociatedToPool: return "SENDER_ID_ASSOCIATED_TO_POOL"
            case .submitRegistrationVersionNotAllowed: return "SUBMIT_REGISTRATION_VERSION_NOT_ALLOWED"
            case .twoWayConfigMismatch: return "TWO_WAY_CONFIG_MISMATCH"
            case .verificationAlreadyComplete: return "VERIFICATION_ALREADY_COMPLETE"
            case .verificationCodeExpired: return "VERIFICATION_CODE_EXPIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CreateConfigurationSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case configurationSetName = "ConfigurationSetName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateConfigurationSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConfigurationSetInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The name to use for the new configuration set.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// An array of key and value pair tags that's associated with the new configuration set.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.configurationSetName = configurationSetName
        self.tags = tags
    }
}

struct CreateConfigurationSetInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateConfigurationSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case configurationSetName = "ConfigurationSetName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateConfigurationSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConfigurationSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.createdTimestamp = output.createdTimestamp
            self.tags = output.tags
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.createdTimestamp = nil
            self.tags = nil
        }
    }
}

public struct CreateConfigurationSetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the newly created configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the new configuration set.
    public var configurationSetName: Swift.String?
    /// The time when the configuration set was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// An array of key and value pair tags that's associated with the configuration set.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.createdTimestamp = createdTimestamp
        self.tags = tags
    }
}

struct CreateConfigurationSetOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
}

extension CreateConfigurationSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case createdTimestamp = "CreatedTimestamp"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum CreateConfigurationSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEventDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let cloudWatchLogsDestination = self.cloudWatchLogsDestination {
            try encodeContainer.encode(cloudWatchLogsDestination, forKey: .cloudWatchLogsDestination)
        }
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let eventDestinationName = self.eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
        if let kinesisFirehoseDestination = self.kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtype0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtype0.rawValue)
            }
        }
        if let snsDestination = self.snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }
}

extension CreateEventDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEventDestinationInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// An object that contains information about an event destination for logging to Amazon CloudWatch logs.
    public var cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
    /// Either the name of the configuration set or the configuration set ARN to apply event logging to. The ConfigurateSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The name that identifies the event destination.
    /// This member is required.
    public var eventDestinationName: Swift.String?
    /// An object that contains information about an event destination for logging to Amazon Kinesis Data Firehose.
    public var kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
    /// An array of event types that determine which events to log. If "ALL" is used, then Amazon Pinpoint logs every event type. The TEXT_SENT event type is not supported.
    /// This member is required.
    public var matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
    /// An object that contains information about an event destination for logging to Amazon SNS.
    public var snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?

    public init(
        clientToken: Swift.String? = nil,
        cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination? = nil,
        configurationSetName: Swift.String? = nil,
        eventDestinationName: Swift.String? = nil,
        kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination? = nil,
        matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]? = nil,
        snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination? = nil
    )
    {
        self.clientToken = clientToken
        self.cloudWatchLogsDestination = cloudWatchLogsDestination
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.snsDestination = snsDestination
    }
}

struct CreateEventDestinationInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
    let eventDestinationName: Swift.String?
    let matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
    let cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
    let kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
    let snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?
    let clientToken: Swift.String?
}

extension CreateEventDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[PinpointSMSVoiceV2ClientTypes.EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [PinpointSMSVoiceV2ClientTypes.EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let cloudWatchLogsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination.self, forKey: .cloudWatchLogsDestination)
        cloudWatchLogsDestination = cloudWatchLogsDestinationDecoded
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateEventDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEventDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.eventDestination = output.eventDestination
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.eventDestination = nil
        }
    }
}

public struct CreateEventDestinationOutput: Swift.Equatable {
    /// The ARN of the configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set.
    public var configurationSetName: Swift.String?
    /// The details of the destination where events are logged.
    public var eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
    }
}

struct CreateEventDestinationOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?
}

extension CreateEventDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case eventDestination = "EventDestination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.EventDestination.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

enum CreateEventDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateOptOutListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case optOutListName = "OptOutListName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateOptOutListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateOptOutListInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The name of the new OptOutList.
    /// This member is required.
    public var optOutListName: Swift.String?
    /// An array of tags (key and value pairs) to associate with the new OptOutList.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.optOutListName = optOutListName
        self.tags = tags
    }
}

struct CreateOptOutListInputBody: Swift.Equatable {
    let optOutListName: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateOptOutListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case optOutListName = "OptOutListName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateOptOutListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateOptOutListOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.optOutListArn = output.optOutListArn
            self.optOutListName = output.optOutListName
            self.tags = output.tags
        } else {
            self.createdTimestamp = nil
            self.optOutListArn = nil
            self.optOutListName = nil
            self.tags = nil
        }
    }
}

public struct CreateOptOutListOutput: Swift.Equatable {
    /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the OptOutList.
    public var optOutListArn: Swift.String?
    /// The name of the new OptOutList.
    public var optOutListName: Swift.String?
    /// An array of tags (key and value pairs) associated with the new OptOutList.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
        self.tags = tags
    }
}

struct CreateOptOutListOutputBody: Swift.Equatable {
    let optOutListArn: Swift.String?
    let optOutListName: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
}

extension CreateOptOutListOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case optOutListArn = "OptOutListArn"
        case optOutListName = "OptOutListName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListArn)
        optOutListArn = optOutListArnDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum CreateOptOutListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case originationIdentity = "OriginationIdentity"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deletionProtectionEnabled = self.deletionProtectionEnabled {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePoolInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// By default this is set to false. When set to true the pool can't be deleted. You can change this value using the [UpdatePool] action.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The new two-character code, in ISO 3166-1 alpha-2 format, for the country or region of the new pool.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use [DescribePhoneNumbers] to find the values for PhoneNumberId and PhoneNumberArn while [DescribeSenderIds] can be used to get the values for SenderId and SenderIdArn.
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// An array of tags (key and value pairs) associated with the pool.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        deletionProtectionEnabled: Swift.Bool? = nil,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        originationIdentity: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.originationIdentity = originationIdentity
        self.tags = tags
    }
}

struct CreatePoolInputBody: Swift.Equatable {
    let originationIdentity: Swift.String?
    let isoCountryCode: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let deletionProtectionEnabled: Swift.Bool?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreatePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case originationIdentity = "OriginationIdentity"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled)
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePoolOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.deletionProtectionEnabled = output.deletionProtectionEnabled
            self.messageType = output.messageType
            self.optOutListName = output.optOutListName
            self.poolArn = output.poolArn
            self.poolId = output.poolId
            self.selfManagedOptOutsEnabled = output.selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = output.sharedRoutesEnabled
            self.status = output.status
            self.tags = output.tags
            self.twoWayChannelArn = output.twoWayChannelArn
            self.twoWayChannelRole = output.twoWayChannelRole
            self.twoWayEnabled = output.twoWayEnabled
        } else {
            self.createdTimestamp = nil
            self.deletionProtectionEnabled = false
            self.messageType = nil
            self.optOutListName = nil
            self.poolArn = nil
            self.poolId = nil
            self.selfManagedOptOutsEnabled = false
            self.sharedRoutesEnabled = false
            self.status = nil
            self.tags = nil
            self.twoWayChannelArn = nil
            self.twoWayChannelRole = nil
            self.twoWayEnabled = false
        }
    }
}

public struct CreatePoolOutput: Swift.Equatable {
    /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// When set to true deletion protection is enabled. By default this is set to false.
    public var deletionProtectionEnabled: Swift.Bool
    /// The type of message for the pool to use.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The name of the OptOutList associated with the pool.
    public var optOutListName: Swift.String?
    /// The Amazon Resource Name (ARN) for the pool.
    public var poolArn: Swift.String?
    /// The unique identifier for the pool.
    public var poolId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// Indicates whether shared routes are enabled for the pool.
    public var sharedRoutesEnabled: Swift.Bool
    /// The current status of the pool.
    ///
    /// * CREATING: The pool is currently being created and isn't yet available for use.
    ///
    /// * ACTIVE: The pool is active and available for use.
    ///
    /// * DELETING: The pool is being deleted.
    public var status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    /// An array of tags (key and value pairs) associated with the pool.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        optOutListName: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        sharedRoutesEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.PoolStatus? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.messageType = messageType
        self.optOutListName = optOutListName
        self.poolArn = poolArn
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.sharedRoutesEnabled = sharedRoutesEnabled
        self.status = status
        self.tags = tags
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

struct CreatePoolOutputBody: Swift.Equatable {
    let poolArn: Swift.String?
    let poolId: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let twoWayEnabled: Swift.Bool
    let twoWayChannelArn: Swift.String?
    let twoWayChannelRole: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool
    let optOutListName: Swift.String?
    let sharedRoutesEnabled: Swift.Bool
    let deletionProtectionEnabled: Swift.Bool
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
}

extension CreatePoolOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case messageType = "MessageType"
        case optOutListName = "OptOutListName"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case sharedRoutesEnabled = "SharedRoutesEnabled"
        case status = "Status"
        case tags = "Tags"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayChannelRole = "TwoWayChannelRole"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PoolStatus.self, forKey: .status)
        status = statusDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let twoWayChannelRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelRole)
        twoWayChannelRole = twoWayChannelRoleDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let sharedRoutesEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharedRoutesEnabled) ?? false
        sharedRoutesEnabled = sharedRoutesEnabledDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum CreatePoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRegistrationAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationId = "RegistrationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension CreateRegistrationAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRegistrationAssociationInput: Swift.Equatable {
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The unique identifier for the origination identity. For example this could be a PhoneNumberId or SenderId.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        registrationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.registrationId = registrationId
        self.resourceId = resourceId
    }
}

struct CreateRegistrationAssociationInputBody: Swift.Equatable {
    let registrationId: Swift.String?
    let resourceId: Swift.String?
}

extension CreateRegistrationAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationId = "RegistrationId"
        case resourceId = "ResourceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension CreateRegistrationAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRegistrationAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.isoCountryCode = output.isoCountryCode
            self.phoneNumber = output.phoneNumber
            self.registrationArn = output.registrationArn
            self.registrationId = output.registrationId
            self.registrationType = output.registrationType
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.isoCountryCode = nil
            self.phoneNumber = nil
            self.registrationArn = nil
            self.registrationId = nil
            self.registrationType = nil
            self.resourceArn = nil
            self.resourceId = nil
            self.resourceType = nil
        }
    }
}

public struct CreateRegistrationAssociationOutput: Swift.Equatable {
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The phone number associated with the registration in E.164 format.
    public var phoneNumber: Swift.String?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?
    /// The Amazon Resource Name (ARN) of the origination identity that is associated with the registration.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The unique identifier for the origination identity. For example this could be a PhoneNumberId or SenderId.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The registration type or origination identity type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        isoCountryCode: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationType: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.phoneNumber = phoneNumber
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationType = registrationType
        self.resourceArn = resourceArn
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct CreateRegistrationAssociationOutputBody: Swift.Equatable {
    let registrationArn: Swift.String?
    let registrationId: Swift.String?
    let registrationType: Swift.String?
    let resourceArn: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let isoCountryCode: Swift.String?
    let phoneNumber: Swift.String?
}

extension CreateRegistrationAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case phoneNumber = "PhoneNumber"
        case registrationArn = "RegistrationArn"
        case registrationId = "RegistrationId"
        case registrationType = "RegistrationType"
        case resourceArn = "ResourceArn"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationArn)
        registrationArn = registrationArnDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let registrationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationType)
        registrationType = registrationTypeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

enum CreateRegistrationAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRegistrationAttachmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentBody = "AttachmentBody"
        case attachmentUrl = "AttachmentUrl"
        case clientToken = "ClientToken"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentBody = self.attachmentBody {
            try encodeContainer.encode(attachmentBody.base64EncodedString(), forKey: .attachmentBody)
        }
        if let attachmentUrl = self.attachmentUrl {
            try encodeContainer.encode(attachmentUrl, forKey: .attachmentUrl)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateRegistrationAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRegistrationAttachmentInput: Swift.Equatable {
    /// The registration file to upload. The maximum file size is 1MiB and valid file extensions are PDF, JPEG and PNG.
    public var attachmentBody: ClientRuntime.Data?
    /// A URL to the required registration file. For example, you can provide the S3 object URL.
    public var attachmentUrl: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// An array of tags (key and value pairs) to associate with the registration attachment.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        attachmentBody: ClientRuntime.Data? = nil,
        attachmentUrl: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.attachmentBody = attachmentBody
        self.attachmentUrl = attachmentUrl
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateRegistrationAttachmentInputBody: Swift.Equatable {
    let attachmentBody: ClientRuntime.Data?
    let attachmentUrl: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateRegistrationAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentBody = "AttachmentBody"
        case attachmentUrl = "AttachmentUrl"
        case clientToken = "ClientToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentBodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .attachmentBody)
        attachmentBody = attachmentBodyDecoded
        let attachmentUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentUrl)
        attachmentUrl = attachmentUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateRegistrationAttachmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRegistrationAttachmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachmentStatus = output.attachmentStatus
            self.createdTimestamp = output.createdTimestamp
            self.registrationAttachmentArn = output.registrationAttachmentArn
            self.registrationAttachmentId = output.registrationAttachmentId
            self.tags = output.tags
        } else {
            self.attachmentStatus = nil
            self.createdTimestamp = nil
            self.registrationAttachmentArn = nil
            self.registrationAttachmentId = nil
            self.tags = nil
        }
    }
}

public struct CreateRegistrationAttachmentOutput: Swift.Equatable {
    /// The status of the registration attachment.
    ///
    /// * UPLOAD_IN_PROGRESS The attachment is being uploaded.
    ///
    /// * UPLOAD_COMPLETE The attachment has been uploaded.
    ///
    /// * UPLOAD_FAILED The attachment failed to uploaded.
    ///
    /// * DELETED The attachment has been deleted..
    /// This member is required.
    public var attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus?
    /// The time when the registration attachment was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the registration attachment.
    /// This member is required.
    public var registrationAttachmentArn: Swift.String?
    /// The unique identifier for the registration attachment.
    /// This member is required.
    public var registrationAttachmentId: Swift.String?
    /// An array of tags (key and value pairs) to associate with the registration attachment.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        registrationAttachmentArn: Swift.String? = nil,
        registrationAttachmentId: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.attachmentStatus = attachmentStatus
        self.createdTimestamp = createdTimestamp
        self.registrationAttachmentArn = registrationAttachmentArn
        self.registrationAttachmentId = registrationAttachmentId
        self.tags = tags
    }
}

struct CreateRegistrationAttachmentOutputBody: Swift.Equatable {
    let registrationAttachmentArn: Swift.String?
    let registrationAttachmentId: Swift.String?
    let attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
}

extension CreateRegistrationAttachmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentStatus = "AttachmentStatus"
        case createdTimestamp = "CreatedTimestamp"
        case registrationAttachmentArn = "RegistrationAttachmentArn"
        case registrationAttachmentId = "RegistrationAttachmentId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationAttachmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationAttachmentArn)
        registrationAttachmentArn = registrationAttachmentArnDecoded
        let registrationAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationAttachmentId)
        registrationAttachmentId = registrationAttachmentIdDecoded
        let attachmentStatusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.AttachmentStatus.self, forKey: .attachmentStatus)
        attachmentStatus = attachmentStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum CreateRegistrationAttachmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRegistrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case registrationType = "RegistrationType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let registrationType = self.registrationType {
            try encodeContainer.encode(registrationType, forKey: .registrationType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateRegistrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRegistrationInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The type of registration form to create. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?
    /// An array of tags (key and value pairs) to associate with the registration.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        registrationType: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.registrationType = registrationType
        self.tags = tags
    }
}

struct CreateRegistrationInputBody: Swift.Equatable {
    let registrationType: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateRegistrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case registrationType = "RegistrationType"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationType)
        registrationType = registrationTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateRegistrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRegistrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.additionalAttributes = output.additionalAttributes
            self.createdTimestamp = output.createdTimestamp
            self.currentVersionNumber = output.currentVersionNumber
            self.registrationArn = output.registrationArn
            self.registrationId = output.registrationId
            self.registrationStatus = output.registrationStatus
            self.registrationType = output.registrationType
            self.tags = output.tags
        } else {
            self.additionalAttributes = nil
            self.createdTimestamp = nil
            self.currentVersionNumber = nil
            self.registrationArn = nil
            self.registrationId = nil
            self.registrationStatus = nil
            self.registrationType = nil
            self.tags = nil
        }
    }
}

public struct CreateRegistrationOutput: Swift.Equatable {
    /// Metadata about a given registration which is specific to that registration type.
    public var additionalAttributes: [Swift.String:Swift.String]?
    /// The time when the registration was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: ClientRuntime.Date?
    /// The current version number of the registration.
    /// This member is required.
    public var currentVersionNumber: Swift.Int?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The status of the registration.
    ///
    /// * CREATED: Your registration is created but not submitted.
    ///
    /// * SUBMITTED: Your registration has been submitted and is awaiting review.
    ///
    /// * REVIEWING: Your registration has been accepted and is being reviewed.
    ///
    /// * PROVISIONING: Your registration has been approved and your origination identity is being created.
    ///
    /// * COMPLETE: Your registration has been approved and and your origination identity has been created.
    ///
    /// * REQUIRES_UPDATES: You must fix your registration and resubmit it.
    ///
    /// * CLOSED: The phone number or sender ID has been deleted and you must also delete the registration for the number.
    ///
    /// * DELETED: The registration has been deleted.
    /// This member is required.
    public var registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus?
    /// The type of registration form to create. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?
    /// An array of tags (key and value pairs) to associate with the registration.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        additionalAttributes: [Swift.String:Swift.String]? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        currentVersionNumber: Swift.Int? = nil,
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus? = nil,
        registrationType: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.additionalAttributes = additionalAttributes
        self.createdTimestamp = createdTimestamp
        self.currentVersionNumber = currentVersionNumber
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationStatus = registrationStatus
        self.registrationType = registrationType
        self.tags = tags
    }
}

struct CreateRegistrationOutputBody: Swift.Equatable {
    let registrationArn: Swift.String?
    let registrationId: Swift.String?
    let registrationType: Swift.String?
    let registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus?
    let currentVersionNumber: Swift.Int?
    let additionalAttributes: [Swift.String:Swift.String]?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
}

extension CreateRegistrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAttributes = "AdditionalAttributes"
        case createdTimestamp = "CreatedTimestamp"
        case currentVersionNumber = "CurrentVersionNumber"
        case registrationArn = "RegistrationArn"
        case registrationId = "RegistrationId"
        case registrationStatus = "RegistrationStatus"
        case registrationType = "RegistrationType"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationArn)
        registrationArn = registrationArnDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let registrationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationType)
        registrationType = registrationTypeDecoded
        let registrationStatusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationStatus.self, forKey: .registrationStatus)
        registrationStatus = registrationStatusDecoded
        let currentVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentVersionNumber)
        currentVersionNumber = currentVersionNumberDecoded
        let additionalAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalAttributes)
        var additionalAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalAttributesContainer = additionalAttributesContainer {
            additionalAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in additionalAttributesContainer {
                if let string0 = string0 {
                    additionalAttributesDecoded0?[key0] = string0
                }
            }
        }
        additionalAttributes = additionalAttributesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum CreateRegistrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRegistrationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationId = "RegistrationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
    }
}

extension CreateRegistrationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRegistrationVersionInput: Swift.Equatable {
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?

    public init(
        registrationId: Swift.String? = nil
    )
    {
        self.registrationId = registrationId
    }
}

struct CreateRegistrationVersionInputBody: Swift.Equatable {
    let registrationId: Swift.String?
}

extension CreateRegistrationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationId = "RegistrationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
    }
}

extension CreateRegistrationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRegistrationVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.registrationArn = output.registrationArn
            self.registrationId = output.registrationId
            self.registrationVersionStatus = output.registrationVersionStatus
            self.registrationVersionStatusHistory = output.registrationVersionStatusHistory
            self.versionNumber = output.versionNumber
        } else {
            self.registrationArn = nil
            self.registrationId = nil
            self.registrationVersionStatus = nil
            self.registrationVersionStatusHistory = nil
            self.versionNumber = nil
        }
    }
}

public struct CreateRegistrationVersionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The status of the registration.
    ///
    /// * DRAFT: The initial status of a registration version after it’s created.
    ///
    /// * SUBMITTED: Your registration has been submitted.
    ///
    /// * REVIEWING: Your registration has been accepted and is being reviewed.
    ///
    /// * APPROVED: Your registration has been approved.
    ///
    /// * DISCARDED: You've abandon this version of their registration to start over with a new version.
    ///
    /// * DENIED: You must fix your registration and resubmit it.
    ///
    /// * REVOKED: Your previously approved registration has been revoked.
    ///
    /// * ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.
    /// This member is required.
    public var registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus?
    /// A RegistrationVersionStatusHistory object that contains timestamps for the registration.
    /// This member is required.
    public var registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory?
    /// The new version number of the registration.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus? = nil,
        registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationVersionStatus = registrationVersionStatus
        self.registrationVersionStatusHistory = registrationVersionStatusHistory
        self.versionNumber = versionNumber
    }
}

struct CreateRegistrationVersionOutputBody: Swift.Equatable {
    let registrationArn: Swift.String?
    let registrationId: Swift.String?
    let versionNumber: Swift.Int?
    let registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus?
    let registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory?
}

extension CreateRegistrationVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationArn = "RegistrationArn"
        case registrationId = "RegistrationId"
        case registrationVersionStatus = "RegistrationVersionStatus"
        case registrationVersionStatusHistory = "RegistrationVersionStatusHistory"
        case versionNumber = "VersionNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationArn)
        registrationArn = registrationArnDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let registrationVersionStatusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus.self, forKey: .registrationVersionStatus)
        registrationVersionStatus = registrationVersionStatusDecoded
        let registrationVersionStatusHistoryDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory.self, forKey: .registrationVersionStatusHistory)
        registrationVersionStatusHistory = registrationVersionStatusHistoryDecoded
    }
}

enum CreateRegistrationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVerifiedDestinationNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destinationPhoneNumber = self.destinationPhoneNumber {
            try encodeContainer.encode(destinationPhoneNumber, forKey: .destinationPhoneNumber)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateVerifiedDestinationNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVerifiedDestinationNumberInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The verified destination phone number, in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// An array of tags (key and value pairs) to associate with the destination number.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.destinationPhoneNumber = destinationPhoneNumber
        self.tags = tags
    }
}

struct CreateVerifiedDestinationNumberInputBody: Swift.Equatable {
    let destinationPhoneNumber: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension CreateVerifiedDestinationNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVerifiedDestinationNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVerifiedDestinationNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.destinationPhoneNumber = output.destinationPhoneNumber
            self.status = output.status
            self.tags = output.tags
            self.verifiedDestinationNumberArn = output.verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = output.verifiedDestinationNumberId
        } else {
            self.createdTimestamp = nil
            self.destinationPhoneNumber = nil
            self.status = nil
            self.tags = nil
            self.verifiedDestinationNumberArn = nil
            self.verifiedDestinationNumberId = nil
        }
    }
}

public struct CreateVerifiedDestinationNumberOutput: Swift.Equatable {
    /// The time when the verified phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: ClientRuntime.Date?
    /// The verified destination phone number, in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// The status of the verified destination phone number.
    ///
    /// * PENDING: The phone number hasn't been verified yet.
    ///
    /// * VERIFIED: The phone number is verified and can receive messages.
    /// This member is required.
    public var status: PinpointSMSVoiceV2ClientTypes.VerificationStatus?
    /// An array of tags (key and value pairs) to associate with the destination number.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberArn: Swift.String?
    /// The unique identifier for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberId: Swift.String?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        status: PinpointSMSVoiceV2ClientTypes.VerificationStatus? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil,
        verifiedDestinationNumberArn: Swift.String? = nil,
        verifiedDestinationNumberId: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinationPhoneNumber = destinationPhoneNumber
        self.status = status
        self.tags = tags
        self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
        self.verifiedDestinationNumberId = verifiedDestinationNumberId
    }
}

struct CreateVerifiedDestinationNumberOutputBody: Swift.Equatable {
    let verifiedDestinationNumberArn: Swift.String?
    let verifiedDestinationNumberId: Swift.String?
    let destinationPhoneNumber: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.VerificationStatus?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
}

extension CreateVerifiedDestinationNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case status = "Status"
        case tags = "Tags"
        case verifiedDestinationNumberArn = "VerifiedDestinationNumberArn"
        case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verifiedDestinationNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedDestinationNumberArn)
        verifiedDestinationNumberArn = verifiedDestinationNumberArnDecoded
        let verifiedDestinationNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedDestinationNumberId)
        verifiedDestinationNumberId = verifiedDestinationNumberIdDecoded
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.VerificationStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum CreateVerifiedDestinationNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConfigurationSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
    }
}

extension DeleteConfigurationSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConfigurationSetInput: Swift.Equatable {
    /// The name of the configuration set or the configuration set ARN that you want to delete. The ConfigurationSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct DeleteConfigurationSetInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
}

extension DeleteConfigurationSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension DeleteConfigurationSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteConfigurationSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.createdTimestamp = output.createdTimestamp
            self.defaultMessageType = output.defaultMessageType
            self.defaultSenderId = output.defaultSenderId
            self.eventDestinations = output.eventDestinations
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.createdTimestamp = nil
            self.defaultMessageType = nil
            self.defaultSenderId = nil
            self.eventDestinations = nil
        }
    }
}

public struct DeleteConfigurationSetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the deleted configuration set.
    public var configurationSetName: Swift.String?
    /// The time that the deleted configuration set was created in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The default message type of the configuration set that was deleted.
    public var defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The default Sender ID of the configuration set that was deleted.
    public var defaultSenderId: Swift.String?
    /// An array of any EventDestination objects that were associated with the deleted configuration set.
    public var eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        defaultSenderId: Swift.String? = nil,
        eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.createdTimestamp = createdTimestamp
        self.defaultMessageType = defaultMessageType
        self.defaultSenderId = defaultSenderId
        self.eventDestinations = eventDestinations
    }
}

struct DeleteConfigurationSetOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]?
    let defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let defaultSenderId: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
}

extension DeleteConfigurationSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case createdTimestamp = "CreatedTimestamp"
        case defaultMessageType = "DefaultMessageType"
        case defaultSenderId = "DefaultSenderId"
        case eventDestinations = "EventDestinations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.EventDestination?].self, forKey: .eventDestinations)
        var eventDestinationsDecoded0:[PinpointSMSVoiceV2ClientTypes.EventDestination]? = nil
        if let eventDestinationsContainer = eventDestinationsContainer {
            eventDestinationsDecoded0 = [PinpointSMSVoiceV2ClientTypes.EventDestination]()
            for structure0 in eventDestinationsContainer {
                if let structure0 = structure0 {
                    eventDestinationsDecoded0?.append(structure0)
                }
            }
        }
        eventDestinations = eventDestinationsDecoded0
        let defaultMessageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .defaultMessageType)
        defaultMessageType = defaultMessageTypeDecoded
        let defaultSenderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSenderId)
        defaultSenderId = defaultSenderIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum DeleteConfigurationSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDefaultMessageTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
    }
}

extension DeleteDefaultMessageTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDefaultMessageTypeInput: Swift.Equatable {
    /// The name of the configuration set or the configuration set Amazon Resource Name (ARN) to delete the default message type from. The ConfigurationSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct DeleteDefaultMessageTypeInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
}

extension DeleteDefaultMessageTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension DeleteDefaultMessageTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDefaultMessageTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.messageType = output.messageType
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.messageType = nil
        }
    }
}

public struct DeleteDefaultMessageTypeOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set.
    public var configurationSetName: Swift.String?
    /// The current message type for the configuration set.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.messageType = messageType
    }
}

struct DeleteDefaultMessageTypeOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
}

extension DeleteDefaultMessageTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case messageType = "MessageType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
    }
}

enum DeleteDefaultMessageTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDefaultSenderIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
    }
}

extension DeleteDefaultSenderIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDefaultSenderIdInput: Swift.Equatable {
    /// The name of the configuration set or the configuration set Amazon Resource Name (ARN) to delete the default sender ID from. The ConfigurationSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct DeleteDefaultSenderIdInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
}

extension DeleteDefaultSenderIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension DeleteDefaultSenderIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDefaultSenderIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.senderId = output.senderId
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.senderId = nil
        }
    }
}

public struct DeleteDefaultSenderIdOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set.
    public var configurationSetName: Swift.String?
    /// The current sender ID for the configuration set.
    public var senderId: Swift.String?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.senderId = senderId
    }
}

struct DeleteDefaultSenderIdOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let senderId: Swift.String?
}

extension DeleteDefaultSenderIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case senderId = "SenderId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
    }
}

enum DeleteDefaultSenderIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let eventDestinationName = self.eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
    }
}

extension DeleteEventDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEventDestinationInput: Swift.Equatable {
    /// The name of the configuration set or the configuration set's Amazon Resource Name (ARN) to remove the event destination from. The ConfigurateSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The name of the event destination to delete.
    /// This member is required.
    public var eventDestinationName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        eventDestinationName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
    }
}

struct DeleteEventDestinationInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
    let eventDestinationName: Swift.String?
}

extension DeleteEventDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
    }
}

extension DeleteEventDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEventDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.eventDestination = output.eventDestination
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.eventDestination = nil
        }
    }
}

public struct DeleteEventDestinationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set the event destination was deleted from.
    public var configurationSetName: Swift.String?
    /// The event destination object that was deleted.
    public var eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
    }
}

struct DeleteEventDestinationOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?
}

extension DeleteEventDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case eventDestination = "EventDestination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.EventDestination.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

enum DeleteEventDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKeywordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case originationIdentity = "OriginationIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyword = self.keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
    }
}

extension DeleteKeywordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteKeywordInput: Swift.Equatable {
    /// The keyword to delete.
    /// This member is required.
    public var keyword: Swift.String?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, PoolId or PoolArn. You can use [DescribePhoneNumbers] to find the values for PhoneNumberId and PhoneNumberArn and [DescribePools] to find the values of PoolId and PoolArn.
    /// This member is required.
    public var originationIdentity: Swift.String?

    public init(
        keyword: Swift.String? = nil,
        originationIdentity: Swift.String? = nil
    )
    {
        self.keyword = keyword
        self.originationIdentity = originationIdentity
    }
}

struct DeleteKeywordInputBody: Swift.Equatable {
    let originationIdentity: Swift.String?
    let keyword: Swift.String?
}

extension DeleteKeywordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case originationIdentity = "OriginationIdentity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
    }
}

extension DeleteKeywordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteKeywordOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyword = output.keyword
            self.keywordAction = output.keywordAction
            self.keywordMessage = output.keywordMessage
            self.originationIdentity = output.originationIdentity
            self.originationIdentityArn = output.originationIdentityArn
        } else {
            self.keyword = nil
            self.keywordAction = nil
            self.keywordMessage = nil
            self.originationIdentity = nil
            self.originationIdentityArn = nil
        }
    }
}

public struct DeleteKeywordOutput: Swift.Equatable {
    /// The keyword that was deleted.
    public var keyword: Swift.String?
    /// The action that was associated with the deleted keyword.
    public var keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
    /// The message that was associated with the deleted keyword.
    public var keywordMessage: Swift.String?
    /// The PhoneNumberId or PoolId that the keyword was associated with.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or PoolArn that the keyword was associated with.
    public var originationIdentityArn: Swift.String?

    public init(
        keyword: Swift.String? = nil,
        keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction? = nil,
        keywordMessage: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil
    )
    {
        self.keyword = keyword
        self.keywordAction = keywordAction
        self.keywordMessage = keywordMessage
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
    }
}

struct DeleteKeywordOutputBody: Swift.Equatable {
    let originationIdentityArn: Swift.String?
    let originationIdentity: Swift.String?
    let keyword: Swift.String?
    let keywordMessage: Swift.String?
    let keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
}

extension DeleteKeywordOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case keywordAction = "KeywordAction"
        case keywordMessage = "KeywordMessage"
        case originationIdentity = "OriginationIdentity"
        case originationIdentityArn = "OriginationIdentityArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentityArn)
        originationIdentityArn = originationIdentityArnDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
        let keywordMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywordMessage)
        keywordMessage = keywordMessageDecoded
        let keywordActionDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KeywordAction.self, forKey: .keywordAction)
        keywordAction = keywordActionDecoded
    }
}

enum DeleteKeywordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteOptOutListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optOutListName = "OptOutListName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
    }
}

extension DeleteOptOutListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOptOutListInput: Swift.Equatable {
    /// The OptOutListName or OptOutListArn of the OptOutList to delete. You can use [DescribeOptOutLists] to find the values for OptOutListName and OptOutListArn.
    /// This member is required.
    public var optOutListName: Swift.String?

    public init(
        optOutListName: Swift.String? = nil
    )
    {
        self.optOutListName = optOutListName
    }
}

struct DeleteOptOutListInputBody: Swift.Equatable {
    let optOutListName: Swift.String?
}

extension DeleteOptOutListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optOutListName = "OptOutListName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
    }
}

extension DeleteOptOutListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteOptOutListOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.optOutListArn = output.optOutListArn
            self.optOutListName = output.optOutListName
        } else {
            self.createdTimestamp = nil
            self.optOutListArn = nil
            self.optOutListName = nil
        }
    }
}

public struct DeleteOptOutListOutput: Swift.Equatable {
    /// The time when the OptOutList was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the OptOutList that was removed.
    public var optOutListArn: Swift.String?
    /// The name of the OptOutList that was removed.
    public var optOutListName: Swift.String?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
    }
}

struct DeleteOptOutListOutputBody: Swift.Equatable {
    let optOutListArn: Swift.String?
    let optOutListName: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
}

extension DeleteOptOutListOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case optOutListArn = "OptOutListArn"
        case optOutListName = "OptOutListName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListArn)
        optOutListArn = optOutListArnDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum DeleteOptOutListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteOptedOutNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optOutListName = "OptOutListName"
        case optedOutNumber = "OptedOutNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let optedOutNumber = self.optedOutNumber {
            try encodeContainer.encode(optedOutNumber, forKey: .optedOutNumber)
        }
    }
}

extension DeleteOptedOutNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOptedOutNumberInput: Swift.Equatable {
    /// The OptOutListName or OptOutListArn to remove the phone number from.
    /// This member is required.
    public var optOutListName: Swift.String?
    /// The phone number, in E.164 format, to remove from the OptOutList.
    /// This member is required.
    public var optedOutNumber: Swift.String?

    public init(
        optOutListName: Swift.String? = nil,
        optedOutNumber: Swift.String? = nil
    )
    {
        self.optOutListName = optOutListName
        self.optedOutNumber = optedOutNumber
    }
}

struct DeleteOptedOutNumberInputBody: Swift.Equatable {
    let optOutListName: Swift.String?
    let optedOutNumber: Swift.String?
}

extension DeleteOptedOutNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optOutListName = "OptOutListName"
        case optedOutNumber = "OptedOutNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let optedOutNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optedOutNumber)
        optedOutNumber = optedOutNumberDecoded
    }
}

extension DeleteOptedOutNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteOptedOutNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.endUserOptedOut = output.endUserOptedOut
            self.optOutListArn = output.optOutListArn
            self.optOutListName = output.optOutListName
            self.optedOutNumber = output.optedOutNumber
            self.optedOutTimestamp = output.optedOutTimestamp
        } else {
            self.endUserOptedOut = false
            self.optOutListArn = nil
            self.optOutListName = nil
            self.optedOutNumber = nil
            self.optedOutTimestamp = nil
        }
    }
}

public struct DeleteOptedOutNumberOutput: Swift.Equatable {
    /// This is true if it was the end user who requested their phone number be removed.
    public var endUserOptedOut: Swift.Bool
    /// The OptOutListArn that the phone number was removed from.
    public var optOutListArn: Swift.String?
    /// The OptOutListName that the phone number was removed from.
    public var optOutListName: Swift.String?
    /// The phone number that was removed from the OptOutList.
    public var optedOutNumber: Swift.String?
    /// The time that the number was removed at, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var optedOutTimestamp: ClientRuntime.Date?

    public init(
        endUserOptedOut: Swift.Bool = false,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        optedOutNumber: Swift.String? = nil,
        optedOutTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.endUserOptedOut = endUserOptedOut
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
        self.optedOutNumber = optedOutNumber
        self.optedOutTimestamp = optedOutTimestamp
    }
}

struct DeleteOptedOutNumberOutputBody: Swift.Equatable {
    let optOutListArn: Swift.String?
    let optOutListName: Swift.String?
    let optedOutNumber: Swift.String?
    let optedOutTimestamp: ClientRuntime.Date?
    let endUserOptedOut: Swift.Bool
}

extension DeleteOptedOutNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endUserOptedOut = "EndUserOptedOut"
        case optOutListArn = "OptOutListArn"
        case optOutListName = "OptOutListName"
        case optedOutNumber = "OptedOutNumber"
        case optedOutTimestamp = "OptedOutTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListArn)
        optOutListArn = optOutListArnDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let optedOutNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optedOutNumber)
        optedOutNumber = optedOutNumberDecoded
        let optedOutTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .optedOutTimestamp)
        optedOutTimestamp = optedOutTimestampDecoded
        let endUserOptedOutDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .endUserOptedOut) ?? false
        endUserOptedOut = endUserOptedOutDecoded
    }
}

enum DeleteOptedOutNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolId = "PoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
    }
}

extension DeletePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePoolInput: Swift.Equatable {
    /// The PoolId or PoolArn of the pool to delete. You can use [DescribePools] to find the values for PoolId and PoolArn .
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        poolId: Swift.String? = nil
    )
    {
        self.poolId = poolId
    }
}

struct DeletePoolInputBody: Swift.Equatable {
    let poolId: Swift.String?
}

extension DeletePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
    }
}

extension DeletePoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePoolOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.messageType = output.messageType
            self.optOutListName = output.optOutListName
            self.poolArn = output.poolArn
            self.poolId = output.poolId
            self.selfManagedOptOutsEnabled = output.selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = output.sharedRoutesEnabled
            self.status = output.status
            self.twoWayChannelArn = output.twoWayChannelArn
            self.twoWayChannelRole = output.twoWayChannelRole
            self.twoWayEnabled = output.twoWayEnabled
        } else {
            self.createdTimestamp = nil
            self.messageType = nil
            self.optOutListName = nil
            self.poolArn = nil
            self.poolId = nil
            self.selfManagedOptOutsEnabled = false
            self.sharedRoutesEnabled = false
            self.status = nil
            self.twoWayChannelArn = nil
            self.twoWayChannelRole = nil
            self.twoWayEnabled = false
        }
    }
}

public struct DeletePoolOutput: Swift.Equatable {
    /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The message type that was associated with the deleted pool.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The name of the OptOutList that was associated with the deleted pool.
    public var optOutListName: Swift.String?
    /// The Amazon Resource Name (ARN) of the pool that was deleted.
    public var poolArn: Swift.String?
    /// The PoolId of the pool that was deleted.
    public var poolId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// Indicates whether shared routes are enabled for the pool.
    public var sharedRoutesEnabled: Swift.Bool
    /// The current status of the pool.
    ///
    /// * CREATING: The pool is currently being created and isn't yet available for use.
    ///
    /// * ACTIVE: The pool is active and available for use.
    ///
    /// * DELETING: The pool is being deleted.
    public var status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    /// The Amazon Resource Name (ARN) of the TwoWayChannel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        optOutListName: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        sharedRoutesEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.PoolStatus? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.messageType = messageType
        self.optOutListName = optOutListName
        self.poolArn = poolArn
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.sharedRoutesEnabled = sharedRoutesEnabled
        self.status = status
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

struct DeletePoolOutputBody: Swift.Equatable {
    let poolArn: Swift.String?
    let poolId: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let twoWayEnabled: Swift.Bool
    let twoWayChannelArn: Swift.String?
    let twoWayChannelRole: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool
    let optOutListName: Swift.String?
    let sharedRoutesEnabled: Swift.Bool
    let createdTimestamp: ClientRuntime.Date?
}

extension DeletePoolOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case messageType = "MessageType"
        case optOutListName = "OptOutListName"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case sharedRoutesEnabled = "SharedRoutesEnabled"
        case status = "Status"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayChannelRole = "TwoWayChannelRole"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PoolStatus.self, forKey: .status)
        status = statusDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let twoWayChannelRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelRole)
        twoWayChannelRole = twoWayChannelRoleDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let sharedRoutesEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharedRoutesEnabled) ?? false
        sharedRoutesEnabled = sharedRoutesEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum DeletePoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRegistrationAttachmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationAttachmentId = "RegistrationAttachmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registrationAttachmentId = self.registrationAttachmentId {
            try encodeContainer.encode(registrationAttachmentId, forKey: .registrationAttachmentId)
        }
    }
}

extension DeleteRegistrationAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRegistrationAttachmentInput: Swift.Equatable {
    /// The unique identifier for the registration attachment.
    /// This member is required.
    public var registrationAttachmentId: Swift.String?

    public init(
        registrationAttachmentId: Swift.String? = nil
    )
    {
        self.registrationAttachmentId = registrationAttachmentId
    }
}

struct DeleteRegistrationAttachmentInputBody: Swift.Equatable {
    let registrationAttachmentId: Swift.String?
}

extension DeleteRegistrationAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationAttachmentId = "RegistrationAttachmentId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationAttachmentId)
        registrationAttachmentId = registrationAttachmentIdDecoded
    }
}

extension DeleteRegistrationAttachmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRegistrationAttachmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachmentStatus = output.attachmentStatus
            self.attachmentUploadErrorReason = output.attachmentUploadErrorReason
            self.createdTimestamp = output.createdTimestamp
            self.registrationAttachmentArn = output.registrationAttachmentArn
            self.registrationAttachmentId = output.registrationAttachmentId
        } else {
            self.attachmentStatus = nil
            self.attachmentUploadErrorReason = nil
            self.createdTimestamp = nil
            self.registrationAttachmentArn = nil
            self.registrationAttachmentId = nil
        }
    }
}

public struct DeleteRegistrationAttachmentOutput: Swift.Equatable {
    /// The status of the registration attachment.
    ///
    /// * UPLOAD_IN_PROGRESS The attachment is being uploaded.
    ///
    /// * UPLOAD_COMPLETE The attachment has been uploaded.
    ///
    /// * UPLOAD_FAILED The attachment failed to uploaded.
    ///
    /// * DELETED The attachment has been deleted..
    /// This member is required.
    public var attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus?
    /// The error message if the upload failed.
    public var attachmentUploadErrorReason: PinpointSMSVoiceV2ClientTypes.AttachmentUploadErrorReason?
    /// The time when the registration attachment was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the registration attachment.
    /// This member is required.
    public var registrationAttachmentArn: Swift.String?
    /// The unique identifier for the registration attachment.
    /// This member is required.
    public var registrationAttachmentId: Swift.String?

    public init(
        attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus? = nil,
        attachmentUploadErrorReason: PinpointSMSVoiceV2ClientTypes.AttachmentUploadErrorReason? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        registrationAttachmentArn: Swift.String? = nil,
        registrationAttachmentId: Swift.String? = nil
    )
    {
        self.attachmentStatus = attachmentStatus
        self.attachmentUploadErrorReason = attachmentUploadErrorReason
        self.createdTimestamp = createdTimestamp
        self.registrationAttachmentArn = registrationAttachmentArn
        self.registrationAttachmentId = registrationAttachmentId
    }
}

struct DeleteRegistrationAttachmentOutputBody: Swift.Equatable {
    let registrationAttachmentArn: Swift.String?
    let registrationAttachmentId: Swift.String?
    let attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus?
    let attachmentUploadErrorReason: PinpointSMSVoiceV2ClientTypes.AttachmentUploadErrorReason?
    let createdTimestamp: ClientRuntime.Date?
}

extension DeleteRegistrationAttachmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentStatus = "AttachmentStatus"
        case attachmentUploadErrorReason = "AttachmentUploadErrorReason"
        case createdTimestamp = "CreatedTimestamp"
        case registrationAttachmentArn = "RegistrationAttachmentArn"
        case registrationAttachmentId = "RegistrationAttachmentId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationAttachmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationAttachmentArn)
        registrationAttachmentArn = registrationAttachmentArnDecoded
        let registrationAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationAttachmentId)
        registrationAttachmentId = registrationAttachmentIdDecoded
        let attachmentStatusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.AttachmentStatus.self, forKey: .attachmentStatus)
        attachmentStatus = attachmentStatusDecoded
        let attachmentUploadErrorReasonDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.AttachmentUploadErrorReason.self, forKey: .attachmentUploadErrorReason)
        attachmentUploadErrorReason = attachmentUploadErrorReasonDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum DeleteRegistrationAttachmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRegistrationFieldValueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPath = "FieldPath"
        case registrationId = "RegistrationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldPath = self.fieldPath {
            try encodeContainer.encode(fieldPath, forKey: .fieldPath)
        }
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
    }
}

extension DeleteRegistrationFieldValueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRegistrationFieldValueInput: Swift.Equatable {
    /// The path to the registration form field. You can use [DescribeRegistrationFieldDefinitions] for a list of FieldPaths.
    /// This member is required.
    public var fieldPath: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?

    public init(
        fieldPath: Swift.String? = nil,
        registrationId: Swift.String? = nil
    )
    {
        self.fieldPath = fieldPath
        self.registrationId = registrationId
    }
}

struct DeleteRegistrationFieldValueInputBody: Swift.Equatable {
    let registrationId: Swift.String?
    let fieldPath: Swift.String?
}

extension DeleteRegistrationFieldValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPath = "FieldPath"
        case registrationId = "RegistrationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let fieldPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldPath)
        fieldPath = fieldPathDecoded
    }
}

extension DeleteRegistrationFieldValueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRegistrationFieldValueOutputBody = try responseDecoder.decode(responseBody: data)
            self.fieldPath = output.fieldPath
            self.registrationArn = output.registrationArn
            self.registrationAttachmentId = output.registrationAttachmentId
            self.registrationId = output.registrationId
            self.selectChoices = output.selectChoices
            self.textValue = output.textValue
            self.versionNumber = output.versionNumber
        } else {
            self.fieldPath = nil
            self.registrationArn = nil
            self.registrationAttachmentId = nil
            self.registrationId = nil
            self.selectChoices = nil
            self.textValue = nil
            self.versionNumber = nil
        }
    }
}

public struct DeleteRegistrationFieldValueOutput: Swift.Equatable {
    /// The path to the registration form field.
    /// This member is required.
    public var fieldPath: Swift.String?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration attachment.
    public var registrationAttachmentId: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// An array of values for the form field.
    public var selectChoices: [Swift.String]?
    /// The text data for a free form field.
    public var textValue: Swift.String?
    /// The version number of the registration.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        fieldPath: Swift.String? = nil,
        registrationArn: Swift.String? = nil,
        registrationAttachmentId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        selectChoices: [Swift.String]? = nil,
        textValue: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.fieldPath = fieldPath
        self.registrationArn = registrationArn
        self.registrationAttachmentId = registrationAttachmentId
        self.registrationId = registrationId
        self.selectChoices = selectChoices
        self.textValue = textValue
        self.versionNumber = versionNumber
    }
}

struct DeleteRegistrationFieldValueOutputBody: Swift.Equatable {
    let registrationArn: Swift.String?
    let registrationId: Swift.String?
    let versionNumber: Swift.Int?
    let fieldPath: Swift.String?
    let selectChoices: [Swift.String]?
    let textValue: Swift.String?
    let registrationAttachmentId: Swift.String?
}

extension DeleteRegistrationFieldValueOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPath = "FieldPath"
        case registrationArn = "RegistrationArn"
        case registrationAttachmentId = "RegistrationAttachmentId"
        case registrationId = "RegistrationId"
        case selectChoices = "SelectChoices"
        case textValue = "TextValue"
        case versionNumber = "VersionNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationArn)
        registrationArn = registrationArnDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let fieldPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldPath)
        fieldPath = fieldPathDecoded
        let selectChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectChoices)
        var selectChoicesDecoded0:[Swift.String]? = nil
        if let selectChoicesContainer = selectChoicesContainer {
            selectChoicesDecoded0 = [Swift.String]()
            for string0 in selectChoicesContainer {
                if let string0 = string0 {
                    selectChoicesDecoded0?.append(string0)
                }
            }
        }
        selectChoices = selectChoicesDecoded0
        let textValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textValue)
        textValue = textValueDecoded
        let registrationAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationAttachmentId)
        registrationAttachmentId = registrationAttachmentIdDecoded
    }
}

enum DeleteRegistrationFieldValueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRegistrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationId = "RegistrationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
    }
}

extension DeleteRegistrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRegistrationInput: Swift.Equatable {
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?

    public init(
        registrationId: Swift.String? = nil
    )
    {
        self.registrationId = registrationId
    }
}

struct DeleteRegistrationInputBody: Swift.Equatable {
    let registrationId: Swift.String?
}

extension DeleteRegistrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationId = "RegistrationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
    }
}

extension DeleteRegistrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRegistrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.additionalAttributes = output.additionalAttributes
            self.approvedVersionNumber = output.approvedVersionNumber
            self.createdTimestamp = output.createdTimestamp
            self.currentVersionNumber = output.currentVersionNumber
            self.latestDeniedVersionNumber = output.latestDeniedVersionNumber
            self.registrationArn = output.registrationArn
            self.registrationId = output.registrationId
            self.registrationStatus = output.registrationStatus
            self.registrationType = output.registrationType
        } else {
            self.additionalAttributes = nil
            self.approvedVersionNumber = nil
            self.createdTimestamp = nil
            self.currentVersionNumber = nil
            self.latestDeniedVersionNumber = nil
            self.registrationArn = nil
            self.registrationId = nil
            self.registrationStatus = nil
            self.registrationType = nil
        }
    }
}

public struct DeleteRegistrationOutput: Swift.Equatable {
    /// Metadata about a given registration which is specific to that registration type.
    public var additionalAttributes: [Swift.String:Swift.String]?
    /// The version number of the registration that was approved.
    public var approvedVersionNumber: Swift.Int?
    /// The time when the registration was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: ClientRuntime.Date?
    /// The current version number of the registration.
    /// This member is required.
    public var currentVersionNumber: Swift.Int?
    /// The latest version number of the registration that was denied.
    public var latestDeniedVersionNumber: Swift.Int?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The status of the registration.
    ///
    /// * CREATED: Your registration is created but not submitted.
    ///
    /// * SUBMITTED: Your registration has been submitted and is awaiting review.
    ///
    /// * REVIEWING: Your registration has been accepted and is being reviewed.
    ///
    /// * PROVISIONING: Your registration has been approved and your origination identity is being created.
    ///
    /// * COMPLETE: Your registration has been approved and and your origination identity has been created.
    ///
    /// * REQUIRES_UPDATES: You must fix your registration and resubmit it.
    ///
    /// * CLOSED: The phone number or sender ID has been deleted and you must also delete the registration for the number.
    ///
    /// * DELETED: The registration has been deleted.
    /// This member is required.
    public var registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?

    public init(
        additionalAttributes: [Swift.String:Swift.String]? = nil,
        approvedVersionNumber: Swift.Int? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        currentVersionNumber: Swift.Int? = nil,
        latestDeniedVersionNumber: Swift.Int? = nil,
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus? = nil,
        registrationType: Swift.String? = nil
    )
    {
        self.additionalAttributes = additionalAttributes
        self.approvedVersionNumber = approvedVersionNumber
        self.createdTimestamp = createdTimestamp
        self.currentVersionNumber = currentVersionNumber
        self.latestDeniedVersionNumber = latestDeniedVersionNumber
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationStatus = registrationStatus
        self.registrationType = registrationType
    }
}

struct DeleteRegistrationOutputBody: Swift.Equatable {
    let registrationArn: Swift.String?
    let registrationId: Swift.String?
    let registrationType: Swift.String?
    let registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus?
    let currentVersionNumber: Swift.Int?
    let approvedVersionNumber: Swift.Int?
    let latestDeniedVersionNumber: Swift.Int?
    let additionalAttributes: [Swift.String:Swift.String]?
    let createdTimestamp: ClientRuntime.Date?
}

extension DeleteRegistrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAttributes = "AdditionalAttributes"
        case approvedVersionNumber = "ApprovedVersionNumber"
        case createdTimestamp = "CreatedTimestamp"
        case currentVersionNumber = "CurrentVersionNumber"
        case latestDeniedVersionNumber = "LatestDeniedVersionNumber"
        case registrationArn = "RegistrationArn"
        case registrationId = "RegistrationId"
        case registrationStatus = "RegistrationStatus"
        case registrationType = "RegistrationType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationArn)
        registrationArn = registrationArnDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let registrationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationType)
        registrationType = registrationTypeDecoded
        let registrationStatusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationStatus.self, forKey: .registrationStatus)
        registrationStatus = registrationStatusDecoded
        let currentVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentVersionNumber)
        currentVersionNumber = currentVersionNumberDecoded
        let approvedVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approvedVersionNumber)
        approvedVersionNumber = approvedVersionNumberDecoded
        let latestDeniedVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latestDeniedVersionNumber)
        latestDeniedVersionNumber = latestDeniedVersionNumberDecoded
        let additionalAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalAttributes)
        var additionalAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalAttributesContainer = additionalAttributesContainer {
            additionalAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in additionalAttributesContainer {
                if let string0 = string0 {
                    additionalAttributesDecoded0?[key0] = string0
                }
            }
        }
        additionalAttributes = additionalAttributesDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum DeleteRegistrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTextMessageSpendLimitOverrideInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteTextMessageSpendLimitOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTextMessageSpendLimitOverrideInput: Swift.Equatable {

    public init() { }
}

struct DeleteTextMessageSpendLimitOverrideInputBody: Swift.Equatable {
}

extension DeleteTextMessageSpendLimitOverrideInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTextMessageSpendLimitOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteTextMessageSpendLimitOverrideOutputBody = try responseDecoder.decode(responseBody: data)
            self.monthlyLimit = output.monthlyLimit
        } else {
            self.monthlyLimit = nil
        }
    }
}

public struct DeleteTextMessageSpendLimitOverrideOutput: Swift.Equatable {
    /// The current monthly limit, in US dollars.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

struct DeleteTextMessageSpendLimitOverrideOutputBody: Swift.Equatable {
    let monthlyLimit: Swift.Int?
}

extension DeleteTextMessageSpendLimitOverrideOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlyLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monthlyLimit)
        monthlyLimit = monthlyLimitDecoded
    }
}

enum DeleteTextMessageSpendLimitOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVerifiedDestinationNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let verifiedDestinationNumberId = self.verifiedDestinationNumberId {
            try encodeContainer.encode(verifiedDestinationNumberId, forKey: .verifiedDestinationNumberId)
        }
    }
}

extension DeleteVerifiedDestinationNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVerifiedDestinationNumberInput: Swift.Equatable {
    /// The unique identifier for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberId: Swift.String?

    public init(
        verifiedDestinationNumberId: Swift.String? = nil
    )
    {
        self.verifiedDestinationNumberId = verifiedDestinationNumberId
    }
}

struct DeleteVerifiedDestinationNumberInputBody: Swift.Equatable {
    let verifiedDestinationNumberId: Swift.String?
}

extension DeleteVerifiedDestinationNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verifiedDestinationNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedDestinationNumberId)
        verifiedDestinationNumberId = verifiedDestinationNumberIdDecoded
    }
}

extension DeleteVerifiedDestinationNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteVerifiedDestinationNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.destinationPhoneNumber = output.destinationPhoneNumber
            self.verifiedDestinationNumberArn = output.verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = output.verifiedDestinationNumberId
        } else {
            self.createdTimestamp = nil
            self.destinationPhoneNumber = nil
            self.verifiedDestinationNumberArn = nil
            self.verifiedDestinationNumberId = nil
        }
    }
}

public struct DeleteVerifiedDestinationNumberOutput: Swift.Equatable {
    /// The time when the destination phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: ClientRuntime.Date?
    /// The verified destination phone number, in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// The Amazon Resource Name (ARN) for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberArn: Swift.String?
    /// The unique identifier for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberId: Swift.String?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        verifiedDestinationNumberArn: Swift.String? = nil,
        verifiedDestinationNumberId: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinationPhoneNumber = destinationPhoneNumber
        self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
        self.verifiedDestinationNumberId = verifiedDestinationNumberId
    }
}

struct DeleteVerifiedDestinationNumberOutputBody: Swift.Equatable {
    let verifiedDestinationNumberArn: Swift.String?
    let verifiedDestinationNumberId: Swift.String?
    let destinationPhoneNumber: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
}

extension DeleteVerifiedDestinationNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case verifiedDestinationNumberArn = "VerifiedDestinationNumberArn"
        case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verifiedDestinationNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedDestinationNumberArn)
        verifiedDestinationNumberArn = verifiedDestinationNumberArnDecoded
        let verifiedDestinationNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedDestinationNumberId)
        verifiedDestinationNumberId = verifiedDestinationNumberIdDecoded
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum DeleteVerifiedDestinationNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceMessageSpendLimitOverrideInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteVoiceMessageSpendLimitOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVoiceMessageSpendLimitOverrideInput: Swift.Equatable {

    public init() { }
}

struct DeleteVoiceMessageSpendLimitOverrideInputBody: Swift.Equatable {
}

extension DeleteVoiceMessageSpendLimitOverrideInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceMessageSpendLimitOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteVoiceMessageSpendLimitOverrideOutputBody = try responseDecoder.decode(responseBody: data)
            self.monthlyLimit = output.monthlyLimit
        } else {
            self.monthlyLimit = nil
        }
    }
}

public struct DeleteVoiceMessageSpendLimitOverrideOutput: Swift.Equatable {
    /// The current monthly limit, in US dollars.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

struct DeleteVoiceMessageSpendLimitOverrideOutputBody: Swift.Equatable {
    let monthlyLimit: Swift.Int?
}

extension DeleteVoiceMessageSpendLimitOverrideOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlyLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monthlyLimit)
        monthlyLimit = monthlyLimitDecoded
    }
}

enum DeleteVoiceMessageSpendLimitOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAccountAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountAttributesInput: Swift.Equatable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAccountAttributesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAccountAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAccountAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAttributes = output.accountAttributes
            self.nextToken = output.nextToken
        } else {
            self.accountAttributes = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAccountAttributesOutput: Swift.Equatable {
    /// An array of AccountAttributes objects.
    public var accountAttributes: [PinpointSMSVoiceV2ClientTypes.AccountAttribute]?
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?

    public init(
        accountAttributes: [PinpointSMSVoiceV2ClientTypes.AccountAttribute]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAttributes = accountAttributes
        self.nextToken = nextToken
    }
}

struct DescribeAccountAttributesOutputBody: Swift.Equatable {
    let accountAttributes: [PinpointSMSVoiceV2ClientTypes.AccountAttribute]?
    let nextToken: Swift.String?
}

extension DescribeAccountAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAttributes = "AccountAttributes"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAttributesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.AccountAttribute?].self, forKey: .accountAttributes)
        var accountAttributesDecoded0:[PinpointSMSVoiceV2ClientTypes.AccountAttribute]? = nil
        if let accountAttributesContainer = accountAttributesContainer {
            accountAttributesDecoded0 = [PinpointSMSVoiceV2ClientTypes.AccountAttribute]()
            for structure0 in accountAttributesContainer {
                if let structure0 = structure0 {
                    accountAttributesDecoded0?.append(structure0)
                }
            }
        }
        accountAttributes = accountAttributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAccountAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountLimitsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAccountLimitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountLimitsInput: Swift.Equatable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAccountLimitsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAccountLimitsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAccountLimitsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountLimitsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountLimits = output.accountLimits
            self.nextToken = output.nextToken
        } else {
            self.accountLimits = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAccountLimitsOutput: Swift.Equatable {
    /// An array of AccountLimit objects that show the current spend limits.
    public var accountLimits: [PinpointSMSVoiceV2ClientTypes.AccountLimit]?
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?

    public init(
        accountLimits: [PinpointSMSVoiceV2ClientTypes.AccountLimit]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountLimits = accountLimits
        self.nextToken = nextToken
    }
}

struct DescribeAccountLimitsOutputBody: Swift.Equatable {
    let accountLimits: [PinpointSMSVoiceV2ClientTypes.AccountLimit]?
    let nextToken: Swift.String?
}

extension DescribeAccountLimitsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLimits = "AccountLimits"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountLimitsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.AccountLimit?].self, forKey: .accountLimits)
        var accountLimitsDecoded0:[PinpointSMSVoiceV2ClientTypes.AccountLimit]? = nil
        if let accountLimitsContainer = accountLimitsContainer {
            accountLimitsDecoded0 = [PinpointSMSVoiceV2ClientTypes.AccountLimit]()
            for structure0 in accountLimitsContainer {
                if let structure0 = structure0 {
                    accountLimitsDecoded0?.append(structure0)
                }
            }
        }
        accountLimits = accountLimitsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAccountLimitsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConfigurationSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetNames = "ConfigurationSetNames"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetNames = configurationSetNames {
            var configurationSetNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationSetNames)
            for configurationsetnameorarn0 in configurationSetNames {
                try configurationSetNamesContainer.encode(configurationsetnameorarn0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for configurationsetfilter0 in filters {
                try filtersContainer.encode(configurationsetfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConfigurationSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConfigurationSetsInput: Swift.Equatable {
    /// An array of strings. Each element can be either a ConfigurationSetName or ConfigurationSetArn.
    public var configurationSetNames: [Swift.String]?
    /// An array of filters to apply to the results that are returned.
    public var filters: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?

    public init(
        configurationSetNames: [Swift.String]? = nil,
        filters: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationSetNames = configurationSetNames
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeConfigurationSetsInputBody: Swift.Equatable {
    let configurationSetNames: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeConfigurationSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetNames = "ConfigurationSetNames"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationSetNames)
        var configurationSetNamesDecoded0:[Swift.String]? = nil
        if let configurationSetNamesContainer = configurationSetNamesContainer {
            configurationSetNamesDecoded0 = [Swift.String]()
            for string0 in configurationSetNamesContainer {
                if let string0 = string0 {
                    configurationSetNamesDecoded0?.append(string0)
                }
            }
        }
        configurationSetNames = configurationSetNamesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeConfigurationSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConfigurationSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSets = output.configurationSets
            self.nextToken = output.nextToken
        } else {
            self.configurationSets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConfigurationSetsOutput: Swift.Equatable {
    /// An array of ConfigurationSets objects.
    public var configurationSets: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]?
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?

    public init(
        configurationSets: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationSets = configurationSets
        self.nextToken = nextToken
    }
}

struct DescribeConfigurationSetsOutputBody: Swift.Equatable {
    let configurationSets: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]?
    let nextToken: Swift.String?
}

extension DescribeConfigurationSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSets = "ConfigurationSets"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation?].self, forKey: .configurationSets)
        var configurationSetsDecoded0:[PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]? = nil
        if let configurationSetsContainer = configurationSetsContainer {
            configurationSetsDecoded0 = [PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]()
            for structure0 in configurationSetsContainer {
                if let structure0 = structure0 {
                    configurationSetsDecoded0?.append(structure0)
                }
            }
        }
        configurationSets = configurationSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeConfigurationSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeKeywordsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case keywords = "Keywords"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case originationIdentity = "OriginationIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for keywordfilter0 in filters {
                try filtersContainer.encode(keywordfilter0)
            }
        }
        if let keywords = keywords {
            var keywordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keywords)
            for keyword0 in keywords {
                try keywordsContainer.encode(keyword0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
    }
}

extension DescribeKeywordsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeKeywordsInput: Swift.Equatable {
    /// An array of keyword filters to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.KeywordFilter]?
    /// An array of keywords to search for.
    public var keywords: [Swift.String]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use [DescribePhoneNumbers] to find the values for PhoneNumberId and PhoneNumberArn while [DescribeSenderIds] can be used to get the values for SenderId and SenderIdArn.
    /// This member is required.
    public var originationIdentity: Swift.String?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.KeywordFilter]? = nil,
        keywords: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        originationIdentity: Swift.String? = nil
    )
    {
        self.filters = filters
        self.keywords = keywords
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.originationIdentity = originationIdentity
    }
}

struct DescribeKeywordsInputBody: Swift.Equatable {
    let originationIdentity: Swift.String?
    let keywords: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.KeywordFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeKeywordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case keywords = "Keywords"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case originationIdentity = "OriginationIdentity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let keywordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keywords)
        var keywordsDecoded0:[Swift.String]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [Swift.String]()
            for string0 in keywordsContainer {
                if let string0 = string0 {
                    keywordsDecoded0?.append(string0)
                }
            }
        }
        keywords = keywordsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.KeywordFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.KeywordFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.KeywordFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeKeywordsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeKeywordsOutputBody = try responseDecoder.decode(responseBody: data)
            self.keywords = output.keywords
            self.nextToken = output.nextToken
            self.originationIdentity = output.originationIdentity
            self.originationIdentityArn = output.originationIdentityArn
        } else {
            self.keywords = nil
            self.nextToken = nil
            self.originationIdentity = nil
            self.originationIdentityArn = nil
        }
    }
}

public struct DescribeKeywordsOutput: Swift.Equatable {
    /// An array of KeywordInformation objects that contain the results.
    public var keywords: [PinpointSMSVoiceV2ClientTypes.KeywordInformation]?
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// The PhoneNumberId or PoolId that is associated with the OriginationIdentity.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or PoolArn that is associated with the OriginationIdentity.
    public var originationIdentityArn: Swift.String?

    public init(
        keywords: [PinpointSMSVoiceV2ClientTypes.KeywordInformation]? = nil,
        nextToken: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil
    )
    {
        self.keywords = keywords
        self.nextToken = nextToken
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
    }
}

struct DescribeKeywordsOutputBody: Swift.Equatable {
    let originationIdentityArn: Swift.String?
    let originationIdentity: Swift.String?
    let keywords: [PinpointSMSVoiceV2ClientTypes.KeywordInformation]?
    let nextToken: Swift.String?
}

extension DescribeKeywordsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keywords = "Keywords"
        case nextToken = "NextToken"
        case originationIdentity = "OriginationIdentity"
        case originationIdentityArn = "OriginationIdentityArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentityArn)
        originationIdentityArn = originationIdentityArnDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let keywordsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.KeywordInformation?].self, forKey: .keywords)
        var keywordsDecoded0:[PinpointSMSVoiceV2ClientTypes.KeywordInformation]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [PinpointSMSVoiceV2ClientTypes.KeywordInformation]()
            for structure0 in keywordsContainer {
                if let structure0 = structure0 {
                    keywordsDecoded0?.append(structure0)
                }
            }
        }
        keywords = keywordsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeKeywordsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOptOutListsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case optOutListNames = "OptOutListNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let optOutListNames = optOutListNames {
            var optOutListNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .optOutListNames)
            for optoutlistnameorarn0 in optOutListNames {
                try optOutListNamesContainer.encode(optoutlistnameorarn0)
            }
        }
    }
}

extension DescribeOptOutListsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeOptOutListsInput: Swift.Equatable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The OptOutLists to show the details of. This is an array of strings that can be either the OptOutListName or OptOutListArn.
    public var optOutListNames: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        optOutListNames: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.optOutListNames = optOutListNames
    }
}

struct DescribeOptOutListsInputBody: Swift.Equatable {
    let optOutListNames: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeOptOutListsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case optOutListNames = "OptOutListNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .optOutListNames)
        var optOutListNamesDecoded0:[Swift.String]? = nil
        if let optOutListNamesContainer = optOutListNamesContainer {
            optOutListNamesDecoded0 = [Swift.String]()
            for string0 in optOutListNamesContainer {
                if let string0 = string0 {
                    optOutListNamesDecoded0?.append(string0)
                }
            }
        }
        optOutListNames = optOutListNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeOptOutListsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOptOutListsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.optOutLists = output.optOutLists
        } else {
            self.nextToken = nil
            self.optOutLists = nil
        }
    }
}

public struct DescribeOptOutListsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of OptOutListInformation objects that contain the details for the requested OptOutLists.
    public var optOutLists: [PinpointSMSVoiceV2ClientTypes.OptOutListInformation]?

    public init(
        nextToken: Swift.String? = nil,
        optOutLists: [PinpointSMSVoiceV2ClientTypes.OptOutListInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.optOutLists = optOutLists
    }
}

struct DescribeOptOutListsOutputBody: Swift.Equatable {
    let optOutLists: [PinpointSMSVoiceV2ClientTypes.OptOutListInformation]?
    let nextToken: Swift.String?
}

extension DescribeOptOutListsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case optOutLists = "OptOutLists"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.OptOutListInformation?].self, forKey: .optOutLists)
        var optOutListsDecoded0:[PinpointSMSVoiceV2ClientTypes.OptOutListInformation]? = nil
        if let optOutListsContainer = optOutListsContainer {
            optOutListsDecoded0 = [PinpointSMSVoiceV2ClientTypes.OptOutListInformation]()
            for structure0 in optOutListsContainer {
                if let structure0 = structure0 {
                    optOutListsDecoded0?.append(structure0)
                }
            }
        }
        optOutLists = optOutListsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeOptOutListsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOptedOutNumbersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case optOutListName = "OptOutListName"
        case optedOutNumbers = "OptedOutNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for optedoutfilter0 in filters {
                try filtersContainer.encode(optedoutfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let optedOutNumbers = optedOutNumbers {
            var optedOutNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .optedOutNumbers)
            for phonenumber0 in optedOutNumbers {
                try optedOutNumbersContainer.encode(phonenumber0)
            }
        }
    }
}

extension DescribeOptedOutNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeOptedOutNumbersInput: Swift.Equatable {
    /// An array of OptedOutFilter objects to filter the results on.
    public var filters: [PinpointSMSVoiceV2ClientTypes.OptedOutFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The OptOutListName or OptOutListArn of the OptOutList. You can use [DescribeOptOutLists] to find the values for OptOutListName and OptOutListArn.
    /// This member is required.
    public var optOutListName: Swift.String?
    /// An array of phone numbers to search for in the OptOutList.
    public var optedOutNumbers: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.OptedOutFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        optedOutNumbers: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.optOutListName = optOutListName
        self.optedOutNumbers = optedOutNumbers
    }
}

struct DescribeOptedOutNumbersInputBody: Swift.Equatable {
    let optOutListName: Swift.String?
    let optedOutNumbers: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.OptedOutFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeOptedOutNumbersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case optOutListName = "OptOutListName"
        case optedOutNumbers = "OptedOutNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let optedOutNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .optedOutNumbers)
        var optedOutNumbersDecoded0:[Swift.String]? = nil
        if let optedOutNumbersContainer = optedOutNumbersContainer {
            optedOutNumbersDecoded0 = [Swift.String]()
            for string0 in optedOutNumbersContainer {
                if let string0 = string0 {
                    optedOutNumbersDecoded0?.append(string0)
                }
            }
        }
        optedOutNumbers = optedOutNumbersDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.OptedOutFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.OptedOutFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.OptedOutFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeOptedOutNumbersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOptedOutNumbersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.optOutListArn = output.optOutListArn
            self.optOutListName = output.optOutListName
            self.optedOutNumbers = output.optedOutNumbers
        } else {
            self.nextToken = nil
            self.optOutListArn = nil
            self.optOutListName = nil
            self.optedOutNumbers = nil
        }
    }
}

public struct DescribeOptedOutNumbersOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the OptOutList.
    public var optOutListArn: Swift.String?
    /// The name of the OptOutList.
    public var optOutListName: Swift.String?
    /// An array of OptedOutNumbersInformation objects that provide information about the requested OptedOutNumbers.
    public var optedOutNumbers: [PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]?

    public init(
        nextToken: Swift.String? = nil,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        optedOutNumbers: [PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
        self.optedOutNumbers = optedOutNumbers
    }
}

struct DescribeOptedOutNumbersOutputBody: Swift.Equatable {
    let optOutListArn: Swift.String?
    let optOutListName: Swift.String?
    let optedOutNumbers: [PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]?
    let nextToken: Swift.String?
}

extension DescribeOptedOutNumbersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case optOutListArn = "OptOutListArn"
        case optOutListName = "OptOutListName"
        case optedOutNumbers = "OptedOutNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListArn)
        optOutListArn = optOutListArnDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let optedOutNumbersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation?].self, forKey: .optedOutNumbers)
        var optedOutNumbersDecoded0:[PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]? = nil
        if let optedOutNumbersContainer = optedOutNumbersContainer {
            optedOutNumbersDecoded0 = [PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]()
            for structure0 in optedOutNumbersContainer {
                if let structure0 = structure0 {
                    optedOutNumbersDecoded0?.append(structure0)
                }
            }
        }
        optedOutNumbers = optedOutNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeOptedOutNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePhoneNumbersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case phoneNumberIds = "PhoneNumberIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for phonenumberfilter0 in filters {
                try filtersContainer.encode(phonenumberfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let phoneNumberIds = phoneNumberIds {
            var phoneNumberIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberIds)
            for phonenumberidorarn0 in phoneNumberIds {
                try phoneNumberIdsContainer.encode(phonenumberidorarn0)
            }
        }
    }
}

extension DescribePhoneNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePhoneNumbersInput: Swift.Equatable {
    /// An array of PhoneNumberFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier of phone numbers to find information about. This is an array of strings that can be either the PhoneNumberId or PhoneNumberArn.
    public var phoneNumberIds: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberIds = phoneNumberIds
    }
}

struct DescribePhoneNumbersInputBody: Swift.Equatable {
    let phoneNumberIds: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribePhoneNumbersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case phoneNumberIds = "PhoneNumberIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberIds)
        var phoneNumberIdsDecoded0:[Swift.String]? = nil
        if let phoneNumberIdsContainer = phoneNumberIdsContainer {
            phoneNumberIdsDecoded0 = [Swift.String]()
            for string0 in phoneNumberIdsContainer {
                if let string0 = string0 {
                    phoneNumberIdsDecoded0?.append(string0)
                }
            }
        }
        phoneNumberIds = phoneNumberIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribePhoneNumbersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePhoneNumbersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct DescribePhoneNumbersOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of PhoneNumberInformation objects that contain the details for the requested phone numbers.
    public var phoneNumbers: [PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct DescribePhoneNumbersOutputBody: Swift.Equatable {
    let phoneNumbers: [PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]?
    let nextToken: Swift.String?
}

extension DescribePhoneNumbersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumbersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribePhoneNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePoolsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolIds = "PoolIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for poolfilter0 in filters {
                try filtersContainer.encode(poolfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let poolIds = poolIds {
            var poolIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .poolIds)
            for poolidorarn0 in poolIds {
                try poolIdsContainer.encode(poolidorarn0)
            }
        }
    }
}

extension DescribePoolsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePoolsInput: Swift.Equatable {
    /// An array of PoolFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.PoolFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier of pools to find. This is an array of strings that can be either the PoolId or PoolArn.
    public var poolIds: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.PoolFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        poolIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolIds = poolIds
    }
}

struct DescribePoolsInputBody: Swift.Equatable {
    let poolIds: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.PoolFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribePoolsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolIds = "PoolIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .poolIds)
        var poolIdsDecoded0:[Swift.String]? = nil
        if let poolIdsContainer = poolIdsContainer {
            poolIdsDecoded0 = [Swift.String]()
            for string0 in poolIdsContainer {
                if let string0 = string0 {
                    poolIdsDecoded0?.append(string0)
                }
            }
        }
        poolIds = poolIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.PoolFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.PoolFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.PoolFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribePoolsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePoolsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pools = output.pools
        } else {
            self.nextToken = nil
            self.pools = nil
        }
    }
}

public struct DescribePoolsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of PoolInformation objects that contain the details for the requested pools.
    public var pools: [PinpointSMSVoiceV2ClientTypes.PoolInformation]?

    public init(
        nextToken: Swift.String? = nil,
        pools: [PinpointSMSVoiceV2ClientTypes.PoolInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.pools = pools
    }
}

struct DescribePoolsOutputBody: Swift.Equatable {
    let pools: [PinpointSMSVoiceV2ClientTypes.PoolInformation]?
    let nextToken: Swift.String?
}

extension DescribePoolsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pools = "Pools"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.PoolInformation?].self, forKey: .pools)
        var poolsDecoded0:[PinpointSMSVoiceV2ClientTypes.PoolInformation]? = nil
        if let poolsContainer = poolsContainer {
            poolsDecoded0 = [PinpointSMSVoiceV2ClientTypes.PoolInformation]()
            for structure0 in poolsContainer {
                if let structure0 = structure0 {
                    poolsDecoded0?.append(structure0)
                }
            }
        }
        pools = poolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribePoolsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRegistrationAttachmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationAttachmentIds = "RegistrationAttachmentIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for registrationattachmentfilter0 in filters {
                try filtersContainer.encode(registrationattachmentfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registrationAttachmentIds = registrationAttachmentIds {
            var registrationAttachmentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .registrationAttachmentIds)
            for registrationidorarn0 in registrationAttachmentIds {
                try registrationAttachmentIdsContainer.encode(registrationidorarn0)
            }
        }
    }
}

extension DescribeRegistrationAttachmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRegistrationAttachmentsInput: Swift.Equatable {
    /// An array of RegistrationAttachmentFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier of registration attachments to find. This is an array of RegistrationAttachmentId.
    public var registrationAttachmentIds: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationAttachmentIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationAttachmentIds = registrationAttachmentIds
    }
}

struct DescribeRegistrationAttachmentsInputBody: Swift.Equatable {
    let registrationAttachmentIds: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeRegistrationAttachmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationAttachmentIds = "RegistrationAttachmentIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationAttachmentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .registrationAttachmentIds)
        var registrationAttachmentIdsDecoded0:[Swift.String]? = nil
        if let registrationAttachmentIdsContainer = registrationAttachmentIdsContainer {
            registrationAttachmentIdsDecoded0 = [Swift.String]()
            for string0 in registrationAttachmentIdsContainer {
                if let string0 = string0 {
                    registrationAttachmentIdsDecoded0?.append(string0)
                }
            }
        }
        registrationAttachmentIds = registrationAttachmentIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRegistrationAttachmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRegistrationAttachmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registrationAttachments = output.registrationAttachments
        } else {
            self.nextToken = nil
            self.registrationAttachments = nil
        }
    }
}

public struct DescribeRegistrationAttachmentsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of RegistrationAttachments objects that contain the details for the requested registration attachments.
    /// This member is required.
    public var registrationAttachments: [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation]?

    public init(
        nextToken: Swift.String? = nil,
        registrationAttachments: [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationAttachments = registrationAttachments
    }
}

struct DescribeRegistrationAttachmentsOutputBody: Swift.Equatable {
    let registrationAttachments: [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation]?
    let nextToken: Swift.String?
}

extension DescribeRegistrationAttachmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case registrationAttachments = "RegistrationAttachments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationAttachmentsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation?].self, forKey: .registrationAttachments)
        var registrationAttachmentsDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation]? = nil
        if let registrationAttachmentsContainer = registrationAttachmentsContainer {
            registrationAttachmentsDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation]()
            for structure0 in registrationAttachmentsContainer {
                if let structure0 = structure0 {
                    registrationAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        registrationAttachments = registrationAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeRegistrationAttachmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRegistrationFieldDefinitionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPaths = "FieldPaths"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationType = "RegistrationType"
        case sectionPath = "SectionPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldPaths = fieldPaths {
            var fieldPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldPaths)
            for fieldpath0 in fieldPaths {
                try fieldPathsContainer.encode(fieldpath0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registrationType = self.registrationType {
            try encodeContainer.encode(registrationType, forKey: .registrationType)
        }
        if let sectionPath = self.sectionPath {
            try encodeContainer.encode(sectionPath, forKey: .sectionPath)
        }
    }
}

extension DescribeRegistrationFieldDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRegistrationFieldDefinitionsInput: Swift.Equatable {
    /// An array of paths to the registration form field.
    public var fieldPaths: [Swift.String]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?
    /// The path to the section of the registration.
    public var sectionPath: Swift.String?

    public init(
        fieldPaths: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationType: Swift.String? = nil,
        sectionPath: Swift.String? = nil
    )
    {
        self.fieldPaths = fieldPaths
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationType = registrationType
        self.sectionPath = sectionPath
    }
}

struct DescribeRegistrationFieldDefinitionsInputBody: Swift.Equatable {
    let registrationType: Swift.String?
    let sectionPath: Swift.String?
    let fieldPaths: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeRegistrationFieldDefinitionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPaths = "FieldPaths"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationType = "RegistrationType"
        case sectionPath = "SectionPath"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationType)
        registrationType = registrationTypeDecoded
        let sectionPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sectionPath)
        sectionPath = sectionPathDecoded
        let fieldPathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fieldPaths)
        var fieldPathsDecoded0:[Swift.String]? = nil
        if let fieldPathsContainer = fieldPathsContainer {
            fieldPathsDecoded0 = [Swift.String]()
            for string0 in fieldPathsContainer {
                if let string0 = string0 {
                    fieldPathsDecoded0?.append(string0)
                }
            }
        }
        fieldPaths = fieldPathsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRegistrationFieldDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRegistrationFieldDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registrationFieldDefinitions = output.registrationFieldDefinitions
            self.registrationType = output.registrationType
        } else {
            self.nextToken = nil
            self.registrationFieldDefinitions = nil
            self.registrationType = nil
        }
    }
}

public struct DescribeRegistrationFieldDefinitionsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of RegistrationFieldDefinitions objects that contain the details for the requested fields.
    /// This member is required.
    public var registrationFieldDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition]?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        registrationFieldDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition]? = nil,
        registrationType: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationFieldDefinitions = registrationFieldDefinitions
        self.registrationType = registrationType
    }
}

struct DescribeRegistrationFieldDefinitionsOutputBody: Swift.Equatable {
    let registrationType: Swift.String?
    let registrationFieldDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition]?
    let nextToken: Swift.String?
}

extension DescribeRegistrationFieldDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case registrationFieldDefinitions = "RegistrationFieldDefinitions"
        case registrationType = "RegistrationType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationType)
        registrationType = registrationTypeDecoded
        let registrationFieldDefinitionsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition?].self, forKey: .registrationFieldDefinitions)
        var registrationFieldDefinitionsDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition]? = nil
        if let registrationFieldDefinitionsContainer = registrationFieldDefinitionsContainer {
            registrationFieldDefinitionsDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition]()
            for structure0 in registrationFieldDefinitionsContainer {
                if let structure0 = structure0 {
                    registrationFieldDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        registrationFieldDefinitions = registrationFieldDefinitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeRegistrationFieldDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRegistrationFieldValuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPaths = "FieldPaths"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationId = "RegistrationId"
        case sectionPath = "SectionPath"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldPaths = fieldPaths {
            var fieldPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldPaths)
            for fieldpath0 in fieldPaths {
                try fieldPathsContainer.encode(fieldpath0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
        if let sectionPath = self.sectionPath {
            try encodeContainer.encode(sectionPath, forKey: .sectionPath)
        }
        if let versionNumber = self.versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }
}

extension DescribeRegistrationFieldValuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRegistrationFieldValuesInput: Swift.Equatable {
    /// An array of paths to the registration form field.
    public var fieldPaths: [Swift.String]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The path to the section of the registration.
    public var sectionPath: Swift.String?
    /// The version number of the registration.
    public var versionNumber: Swift.Int?

    public init(
        fieldPaths: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        sectionPath: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.fieldPaths = fieldPaths
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationId = registrationId
        self.sectionPath = sectionPath
        self.versionNumber = versionNumber
    }
}

struct DescribeRegistrationFieldValuesInputBody: Swift.Equatable {
    let registrationId: Swift.String?
    let versionNumber: Swift.Int?
    let sectionPath: Swift.String?
    let fieldPaths: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeRegistrationFieldValuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPaths = "FieldPaths"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationId = "RegistrationId"
        case sectionPath = "SectionPath"
        case versionNumber = "VersionNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let sectionPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sectionPath)
        sectionPath = sectionPathDecoded
        let fieldPathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fieldPaths)
        var fieldPathsDecoded0:[Swift.String]? = nil
        if let fieldPathsContainer = fieldPathsContainer {
            fieldPathsDecoded0 = [Swift.String]()
            for string0 in fieldPathsContainer {
                if let string0 = string0 {
                    fieldPathsDecoded0?.append(string0)
                }
            }
        }
        fieldPaths = fieldPathsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRegistrationFieldValuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRegistrationFieldValuesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registrationArn = output.registrationArn
            self.registrationFieldValues = output.registrationFieldValues
            self.registrationId = output.registrationId
            self.versionNumber = output.versionNumber
        } else {
            self.nextToken = nil
            self.registrationArn = nil
            self.registrationFieldValues = nil
            self.registrationId = nil
            self.versionNumber = nil
        }
    }
}

public struct DescribeRegistrationFieldValuesOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// An array of RegistrationFieldValues objects that contain the values for the requested registration.
    /// This member is required.
    public var registrationFieldValues: [PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation]?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The current version of the registration.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        registrationArn: Swift.String? = nil,
        registrationFieldValues: [PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation]? = nil,
        registrationId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationArn = registrationArn
        self.registrationFieldValues = registrationFieldValues
        self.registrationId = registrationId
        self.versionNumber = versionNumber
    }
}

struct DescribeRegistrationFieldValuesOutputBody: Swift.Equatable {
    let registrationArn: Swift.String?
    let registrationId: Swift.String?
    let versionNumber: Swift.Int?
    let registrationFieldValues: [PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation]?
    let nextToken: Swift.String?
}

extension DescribeRegistrationFieldValuesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case registrationArn = "RegistrationArn"
        case registrationFieldValues = "RegistrationFieldValues"
        case registrationId = "RegistrationId"
        case versionNumber = "VersionNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationArn)
        registrationArn = registrationArnDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let registrationFieldValuesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation?].self, forKey: .registrationFieldValues)
        var registrationFieldValuesDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation]? = nil
        if let registrationFieldValuesContainer = registrationFieldValuesContainer {
            registrationFieldValuesDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation]()
            for structure0 in registrationFieldValuesContainer {
                if let structure0 = structure0 {
                    registrationFieldValuesDecoded0?.append(structure0)
                }
            }
        }
        registrationFieldValues = registrationFieldValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeRegistrationFieldValuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRegistrationSectionDefinitionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationType = "RegistrationType"
        case sectionPaths = "SectionPaths"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registrationType = self.registrationType {
            try encodeContainer.encode(registrationType, forKey: .registrationType)
        }
        if let sectionPaths = sectionPaths {
            var sectionPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sectionPaths)
            for sectionpath0 in sectionPaths {
                try sectionPathsContainer.encode(sectionpath0)
            }
        }
    }
}

extension DescribeRegistrationSectionDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRegistrationSectionDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?
    /// An array of paths for the registration form section.
    public var sectionPaths: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationType: Swift.String? = nil,
        sectionPaths: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationType = registrationType
        self.sectionPaths = sectionPaths
    }
}

struct DescribeRegistrationSectionDefinitionsInputBody: Swift.Equatable {
    let registrationType: Swift.String?
    let sectionPaths: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeRegistrationSectionDefinitionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationType = "RegistrationType"
        case sectionPaths = "SectionPaths"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationType)
        registrationType = registrationTypeDecoded
        let sectionPathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sectionPaths)
        var sectionPathsDecoded0:[Swift.String]? = nil
        if let sectionPathsContainer = sectionPathsContainer {
            sectionPathsDecoded0 = [Swift.String]()
            for string0 in sectionPathsContainer {
                if let string0 = string0 {
                    sectionPathsDecoded0?.append(string0)
                }
            }
        }
        sectionPaths = sectionPathsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRegistrationSectionDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRegistrationSectionDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registrationSectionDefinitions = output.registrationSectionDefinitions
            self.registrationType = output.registrationType
        } else {
            self.nextToken = nil
            self.registrationSectionDefinitions = nil
            self.registrationType = nil
        }
    }
}

public struct DescribeRegistrationSectionDefinitionsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of RegistrationSectionDefinition objects.
    /// This member is required.
    public var registrationSectionDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition]?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        registrationSectionDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition]? = nil,
        registrationType: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationSectionDefinitions = registrationSectionDefinitions
        self.registrationType = registrationType
    }
}

struct DescribeRegistrationSectionDefinitionsOutputBody: Swift.Equatable {
    let registrationType: Swift.String?
    let registrationSectionDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition]?
    let nextToken: Swift.String?
}

extension DescribeRegistrationSectionDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case registrationSectionDefinitions = "RegistrationSectionDefinitions"
        case registrationType = "RegistrationType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationType)
        registrationType = registrationTypeDecoded
        let registrationSectionDefinitionsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition?].self, forKey: .registrationSectionDefinitions)
        var registrationSectionDefinitionsDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition]? = nil
        if let registrationSectionDefinitionsContainer = registrationSectionDefinitionsContainer {
            registrationSectionDefinitionsDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition]()
            for structure0 in registrationSectionDefinitionsContainer {
                if let structure0 = structure0 {
                    registrationSectionDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        registrationSectionDefinitions = registrationSectionDefinitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeRegistrationSectionDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRegistrationTypeDefinitionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationTypes = "RegistrationTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for registrationtypefilter0 in filters {
                try filtersContainer.encode(registrationtypefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registrationTypes = registrationTypes {
            var registrationTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .registrationTypes)
            for registrationtype0 in registrationTypes {
                try registrationTypesContainer.encode(registrationtype0)
            }
        }
    }
}

extension DescribeRegistrationTypeDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRegistrationTypeDefinitionsInput: Swift.Equatable {
    /// An array of RegistrationFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    public var registrationTypes: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationTypes: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationTypes = registrationTypes
    }
}

struct DescribeRegistrationTypeDefinitionsInputBody: Swift.Equatable {
    let registrationTypes: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeRegistrationTypeDefinitionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationTypes = "RegistrationTypes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .registrationTypes)
        var registrationTypesDecoded0:[Swift.String]? = nil
        if let registrationTypesContainer = registrationTypesContainer {
            registrationTypesDecoded0 = [Swift.String]()
            for string0 in registrationTypesContainer {
                if let string0 = string0 {
                    registrationTypesDecoded0?.append(string0)
                }
            }
        }
        registrationTypes = registrationTypesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRegistrationTypeDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRegistrationTypeDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registrationTypeDefinitions = output.registrationTypeDefinitions
        } else {
            self.nextToken = nil
            self.registrationTypeDefinitions = nil
        }
    }
}

public struct DescribeRegistrationTypeDefinitionsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationTypeDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition]?

    public init(
        nextToken: Swift.String? = nil,
        registrationTypeDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationTypeDefinitions = registrationTypeDefinitions
    }
}

struct DescribeRegistrationTypeDefinitionsOutputBody: Swift.Equatable {
    let registrationTypeDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition]?
    let nextToken: Swift.String?
}

extension DescribeRegistrationTypeDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case registrationTypeDefinitions = "RegistrationTypeDefinitions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationTypeDefinitionsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition?].self, forKey: .registrationTypeDefinitions)
        var registrationTypeDefinitionsDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition]? = nil
        if let registrationTypeDefinitionsContainer = registrationTypeDefinitionsContainer {
            registrationTypeDefinitionsDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition]()
            for structure0 in registrationTypeDefinitionsContainer {
                if let structure0 = structure0 {
                    registrationTypeDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        registrationTypeDefinitions = registrationTypeDefinitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeRegistrationTypeDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRegistrationVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationId = "RegistrationId"
        case versionNumbers = "VersionNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for registrationversionfilter0 in filters {
                try filtersContainer.encode(registrationversionfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
        if let versionNumbers = versionNumbers {
            var versionNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versionNumbers)
            for registrationversionnumber0 in versionNumbers {
                try versionNumbersContainer.encode(registrationversionnumber0)
            }
        }
    }
}

extension DescribeRegistrationVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRegistrationVersionsInput: Swift.Equatable {
    /// An array of RegistrationVersionFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// An array of registration version numbers.
    public var versionNumbers: [Swift.Int]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        versionNumbers: [Swift.Int]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationId = registrationId
        self.versionNumbers = versionNumbers
    }
}

struct DescribeRegistrationVersionsInputBody: Swift.Equatable {
    let registrationId: Swift.String?
    let versionNumbers: [Swift.Int]?
    let filters: [PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeRegistrationVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationId = "RegistrationId"
        case versionNumbers = "VersionNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let versionNumbersContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .versionNumbers)
        var versionNumbersDecoded0:[Swift.Int]? = nil
        if let versionNumbersContainer = versionNumbersContainer {
            versionNumbersDecoded0 = [Swift.Int]()
            for long0 in versionNumbersContainer {
                if let long0 = long0 {
                    versionNumbersDecoded0?.append(long0)
                }
            }
        }
        versionNumbers = versionNumbersDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRegistrationVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRegistrationVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registrationArn = output.registrationArn
            self.registrationId = output.registrationId
            self.registrationVersions = output.registrationVersions
        } else {
            self.nextToken = nil
            self.registrationArn = nil
            self.registrationId = nil
            self.registrationVersions = nil
        }
    }
}

public struct DescribeRegistrationVersionsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// An array of RegistrationVersions objects.
    /// This member is required.
    public var registrationVersions: [PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationVersions: [PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationVersions = registrationVersions
    }
}

struct DescribeRegistrationVersionsOutputBody: Swift.Equatable {
    let registrationArn: Swift.String?
    let registrationId: Swift.String?
    let registrationVersions: [PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation]?
    let nextToken: Swift.String?
}

extension DescribeRegistrationVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case registrationArn = "RegistrationArn"
        case registrationId = "RegistrationId"
        case registrationVersions = "RegistrationVersions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationArn)
        registrationArn = registrationArnDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let registrationVersionsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation?].self, forKey: .registrationVersions)
        var registrationVersionsDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation]? = nil
        if let registrationVersionsContainer = registrationVersionsContainer {
            registrationVersionsDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation]()
            for structure0 in registrationVersionsContainer {
                if let structure0 = structure0 {
                    registrationVersionsDecoded0?.append(structure0)
                }
            }
        }
        registrationVersions = registrationVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeRegistrationVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRegistrationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationIds = "RegistrationIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for registrationfilter0 in filters {
                try filtersContainer.encode(registrationfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registrationIds = registrationIds {
            var registrationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .registrationIds)
            for registrationidorarn0 in registrationIds {
                try registrationIdsContainer.encode(registrationidorarn0)
            }
        }
    }
}

extension DescribeRegistrationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRegistrationsInput: Swift.Equatable {
    /// An array of RegistrationFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.RegistrationFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of unique identifiers for each registration.
    public var registrationIds: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.RegistrationFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationIds = registrationIds
    }
}

struct DescribeRegistrationsInputBody: Swift.Equatable {
    let registrationIds: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.RegistrationFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeRegistrationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationIds = "RegistrationIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .registrationIds)
        var registrationIdsDecoded0:[Swift.String]? = nil
        if let registrationIdsContainer = registrationIdsContainer {
            registrationIdsDecoded0 = [Swift.String]()
            for string0 in registrationIdsContainer {
                if let string0 = string0 {
                    registrationIdsDecoded0?.append(string0)
                }
            }
        }
        registrationIds = registrationIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRegistrationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRegistrationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registrations = output.registrations
        } else {
            self.nextToken = nil
            self.registrations = nil
        }
    }
}

public struct DescribeRegistrationsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of RegistrationInformation objects.
    /// This member is required.
    public var registrations: [PinpointSMSVoiceV2ClientTypes.RegistrationInformation]?

    public init(
        nextToken: Swift.String? = nil,
        registrations: [PinpointSMSVoiceV2ClientTypes.RegistrationInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.registrations = registrations
    }
}

struct DescribeRegistrationsOutputBody: Swift.Equatable {
    let registrations: [PinpointSMSVoiceV2ClientTypes.RegistrationInformation]?
    let nextToken: Swift.String?
}

extension DescribeRegistrationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case registrations = "Registrations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationInformation?].self, forKey: .registrations)
        var registrationsDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationInformation]? = nil
        if let registrationsContainer = registrationsContainer {
            registrationsDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationInformation]()
            for structure0 in registrationsContainer {
                if let structure0 = structure0 {
                    registrationsDecoded0?.append(structure0)
                }
            }
        }
        registrations = registrationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeRegistrationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSenderIdsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case senderIds = "SenderIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for senderidfilter0 in filters {
                try filtersContainer.encode(senderidfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let senderIds = senderIds {
            var senderIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .senderIds)
            for senderidandcountry0 in senderIds {
                try senderIdsContainer.encode(senderidandcountry0)
            }
        }
    }
}

extension DescribeSenderIdsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSenderIdsInput: Swift.Equatable {
    /// An array of SenderIdFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.SenderIdFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of SenderIdAndCountry objects to search for.
    public var senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.SenderIdFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.senderIds = senderIds
    }
}

struct DescribeSenderIdsInputBody: Swift.Equatable {
    let senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry]?
    let filters: [PinpointSMSVoiceV2ClientTypes.SenderIdFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeSenderIdsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case senderIds = "SenderIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry?].self, forKey: .senderIds)
        var senderIdsDecoded0:[PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry]? = nil
        if let senderIdsContainer = senderIdsContainer {
            senderIdsDecoded0 = [PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry]()
            for structure0 in senderIdsContainer {
                if let structure0 = structure0 {
                    senderIdsDecoded0?.append(structure0)
                }
            }
        }
        senderIds = senderIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.SenderIdFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.SenderIdFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.SenderIdFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeSenderIdsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSenderIdsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.senderIds = output.senderIds
        } else {
            self.nextToken = nil
            self.senderIds = nil
        }
    }
}

public struct DescribeSenderIdsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of SernderIdInformation objects that contain the details for the requested SenderIds.
    public var senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdInformation]?

    public init(
        nextToken: Swift.String? = nil,
        senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.senderIds = senderIds
    }
}

struct DescribeSenderIdsOutputBody: Swift.Equatable {
    let senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdInformation]?
    let nextToken: Swift.String?
}

extension DescribeSenderIdsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case senderIds = "SenderIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.SenderIdInformation?].self, forKey: .senderIds)
        var senderIdsDecoded0:[PinpointSMSVoiceV2ClientTypes.SenderIdInformation]? = nil
        if let senderIdsContainer = senderIdsContainer {
            senderIdsDecoded0 = [PinpointSMSVoiceV2ClientTypes.SenderIdInformation]()
            for structure0 in senderIdsContainer {
                if let structure0 = structure0 {
                    senderIdsDecoded0?.append(structure0)
                }
            }
        }
        senderIds = senderIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSenderIdsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSpendLimitsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeSpendLimitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSpendLimitsInput: Swift.Equatable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeSpendLimitsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeSpendLimitsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeSpendLimitsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSpendLimitsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.spendLimits = output.spendLimits
        } else {
            self.nextToken = nil
            self.spendLimits = nil
        }
    }
}

public struct DescribeSpendLimitsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of SpendLimit objects that contain the details for the requested spend limits.
    public var spendLimits: [PinpointSMSVoiceV2ClientTypes.SpendLimit]?

    public init(
        nextToken: Swift.String? = nil,
        spendLimits: [PinpointSMSVoiceV2ClientTypes.SpendLimit]? = nil
    )
    {
        self.nextToken = nextToken
        self.spendLimits = spendLimits
    }
}

struct DescribeSpendLimitsOutputBody: Swift.Equatable {
    let spendLimits: [PinpointSMSVoiceV2ClientTypes.SpendLimit]?
    let nextToken: Swift.String?
}

extension DescribeSpendLimitsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case spendLimits = "SpendLimits"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spendLimitsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.SpendLimit?].self, forKey: .spendLimits)
        var spendLimitsDecoded0:[PinpointSMSVoiceV2ClientTypes.SpendLimit]? = nil
        if let spendLimitsContainer = spendLimitsContainer {
            spendLimitsDecoded0 = [PinpointSMSVoiceV2ClientTypes.SpendLimit]()
            for structure0 in spendLimitsContainer {
                if let structure0 = structure0 {
                    spendLimitsDecoded0?.append(structure0)
                }
            }
        }
        spendLimits = spendLimitsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSpendLimitsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeVerifiedDestinationNumbersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPhoneNumbers = "DestinationPhoneNumbers"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case verifiedDestinationNumberIds = "VerifiedDestinationNumberIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPhoneNumbers = destinationPhoneNumbers {
            var destinationPhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPhoneNumbers)
            for phonenumber0 in destinationPhoneNumbers {
                try destinationPhoneNumbersContainer.encode(phonenumber0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for verifieddestinationnumberfilter0 in filters {
                try filtersContainer.encode(verifieddestinationnumberfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let verifiedDestinationNumberIds = verifiedDestinationNumberIds {
            var verifiedDestinationNumberIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .verifiedDestinationNumberIds)
            for verifieddestinationnumberidorarn0 in verifiedDestinationNumberIds {
                try verifiedDestinationNumberIdsContainer.encode(verifieddestinationnumberidorarn0)
            }
        }
    }
}

extension DescribeVerifiedDestinationNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeVerifiedDestinationNumbersInput: Swift.Equatable {
    /// An array of verified destination phone number, in E.164 format.
    public var destinationPhoneNumbers: [Swift.String]?
    /// An array of VerifiedDestinationNumberFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of VerifiedDestinationNumberid to retreive.
    public var verifiedDestinationNumberIds: [Swift.String]?

    public init(
        destinationPhoneNumbers: [Swift.String]? = nil,
        filters: [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        verifiedDestinationNumberIds: [Swift.String]? = nil
    )
    {
        self.destinationPhoneNumbers = destinationPhoneNumbers
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.verifiedDestinationNumberIds = verifiedDestinationNumberIds
    }
}

struct DescribeVerifiedDestinationNumbersInputBody: Swift.Equatable {
    let verifiedDestinationNumberIds: [Swift.String]?
    let destinationPhoneNumbers: [Swift.String]?
    let filters: [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeVerifiedDestinationNumbersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPhoneNumbers = "DestinationPhoneNumbers"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case verifiedDestinationNumberIds = "VerifiedDestinationNumberIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verifiedDestinationNumberIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .verifiedDestinationNumberIds)
        var verifiedDestinationNumberIdsDecoded0:[Swift.String]? = nil
        if let verifiedDestinationNumberIdsContainer = verifiedDestinationNumberIdsContainer {
            verifiedDestinationNumberIdsDecoded0 = [Swift.String]()
            for string0 in verifiedDestinationNumberIdsContainer {
                if let string0 = string0 {
                    verifiedDestinationNumberIdsDecoded0?.append(string0)
                }
            }
        }
        verifiedDestinationNumberIds = verifiedDestinationNumberIdsDecoded0
        let destinationPhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinationPhoneNumbers)
        var destinationPhoneNumbersDecoded0:[Swift.String]? = nil
        if let destinationPhoneNumbersContainer = destinationPhoneNumbersContainer {
            destinationPhoneNumbersDecoded0 = [Swift.String]()
            for string0 in destinationPhoneNumbersContainer {
                if let string0 = string0 {
                    destinationPhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        destinationPhoneNumbers = destinationPhoneNumbersDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeVerifiedDestinationNumbersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeVerifiedDestinationNumbersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.verifiedDestinationNumbers = output.verifiedDestinationNumbers
        } else {
            self.nextToken = nil
            self.verifiedDestinationNumbers = nil
        }
    }
}

public struct DescribeVerifiedDestinationNumbersOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of VerifiedDestinationNumberInformation objects
    /// This member is required.
    public var verifiedDestinationNumbers: [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation]?

    public init(
        nextToken: Swift.String? = nil,
        verifiedDestinationNumbers: [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.verifiedDestinationNumbers = verifiedDestinationNumbers
    }
}

struct DescribeVerifiedDestinationNumbersOutputBody: Swift.Equatable {
    let verifiedDestinationNumbers: [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation]?
    let nextToken: Swift.String?
}

extension DescribeVerifiedDestinationNumbersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case verifiedDestinationNumbers = "VerifiedDestinationNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verifiedDestinationNumbersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation?].self, forKey: .verifiedDestinationNumbers)
        var verifiedDestinationNumbersDecoded0:[PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation]? = nil
        if let verifiedDestinationNumbersContainer = verifiedDestinationNumbersContainer {
            verifiedDestinationNumbersDecoded0 = [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation]()
            for structure0 in verifiedDestinationNumbersContainer {
                if let structure0 = structure0 {
                    verifiedDestinationNumbersDecoded0?.append(structure0)
                }
            }
        }
        verifiedDestinationNumbers = verifiedDestinationNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeVerifiedDestinationNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum DestinationCountryParameterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inEntityId
        case inTemplateId
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationCountryParameterKey] {
            return [
                .inEntityId,
                .inTemplateId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inEntityId: return "IN_ENTITY_ID"
            case .inTemplateId: return "IN_TEMPLATE_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationCountryParameterKey(rawValue: rawValue) ?? DestinationCountryParameterKey.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateOriginationIdentityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case isoCountryCode = "IsoCountryCode"
        case originationIdentity = "OriginationIdentity"
        case poolId = "PoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
    }
}

extension DisassociateOriginationIdentityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateOriginationIdentityInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use [DescribePhoneNumbers] find the values for PhoneNumberId and PhoneNumberArn, or use [DescribeSenderIds] to get the values for SenderId and SenderIdArn.
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// The unique identifier for the pool to disassociate with the origination identity. This value can be either the PoolId or PoolArn.
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        isoCountryCode: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.isoCountryCode = isoCountryCode
        self.originationIdentity = originationIdentity
        self.poolId = poolId
    }
}

struct DisassociateOriginationIdentityInputBody: Swift.Equatable {
    let poolId: Swift.String?
    let originationIdentity: Swift.String?
    let isoCountryCode: Swift.String?
    let clientToken: Swift.String?
}

extension DisassociateOriginationIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case isoCountryCode = "IsoCountryCode"
        case originationIdentity = "OriginationIdentity"
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateOriginationIdentityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateOriginationIdentityOutputBody = try responseDecoder.decode(responseBody: data)
            self.isoCountryCode = output.isoCountryCode
            self.originationIdentity = output.originationIdentity
            self.originationIdentityArn = output.originationIdentityArn
            self.poolArn = output.poolArn
            self.poolId = output.poolId
        } else {
            self.isoCountryCode = nil
            self.originationIdentity = nil
            self.originationIdentityArn = nil
            self.poolArn = nil
            self.poolId = nil
        }
    }
}

public struct DisassociateOriginationIdentityOutput: Swift.Equatable {
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The PhoneNumberId or SenderId of the origination identity.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or SenderIdArn of the origination identity.
    public var originationIdentityArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the pool.
    public var poolArn: Swift.String?
    /// The PoolId of the pool no longer associated with the origination identity.
    public var poolId: Swift.String?

    public init(
        isoCountryCode: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
        self.poolArn = poolArn
        self.poolId = poolId
    }
}

struct DisassociateOriginationIdentityOutputBody: Swift.Equatable {
    let poolArn: Swift.String?
    let poolId: Swift.String?
    let originationIdentityArn: Swift.String?
    let originationIdentity: Swift.String?
    let isoCountryCode: Swift.String?
}

extension DisassociateOriginationIdentityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case originationIdentity = "OriginationIdentity"
        case originationIdentityArn = "OriginationIdentityArn"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let originationIdentityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentityArn)
        originationIdentityArn = originationIdentityArnDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
    }
}

enum DisassociateOriginationIdentityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DiscardRegistrationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationId = "RegistrationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
    }
}

extension DiscardRegistrationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DiscardRegistrationVersionInput: Swift.Equatable {
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?

    public init(
        registrationId: Swift.String? = nil
    )
    {
        self.registrationId = registrationId
    }
}

struct DiscardRegistrationVersionInputBody: Swift.Equatable {
    let registrationId: Swift.String?
}

extension DiscardRegistrationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationId = "RegistrationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
    }
}

extension DiscardRegistrationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DiscardRegistrationVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.registrationArn = output.registrationArn
            self.registrationId = output.registrationId
            self.registrationVersionStatus = output.registrationVersionStatus
            self.registrationVersionStatusHistory = output.registrationVersionStatusHistory
            self.versionNumber = output.versionNumber
        } else {
            self.registrationArn = nil
            self.registrationId = nil
            self.registrationVersionStatus = nil
            self.registrationVersionStatusHistory = nil
            self.versionNumber = nil
        }
    }
}

public struct DiscardRegistrationVersionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The status of the registration version.
    ///
    /// * DRAFT: The initial status of a registration version after it’s created.
    ///
    /// * SUBMITTED: Your registration has been submitted.
    ///
    /// * REVIEWING: Your registration has been accepted and is being reviewed.
    ///
    /// * APPROVED: Your registration has been approved.
    ///
    /// * DISCARDED: You've abandon this version of their registration to start over with a new version.
    ///
    /// * DENIED: You must fix your registration and resubmit it.
    ///
    /// * REVOKED: Your previously approved registration has been revoked.
    ///
    /// * ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.
    /// This member is required.
    public var registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus?
    /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
    /// This member is required.
    public var registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory?
    /// The version number of the registration.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus? = nil,
        registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationVersionStatus = registrationVersionStatus
        self.registrationVersionStatusHistory = registrationVersionStatusHistory
        self.versionNumber = versionNumber
    }
}

struct DiscardRegistrationVersionOutputBody: Swift.Equatable {
    let registrationArn: Swift.String?
    let registrationId: Swift.String?
    let versionNumber: Swift.Int?
    let registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus?
    let registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory?
}

extension DiscardRegistrationVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationArn = "RegistrationArn"
        case registrationId = "RegistrationId"
        case registrationVersionStatus = "RegistrationVersionStatus"
        case registrationVersionStatusHistory = "RegistrationVersionStatusHistory"
        case versionNumber = "VersionNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationArn)
        registrationArn = registrationArnDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let registrationVersionStatusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus.self, forKey: .registrationVersionStatus)
        registrationVersionStatus = registrationVersionStatusDecoded
        let registrationVersionStatusHistoryDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory.self, forKey: .registrationVersionStatusHistory)
        registrationVersionStatusHistory = registrationVersionStatusHistoryDecoded
    }
}

enum DiscardRegistrationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.EventDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case enabled = "Enabled"
        case eventDestinationName = "EventDestinationName"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsDestination = self.cloudWatchLogsDestination {
            try encodeContainer.encode(cloudWatchLogsDestination, forKey: .cloudWatchLogsDestination)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventDestinationName = self.eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
        if let kinesisFirehoseDestination = self.kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtype0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtype0.rawValue)
            }
        }
        if let snsDestination = self.snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[PinpointSMSVoiceV2ClientTypes.EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [PinpointSMSVoiceV2ClientTypes.EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let cloudWatchLogsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination.self, forKey: .cloudWatchLogsDestination)
        cloudWatchLogsDestination = cloudWatchLogsDestinationDecoded
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Contains information about an event destination. Event destinations are associated with configuration sets, which enable you to publish message sending events to CloudWatch, Kinesis Data Firehose,or Amazon SNS.
    public struct EventDestination: Swift.Equatable {
        /// An object that contains information about an event destination that sends logging events to Amazon CloudWatch logs.
        public var cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
        /// When set to true events will be logged.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The name of the EventDestination.
        /// This member is required.
        public var eventDestinationName: Swift.String?
        /// An object that contains information about an event destination for logging to Amazon Kinesis Data Firehose.
        public var kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
        /// An array of event types that determine which events to log. The TEXT_SENT event type is not supported.
        /// This member is required.
        public var matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
        /// An object that contains information about an event destination that sends logging events to Amazon SNS.
        public var snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?

        public init(
            cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination? = nil,
            enabled: Swift.Bool? = nil,
            eventDestinationName: Swift.String? = nil,
            kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination? = nil,
            matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]? = nil,
            snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination? = nil
        )
        {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.enabled = enabled
            self.eventDestinationName = eventDestinationName
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case textAll
        case textBlocked
        case textCarrierBlocked
        case textCarrierUnreachable
        case textDelivered
        case textInvalid
        case textInvalidMessage
        case textPending
        case textQueued
        case textSent
        case textSpam
        case textSuccessful
        case textTtlExpired
        case textUnknown
        case textUnreachable
        case voiceAll
        case voiceAnswered
        case voiceBusy
        case voiceCompleted
        case voiceFailed
        case voiceInitiated
        case voiceNoAnswer
        case voiceRinging
        case voiceTtlExpired
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .all,
                .textAll,
                .textBlocked,
                .textCarrierBlocked,
                .textCarrierUnreachable,
                .textDelivered,
                .textInvalid,
                .textInvalidMessage,
                .textPending,
                .textQueued,
                .textSent,
                .textSpam,
                .textSuccessful,
                .textTtlExpired,
                .textUnknown,
                .textUnreachable,
                .voiceAll,
                .voiceAnswered,
                .voiceBusy,
                .voiceCompleted,
                .voiceFailed,
                .voiceInitiated,
                .voiceNoAnswer,
                .voiceRinging,
                .voiceTtlExpired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .textAll: return "TEXT_ALL"
            case .textBlocked: return "TEXT_BLOCKED"
            case .textCarrierBlocked: return "TEXT_CARRIER_BLOCKED"
            case .textCarrierUnreachable: return "TEXT_CARRIER_UNREACHABLE"
            case .textDelivered: return "TEXT_DELIVERED"
            case .textInvalid: return "TEXT_INVALID"
            case .textInvalidMessage: return "TEXT_INVALID_MESSAGE"
            case .textPending: return "TEXT_PENDING"
            case .textQueued: return "TEXT_QUEUED"
            case .textSent: return "TEXT_SENT"
            case .textSpam: return "TEXT_SPAM"
            case .textSuccessful: return "TEXT_SUCCESSFUL"
            case .textTtlExpired: return "TEXT_TTL_EXPIRED"
            case .textUnknown: return "TEXT_UNKNOWN"
            case .textUnreachable: return "TEXT_UNREACHABLE"
            case .voiceAll: return "VOICE_ALL"
            case .voiceAnswered: return "VOICE_ANSWERED"
            case .voiceBusy: return "VOICE_BUSY"
            case .voiceCompleted: return "VOICE_COMPLETED"
            case .voiceFailed: return "VOICE_FAILED"
            case .voiceInitiated: return "VOICE_INITIATED"
            case .voiceNoAnswer: return "VOICE_NO_ANSWER"
            case .voiceRinging: return "VOICE_RINGING"
            case .voiceTtlExpired: return "VOICE_TTL_EXPIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum FieldRequirement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conditional
        case `optional`
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldRequirement] {
            return [
                .conditional,
                .optional,
                .required,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conditional: return "CONDITIONAL"
            case .optional: return "OPTIONAL"
            case .required: return "REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FieldRequirement(rawValue: rawValue) ?? FieldRequirement.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum FieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachment
        case select
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldType] {
            return [
                .attachment,
                .select,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachment: return "ATTACHMENT"
            case .select: return "SELECT"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FieldType(rawValue: rawValue) ?? FieldType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The API encountered an unexpected error and couldn't complete the request. You might be able to successfully issue the request again in the future.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum KeywordAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automaticResponse
        case optIn
        case optOut
        case sdkUnknown(Swift.String)

        public static var allCases: [KeywordAction] {
            return [
                .automaticResponse,
                .optIn,
                .optOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automaticResponse: return "AUTOMATIC_RESPONSE"
            case .optIn: return "OPT_IN"
            case .optOut: return "OPT_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KeywordAction(rawValue: rawValue) ?? KeywordAction.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.KeywordFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KeywordFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for keywords that meet a specified criteria.
    public struct KeywordFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.KeywordFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.KeywordFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum KeywordFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case keywordAction
        case sdkUnknown(Swift.String)

        public static var allCases: [KeywordFilterName] {
            return [
                .keywordAction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .keywordAction: return "keyword-action"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KeywordFilterName(rawValue: rawValue) ?? KeywordFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.KeywordInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case keywordAction = "KeywordAction"
        case keywordMessage = "KeywordMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyword = self.keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let keywordAction = self.keywordAction {
            try encodeContainer.encode(keywordAction.rawValue, forKey: .keywordAction)
        }
        if let keywordMessage = self.keywordMessage {
            try encodeContainer.encode(keywordMessage, forKey: .keywordMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
        let keywordMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywordMessage)
        keywordMessage = keywordMessageDecoded
        let keywordActionDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KeywordAction.self, forKey: .keywordAction)
        keywordAction = keywordActionDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for all keywords in a pool.
    public struct KeywordInformation: Swift.Equatable {
        /// The keyword as a string.
        /// This member is required.
        public var keyword: Swift.String?
        /// The action to perform for the keyword.
        /// This member is required.
        public var keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
        /// A custom message that can be used with the keyword.
        /// This member is required.
        public var keywordMessage: Swift.String?

        public init(
            keyword: Swift.String? = nil,
            keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction? = nil,
            keywordMessage: Swift.String? = nil
        )
        {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStreamArn = "DeliveryStreamArn"
        case iamRoleArn = "IamRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamArn = self.deliveryStreamArn {
            try encodeContainer.encode(deliveryStreamArn, forKey: .deliveryStreamArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let deliveryStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStreamArn)
        deliveryStreamArn = deliveryStreamArnDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Contains the delivery stream Amazon Resource Name (ARN), and the ARN of the Identity and Access Management (IAM) role associated with an Kinesis Data Firehose event destination. Event destinations, such as Kinesis Data Firehose, are associated with configuration sets, which enable you to publish message sending events.
    public struct KinesisFirehoseDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        /// This member is required.
        public var deliveryStreamArn: Swift.String?
        /// The ARN of an Amazon Identity and Access Management (IAM) role that is able to write event data to an Amazon Firehose destination.
        /// This member is required.
        public var iamRoleArn: Swift.String?

        public init(
            deliveryStreamArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil
        )
        {
            self.deliveryStreamArn = deliveryStreamArn
            self.iamRoleArn = iamRoleArn
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum LanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enGb
        case enUs
        case es419
        case esEs
        case frCa
        case frFr
        case itIt
        case jaJp
        case koKr
        case ptBr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .deDe,
                .enGb,
                .enUs,
                .es419,
                .esEs,
                .frCa,
                .frFr,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .zhCn,
                .zhTw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "DE_DE"
            case .enGb: return "EN_GB"
            case .enUs: return "EN_US"
            case .es419: return "ES_419"
            case .esEs: return "ES_ES"
            case .frCa: return "FR_CA"
            case .frFr: return "FR_FR"
            case .itIt: return "IT_IT"
            case .jaJp: return "JA_JP"
            case .koKr: return "KO_KR"
            case .ptBr: return "PT_BR"
            case .zhCn: return "ZH_CN"
            case .zhTw: return "ZH_TW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ListPoolOriginationIdentitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolId = "PoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for pooloriginationidentitiesfilter0 in filters {
                try filtersContainer.encode(pooloriginationidentitiesfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
    }
}

extension ListPoolOriginationIdentitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPoolOriginationIdentitiesInput: Swift.Equatable {
    /// An array of PoolOriginationIdentitiesFilter objects to filter the results..
    public var filters: [PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier for the pool. This value can be either the PoolId or PoolArn.
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolId = poolId
    }
}

struct ListPoolOriginationIdentitiesInputBody: Swift.Equatable {
    let poolId: Swift.String?
    let filters: [PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPoolOriginationIdentitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPoolOriginationIdentitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPoolOriginationIdentitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.originationIdentities = output.originationIdentities
            self.poolArn = output.poolArn
            self.poolId = output.poolId
        } else {
            self.nextToken = nil
            self.originationIdentities = nil
            self.poolArn = nil
            self.poolId = nil
        }
    }
}

public struct ListPoolOriginationIdentitiesOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of any OriginationIdentityMetadata objects.
    public var originationIdentities: [PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]?
    /// The Amazon Resource Name (ARN) for the pool.
    public var poolArn: Swift.String?
    /// The unique PoolId of the pool.
    public var poolId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        originationIdentities: [PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.originationIdentities = originationIdentities
        self.poolArn = poolArn
        self.poolId = poolId
    }
}

struct ListPoolOriginationIdentitiesOutputBody: Swift.Equatable {
    let poolArn: Swift.String?
    let poolId: Swift.String?
    let originationIdentities: [PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]?
    let nextToken: Swift.String?
}

extension ListPoolOriginationIdentitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case originationIdentities = "OriginationIdentities"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let originationIdentitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata?].self, forKey: .originationIdentities)
        var originationIdentitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]? = nil
        if let originationIdentitiesContainer = originationIdentitiesContainer {
            originationIdentitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]()
            for structure0 in originationIdentitiesContainer {
                if let structure0 = structure0 {
                    originationIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        originationIdentities = originationIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPoolOriginationIdentitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRegistrationAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationId = "RegistrationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for registrationassociationfilter0 in filters {
                try filtersContainer.encode(registrationassociationfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
    }
}

extension ListRegistrationAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRegistrationAssociationsInput: Swift.Equatable {
    /// An array of RegistrationAssociationFilter to apply to the results that are returned.
    public var filters: [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationId = registrationId
    }
}

struct ListRegistrationAssociationsInputBody: Swift.Equatable {
    let registrationId: Swift.String?
    let filters: [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRegistrationAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case registrationId = "RegistrationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilter?].self, forKey: .filters)
        var filtersDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRegistrationAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRegistrationAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registrationArn = output.registrationArn
            self.registrationAssociations = output.registrationAssociations
            self.registrationId = output.registrationId
            self.registrationType = output.registrationType
        } else {
            self.nextToken = nil
            self.registrationArn = nil
            self.registrationAssociations = nil
            self.registrationId = nil
            self.registrationType = nil
        }
    }
}

public struct ListRegistrationAssociationsOutput: Swift.Equatable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// An array of RegistrationAssociationMetadata objects.
    /// This member is required.
    public var registrationAssociations: [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata]?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        registrationArn: Swift.String? = nil,
        registrationAssociations: [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata]? = nil,
        registrationId: Swift.String? = nil,
        registrationType: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationArn = registrationArn
        self.registrationAssociations = registrationAssociations
        self.registrationId = registrationId
        self.registrationType = registrationType
    }
}

struct ListRegistrationAssociationsOutputBody: Swift.Equatable {
    let registrationArn: Swift.String?
    let registrationId: Swift.String?
    let registrationType: Swift.String?
    let registrationAssociations: [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata]?
    let nextToken: Swift.String?
}

extension ListRegistrationAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case registrationArn = "RegistrationArn"
        case registrationAssociations = "RegistrationAssociations"
        case registrationId = "RegistrationId"
        case registrationType = "RegistrationType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationArn)
        registrationArn = registrationArnDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let registrationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationType)
        registrationType = registrationTypeDecoded
        let registrationAssociationsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata?].self, forKey: .registrationAssociations)
        var registrationAssociationsDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata]? = nil
        if let registrationAssociationsContainer = registrationAssociationsContainer {
            registrationAssociationsDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata]()
            for structure0 in registrationAssociationsContainer {
                if let structure0 = structure0 {
                    registrationAssociationsDecoded0?.append(structure0)
                }
            }
        }
        registrationAssociations = registrationAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRegistrationAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to query for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.tags = output.tags
        } else {
            self.resourceArn = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The ARN of the resource.
    public var resourceArn: Swift.String?
    /// An array of key and value pair tags that are associated with the resource.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum MessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case promotional
        case transactional
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .promotional,
                .transactional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .promotional: return "PROMOTIONAL"
            case .transactional: return "TRANSACTIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum NumberCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberCapability] {
            return [
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberCapability(rawValue: rawValue) ?? NumberCapability.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum NumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case associating
        case deleted
        case disassociating
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberStatus] {
            return [
                .active,
                .associating,
                .deleted,
                .disassociating,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .associating: return "ASSOCIATING"
            case .deleted: return "DELETED"
            case .disassociating: return "DISASSOCIATING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberStatus(rawValue: rawValue) ?? NumberStatus.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum NumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case longCode
        case shortCode
        case simulator
        case tenDlc
        case tollFree
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberType] {
            return [
                .longCode,
                .shortCode,
                .simulator,
                .tenDlc,
                .tollFree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .longCode: return "LONG_CODE"
            case .shortCode: return "SHORT_CODE"
            case .simulator: return "SIMULATOR"
            case .tenDlc: return "TEN_DLC"
            case .tollFree: return "TOLL_FREE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberType(rawValue: rawValue) ?? NumberType.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.OptOutListInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case optOutListArn = "OptOutListArn"
        case optOutListName = "OptOutListName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let optOutListArn = self.optOutListArn {
            try encodeContainer.encode(optOutListArn, forKey: .optOutListArn)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListArn)
        optOutListArn = optOutListArnDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for all OptOutList in an Amazon Web Services account.
    public struct OptOutListInformation: Swift.Equatable {
        /// The time when the OutOutList was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the OptOutList.
        /// This member is required.
        public var optOutListArn: Swift.String?
        /// The name of the OptOutList.
        /// This member is required.
        public var optOutListName: Swift.String?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            optOutListArn: Swift.String? = nil,
            optOutListName: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.OptedOutFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.OptedOutFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for opted out numbers that meet a specified criteria.
    public struct OptedOutFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.OptedOutFilterName?
        /// An array of values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.OptedOutFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum OptedOutFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case endUserOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [OptedOutFilterName] {
            return [
                .endUserOptedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .endUserOptedOut: return "end-user-opted-out"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptedOutFilterName(rawValue: rawValue) ?? OptedOutFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endUserOptedOut = "EndUserOptedOut"
        case optedOutNumber = "OptedOutNumber"
        case optedOutTimestamp = "OptedOutTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if endUserOptedOut != false {
            try encodeContainer.encode(endUserOptedOut, forKey: .endUserOptedOut)
        }
        if let optedOutNumber = self.optedOutNumber {
            try encodeContainer.encode(optedOutNumber, forKey: .optedOutNumber)
        }
        if let optedOutTimestamp = self.optedOutTimestamp {
            try encodeContainer.encodeTimestamp(optedOutTimestamp, format: .epochSeconds, forKey: .optedOutTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optedOutNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optedOutNumber)
        optedOutNumber = optedOutNumberDecoded
        let optedOutTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .optedOutTimestamp)
        optedOutTimestamp = optedOutTimestampDecoded
        let endUserOptedOutDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .endUserOptedOut) ?? false
        endUserOptedOut = endUserOptedOutDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for an opted out number in an Amazon Web Services account.
    public struct OptedOutNumberInformation: Swift.Equatable {
        /// This is set to true if it was the end recipient that opted out.
        /// This member is required.
        public var endUserOptedOut: Swift.Bool
        /// The phone number that is opted out.
        /// This member is required.
        public var optedOutNumber: Swift.String?
        /// The time that the op tout occurred, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var optedOutTimestamp: ClientRuntime.Date?

        public init(
            endUserOptedOut: Swift.Bool = false,
            optedOutNumber: Swift.String? = nil,
            optedOutTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.endUserOptedOut = endUserOptedOut
            self.optedOutNumber = optedOutNumber
            self.optedOutTimestamp = optedOutTimestamp
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case numberCapabilities = "NumberCapabilities"
        case originationIdentity = "OriginationIdentity"
        case originationIdentityArn = "OriginationIdentityArn"
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let numberCapabilities = numberCapabilities {
            var numberCapabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .numberCapabilities)
            for numbercapability0 in numberCapabilities {
                try numberCapabilitiesContainer.encode(numbercapability0.rawValue)
            }
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let originationIdentityArn = self.originationIdentityArn {
            try encodeContainer.encode(originationIdentityArn, forKey: .originationIdentityArn)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentityArn)
        originationIdentityArn = originationIdentityArnDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let numberCapabilitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.NumberCapability?].self, forKey: .numberCapabilities)
        var numberCapabilitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil
        if let numberCapabilitiesContainer = numberCapabilitiesContainer {
            numberCapabilitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.NumberCapability]()
            for string0 in numberCapabilitiesContainer {
                if let string0 = string0 {
                    numberCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        numberCapabilities = numberCapabilitiesDecoded0
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The metadata for an origination identity associated with a pool.
    public struct OriginationIdentityMetadata: Swift.Equatable {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        /// This member is required.
        public var isoCountryCode: Swift.String?
        /// Describes if the origination identity can be used for text messages, voice calls or both.
        /// This member is required.
        public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
        /// The unique identifier of the origination identity.
        /// This member is required.
        public var originationIdentity: Swift.String?
        /// The Amazon Resource Name (ARN) associated with the origination identity.
        /// This member is required.
        public var originationIdentityArn: Swift.String?
        /// The phone number in E.164 format.
        public var phoneNumber: Swift.String?

        public init(
            isoCountryCode: Swift.String? = nil,
            numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
            originationIdentity: Swift.String? = nil,
            originationIdentityArn: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.isoCountryCode = isoCountryCode
            self.numberCapabilities = numberCapabilities
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
            self.phoneNumber = phoneNumber
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PhoneNumberFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for a phone number that meets a specified criteria.
    public struct PhoneNumberFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.PhoneNumberFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.PhoneNumberFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum PhoneNumberFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deletionProtectionEnabled
        case isoCountryCode
        case messageType
        case numberCapability
        case numberType
        case optOutListName
        case selfManagedOptOutsEnabled
        case status
        case twoWayChannelArn
        case twoWayEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberFilterName] {
            return [
                .deletionProtectionEnabled,
                .isoCountryCode,
                .messageType,
                .numberCapability,
                .numberType,
                .optOutListName,
                .selfManagedOptOutsEnabled,
                .status,
                .twoWayChannelArn,
                .twoWayEnabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deletionProtectionEnabled: return "deletion-protection-enabled"
            case .isoCountryCode: return "iso-country-code"
            case .messageType: return "message-type"
            case .numberCapability: return "number-capability"
            case .numberType: return "number-type"
            case .optOutListName: return "opt-out-list-name"
            case .selfManagedOptOutsEnabled: return "self-managed-opt-outs-enabled"
            case .status: return "status"
            case .twoWayChannelArn: return "two-way-channel-arn"
            case .twoWayEnabled: return "two-way-enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberFilterName(rawValue: rawValue) ?? PhoneNumberFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case numberCapabilities = "NumberCapabilities"
        case numberType = "NumberType"
        case optOutListName = "OptOutListName"
        case phoneNumber = "PhoneNumber"
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberId = "PhoneNumberId"
        case poolId = "PoolId"
        case registrationId = "RegistrationId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case status = "Status"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayChannelRole = "TwoWayChannelRole"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if deletionProtectionEnabled != false {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let monthlyLeasingPrice = self.monthlyLeasingPrice {
            try encodeContainer.encode(monthlyLeasingPrice, forKey: .monthlyLeasingPrice)
        }
        if let numberCapabilities = numberCapabilities {
            var numberCapabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .numberCapabilities)
            for numbercapability0 in numberCapabilities {
                try numberCapabilitiesContainer.encode(numbercapability0.rawValue)
            }
        }
        if let numberType = self.numberType {
            try encodeContainer.encode(numberType.rawValue, forKey: .numberType)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumberArn = self.phoneNumberArn {
            try encodeContainer.encode(phoneNumberArn, forKey: .phoneNumberArn)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
        if selfManagedOptOutsEnabled != false {
            try encodeContainer.encode(selfManagedOptOutsEnabled, forKey: .selfManagedOptOutsEnabled)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let twoWayChannelArn = self.twoWayChannelArn {
            try encodeContainer.encode(twoWayChannelArn, forKey: .twoWayChannelArn)
        }
        if let twoWayChannelRole = self.twoWayChannelRole {
            try encodeContainer.encode(twoWayChannelRole, forKey: .twoWayChannelRole)
        }
        if twoWayEnabled != false {
            try encodeContainer.encode(twoWayEnabled, forKey: .twoWayEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberStatus.self, forKey: .status)
        status = statusDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let numberCapabilitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.NumberCapability?].self, forKey: .numberCapabilities)
        var numberCapabilitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil
        if let numberCapabilitiesContainer = numberCapabilitiesContainer {
            numberCapabilitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.NumberCapability]()
            for string0 in numberCapabilitiesContainer {
                if let string0 = string0 {
                    numberCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        numberCapabilities = numberCapabilitiesDecoded0
        let numberTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberType.self, forKey: .numberType)
        numberType = numberTypeDecoded
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let twoWayChannelRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelRole)
        twoWayChannelRole = twoWayChannelRoleDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for a phone number, in E.164 format, in an Amazon Web Services account.
    public struct PhoneNumberInformation: Swift.Equatable {
        /// The time when the phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: ClientRuntime.Date?
        /// When set to true the phone number can't be deleted.
        /// This member is required.
        public var deletionProtectionEnabled: Swift.Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        /// This member is required.
        public var isoCountryCode: Swift.String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        /// This member is required.
        public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
        /// The price, in US dollars, to lease the phone number.
        /// This member is required.
        public var monthlyLeasingPrice: Swift.String?
        /// Describes if the origination identity can be used for text messages, voice calls or both.
        /// This member is required.
        public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
        /// The type of phone number.
        /// This member is required.
        public var numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
        /// The name of the OptOutList associated with the phone number.
        /// This member is required.
        public var optOutListName: Swift.String?
        /// The phone number in E.164 format.
        /// This member is required.
        public var phoneNumber: Swift.String?
        /// The Amazon Resource Name (ARN) associated with the phone number.
        /// This member is required.
        public var phoneNumberArn: Swift.String?
        /// The unique identifier for the phone number.
        public var phoneNumberId: Swift.String?
        /// The unique identifier of the pool associated with the phone number.
        public var poolId: Swift.String?
        /// The unique identifier for the registration.
        public var registrationId: Swift.String?
        /// When set to false an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out request. For more information see [Self-managed opt-outs](https://docs.aws.amazon.com/pinpoint/latest/userguide/settings-sms-managing.html#settings-account-sms-self-managed-opt-out)
        /// This member is required.
        public var selfManagedOptOutsEnabled: Swift.Bool
        /// The current status of the phone number.
        /// This member is required.
        public var status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public var twoWayChannelArn: Swift.String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public var twoWayChannelRole: Swift.String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients using the TwoWayChannelArn.
        /// This member is required.
        public var twoWayEnabled: Swift.Bool

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            deletionProtectionEnabled: Swift.Bool = false,
            isoCountryCode: Swift.String? = nil,
            messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
            monthlyLeasingPrice: Swift.String? = nil,
            numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
            numberType: PinpointSMSVoiceV2ClientTypes.NumberType? = nil,
            optOutListName: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumberArn: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            poolId: Swift.String? = nil,
            registrationId: Swift.String? = nil,
            selfManagedOptOutsEnabled: Swift.Bool = false,
            status: PinpointSMSVoiceV2ClientTypes.NumberStatus? = nil,
            twoWayChannelArn: Swift.String? = nil,
            twoWayChannelRole: Swift.String? = nil,
            twoWayEnabled: Swift.Bool = false
        )
        {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.poolId = poolId
            self.registrationId = registrationId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.PoolFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PoolFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for a pool that meets a specified criteria.
    public struct PoolFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.PoolFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.PoolFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum PoolFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deletionProtectionEnabled
        case messageType
        case optOutListName
        case selfManagedOptOutsEnabled
        case sharedRoutesEnabled
        case status
        case twoWayChannelArn
        case twoWayEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PoolFilterName] {
            return [
                .deletionProtectionEnabled,
                .messageType,
                .optOutListName,
                .selfManagedOptOutsEnabled,
                .sharedRoutesEnabled,
                .status,
                .twoWayChannelArn,
                .twoWayEnabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deletionProtectionEnabled: return "deletion-protection-enabled"
            case .messageType: return "message-type"
            case .optOutListName: return "opt-out-list-name"
            case .selfManagedOptOutsEnabled: return "self-managed-opt-outs-enabled"
            case .sharedRoutesEnabled: return "shared-routes-enabled"
            case .status: return "status"
            case .twoWayChannelArn: return "two-way-channel-arn"
            case .twoWayEnabled: return "two-way-enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PoolFilterName(rawValue: rawValue) ?? PoolFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.PoolInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case messageType = "MessageType"
        case optOutListName = "OptOutListName"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case sharedRoutesEnabled = "SharedRoutesEnabled"
        case status = "Status"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayChannelRole = "TwoWayChannelRole"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if deletionProtectionEnabled != false {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let poolArn = self.poolArn {
            try encodeContainer.encode(poolArn, forKey: .poolArn)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if selfManagedOptOutsEnabled != false {
            try encodeContainer.encode(selfManagedOptOutsEnabled, forKey: .selfManagedOptOutsEnabled)
        }
        if sharedRoutesEnabled != false {
            try encodeContainer.encode(sharedRoutesEnabled, forKey: .sharedRoutesEnabled)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let twoWayChannelArn = self.twoWayChannelArn {
            try encodeContainer.encode(twoWayChannelArn, forKey: .twoWayChannelArn)
        }
        if let twoWayChannelRole = self.twoWayChannelRole {
            try encodeContainer.encode(twoWayChannelRole, forKey: .twoWayChannelRole)
        }
        if twoWayEnabled != false {
            try encodeContainer.encode(twoWayEnabled, forKey: .twoWayEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PoolStatus.self, forKey: .status)
        status = statusDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let twoWayChannelRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelRole)
        twoWayChannelRole = twoWayChannelRoleDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let sharedRoutesEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharedRoutesEnabled) ?? false
        sharedRoutesEnabled = sharedRoutesEnabledDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for a pool in an Amazon Web Services account.
    public struct PoolInformation: Swift.Equatable {
        /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: ClientRuntime.Date?
        /// When set to true the pool can't be deleted.
        /// This member is required.
        public var deletionProtectionEnabled: Swift.Bool
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        /// This member is required.
        public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
        /// The name of the OptOutList associated with the pool.
        /// This member is required.
        public var optOutListName: Swift.String?
        /// The Amazon Resource Name (ARN) for the pool.
        /// This member is required.
        public var poolArn: Swift.String?
        /// The unique identifier for the pool.
        /// This member is required.
        public var poolId: Swift.String?
        /// When set to false, an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests. For more information see [Self-managed opt-outs](https://docs.aws.amazon.com/pinpoint/latest/userguide/settings-sms-managing.html#settings-account-sms-self-managed-opt-out)
        /// This member is required.
        public var selfManagedOptOutsEnabled: Swift.Bool
        /// Allows you to enable shared routes on your pool. By default, this is set to False. If you set this value to True, your messages are sent using phone numbers or sender IDs (depending on the country) that are shared with other Amazon Pinpoint users. In some countries, such as the United States, senders aren't allowed to use shared routes and must use a dedicated phone number or short code.
        /// This member is required.
        public var sharedRoutesEnabled: Swift.Bool
        /// The current status of the pool.
        /// This member is required.
        public var status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public var twoWayChannelArn: Swift.String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public var twoWayChannelRole: Swift.String?
        /// When set to true you can receive incoming text messages from your end recipients using the TwoWayChannelArn.
        /// This member is required.
        public var twoWayEnabled: Swift.Bool

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            deletionProtectionEnabled: Swift.Bool = false,
            messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
            optOutListName: Swift.String? = nil,
            poolArn: Swift.String? = nil,
            poolId: Swift.String? = nil,
            selfManagedOptOutsEnabled: Swift.Bool = false,
            sharedRoutesEnabled: Swift.Bool = false,
            status: PinpointSMSVoiceV2ClientTypes.PoolStatus? = nil,
            twoWayChannelArn: Swift.String? = nil,
            twoWayChannelRole: Swift.String? = nil,
            twoWayEnabled: Swift.Bool = false
        )
        {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Information about origination identities associated with a pool that meets a specified criteria.
    public struct PoolOriginationIdentitiesFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum PoolOriginationIdentitiesFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case isoCountryCode
        case numberCapability
        case sdkUnknown(Swift.String)

        public static var allCases: [PoolOriginationIdentitiesFilterName] {
            return [
                .isoCountryCode,
                .numberCapability,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .isoCountryCode: return "iso-country-code"
            case .numberCapability: return "number-capability"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PoolOriginationIdentitiesFilterName(rawValue: rawValue) ?? PoolOriginationIdentitiesFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum PoolStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [PoolStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PoolStatus(rawValue: rawValue) ?? PoolStatus.sdkUnknown(rawValue)
        }
    }
}

extension PutKeywordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case keywordAction = "KeywordAction"
        case keywordMessage = "KeywordMessage"
        case originationIdentity = "OriginationIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyword = self.keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let keywordAction = self.keywordAction {
            try encodeContainer.encode(keywordAction.rawValue, forKey: .keywordAction)
        }
        if let keywordMessage = self.keywordMessage {
            try encodeContainer.encode(keywordMessage, forKey: .keywordMessage)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
    }
}

extension PutKeywordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutKeywordInput: Swift.Equatable {
    /// The new keyword to add.
    /// This member is required.
    public var keyword: Swift.String?
    /// The action to perform for the new keyword when it is received.
    ///
    /// * AUTOMATIC_RESPONSE: A message is sent to the recipient.
    ///
    /// * OPT_OUT: Keeps the recipient from receiving future messages.
    ///
    /// * OPT_IN: The recipient wants to receive future messages.
    public var keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
    /// The message associated with the keyword.
    /// This member is required.
    public var keywordMessage: Swift.String?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use [DescribePhoneNumbers] get the values for PhoneNumberId and PhoneNumberArn while [DescribeSenderIds] can be used to get the values for SenderId and SenderIdArn.
    /// This member is required.
    public var originationIdentity: Swift.String?

    public init(
        keyword: Swift.String? = nil,
        keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction? = nil,
        keywordMessage: Swift.String? = nil,
        originationIdentity: Swift.String? = nil
    )
    {
        self.keyword = keyword
        self.keywordAction = keywordAction
        self.keywordMessage = keywordMessage
        self.originationIdentity = originationIdentity
    }
}

struct PutKeywordInputBody: Swift.Equatable {
    let originationIdentity: Swift.String?
    let keyword: Swift.String?
    let keywordMessage: Swift.String?
    let keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
}

extension PutKeywordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case keywordAction = "KeywordAction"
        case keywordMessage = "KeywordMessage"
        case originationIdentity = "OriginationIdentity"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
        let keywordMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywordMessage)
        keywordMessage = keywordMessageDecoded
        let keywordActionDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KeywordAction.self, forKey: .keywordAction)
        keywordAction = keywordActionDecoded
    }
}

extension PutKeywordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutKeywordOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyword = output.keyword
            self.keywordAction = output.keywordAction
            self.keywordMessage = output.keywordMessage
            self.originationIdentity = output.originationIdentity
            self.originationIdentityArn = output.originationIdentityArn
        } else {
            self.keyword = nil
            self.keywordAction = nil
            self.keywordMessage = nil
            self.originationIdentity = nil
            self.originationIdentityArn = nil
        }
    }
}

public struct PutKeywordOutput: Swift.Equatable {
    /// The keyword that was added.
    public var keyword: Swift.String?
    /// The action to perform when the keyword is used.
    public var keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
    /// The message associated with the keyword.
    public var keywordMessage: Swift.String?
    /// The PhoneNumberId or PoolId that the keyword was associated with.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or PoolArn that the keyword was associated with.
    public var originationIdentityArn: Swift.String?

    public init(
        keyword: Swift.String? = nil,
        keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction? = nil,
        keywordMessage: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil
    )
    {
        self.keyword = keyword
        self.keywordAction = keywordAction
        self.keywordMessage = keywordMessage
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
    }
}

struct PutKeywordOutputBody: Swift.Equatable {
    let originationIdentityArn: Swift.String?
    let originationIdentity: Swift.String?
    let keyword: Swift.String?
    let keywordMessage: Swift.String?
    let keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
}

extension PutKeywordOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case keywordAction = "KeywordAction"
        case keywordMessage = "KeywordMessage"
        case originationIdentity = "OriginationIdentity"
        case originationIdentityArn = "OriginationIdentityArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationIdentityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentityArn)
        originationIdentityArn = originationIdentityArnDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
        let keywordMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywordMessage)
        keywordMessage = keywordMessageDecoded
        let keywordActionDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KeywordAction.self, forKey: .keywordAction)
        keywordAction = keywordActionDecoded
    }
}

enum PutKeywordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutOptedOutNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optOutListName = "OptOutListName"
        case optedOutNumber = "OptedOutNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let optedOutNumber = self.optedOutNumber {
            try encodeContainer.encode(optedOutNumber, forKey: .optedOutNumber)
        }
    }
}

extension PutOptedOutNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutOptedOutNumberInput: Swift.Equatable {
    /// The OptOutListName or OptOutListArn to add the phone number to.
    /// This member is required.
    public var optOutListName: Swift.String?
    /// The phone number to add to the OptOutList in E.164 format.
    /// This member is required.
    public var optedOutNumber: Swift.String?

    public init(
        optOutListName: Swift.String? = nil,
        optedOutNumber: Swift.String? = nil
    )
    {
        self.optOutListName = optOutListName
        self.optedOutNumber = optedOutNumber
    }
}

struct PutOptedOutNumberInputBody: Swift.Equatable {
    let optOutListName: Swift.String?
    let optedOutNumber: Swift.String?
}

extension PutOptedOutNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optOutListName = "OptOutListName"
        case optedOutNumber = "OptedOutNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let optedOutNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optedOutNumber)
        optedOutNumber = optedOutNumberDecoded
    }
}

extension PutOptedOutNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutOptedOutNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.endUserOptedOut = output.endUserOptedOut
            self.optOutListArn = output.optOutListArn
            self.optOutListName = output.optOutListName
            self.optedOutNumber = output.optedOutNumber
            self.optedOutTimestamp = output.optedOutTimestamp
        } else {
            self.endUserOptedOut = false
            self.optOutListArn = nil
            self.optOutListName = nil
            self.optedOutNumber = nil
            self.optedOutTimestamp = nil
        }
    }
}

public struct PutOptedOutNumberOutput: Swift.Equatable {
    /// This is true if it was the end user who requested their phone number be removed.
    public var endUserOptedOut: Swift.Bool
    /// The OptOutListArn that the phone number was removed from.
    public var optOutListArn: Swift.String?
    /// The OptOutListName that the phone number was removed from.
    public var optOutListName: Swift.String?
    /// The phone number that was added to the OptOutList.
    public var optedOutNumber: Swift.String?
    /// The time that the phone number was added to the OptOutList, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var optedOutTimestamp: ClientRuntime.Date?

    public init(
        endUserOptedOut: Swift.Bool = false,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        optedOutNumber: Swift.String? = nil,
        optedOutTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.endUserOptedOut = endUserOptedOut
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
        self.optedOutNumber = optedOutNumber
        self.optedOutTimestamp = optedOutTimestamp
    }
}

struct PutOptedOutNumberOutputBody: Swift.Equatable {
    let optOutListArn: Swift.String?
    let optOutListName: Swift.String?
    let optedOutNumber: Swift.String?
    let optedOutTimestamp: ClientRuntime.Date?
    let endUserOptedOut: Swift.Bool
}

extension PutOptedOutNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endUserOptedOut = "EndUserOptedOut"
        case optOutListArn = "OptOutListArn"
        case optOutListName = "OptOutListName"
        case optedOutNumber = "OptedOutNumber"
        case optedOutTimestamp = "OptedOutTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optOutListArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListArn)
        optOutListArn = optOutListArnDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let optedOutNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optedOutNumber)
        optedOutNumber = optedOutNumberDecoded
        let optedOutTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .optedOutTimestamp)
        optedOutTimestamp = optedOutTimestampDecoded
        let endUserOptedOutDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .endUserOptedOut) ?? false
        endUserOptedOut = endUserOptedOutDecoded
    }
}

enum PutOptedOutNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutRegistrationFieldValueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPath = "FieldPath"
        case registrationAttachmentId = "RegistrationAttachmentId"
        case registrationId = "RegistrationId"
        case selectChoices = "SelectChoices"
        case textValue = "TextValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldPath = self.fieldPath {
            try encodeContainer.encode(fieldPath, forKey: .fieldPath)
        }
        if let registrationAttachmentId = self.registrationAttachmentId {
            try encodeContainer.encode(registrationAttachmentId, forKey: .registrationAttachmentId)
        }
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
        if let selectChoices = selectChoices {
            var selectChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectChoices)
            for selectchoice0 in selectChoices {
                try selectChoicesContainer.encode(selectchoice0)
            }
        }
        if let textValue = self.textValue {
            try encodeContainer.encode(textValue, forKey: .textValue)
        }
    }
}

extension PutRegistrationFieldValueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRegistrationFieldValueInput: Swift.Equatable {
    /// The path to the registration form field. You can use [DescribeRegistrationFieldDefinitions] for a list of FieldPaths.
    /// This member is required.
    public var fieldPath: Swift.String?
    /// The unique identifier for the registration attachment.
    public var registrationAttachmentId: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// An array of values for the form field.
    public var selectChoices: [Swift.String]?
    /// The text data for a free form field.
    public var textValue: Swift.String?

    public init(
        fieldPath: Swift.String? = nil,
        registrationAttachmentId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        selectChoices: [Swift.String]? = nil,
        textValue: Swift.String? = nil
    )
    {
        self.fieldPath = fieldPath
        self.registrationAttachmentId = registrationAttachmentId
        self.registrationId = registrationId
        self.selectChoices = selectChoices
        self.textValue = textValue
    }
}

struct PutRegistrationFieldValueInputBody: Swift.Equatable {
    let registrationId: Swift.String?
    let fieldPath: Swift.String?
    let selectChoices: [Swift.String]?
    let textValue: Swift.String?
    let registrationAttachmentId: Swift.String?
}

extension PutRegistrationFieldValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPath = "FieldPath"
        case registrationAttachmentId = "RegistrationAttachmentId"
        case registrationId = "RegistrationId"
        case selectChoices = "SelectChoices"
        case textValue = "TextValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let fieldPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldPath)
        fieldPath = fieldPathDecoded
        let selectChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectChoices)
        var selectChoicesDecoded0:[Swift.String]? = nil
        if let selectChoicesContainer = selectChoicesContainer {
            selectChoicesDecoded0 = [Swift.String]()
            for string0 in selectChoicesContainer {
                if let string0 = string0 {
                    selectChoicesDecoded0?.append(string0)
                }
            }
        }
        selectChoices = selectChoicesDecoded0
        let textValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textValue)
        textValue = textValueDecoded
        let registrationAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationAttachmentId)
        registrationAttachmentId = registrationAttachmentIdDecoded
    }
}

extension PutRegistrationFieldValueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutRegistrationFieldValueOutputBody = try responseDecoder.decode(responseBody: data)
            self.fieldPath = output.fieldPath
            self.registrationArn = output.registrationArn
            self.registrationAttachmentId = output.registrationAttachmentId
            self.registrationId = output.registrationId
            self.selectChoices = output.selectChoices
            self.textValue = output.textValue
            self.versionNumber = output.versionNumber
        } else {
            self.fieldPath = nil
            self.registrationArn = nil
            self.registrationAttachmentId = nil
            self.registrationId = nil
            self.selectChoices = nil
            self.textValue = nil
            self.versionNumber = nil
        }
    }
}

public struct PutRegistrationFieldValueOutput: Swift.Equatable {
    /// The path to the registration form field. You can use [DescribeRegistrationFieldDefinitions] for a list of FieldPaths.
    /// This member is required.
    public var fieldPath: Swift.String?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration attachment.
    public var registrationAttachmentId: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// An array of values for the form field.
    public var selectChoices: [Swift.String]?
    /// The text data for a free form field.
    public var textValue: Swift.String?
    /// The version number of the registration.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        fieldPath: Swift.String? = nil,
        registrationArn: Swift.String? = nil,
        registrationAttachmentId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        selectChoices: [Swift.String]? = nil,
        textValue: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.fieldPath = fieldPath
        self.registrationArn = registrationArn
        self.registrationAttachmentId = registrationAttachmentId
        self.registrationId = registrationId
        self.selectChoices = selectChoices
        self.textValue = textValue
        self.versionNumber = versionNumber
    }
}

struct PutRegistrationFieldValueOutputBody: Swift.Equatable {
    let registrationArn: Swift.String?
    let registrationId: Swift.String?
    let versionNumber: Swift.Int?
    let fieldPath: Swift.String?
    let selectChoices: [Swift.String]?
    let textValue: Swift.String?
    let registrationAttachmentId: Swift.String?
}

extension PutRegistrationFieldValueOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPath = "FieldPath"
        case registrationArn = "RegistrationArn"
        case registrationAttachmentId = "RegistrationAttachmentId"
        case registrationId = "RegistrationId"
        case selectChoices = "SelectChoices"
        case textValue = "TextValue"
        case versionNumber = "VersionNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationArn)
        registrationArn = registrationArnDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let fieldPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldPath)
        fieldPath = fieldPathDecoded
        let selectChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectChoices)
        var selectChoicesDecoded0:[Swift.String]? = nil
        if let selectChoicesContainer = selectChoicesContainer {
            selectChoicesDecoded0 = [Swift.String]()
            for string0 in selectChoicesContainer {
                if let string0 = string0 {
                    selectChoicesDecoded0?.append(string0)
                }
            }
        }
        selectChoices = selectChoicesDecoded0
        let textValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textValue)
        textValue = textValueDecoded
        let registrationAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationAttachmentId)
        registrationAttachmentId = registrationAttachmentIdDecoded
    }
}

enum PutRegistrationFieldValueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum RegistrationAssociationBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associateAfterComplete
        case associateBeforeSubmit
        case associateOnApproval
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationAssociationBehavior] {
            return [
                .associateAfterComplete,
                .associateBeforeSubmit,
                .associateOnApproval,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associateAfterComplete: return "ASSOCIATE_AFTER_COMPLETE"
            case .associateBeforeSubmit: return "ASSOCIATE_BEFORE_SUBMIT"
            case .associateOnApproval: return "ASSOCIATE_ON_APPROVAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationAssociationBehavior(rawValue: rawValue) ?? RegistrationAssociationBehavior.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The filter definition for filtering registrations that meets a specified criteria.
    public struct RegistrationAssociationFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilterName?
        /// An array of values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum RegistrationAssociationFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case isoCountryCode
        case resourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationAssociationFilterName] {
            return [
                .isoCountryCode,
                .resourceType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .isoCountryCode: return "iso-country-code"
            case .resourceType: return "resource-type"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationAssociationFilterName(rawValue: rawValue) ?? RegistrationAssociationFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case phoneNumber = "PhoneNumber"
        case resourceArn = "ResourceArn"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Metadata for the origination identity that is associated with the registration.
    public struct RegistrationAssociationMetadata: Swift.Equatable {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public var isoCountryCode: Swift.String?
        /// The phone number associated with the registration in E.164 format.
        public var phoneNumber: Swift.String?
        /// The Amazon Resource Name (ARN) of the origination identity that is associated with the registration.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The unique identifier for the origination identity. For example this could be a PhoneNumberId or SenderId.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The origination identity type.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            isoCountryCode: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.isoCountryCode = isoCountryCode
            self.phoneNumber = phoneNumber
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The filter definition for filtering registration attachments that meets a specified criteria.
    public struct RegistrationAttachmentFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilterName?
        /// An array of values to filter on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum RegistrationAttachmentFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachmentStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationAttachmentFilterName] {
            return [
                .attachmentStatus,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachmentStatus: return "attachment-status"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationAttachmentFilterName(rawValue: rawValue) ?? RegistrationAttachmentFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentStatus = "AttachmentStatus"
        case attachmentUploadErrorReason = "AttachmentUploadErrorReason"
        case createdTimestamp = "CreatedTimestamp"
        case registrationAttachmentArn = "RegistrationAttachmentArn"
        case registrationAttachmentId = "RegistrationAttachmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentStatus = self.attachmentStatus {
            try encodeContainer.encode(attachmentStatus.rawValue, forKey: .attachmentStatus)
        }
        if let attachmentUploadErrorReason = self.attachmentUploadErrorReason {
            try encodeContainer.encode(attachmentUploadErrorReason.rawValue, forKey: .attachmentUploadErrorReason)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let registrationAttachmentArn = self.registrationAttachmentArn {
            try encodeContainer.encode(registrationAttachmentArn, forKey: .registrationAttachmentArn)
        }
        if let registrationAttachmentId = self.registrationAttachmentId {
            try encodeContainer.encode(registrationAttachmentId, forKey: .registrationAttachmentId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationAttachmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationAttachmentArn)
        registrationAttachmentArn = registrationAttachmentArnDecoded
        let registrationAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationAttachmentId)
        registrationAttachmentId = registrationAttachmentIdDecoded
        let attachmentStatusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.AttachmentStatus.self, forKey: .attachmentStatus)
        attachmentStatus = attachmentStatusDecoded
        let attachmentUploadErrorReasonDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.AttachmentUploadErrorReason.self, forKey: .attachmentUploadErrorReason)
        attachmentUploadErrorReason = attachmentUploadErrorReasonDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Provides information on the specified registration attachments.
    public struct RegistrationAttachmentsInformation: Swift.Equatable {
        /// The status of the registration attachment.
        ///
        /// * UPLOAD_IN_PROGRESS The attachment is being uploaded.
        ///
        /// * UPLOAD_COMPLETE The attachment has been uploaded.
        ///
        /// * UPLOAD_FAILED The attachment failed to uploaded.
        ///
        /// * DELETED The attachment has been deleted..
        /// This member is required.
        public var attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus?
        /// A description of why the upload didn't successfully complete.
        public var attachmentUploadErrorReason: PinpointSMSVoiceV2ClientTypes.AttachmentUploadErrorReason?
        /// The time when the registration attachment was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the registration attachment.
        /// This member is required.
        public var registrationAttachmentArn: Swift.String?
        /// The unique identifier for the registration attachment.
        /// This member is required.
        public var registrationAttachmentId: Swift.String?

        public init(
            attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus? = nil,
            attachmentUploadErrorReason: PinpointSMSVoiceV2ClientTypes.AttachmentUploadErrorReason? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            registrationAttachmentArn: Swift.String? = nil,
            registrationAttachmentId: Swift.String? = nil
        )
        {
            self.attachmentStatus = attachmentStatus
            self.attachmentUploadErrorReason = attachmentUploadErrorReason
            self.createdTimestamp = createdTimestamp
            self.registrationAttachmentArn = registrationAttachmentArn
            self.registrationAttachmentId = registrationAttachmentId
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.RegistrationDeniedReasonInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentationLink = "DocumentationLink"
        case documentationTitle = "DocumentationTitle"
        case longDescription = "LongDescription"
        case reason = "Reason"
        case shortDescription = "ShortDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentationLink = self.documentationLink {
            try encodeContainer.encode(documentationLink, forKey: .documentationLink)
        }
        if let documentationTitle = self.documentationTitle {
            try encodeContainer.encode(documentationTitle, forKey: .documentationTitle)
        }
        if let longDescription = self.longDescription {
            try encodeContainer.encode(longDescription, forKey: .longDescription)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let shortDescription = self.shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let longDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longDescription)
        longDescription = longDescriptionDecoded
        let documentationTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationTitle)
        documentationTitle = documentationTitleDecoded
        let documentationLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationLink)
        documentationLink = documentationLinkDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Provides the reason a registration was rejected.
    public struct RegistrationDeniedReasonInformation: Swift.Equatable {
        /// The link to the document.
        public var documentationLink: Swift.String?
        /// The title of the document.
        public var documentationTitle: Swift.String?
        /// A long description of the rejection reason.
        public var longDescription: Swift.String?
        /// The reason a registration was rejected.
        /// This member is required.
        public var reason: Swift.String?
        /// A short description of the rejection reason.
        /// This member is required.
        public var shortDescription: Swift.String?

        public init(
            documentationLink: Swift.String? = nil,
            documentationTitle: Swift.String? = nil,
            longDescription: Swift.String? = nil,
            reason: Swift.String? = nil,
            shortDescription: Swift.String? = nil
        )
        {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.longDescription = longDescription
            self.reason = reason
            self.shortDescription = shortDescription
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum RegistrationDisassociationBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteRegistrationDisassociates
        case disassociateAllAllowsDeleteRegistration
        case disassociateAllClosesRegistration
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationDisassociationBehavior] {
            return [
                .deleteRegistrationDisassociates,
                .disassociateAllAllowsDeleteRegistration,
                .disassociateAllClosesRegistration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteRegistrationDisassociates: return "DELETE_REGISTRATION_DISASSOCIATES"
            case .disassociateAllAllowsDeleteRegistration: return "DISASSOCIATE_ALL_ALLOWS_DELETE_REGISTRATION"
            case .disassociateAllClosesRegistration: return "DISASSOCIATE_ALL_CLOSES_REGISTRATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationDisassociationBehavior(rawValue: rawValue) ?? RegistrationDisassociationBehavior.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayHints = "DisplayHints"
        case fieldPath = "FieldPath"
        case fieldRequirement = "FieldRequirement"
        case fieldType = "FieldType"
        case sectionPath = "SectionPath"
        case selectValidation = "SelectValidation"
        case textValidation = "TextValidation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayHints = self.displayHints {
            try encodeContainer.encode(displayHints, forKey: .displayHints)
        }
        if let fieldPath = self.fieldPath {
            try encodeContainer.encode(fieldPath, forKey: .fieldPath)
        }
        if let fieldRequirement = self.fieldRequirement {
            try encodeContainer.encode(fieldRequirement.rawValue, forKey: .fieldRequirement)
        }
        if let fieldType = self.fieldType {
            try encodeContainer.encode(fieldType.rawValue, forKey: .fieldType)
        }
        if let sectionPath = self.sectionPath {
            try encodeContainer.encode(sectionPath, forKey: .sectionPath)
        }
        if let selectValidation = self.selectValidation {
            try encodeContainer.encode(selectValidation, forKey: .selectValidation)
        }
        if let textValidation = self.textValidation {
            try encodeContainer.encode(textValidation, forKey: .textValidation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sectionPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sectionPath)
        sectionPath = sectionPathDecoded
        let fieldPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldPath)
        fieldPath = fieldPathDecoded
        let fieldTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.FieldType.self, forKey: .fieldType)
        fieldType = fieldTypeDecoded
        let fieldRequirementDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.FieldRequirement.self, forKey: .fieldRequirement)
        fieldRequirement = fieldRequirementDecoded
        let selectValidationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.SelectValidation.self, forKey: .selectValidation)
        selectValidation = selectValidationDecoded
        let textValidationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.TextValidation.self, forKey: .textValidation)
        textValidation = textValidationDecoded
        let displayHintsDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationFieldDisplayHints.self, forKey: .displayHints)
        displayHints = displayHintsDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Provides a description of the specified field.
    public struct RegistrationFieldDefinition: Swift.Equatable {
        /// An array of RegistrationFieldDisplayHints objects for the field.
        /// This member is required.
        public var displayHints: PinpointSMSVoiceV2ClientTypes.RegistrationFieldDisplayHints?
        /// The path to the registration form field. You can use [DescribeRegistrationFieldDefinitions] for a list of FieldPaths.
        /// This member is required.
        public var fieldPath: Swift.String?
        /// Specifies if the field for the registration form is required, conditional or optional.
        /// This member is required.
        public var fieldRequirement: PinpointSMSVoiceV2ClientTypes.FieldRequirement?
        /// The type of field.
        /// This member is required.
        public var fieldType: PinpointSMSVoiceV2ClientTypes.FieldType?
        /// The section path of the field.
        /// This member is required.
        public var sectionPath: Swift.String?
        /// The validation rules for a select field.
        public var selectValidation: PinpointSMSVoiceV2ClientTypes.SelectValidation?
        /// The validation rules for a text field.
        public var textValidation: PinpointSMSVoiceV2ClientTypes.TextValidation?

        public init(
            displayHints: PinpointSMSVoiceV2ClientTypes.RegistrationFieldDisplayHints? = nil,
            fieldPath: Swift.String? = nil,
            fieldRequirement: PinpointSMSVoiceV2ClientTypes.FieldRequirement? = nil,
            fieldType: PinpointSMSVoiceV2ClientTypes.FieldType? = nil,
            sectionPath: Swift.String? = nil,
            selectValidation: PinpointSMSVoiceV2ClientTypes.SelectValidation? = nil,
            textValidation: PinpointSMSVoiceV2ClientTypes.TextValidation? = nil
        )
        {
            self.displayHints = displayHints
            self.fieldPath = fieldPath
            self.fieldRequirement = fieldRequirement
            self.fieldType = fieldType
            self.sectionPath = sectionPath
            self.selectValidation = selectValidation
            self.textValidation = textValidation
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.RegistrationFieldDisplayHints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentationLink = "DocumentationLink"
        case documentationTitle = "DocumentationTitle"
        case exampleTextValue = "ExampleTextValue"
        case longDescription = "LongDescription"
        case selectOptionDescriptions = "SelectOptionDescriptions"
        case shortDescription = "ShortDescription"
        case textValidationDescription = "TextValidationDescription"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentationLink = self.documentationLink {
            try encodeContainer.encode(documentationLink, forKey: .documentationLink)
        }
        if let documentationTitle = self.documentationTitle {
            try encodeContainer.encode(documentationTitle, forKey: .documentationTitle)
        }
        if let exampleTextValue = self.exampleTextValue {
            try encodeContainer.encode(exampleTextValue, forKey: .exampleTextValue)
        }
        if let longDescription = self.longDescription {
            try encodeContainer.encode(longDescription, forKey: .longDescription)
        }
        if let selectOptionDescriptions = selectOptionDescriptions {
            var selectOptionDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectOptionDescriptions)
            for selectoptiondescription0 in selectOptionDescriptions {
                try selectOptionDescriptionsContainer.encode(selectoptiondescription0)
            }
        }
        if let shortDescription = self.shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
        if let textValidationDescription = self.textValidationDescription {
            try encodeContainer.encode(textValidationDescription, forKey: .textValidationDescription)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let longDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longDescription)
        longDescription = longDescriptionDecoded
        let documentationTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationTitle)
        documentationTitle = documentationTitleDecoded
        let documentationLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationLink)
        documentationLink = documentationLinkDecoded
        let selectOptionDescriptionsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.SelectOptionDescription?].self, forKey: .selectOptionDescriptions)
        var selectOptionDescriptionsDecoded0:[PinpointSMSVoiceV2ClientTypes.SelectOptionDescription]? = nil
        if let selectOptionDescriptionsContainer = selectOptionDescriptionsContainer {
            selectOptionDescriptionsDecoded0 = [PinpointSMSVoiceV2ClientTypes.SelectOptionDescription]()
            for structure0 in selectOptionDescriptionsContainer {
                if let structure0 = structure0 {
                    selectOptionDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        selectOptionDescriptions = selectOptionDescriptionsDecoded0
        let textValidationDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textValidationDescription)
        textValidationDescription = textValidationDescriptionDecoded
        let exampleTextValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exampleTextValue)
        exampleTextValue = exampleTextValueDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Provides help information on the registration field.
    public struct RegistrationFieldDisplayHints: Swift.Equatable {
        /// The link to the document the display hint is associated with.
        public var documentationLink: Swift.String?
        /// The title of the document the display hint is associated with.
        public var documentationTitle: Swift.String?
        /// Example text of what the value of a field should contain.
        public var exampleTextValue: Swift.String?
        /// A full description of the display hint.
        public var longDescription: Swift.String?
        /// An array of SelectOptionDescription objects.
        public var selectOptionDescriptions: [PinpointSMSVoiceV2ClientTypes.SelectOptionDescription]?
        /// A short description of the display hint.
        /// This member is required.
        public var shortDescription: Swift.String?
        /// The validation rules for the text field.
        public var textValidationDescription: Swift.String?
        /// The title of the display hint.
        /// This member is required.
        public var title: Swift.String?

        public init(
            documentationLink: Swift.String? = nil,
            documentationTitle: Swift.String? = nil,
            exampleTextValue: Swift.String? = nil,
            longDescription: Swift.String? = nil,
            selectOptionDescriptions: [PinpointSMSVoiceV2ClientTypes.SelectOptionDescription]? = nil,
            shortDescription: Swift.String? = nil,
            textValidationDescription: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.exampleTextValue = exampleTextValue
            self.longDescription = longDescription
            self.selectOptionDescriptions = selectOptionDescriptions
            self.shortDescription = shortDescription
            self.textValidationDescription = textValidationDescription
            self.title = title
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deniedReason = "DeniedReason"
        case fieldPath = "FieldPath"
        case registrationAttachmentId = "RegistrationAttachmentId"
        case selectChoices = "SelectChoices"
        case textValue = "TextValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deniedReason = self.deniedReason {
            try encodeContainer.encode(deniedReason, forKey: .deniedReason)
        }
        if let fieldPath = self.fieldPath {
            try encodeContainer.encode(fieldPath, forKey: .fieldPath)
        }
        if let registrationAttachmentId = self.registrationAttachmentId {
            try encodeContainer.encode(registrationAttachmentId, forKey: .registrationAttachmentId)
        }
        if let selectChoices = selectChoices {
            var selectChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectChoices)
            for selectchoice0 in selectChoices {
                try selectChoicesContainer.encode(selectchoice0)
            }
        }
        if let textValue = self.textValue {
            try encodeContainer.encode(textValue, forKey: .textValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldPath)
        fieldPath = fieldPathDecoded
        let selectChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectChoices)
        var selectChoicesDecoded0:[Swift.String]? = nil
        if let selectChoicesContainer = selectChoicesContainer {
            selectChoicesDecoded0 = [Swift.String]()
            for string0 in selectChoicesContainer {
                if let string0 = string0 {
                    selectChoicesDecoded0?.append(string0)
                }
            }
        }
        selectChoices = selectChoicesDecoded0
        let textValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textValue)
        textValue = textValueDecoded
        let registrationAttachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationAttachmentId)
        registrationAttachmentId = registrationAttachmentIdDecoded
        let deniedReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deniedReason)
        deniedReason = deniedReasonDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Provides the values of the specified field.
    public struct RegistrationFieldValueInformation: Swift.Equatable {
        /// A description of why the registration was denied.
        public var deniedReason: Swift.String?
        /// The path to the registration form field. You can use [DescribeRegistrationFieldDefinitions] for a list of FieldPaths.
        /// This member is required.
        public var fieldPath: Swift.String?
        /// The unique identifier for the registration attachment.
        public var registrationAttachmentId: Swift.String?
        /// An array of values for the form field.
        public var selectChoices: [Swift.String]?
        /// The text data for a free form field.
        public var textValue: Swift.String?

        public init(
            deniedReason: Swift.String? = nil,
            fieldPath: Swift.String? = nil,
            registrationAttachmentId: Swift.String? = nil,
            selectChoices: [Swift.String]? = nil,
            textValue: Swift.String? = nil
        )
        {
            self.deniedReason = deniedReason
            self.fieldPath = fieldPath
            self.registrationAttachmentId = registrationAttachmentId
            self.selectChoices = selectChoices
            self.textValue = textValue
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.RegistrationFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The filter definition for filtering registrations that meets a specified criteria.
    public struct RegistrationFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.RegistrationFilterName?
        /// An array of values to filter on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.RegistrationFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum RegistrationFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case registrationStatus
        case registrationType
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationFilterName] {
            return [
                .registrationStatus,
                .registrationType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .registrationStatus: return "registration-status"
            case .registrationType: return "registration-type"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationFilterName(rawValue: rawValue) ?? RegistrationFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAttributes = "AdditionalAttributes"
        case approvedVersionNumber = "ApprovedVersionNumber"
        case createdTimestamp = "CreatedTimestamp"
        case currentVersionNumber = "CurrentVersionNumber"
        case latestDeniedVersionNumber = "LatestDeniedVersionNumber"
        case registrationArn = "RegistrationArn"
        case registrationId = "RegistrationId"
        case registrationStatus = "RegistrationStatus"
        case registrationType = "RegistrationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAttributes = additionalAttributes {
            var additionalAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalAttributes)
            for (dictKey0, stringMap0) in additionalAttributes {
                try additionalAttributesContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let approvedVersionNumber = self.approvedVersionNumber {
            try encodeContainer.encode(approvedVersionNumber, forKey: .approvedVersionNumber)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let currentVersionNumber = self.currentVersionNumber {
            try encodeContainer.encode(currentVersionNumber, forKey: .currentVersionNumber)
        }
        if let latestDeniedVersionNumber = self.latestDeniedVersionNumber {
            try encodeContainer.encode(latestDeniedVersionNumber, forKey: .latestDeniedVersionNumber)
        }
        if let registrationArn = self.registrationArn {
            try encodeContainer.encode(registrationArn, forKey: .registrationArn)
        }
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
        if let registrationStatus = self.registrationStatus {
            try encodeContainer.encode(registrationStatus.rawValue, forKey: .registrationStatus)
        }
        if let registrationType = self.registrationType {
            try encodeContainer.encode(registrationType, forKey: .registrationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationArn)
        registrationArn = registrationArnDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let registrationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationType)
        registrationType = registrationTypeDecoded
        let registrationStatusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationStatus.self, forKey: .registrationStatus)
        registrationStatus = registrationStatusDecoded
        let currentVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentVersionNumber)
        currentVersionNumber = currentVersionNumberDecoded
        let approvedVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approvedVersionNumber)
        approvedVersionNumber = approvedVersionNumberDecoded
        let latestDeniedVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latestDeniedVersionNumber)
        latestDeniedVersionNumber = latestDeniedVersionNumberDecoded
        let additionalAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalAttributes)
        var additionalAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalAttributesContainer = additionalAttributesContainer {
            additionalAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in additionalAttributesContainer {
                if let string0 = string0 {
                    additionalAttributesDecoded0?[key0] = string0
                }
            }
        }
        additionalAttributes = additionalAttributesDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Provides information about the requested registration.
    public struct RegistrationInformation: Swift.Equatable {
        /// Metadata about a given registration which is specific to that registration type.
        public var additionalAttributes: [Swift.String:Swift.String]?
        /// The version number of the registration that was approved.
        public var approvedVersionNumber: Swift.Int?
        /// The time when the registration was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: ClientRuntime.Date?
        /// The current version number of the registration.
        /// This member is required.
        public var currentVersionNumber: Swift.Int?
        /// The latest version number of the registration that was denied.
        public var latestDeniedVersionNumber: Swift.Int?
        /// The Amazon Resource Name (ARN) for the registration.
        /// This member is required.
        public var registrationArn: Swift.String?
        /// The unique identifier for the registration.
        /// This member is required.
        public var registrationId: Swift.String?
        /// The status of the registration.
        ///
        /// * CREATED: Your registration is created but not submitted.
        ///
        /// * SUBMITTED: Your registration has been submitted and is awaiting review.
        ///
        /// * REVIEWING: Your registration has been accepted and is being reviewed.
        ///
        /// * PROVISIONING: Your registration has been approved and your origination identity is being created.
        ///
        /// * COMPLETE: Your registration has been approved and and your origination identity has been created.
        ///
        /// * REQUIRES_UPDATES: You must fix your registration and resubmit it.
        ///
        /// * CLOSED: The phone number or sender ID has been deleted and you must also delete the registration for the number.
        ///
        /// * DELETED: The registration has been deleted.
        /// This member is required.
        public var registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus?
        /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
        /// This member is required.
        public var registrationType: Swift.String?

        public init(
            additionalAttributes: [Swift.String:Swift.String]? = nil,
            approvedVersionNumber: Swift.Int? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            currentVersionNumber: Swift.Int? = nil,
            latestDeniedVersionNumber: Swift.Int? = nil,
            registrationArn: Swift.String? = nil,
            registrationId: Swift.String? = nil,
            registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus? = nil,
            registrationType: Swift.String? = nil
        )
        {
            self.additionalAttributes = additionalAttributes
            self.approvedVersionNumber = approvedVersionNumber
            self.createdTimestamp = createdTimestamp
            self.currentVersionNumber = currentVersionNumber
            self.latestDeniedVersionNumber = latestDeniedVersionNumber
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationStatus = registrationStatus
            self.registrationType = registrationType
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayHints = "DisplayHints"
        case sectionPath = "SectionPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayHints = self.displayHints {
            try encodeContainer.encode(displayHints, forKey: .displayHints)
        }
        if let sectionPath = self.sectionPath {
            try encodeContainer.encode(sectionPath, forKey: .sectionPath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sectionPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sectionPath)
        sectionPath = sectionPathDecoded
        let displayHintsDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationSectionDisplayHints.self, forKey: .displayHints)
        displayHints = displayHintsDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Provides information on the specified section definition.
    public struct RegistrationSectionDefinition: Swift.Equatable {
        /// The path to the section of the registration.
        /// This member is required.
        public var displayHints: PinpointSMSVoiceV2ClientTypes.RegistrationSectionDisplayHints?
        /// The path to the section of the registration.
        /// This member is required.
        public var sectionPath: Swift.String?

        public init(
            displayHints: PinpointSMSVoiceV2ClientTypes.RegistrationSectionDisplayHints? = nil,
            sectionPath: Swift.String? = nil
        )
        {
            self.displayHints = displayHints
            self.sectionPath = sectionPath
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.RegistrationSectionDisplayHints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentationLink = "DocumentationLink"
        case documentationTitle = "DocumentationTitle"
        case longDescription = "LongDescription"
        case shortDescription = "ShortDescription"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentationLink = self.documentationLink {
            try encodeContainer.encode(documentationLink, forKey: .documentationLink)
        }
        if let documentationTitle = self.documentationTitle {
            try encodeContainer.encode(documentationTitle, forKey: .documentationTitle)
        }
        if let longDescription = self.longDescription {
            try encodeContainer.encode(longDescription, forKey: .longDescription)
        }
        if let shortDescription = self.shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let longDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longDescription)
        longDescription = longDescriptionDecoded
        let documentationTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationTitle)
        documentationTitle = documentationTitleDecoded
        let documentationLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationLink)
        documentationLink = documentationLinkDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Provides help information on the registration section.
    public struct RegistrationSectionDisplayHints: Swift.Equatable {
        /// The link to the document the display hint is associated with.
        public var documentationLink: Swift.String?
        /// The title of the document the display hint is associated with.
        public var documentationTitle: Swift.String?
        /// A full description of the display hint.
        public var longDescription: Swift.String?
        /// A short description of the display hint.
        /// This member is required.
        public var shortDescription: Swift.String?
        /// The title of the display hint.
        /// This member is required.
        public var title: Swift.String?

        public init(
            documentationLink: Swift.String? = nil,
            documentationTitle: Swift.String? = nil,
            longDescription: Swift.String? = nil,
            shortDescription: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.longDescription = longDescription
            self.shortDescription = shortDescription
            self.title = title
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum RegistrationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case complete
        case created
        case deleted
        case provisioning
        case requiresUpdates
        case reviewing
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationStatus] {
            return [
                .closed,
                .complete,
                .created,
                .deleted,
                .provisioning,
                .requiresUpdates,
                .reviewing,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .complete: return "COMPLETE"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .provisioning: return "PROVISIONING"
            case .requiresUpdates: return "REQUIRES_UPDATES"
            case .reviewing: return "REVIEWING"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationStatus(rawValue: rawValue) ?? RegistrationStatus.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayHints = "DisplayHints"
        case registrationType = "RegistrationType"
        case supportedAssociations = "SupportedAssociations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayHints = self.displayHints {
            try encodeContainer.encode(displayHints, forKey: .displayHints)
        }
        if let registrationType = self.registrationType {
            try encodeContainer.encode(registrationType, forKey: .registrationType)
        }
        if let supportedAssociations = supportedAssociations {
            var supportedAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedAssociations)
            for supportedassociation0 in supportedAssociations {
                try supportedAssociationsContainer.encode(supportedassociation0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationType)
        registrationType = registrationTypeDecoded
        let supportedAssociationsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.SupportedAssociation?].self, forKey: .supportedAssociations)
        var supportedAssociationsDecoded0:[PinpointSMSVoiceV2ClientTypes.SupportedAssociation]? = nil
        if let supportedAssociationsContainer = supportedAssociationsContainer {
            supportedAssociationsDecoded0 = [PinpointSMSVoiceV2ClientTypes.SupportedAssociation]()
            for structure0 in supportedAssociationsContainer {
                if let structure0 = structure0 {
                    supportedAssociationsDecoded0?.append(structure0)
                }
            }
        }
        supportedAssociations = supportedAssociationsDecoded0
        let displayHintsDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationTypeDisplayHints.self, forKey: .displayHints)
        displayHints = displayHintsDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Provides information on the supported registration type.
    public struct RegistrationTypeDefinition: Swift.Equatable {
        /// Provides help information on the registration.
        /// This member is required.
        public var displayHints: PinpointSMSVoiceV2ClientTypes.RegistrationTypeDisplayHints?
        /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
        /// This member is required.
        public var registrationType: Swift.String?
        /// The supported association behavior for the registration type.
        public var supportedAssociations: [PinpointSMSVoiceV2ClientTypes.SupportedAssociation]?

        public init(
            displayHints: PinpointSMSVoiceV2ClientTypes.RegistrationTypeDisplayHints? = nil,
            registrationType: Swift.String? = nil,
            supportedAssociations: [PinpointSMSVoiceV2ClientTypes.SupportedAssociation]? = nil
        )
        {
            self.displayHints = displayHints
            self.registrationType = registrationType
            self.supportedAssociations = supportedAssociations
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.RegistrationTypeDisplayHints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentationLink = "DocumentationLink"
        case documentationTitle = "DocumentationTitle"
        case longDescription = "LongDescription"
        case shortDescription = "ShortDescription"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentationLink = self.documentationLink {
            try encodeContainer.encode(documentationLink, forKey: .documentationLink)
        }
        if let documentationTitle = self.documentationTitle {
            try encodeContainer.encode(documentationTitle, forKey: .documentationTitle)
        }
        if let longDescription = self.longDescription {
            try encodeContainer.encode(longDescription, forKey: .longDescription)
        }
        if let shortDescription = self.shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let longDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longDescription)
        longDescription = longDescriptionDecoded
        let documentationTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationTitle)
        documentationTitle = documentationTitleDecoded
        let documentationLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationLink)
        documentationLink = documentationLinkDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Provides help information on the registration type.
    public struct RegistrationTypeDisplayHints: Swift.Equatable {
        /// The link to the document the display hint is associated with.
        public var documentationLink: Swift.String?
        /// The title of the document the display hint is associated with.
        public var documentationTitle: Swift.String?
        /// A full description of the display hint.
        public var longDescription: Swift.String?
        /// A short description of the display hint.
        public var shortDescription: Swift.String?
        /// The title of the display hint.
        /// This member is required.
        public var title: Swift.String?

        public init(
            documentationLink: Swift.String? = nil,
            documentationTitle: Swift.String? = nil,
            longDescription: Swift.String? = nil,
            shortDescription: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.longDescription = longDescription
            self.shortDescription = shortDescription
            self.title = title
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The filter definition for filtering registration types that meets a specified criteria.
    public struct RegistrationTypeFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilterName?
        /// An array of values to filter on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum RegistrationTypeFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case supportedAssociationIsoCountryCode
        case supportedAssociationResourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationTypeFilterName] {
            return [
                .supportedAssociationIsoCountryCode,
                .supportedAssociationResourceType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .supportedAssociationIsoCountryCode: return "supported-association-iso-country-code"
            case .supportedAssociationResourceType: return "supported-association-resource-type"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationTypeFilterName(rawValue: rawValue) ?? RegistrationTypeFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The filter definition for filtering registration versions that meets a specified criteria.
    public struct RegistrationVersionFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilterName?
        /// An array of values to filter on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum RegistrationVersionFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case registrationVersionStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationVersionFilterName] {
            return [
                .registrationVersionStatus,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .registrationVersionStatus: return "registration-version-status"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationVersionFilterName(rawValue: rawValue) ?? RegistrationVersionFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deniedReasons = "DeniedReasons"
        case registrationVersionStatus = "RegistrationVersionStatus"
        case registrationVersionStatusHistory = "RegistrationVersionStatusHistory"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deniedReasons = deniedReasons {
            var deniedReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deniedReasons)
            for registrationdeniedreasoninformation0 in deniedReasons {
                try deniedReasonsContainer.encode(registrationdeniedreasoninformation0)
            }
        }
        if let registrationVersionStatus = self.registrationVersionStatus {
            try encodeContainer.encode(registrationVersionStatus.rawValue, forKey: .registrationVersionStatus)
        }
        if let registrationVersionStatusHistory = self.registrationVersionStatusHistory {
            try encodeContainer.encode(registrationVersionStatusHistory, forKey: .registrationVersionStatusHistory)
        }
        if let versionNumber = self.versionNumber {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let registrationVersionStatusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus.self, forKey: .registrationVersionStatus)
        registrationVersionStatus = registrationVersionStatusDecoded
        let registrationVersionStatusHistoryDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory.self, forKey: .registrationVersionStatusHistory)
        registrationVersionStatusHistory = registrationVersionStatusHistoryDecoded
        let deniedReasonsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.RegistrationDeniedReasonInformation?].self, forKey: .deniedReasons)
        var deniedReasonsDecoded0:[PinpointSMSVoiceV2ClientTypes.RegistrationDeniedReasonInformation]? = nil
        if let deniedReasonsContainer = deniedReasonsContainer {
            deniedReasonsDecoded0 = [PinpointSMSVoiceV2ClientTypes.RegistrationDeniedReasonInformation]()
            for structure0 in deniedReasonsContainer {
                if let structure0 = structure0 {
                    deniedReasonsDecoded0?.append(structure0)
                }
            }
        }
        deniedReasons = deniedReasonsDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Provides information about the specified version of the registration.
    public struct RegistrationVersionInformation: Swift.Equatable {
        /// An array of RegistrationDeniedReasonInformation objects.
        public var deniedReasons: [PinpointSMSVoiceV2ClientTypes.RegistrationDeniedReasonInformation]?
        /// The status of the registration.
        ///
        /// * DRAFT: The initial status of a registration version after it’s created.
        ///
        /// * SUBMITTED: Your registration has been submitted.
        ///
        /// * REVIEWING: Your registration has been accepted and is being reviewed.
        ///
        /// * APPROVED: Your registration has been approved.
        ///
        /// * DISCARDED: You've abandon this version of their registration to start over with a new version.
        ///
        /// * DENIED: You must fix your registration and resubmit it.
        ///
        /// * REVOKED: Your previously approved registration has been revoked.
        ///
        /// * ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.
        /// This member is required.
        public var registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus?
        /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
        /// This member is required.
        public var registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory?
        /// The version number of the registration.
        /// This member is required.
        public var versionNumber: Swift.Int?

        public init(
            deniedReasons: [PinpointSMSVoiceV2ClientTypes.RegistrationDeniedReasonInformation]? = nil,
            registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus? = nil,
            registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.deniedReasons = deniedReasons
            self.registrationVersionStatus = registrationVersionStatus
            self.registrationVersionStatusHistory = registrationVersionStatusHistory
            self.versionNumber = versionNumber
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum RegistrationVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case archived
        case denied
        case discarded
        case draft
        case reviewing
        case revoked
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationVersionStatus] {
            return [
                .approved,
                .archived,
                .denied,
                .discarded,
                .draft,
                .reviewing,
                .revoked,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .archived: return "ARCHIVED"
            case .denied: return "DENIED"
            case .discarded: return "DISCARDED"
            case .draft: return "DRAFT"
            case .reviewing: return "REVIEWING"
            case .revoked: return "REVOKED"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationVersionStatus(rawValue: rawValue) ?? RegistrationVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvedTimestamp = "ApprovedTimestamp"
        case archivedTimestamp = "ArchivedTimestamp"
        case deniedTimestamp = "DeniedTimestamp"
        case discardedTimestamp = "DiscardedTimestamp"
        case draftTimestamp = "DraftTimestamp"
        case reviewingTimestamp = "ReviewingTimestamp"
        case revokedTimestamp = "RevokedTimestamp"
        case submittedTimestamp = "SubmittedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvedTimestamp = self.approvedTimestamp {
            try encodeContainer.encodeTimestamp(approvedTimestamp, format: .epochSeconds, forKey: .approvedTimestamp)
        }
        if let archivedTimestamp = self.archivedTimestamp {
            try encodeContainer.encodeTimestamp(archivedTimestamp, format: .epochSeconds, forKey: .archivedTimestamp)
        }
        if let deniedTimestamp = self.deniedTimestamp {
            try encodeContainer.encodeTimestamp(deniedTimestamp, format: .epochSeconds, forKey: .deniedTimestamp)
        }
        if let discardedTimestamp = self.discardedTimestamp {
            try encodeContainer.encodeTimestamp(discardedTimestamp, format: .epochSeconds, forKey: .discardedTimestamp)
        }
        if let draftTimestamp = self.draftTimestamp {
            try encodeContainer.encodeTimestamp(draftTimestamp, format: .epochSeconds, forKey: .draftTimestamp)
        }
        if let reviewingTimestamp = self.reviewingTimestamp {
            try encodeContainer.encodeTimestamp(reviewingTimestamp, format: .epochSeconds, forKey: .reviewingTimestamp)
        }
        if let revokedTimestamp = self.revokedTimestamp {
            try encodeContainer.encodeTimestamp(revokedTimestamp, format: .epochSeconds, forKey: .revokedTimestamp)
        }
        if let submittedTimestamp = self.submittedTimestamp {
            try encodeContainer.encodeTimestamp(submittedTimestamp, format: .epochSeconds, forKey: .submittedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let draftTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .draftTimestamp)
        draftTimestamp = draftTimestampDecoded
        let submittedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submittedTimestamp)
        submittedTimestamp = submittedTimestampDecoded
        let reviewingTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .reviewingTimestamp)
        reviewingTimestamp = reviewingTimestampDecoded
        let approvedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .approvedTimestamp)
        approvedTimestamp = approvedTimestampDecoded
        let discardedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .discardedTimestamp)
        discardedTimestamp = discardedTimestampDecoded
        let deniedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deniedTimestamp)
        deniedTimestamp = deniedTimestampDecoded
        let revokedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .revokedTimestamp)
        revokedTimestamp = revokedTimestampDecoded
        let archivedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .archivedTimestamp)
        archivedTimestamp = archivedTimestampDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
    public struct RegistrationVersionStatusHistory: Swift.Equatable {
        /// The time when the registration was in the approved state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var approvedTimestamp: ClientRuntime.Date?
        /// The time when the registration was in the archived state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var archivedTimestamp: ClientRuntime.Date?
        /// The time when the registration was in the denied state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var deniedTimestamp: ClientRuntime.Date?
        /// The time when the registration was in the discarded state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var discardedTimestamp: ClientRuntime.Date?
        /// The time when the registration was in the draft state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var draftTimestamp: ClientRuntime.Date?
        /// The time when the registration was in the reviewing state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var reviewingTimestamp: ClientRuntime.Date?
        /// The time when the registration was in the revoked state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var revokedTimestamp: ClientRuntime.Date?
        /// The time when the registration was in the submitted state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var submittedTimestamp: ClientRuntime.Date?

        public init(
            approvedTimestamp: ClientRuntime.Date? = nil,
            archivedTimestamp: ClientRuntime.Date? = nil,
            deniedTimestamp: ClientRuntime.Date? = nil,
            discardedTimestamp: ClientRuntime.Date? = nil,
            draftTimestamp: ClientRuntime.Date? = nil,
            reviewingTimestamp: ClientRuntime.Date? = nil,
            revokedTimestamp: ClientRuntime.Date? = nil,
            submittedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.approvedTimestamp = approvedTimestamp
            self.archivedTimestamp = archivedTimestamp
            self.deniedTimestamp = deniedTimestamp
            self.discardedTimestamp = discardedTimestamp
            self.draftTimestamp = draftTimestamp
            self.reviewingTimestamp = reviewingTimestamp
            self.revokedTimestamp = revokedTimestamp
            self.submittedTimestamp = submittedTimestamp
        }
    }

}

extension ReleasePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberId = "PhoneNumberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
    }
}

extension ReleasePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ReleasePhoneNumberInput: Swift.Equatable {
    /// The PhoneNumberId or PhoneNumberArn of the phone number to release. You can use [DescribePhoneNumbers] to get the values for PhoneNumberId and PhoneNumberArn.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct ReleasePhoneNumberInputBody: Swift.Equatable {
    let phoneNumberId: Swift.String?
}

extension ReleasePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberId = "PhoneNumberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
    }
}

extension ReleasePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReleasePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.isoCountryCode = output.isoCountryCode
            self.messageType = output.messageType
            self.monthlyLeasingPrice = output.monthlyLeasingPrice
            self.numberCapabilities = output.numberCapabilities
            self.numberType = output.numberType
            self.optOutListName = output.optOutListName
            self.phoneNumber = output.phoneNumber
            self.phoneNumberArn = output.phoneNumberArn
            self.phoneNumberId = output.phoneNumberId
            self.registrationId = output.registrationId
            self.selfManagedOptOutsEnabled = output.selfManagedOptOutsEnabled
            self.status = output.status
            self.twoWayChannelArn = output.twoWayChannelArn
            self.twoWayChannelRole = output.twoWayChannelRole
            self.twoWayEnabled = output.twoWayEnabled
        } else {
            self.createdTimestamp = nil
            self.isoCountryCode = nil
            self.messageType = nil
            self.monthlyLeasingPrice = nil
            self.numberCapabilities = nil
            self.numberType = nil
            self.optOutListName = nil
            self.phoneNumber = nil
            self.phoneNumberArn = nil
            self.phoneNumberId = nil
            self.registrationId = nil
            self.selfManagedOptOutsEnabled = false
            self.status = nil
            self.twoWayChannelArn = nil
            self.twoWayChannelRole = nil
            self.twoWayEnabled = false
        }
    }
}

public struct ReleasePhoneNumberOutput: Swift.Equatable {
    /// The time when the phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The message type that was associated with the phone number.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The monthly price of the phone number, in US dollars.
    public var monthlyLeasingPrice: Swift.String?
    /// Specifies if the number could be used for text messages, voice, or both.
    public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    /// The type of number that was released.
    public var numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
    /// The name of the OptOutList that was associated with the phone number.
    public var optOutListName: Swift.String?
    /// The phone number that was released.
    public var phoneNumber: Swift.String?
    /// The PhoneNumberArn of the phone number that was released.
    public var phoneNumberArn: Swift.String?
    /// The PhoneNumberId of the phone number that was released.
    public var phoneNumberId: Swift.String?
    /// The unique identifier for the registration.
    public var registrationId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// The current status of the request.
    public var status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    /// The Amazon Resource Name (ARN) of the TwoWayChannel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
        numberType: PinpointSMSVoiceV2ClientTypes.NumberType? = nil,
        optOutListName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.NumberStatus? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.numberCapabilities = numberCapabilities
        self.numberType = numberType
        self.optOutListName = optOutListName
        self.phoneNumber = phoneNumber
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
        self.registrationId = registrationId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.status = status
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

struct ReleasePhoneNumberOutputBody: Swift.Equatable {
    let phoneNumberArn: Swift.String?
    let phoneNumberId: Swift.String?
    let phoneNumber: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    let isoCountryCode: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    let numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
    let monthlyLeasingPrice: Swift.String?
    let twoWayEnabled: Swift.Bool
    let twoWayChannelArn: Swift.String?
    let twoWayChannelRole: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool
    let optOutListName: Swift.String?
    let registrationId: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
}

extension ReleasePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case numberCapabilities = "NumberCapabilities"
        case numberType = "NumberType"
        case optOutListName = "OptOutListName"
        case phoneNumber = "PhoneNumber"
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberId = "PhoneNumberId"
        case registrationId = "RegistrationId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case status = "Status"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayChannelRole = "TwoWayChannelRole"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberStatus.self, forKey: .status)
        status = statusDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let numberCapabilitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.NumberCapability?].self, forKey: .numberCapabilities)
        var numberCapabilitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil
        if let numberCapabilitiesContainer = numberCapabilitiesContainer {
            numberCapabilitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.NumberCapability]()
            for string0 in numberCapabilitiesContainer {
                if let string0 = string0 {
                    numberCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        numberCapabilities = numberCapabilitiesDecoded0
        let numberTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberType.self, forKey: .numberType)
        numberType = numberTypeDecoded
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let twoWayChannelRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelRole)
        twoWayChannelRole = twoWayChannelRoleDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum ReleasePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ReleaseSenderIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case senderId = "SenderId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let senderId = self.senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
    }
}

extension ReleaseSenderIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ReleaseSenderIdInput: Swift.Equatable {
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The sender ID to release.
    /// This member is required.
    public var senderId: Swift.String?

    public init(
        isoCountryCode: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.senderId = senderId
    }
}

struct ReleaseSenderIdInputBody: Swift.Equatable {
    let senderId: Swift.String?
    let isoCountryCode: Swift.String?
}

extension ReleaseSenderIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case senderId = "SenderId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
    }
}

extension ReleaseSenderIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReleaseSenderIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.isoCountryCode = output.isoCountryCode
            self.messageTypes = output.messageTypes
            self.monthlyLeasingPrice = output.monthlyLeasingPrice
            self.registered = output.registered
            self.registrationId = output.registrationId
            self.senderId = output.senderId
            self.senderIdArn = output.senderIdArn
        } else {
            self.isoCountryCode = nil
            self.messageTypes = nil
            self.monthlyLeasingPrice = nil
            self.registered = false
            self.registrationId = nil
            self.senderId = nil
            self.senderIdArn = nil
        }
    }
}

public struct ReleaseSenderIdOutput: Swift.Equatable {
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
    /// The monthly price, in US dollars, to lease the sender ID.
    /// This member is required.
    public var monthlyLeasingPrice: Swift.String?
    /// True if the sender ID is registered.
    /// This member is required.
    public var registered: Swift.Bool
    /// The unique identifier for the registration.
    public var registrationId: Swift.String?
    /// The sender ID that was released.
    /// This member is required.
    public var senderId: Swift.String?
    /// The Amazon Resource Name (ARN) associated with the SenderId.
    /// This member is required.
    public var senderIdArn: Swift.String?

    public init(
        isoCountryCode: Swift.String? = nil,
        messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        registered: Swift.Bool = false,
        registrationId: Swift.String? = nil,
        senderId: Swift.String? = nil,
        senderIdArn: Swift.String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.messageTypes = messageTypes
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.registered = registered
        self.registrationId = registrationId
        self.senderId = senderId
        self.senderIdArn = senderIdArn
    }
}

struct ReleaseSenderIdOutputBody: Swift.Equatable {
    let senderIdArn: Swift.String?
    let senderId: Swift.String?
    let isoCountryCode: Swift.String?
    let messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
    let monthlyLeasingPrice: Swift.String?
    let registered: Swift.Bool
    let registrationId: Swift.String?
}

extension ReleaseSenderIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case messageTypes = "MessageTypes"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case registered = "Registered"
        case registrationId = "RegistrationId"
        case senderId = "SenderId"
        case senderIdArn = "SenderIdArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderIdArn)
        senderIdArn = senderIdArnDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.MessageType?].self, forKey: .messageTypes)
        var messageTypesDecoded0:[PinpointSMSVoiceV2ClientTypes.MessageType]? = nil
        if let messageTypesContainer = messageTypesContainer {
            messageTypesDecoded0 = [PinpointSMSVoiceV2ClientTypes.MessageType]()
            for string0 in messageTypesContainer {
                if let string0 = string0 {
                    messageTypesDecoded0?.append(string0)
                }
            }
        }
        messageTypes = messageTypesDecoded0
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
        let registeredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .registered) ?? false
        registered = registeredDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
    }
}

enum ReleaseSenderIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RequestPhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case numberCapabilities = "NumberCapabilities"
        case numberType = "NumberType"
        case optOutListName = "OptOutListName"
        case poolId = "PoolId"
        case registrationId = "RegistrationId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deletionProtectionEnabled = self.deletionProtectionEnabled {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let numberCapabilities = numberCapabilities {
            var numberCapabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .numberCapabilities)
            for numbercapability0 in numberCapabilities {
                try numberCapabilitiesContainer.encode(numbercapability0.rawValue)
            }
        }
        if let numberType = self.numberType {
            try encodeContainer.encode(numberType.rawValue, forKey: .numberType)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension RequestPhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RequestPhoneNumberInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// By default this is set to false. When set to true the phone number can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// Indicates if the phone number will be used for text messages, voice messages, or both.
    /// This member is required.
    public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    /// The type of phone number to request.
    /// This member is required.
    public var numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType?
    /// The name of the OptOutList to associate with the phone number. You can use the OptOutListName or OptOutListArn.
    public var optOutListName: Swift.String?
    /// The pool to associated with the phone number. You can use the PoolId or PoolArn.
    public var poolId: Swift.String?
    /// Use this field to attach your phone number for an external registration process.
    public var registrationId: Swift.String?
    /// An array of tags (key and value pairs) associate with the requested phone number.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        deletionProtectionEnabled: Swift.Bool? = nil,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
        numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType? = nil,
        optOutListName: Swift.String? = nil,
        poolId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.numberCapabilities = numberCapabilities
        self.numberType = numberType
        self.optOutListName = optOutListName
        self.poolId = poolId
        self.registrationId = registrationId
        self.tags = tags
    }
}

struct RequestPhoneNumberInputBody: Swift.Equatable {
    let isoCountryCode: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    let numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType?
    let optOutListName: Swift.String?
    let poolId: Swift.String?
    let registrationId: Swift.String?
    let deletionProtectionEnabled: Swift.Bool?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension RequestPhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case numberCapabilities = "NumberCapabilities"
        case numberType = "NumberType"
        case optOutListName = "OptOutListName"
        case poolId = "PoolId"
        case registrationId = "RegistrationId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let numberCapabilitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.NumberCapability?].self, forKey: .numberCapabilities)
        var numberCapabilitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil
        if let numberCapabilitiesContainer = numberCapabilitiesContainer {
            numberCapabilitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.NumberCapability]()
            for string0 in numberCapabilitiesContainer {
                if let string0 = string0 {
                    numberCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        numberCapabilities = numberCapabilitiesDecoded0
        let numberTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RequestableNumberType.self, forKey: .numberType)
        numberType = numberTypeDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled)
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RequestPhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestPhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.deletionProtectionEnabled = output.deletionProtectionEnabled
            self.isoCountryCode = output.isoCountryCode
            self.messageType = output.messageType
            self.monthlyLeasingPrice = output.monthlyLeasingPrice
            self.numberCapabilities = output.numberCapabilities
            self.numberType = output.numberType
            self.optOutListName = output.optOutListName
            self.phoneNumber = output.phoneNumber
            self.phoneNumberArn = output.phoneNumberArn
            self.phoneNumberId = output.phoneNumberId
            self.poolId = output.poolId
            self.registrationId = output.registrationId
            self.selfManagedOptOutsEnabled = output.selfManagedOptOutsEnabled
            self.status = output.status
            self.tags = output.tags
            self.twoWayChannelArn = output.twoWayChannelArn
            self.twoWayChannelRole = output.twoWayChannelRole
            self.twoWayEnabled = output.twoWayEnabled
        } else {
            self.createdTimestamp = nil
            self.deletionProtectionEnabled = false
            self.isoCountryCode = nil
            self.messageType = nil
            self.monthlyLeasingPrice = nil
            self.numberCapabilities = nil
            self.numberType = nil
            self.optOutListName = nil
            self.phoneNumber = nil
            self.phoneNumberArn = nil
            self.phoneNumberId = nil
            self.poolId = nil
            self.registrationId = nil
            self.selfManagedOptOutsEnabled = false
            self.status = nil
            self.tags = nil
            self.twoWayChannelArn = nil
            self.twoWayChannelRole = nil
            self.twoWayEnabled = false
        }
    }
}

public struct RequestPhoneNumberOutput: Swift.Equatable {
    /// The time when the phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// By default this is set to false. When set to true the phone number can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The monthly price, in US dollars, to lease the phone number.
    public var monthlyLeasingPrice: Swift.String?
    /// Indicates if the phone number will be used for text messages, voice messages or both.
    public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    /// The type of number that was released.
    public var numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType?
    /// The name of the OptOutList that is associated with the requested phone number.
    public var optOutListName: Swift.String?
    /// The new phone number that was requested.
    public var phoneNumber: Swift.String?
    /// The Amazon Resource Name (ARN) of the requested phone number.
    public var phoneNumberArn: Swift.String?
    /// The unique identifier of the new phone number.
    public var phoneNumberId: Swift.String?
    /// The unique identifier of the pool associated with the phone number
    public var poolId: Swift.String?
    /// The unique identifier for the registration.
    public var registrationId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// The current status of the request.
    public var status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    /// An array of key and value pair tags that are associated with the phone number.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    /// The ARN used to identify the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
        numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType? = nil,
        optOutListName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        poolId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.NumberStatus? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.numberCapabilities = numberCapabilities
        self.numberType = numberType
        self.optOutListName = optOutListName
        self.phoneNumber = phoneNumber
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
        self.poolId = poolId
        self.registrationId = registrationId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.status = status
        self.tags = tags
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

struct RequestPhoneNumberOutputBody: Swift.Equatable {
    let phoneNumberArn: Swift.String?
    let phoneNumberId: Swift.String?
    let phoneNumber: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    let isoCountryCode: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    let numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType?
    let monthlyLeasingPrice: Swift.String?
    let twoWayEnabled: Swift.Bool
    let twoWayChannelArn: Swift.String?
    let twoWayChannelRole: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool
    let optOutListName: Swift.String?
    let deletionProtectionEnabled: Swift.Bool
    let poolId: Swift.String?
    let registrationId: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
}

extension RequestPhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case numberCapabilities = "NumberCapabilities"
        case numberType = "NumberType"
        case optOutListName = "OptOutListName"
        case phoneNumber = "PhoneNumber"
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberId = "PhoneNumberId"
        case poolId = "PoolId"
        case registrationId = "RegistrationId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case status = "Status"
        case tags = "Tags"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayChannelRole = "TwoWayChannelRole"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberStatus.self, forKey: .status)
        status = statusDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let numberCapabilitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.NumberCapability?].self, forKey: .numberCapabilities)
        var numberCapabilitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil
        if let numberCapabilitiesContainer = numberCapabilitiesContainer {
            numberCapabilitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.NumberCapability]()
            for string0 in numberCapabilitiesContainer {
                if let string0 = string0 {
                    numberCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        numberCapabilities = numberCapabilitiesDecoded0
        let numberTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RequestableNumberType.self, forKey: .numberType)
        numberType = numberTypeDecoded
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let twoWayChannelRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelRole)
        twoWayChannelRole = twoWayChannelRoleDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum RequestPhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RequestSenderIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageTypes = "MessageTypes"
        case senderId = "SenderId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deletionProtectionEnabled = self.deletionProtectionEnabled {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let messageTypes = messageTypes {
            var messageTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messageTypes)
            for messagetype0 in messageTypes {
                try messageTypesContainer.encode(messagetype0.rawValue)
            }
        }
        if let senderId = self.senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension RequestSenderIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RequestSenderIdInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// By default this is set to false. When set to true the sender ID can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    public var messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
    /// The sender ID string to request.
    /// This member is required.
    public var senderId: Swift.String?
    /// An array of tags (key and value pairs) to associate with the sender ID.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        deletionProtectionEnabled: Swift.Bool? = nil,
        isoCountryCode: Swift.String? = nil,
        messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]? = nil,
        senderId: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageTypes = messageTypes
        self.senderId = senderId
        self.tags = tags
    }
}

struct RequestSenderIdInputBody: Swift.Equatable {
    let senderId: Swift.String?
    let isoCountryCode: Swift.String?
    let messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
    let deletionProtectionEnabled: Swift.Bool?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    let clientToken: Swift.String?
}

extension RequestSenderIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageTypes = "MessageTypes"
        case senderId = "SenderId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.MessageType?].self, forKey: .messageTypes)
        var messageTypesDecoded0:[PinpointSMSVoiceV2ClientTypes.MessageType]? = nil
        if let messageTypesContainer = messageTypesContainer {
            messageTypesDecoded0 = [PinpointSMSVoiceV2ClientTypes.MessageType]()
            for string0 in messageTypesContainer {
                if let string0 = string0 {
                    messageTypesDecoded0?.append(string0)
                }
            }
        }
        messageTypes = messageTypesDecoded0
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled)
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RequestSenderIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestSenderIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.deletionProtectionEnabled = output.deletionProtectionEnabled
            self.isoCountryCode = output.isoCountryCode
            self.messageTypes = output.messageTypes
            self.monthlyLeasingPrice = output.monthlyLeasingPrice
            self.registered = output.registered
            self.senderId = output.senderId
            self.senderIdArn = output.senderIdArn
            self.tags = output.tags
        } else {
            self.deletionProtectionEnabled = false
            self.isoCountryCode = nil
            self.messageTypes = nil
            self.monthlyLeasingPrice = nil
            self.registered = false
            self.senderId = nil
            self.senderIdArn = nil
            self.tags = nil
        }
    }
}

public struct RequestSenderIdOutput: Swift.Equatable {
    /// By default this is set to false. When set to true the sender ID can't be deleted.
    /// This member is required.
    public var deletionProtectionEnabled: Swift.Bool
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
    /// The monthly price, in US dollars, to lease the sender ID.
    /// This member is required.
    public var monthlyLeasingPrice: Swift.String?
    /// True if the sender ID is registered.
    /// This member is required.
    public var registered: Swift.Bool
    /// The sender ID that was requested.
    /// This member is required.
    public var senderId: Swift.String?
    /// The Amazon Resource Name (ARN) associated with the SenderId.
    /// This member is required.
    public var senderIdArn: Swift.String?
    /// An array of tags (key and value pairs) to associate with the sender ID.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        deletionProtectionEnabled: Swift.Bool = false,
        isoCountryCode: Swift.String? = nil,
        messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        registered: Swift.Bool = false,
        senderId: Swift.String? = nil,
        senderIdArn: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageTypes = messageTypes
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.registered = registered
        self.senderId = senderId
        self.senderIdArn = senderIdArn
        self.tags = tags
    }
}

struct RequestSenderIdOutputBody: Swift.Equatable {
    let senderIdArn: Swift.String?
    let senderId: Swift.String?
    let isoCountryCode: Swift.String?
    let messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
    let monthlyLeasingPrice: Swift.String?
    let deletionProtectionEnabled: Swift.Bool
    let registered: Swift.Bool
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
}

extension RequestSenderIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageTypes = "MessageTypes"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case registered = "Registered"
        case senderId = "SenderId"
        case senderIdArn = "SenderIdArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderIdArn)
        senderIdArn = senderIdArnDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.MessageType?].self, forKey: .messageTypes)
        var messageTypesDecoded0:[PinpointSMSVoiceV2ClientTypes.MessageType]? = nil
        if let messageTypesContainer = messageTypesContainer {
            messageTypesDecoded0 = [PinpointSMSVoiceV2ClientTypes.MessageType]()
            for string0 in messageTypesContainer {
                if let string0 = string0 {
                    messageTypesDecoded0?.append(string0)
                }
            }
        }
        messageTypes = messageTypesDecoded0
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let registeredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .registered) ?? false
        registered = registeredDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum RequestSenderIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum RequestableNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case longCode
        case simulator
        case tenDlc
        case tollFree
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestableNumberType] {
            return [
                .longCode,
                .simulator,
                .tenDlc,
                .tollFree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .longCode: return "LONG_CODE"
            case .simulator: return "SIMULATOR"
            case .tenDlc: return "TEN_DLC"
            case .tollFree: return "TOLL_FREE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequestableNumberType(rawValue: rawValue) ?? RequestableNumberType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A requested resource couldn't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that caused the exception.
        public internal(set) var resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType?
    let resourceId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case configurationSet
        case eventDestination
        case keyword
        case optedOutNumber
        case optOutList
        case phoneNumber
        case pool
        case registration
        case registrationAttachment
        case senderId
        case verifiedDestinationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .account,
                .configurationSet,
                .eventDestination,
                .keyword,
                .optedOutNumber,
                .optOutList,
                .phoneNumber,
                .pool,
                .registration,
                .registrationAttachment,
                .senderId,
                .verifiedDestinationNumber,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "account"
            case .configurationSet: return "configuration-set"
            case .eventDestination: return "event-destination"
            case .keyword: return "keyword"
            case .optedOutNumber: return "opted-out-number"
            case .optOutList: return "opt-out-list"
            case .phoneNumber: return "phone-number"
            case .pool: return "pool"
            case .registration: return "registration"
            case .registrationAttachment: return "registration-attachment"
            case .senderId: return "sender-id"
            case .verifiedDestinationNumber: return "verified-destination-number"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.SelectOptionDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case option = "Option"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let option = self.option {
            try encodeContainer.encode(option, forKey: .option)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .option)
        option = optionDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// A description of each select option.
    public struct SelectOptionDescription: Swift.Equatable {
        /// A description of the option meaning.
        public var description: Swift.String?
        /// The value of the option.
        /// This member is required.
        public var option: Swift.String?
        /// The title of the select option.
        public var title: Swift.String?

        public init(
            description: Swift.String? = nil,
            option: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.description = description
            self.option = option
            self.title = title
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.SelectValidation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxChoices = "MaxChoices"
        case minChoices = "MinChoices"
        case options = "Options"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxChoices = self.maxChoices {
            try encodeContainer.encode(maxChoices, forKey: .maxChoices)
        }
        if let minChoices = self.minChoices {
            try encodeContainer.encode(minChoices, forKey: .minChoices)
        }
        if let options = options {
            var optionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .options)
            for string0 in options {
                try optionsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minChoicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minChoices)
        minChoices = minChoicesDecoded
        let maxChoicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxChoices)
        maxChoices = maxChoicesDecoded
        let optionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .options)
        var optionsDecoded0:[Swift.String]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [Swift.String]()
            for string0 in optionsContainer {
                if let string0 = string0 {
                    optionsDecoded0?.append(string0)
                }
            }
        }
        options = optionsDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Validation rules for a select field.
    public struct SelectValidation: Swift.Equatable {
        /// The maximum number of choices for the select.
        /// This member is required.
        public var maxChoices: Swift.Int?
        /// The minimum number of choices for the select.
        /// This member is required.
        public var minChoices: Swift.Int?
        /// An array of strings for the possible selection options.
        /// This member is required.
        public var options: [Swift.String]?

        public init(
            maxChoices: Swift.Int? = nil,
            minChoices: Swift.Int? = nil,
            options: [Swift.String]? = nil
        )
        {
            self.maxChoices = maxChoices
            self.minChoices = minChoices
            self.options = options
        }
    }

}

extension SendDestinationNumberVerificationCodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case context = "Context"
        case destinationCountryParameters = "DestinationCountryParameters"
        case languageCode = "LanguageCode"
        case originationIdentity = "OriginationIdentity"
        case verificationChannel = "VerificationChannel"
        case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .context)
            for (dictKey0, contextMap0) in context {
                try contextContainer.encode(contextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let destinationCountryParameters = destinationCountryParameters {
            var destinationCountryParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .destinationCountryParameters)
            for (dictKey0, destinationCountryParameters0) in destinationCountryParameters {
                try destinationCountryParametersContainer.encode(destinationCountryParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let verificationChannel = self.verificationChannel {
            try encodeContainer.encode(verificationChannel.rawValue, forKey: .verificationChannel)
        }
        if let verifiedDestinationNumberId = self.verifiedDestinationNumberId {
            try encodeContainer.encode(verifiedDestinationNumberId, forKey: .verifiedDestinationNumberId)
        }
    }
}

extension SendDestinationNumberVerificationCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendDestinationNumberVerificationCodeInput: Swift.Equatable {
    /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
    public var configurationSetName: Swift.String?
    /// You can specify custom data in this field. If you do, that data is logged to the event destination.
    public var context: [Swift.String:Swift.String]?
    /// This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see [Special requirements for sending SMS messages to recipients in India](https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html).
    public var destinationCountryParameters: [Swift.String:Swift.String]?
    /// Choose the language to use for the message.
    public var languageCode: PinpointSMSVoiceV2ClientTypes.LanguageCode?
    /// The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.
    public var originationIdentity: Swift.String?
    /// Choose to send the verification code as an SMS or voice message.
    /// This member is required.
    public var verificationChannel: PinpointSMSVoiceV2ClientTypes.VerificationChannel?
    /// The unique identifier for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberId: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        destinationCountryParameters: [Swift.String:Swift.String]? = nil,
        languageCode: PinpointSMSVoiceV2ClientTypes.LanguageCode? = nil,
        originationIdentity: Swift.String? = nil,
        verificationChannel: PinpointSMSVoiceV2ClientTypes.VerificationChannel? = nil,
        verifiedDestinationNumberId: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.context = context
        self.destinationCountryParameters = destinationCountryParameters
        self.languageCode = languageCode
        self.originationIdentity = originationIdentity
        self.verificationChannel = verificationChannel
        self.verifiedDestinationNumberId = verifiedDestinationNumberId
    }
}

struct SendDestinationNumberVerificationCodeInputBody: Swift.Equatable {
    let verifiedDestinationNumberId: Swift.String?
    let verificationChannel: PinpointSMSVoiceV2ClientTypes.VerificationChannel?
    let languageCode: PinpointSMSVoiceV2ClientTypes.LanguageCode?
    let originationIdentity: Swift.String?
    let configurationSetName: Swift.String?
    let context: [Swift.String:Swift.String]?
    let destinationCountryParameters: [Swift.String:Swift.String]?
}

extension SendDestinationNumberVerificationCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case context = "Context"
        case destinationCountryParameters = "DestinationCountryParameters"
        case languageCode = "LanguageCode"
        case originationIdentity = "OriginationIdentity"
        case verificationChannel = "VerificationChannel"
        case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verifiedDestinationNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedDestinationNumberId)
        verifiedDestinationNumberId = verifiedDestinationNumberIdDecoded
        let verificationChannelDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.VerificationChannel.self, forKey: .verificationChannel)
        verificationChannel = verificationChannelDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, contextvalue0) in contextContainer {
                if let contextvalue0 = contextvalue0 {
                    contextDecoded0?[key0] = contextvalue0
                }
            }
        }
        context = contextDecoded0
        let destinationCountryParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .destinationCountryParameters)
        var destinationCountryParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let destinationCountryParametersContainer = destinationCountryParametersContainer {
            destinationCountryParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, destinationcountryparametervalue0) in destinationCountryParametersContainer {
                if let destinationcountryparametervalue0 = destinationcountryparametervalue0 {
                    destinationCountryParametersDecoded0?[key0] = destinationcountryparametervalue0
                }
            }
        }
        destinationCountryParameters = destinationCountryParametersDecoded0
    }
}

extension SendDestinationNumberVerificationCodeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendDestinationNumberVerificationCodeOutputBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendDestinationNumberVerificationCodeOutput: Swift.Equatable {
    /// The unique identifier for the message.
    /// This member is required.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendDestinationNumberVerificationCodeOutputBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendDestinationNumberVerificationCodeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

enum SendDestinationNumberVerificationCodeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SendTextMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case context = "Context"
        case destinationCountryParameters = "DestinationCountryParameters"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case dryRun = "DryRun"
        case keyword = "Keyword"
        case maxPrice = "MaxPrice"
        case messageBody = "MessageBody"
        case messageType = "MessageType"
        case originationIdentity = "OriginationIdentity"
        case timeToLive = "TimeToLive"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .context)
            for (dictKey0, contextMap0) in context {
                try contextContainer.encode(contextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let destinationCountryParameters = destinationCountryParameters {
            var destinationCountryParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .destinationCountryParameters)
            for (dictKey0, destinationCountryParameters0) in destinationCountryParameters {
                try destinationCountryParametersContainer.encode(destinationCountryParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let destinationPhoneNumber = self.destinationPhoneNumber {
            try encodeContainer.encode(destinationPhoneNumber, forKey: .destinationPhoneNumber)
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let keyword = self.keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let maxPrice = self.maxPrice {
            try encodeContainer.encode(maxPrice, forKey: .maxPrice)
        }
        if let messageBody = self.messageBody {
            try encodeContainer.encode(messageBody, forKey: .messageBody)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let timeToLive = self.timeToLive {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
    }
}

extension SendTextMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendTextMessageInput: Swift.Equatable {
    /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
    public var configurationSetName: Swift.String?
    /// You can specify custom data in this field. If you do, that data is logged to the event destination.
    public var context: [Swift.String:Swift.String]?
    /// This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see [Special requirements for sending SMS messages to recipients in India](https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html).
    public var destinationCountryParameters: [Swift.String:Swift.String]?
    /// The destination phone number in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// When set to true, the message is checked and validated, but isn't sent to the end recipient.
    public var dryRun: Swift.Bool?
    /// When you register a short code in the US, you must specify a program name. If you don’t have a US short code, omit this attribute.
    public var keyword: Swift.String?
    /// The maximum amount that you want to spend, in US dollars, per each text message part. A text message can contain multiple parts.
    public var maxPrice: Swift.String?
    /// The body of the text message.
    public var messageBody: Swift.String?
    /// The type of message. Valid values are for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.
    public var originationIdentity: Swift.String?
    /// How long the text message is valid for. By default this is 72 hours.
    public var timeToLive: Swift.Int?

    public init(
        configurationSetName: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        destinationCountryParameters: [Swift.String:Swift.String]? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        keyword: Swift.String? = nil,
        maxPrice: Swift.String? = nil,
        messageBody: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        originationIdentity: Swift.String? = nil,
        timeToLive: Swift.Int? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.context = context
        self.destinationCountryParameters = destinationCountryParameters
        self.destinationPhoneNumber = destinationPhoneNumber
        self.dryRun = dryRun
        self.keyword = keyword
        self.maxPrice = maxPrice
        self.messageBody = messageBody
        self.messageType = messageType
        self.originationIdentity = originationIdentity
        self.timeToLive = timeToLive
    }
}

struct SendTextMessageInputBody: Swift.Equatable {
    let destinationPhoneNumber: Swift.String?
    let originationIdentity: Swift.String?
    let messageBody: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let keyword: Swift.String?
    let configurationSetName: Swift.String?
    let maxPrice: Swift.String?
    let timeToLive: Swift.Int?
    let context: [Swift.String:Swift.String]?
    let destinationCountryParameters: [Swift.String:Swift.String]?
    let dryRun: Swift.Bool?
}

extension SendTextMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case context = "Context"
        case destinationCountryParameters = "DestinationCountryParameters"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case dryRun = "DryRun"
        case keyword = "Keyword"
        case maxPrice = "MaxPrice"
        case messageBody = "MessageBody"
        case messageType = "MessageType"
        case originationIdentity = "OriginationIdentity"
        case timeToLive = "TimeToLive"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let messageBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let maxPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxPrice)
        maxPrice = maxPriceDecoded
        let timeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, contextvalue0) in contextContainer {
                if let contextvalue0 = contextvalue0 {
                    contextDecoded0?[key0] = contextvalue0
                }
            }
        }
        context = contextDecoded0
        let destinationCountryParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .destinationCountryParameters)
        var destinationCountryParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let destinationCountryParametersContainer = destinationCountryParametersContainer {
            destinationCountryParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, destinationcountryparametervalue0) in destinationCountryParametersContainer {
                if let destinationcountryparametervalue0 = destinationcountryparametervalue0 {
                    destinationCountryParametersDecoded0?[key0] = destinationcountryparametervalue0
                }
            }
        }
        destinationCountryParameters = destinationCountryParametersDecoded0
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension SendTextMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendTextMessageOutputBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendTextMessageOutput: Swift.Equatable {
    /// The unique identifier for the message.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendTextMessageOutputBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendTextMessageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

enum SendTextMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SendVoiceMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case context = "Context"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case dryRun = "DryRun"
        case maxPricePerMinute = "MaxPricePerMinute"
        case messageBody = "MessageBody"
        case messageBodyTextType = "MessageBodyTextType"
        case originationIdentity = "OriginationIdentity"
        case timeToLive = "TimeToLive"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .context)
            for (dictKey0, contextMap0) in context {
                try contextContainer.encode(contextMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let destinationPhoneNumber = self.destinationPhoneNumber {
            try encodeContainer.encode(destinationPhoneNumber, forKey: .destinationPhoneNumber)
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let maxPricePerMinute = self.maxPricePerMinute {
            try encodeContainer.encode(maxPricePerMinute, forKey: .maxPricePerMinute)
        }
        if let messageBody = self.messageBody {
            try encodeContainer.encode(messageBody, forKey: .messageBody)
        }
        if let messageBodyTextType = self.messageBodyTextType {
            try encodeContainer.encode(messageBodyTextType.rawValue, forKey: .messageBodyTextType)
        }
        if let originationIdentity = self.originationIdentity {
            try encodeContainer.encode(originationIdentity, forKey: .originationIdentity)
        }
        if let timeToLive = self.timeToLive {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
        if let voiceId = self.voiceId {
            try encodeContainer.encode(voiceId.rawValue, forKey: .voiceId)
        }
    }
}

extension SendVoiceMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendVoiceMessageInput: Swift.Equatable {
    /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
    public var configurationSetName: Swift.String?
    /// You can specify custom data in this field. If you do, that data is logged to the event destination.
    public var context: [Swift.String:Swift.String]?
    /// The destination phone number in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// When set to true, the message is checked and validated, but isn't sent to the end recipient.
    public var dryRun: Swift.Bool?
    /// The maximum amount to spend per voice message, in US dollars.
    public var maxPricePerMinute: Swift.String?
    /// The text to convert to a voice message.
    public var messageBody: Swift.String?
    /// Specifies if the MessageBody field contains text or [speech synthesis markup language (SSML)](https://docs.aws.amazon.com/polly/latest/dg/what-is.html).
    ///
    /// * TEXT: This is the default value. When used the maximum character limit is 3000.
    ///
    /// * SSML: When used the maximum character limit is 6000 including SSML tagging.
    public var messageBodyTextType: PinpointSMSVoiceV2ClientTypes.VoiceMessageBodyTextType?
    /// The origination identity to use for the voice call. This can be the PhoneNumber, PhoneNumberId, PhoneNumberArn, PoolId, or PoolArn.
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// How long the voice message is valid for. By default this is 72 hours.
    public var timeToLive: Swift.Int?
    /// The voice for the [Amazon Polly](https://docs.aws.amazon.com/polly/latest/dg/what-is.html) service to use. By default this is set to "MATTHEW".
    public var voiceId: PinpointSMSVoiceV2ClientTypes.VoiceId?

    public init(
        configurationSetName: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        maxPricePerMinute: Swift.String? = nil,
        messageBody: Swift.String? = nil,
        messageBodyTextType: PinpointSMSVoiceV2ClientTypes.VoiceMessageBodyTextType? = nil,
        originationIdentity: Swift.String? = nil,
        timeToLive: Swift.Int? = nil,
        voiceId: PinpointSMSVoiceV2ClientTypes.VoiceId? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.context = context
        self.destinationPhoneNumber = destinationPhoneNumber
        self.dryRun = dryRun
        self.maxPricePerMinute = maxPricePerMinute
        self.messageBody = messageBody
        self.messageBodyTextType = messageBodyTextType
        self.originationIdentity = originationIdentity
        self.timeToLive = timeToLive
        self.voiceId = voiceId
    }
}

struct SendVoiceMessageInputBody: Swift.Equatable {
    let destinationPhoneNumber: Swift.String?
    let originationIdentity: Swift.String?
    let messageBody: Swift.String?
    let messageBodyTextType: PinpointSMSVoiceV2ClientTypes.VoiceMessageBodyTextType?
    let voiceId: PinpointSMSVoiceV2ClientTypes.VoiceId?
    let configurationSetName: Swift.String?
    let maxPricePerMinute: Swift.String?
    let timeToLive: Swift.Int?
    let context: [Swift.String:Swift.String]?
    let dryRun: Swift.Bool?
}

extension SendVoiceMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case context = "Context"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case dryRun = "DryRun"
        case maxPricePerMinute = "MaxPricePerMinute"
        case messageBody = "MessageBody"
        case messageBodyTextType = "MessageBodyTextType"
        case originationIdentity = "OriginationIdentity"
        case timeToLive = "TimeToLive"
        case voiceId = "VoiceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let originationIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationIdentity)
        originationIdentity = originationIdentityDecoded
        let messageBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
        let messageBodyTextTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.VoiceMessageBodyTextType.self, forKey: .messageBodyTextType)
        messageBodyTextType = messageBodyTextTypeDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.VoiceId.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let maxPricePerMinuteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxPricePerMinute)
        maxPricePerMinute = maxPricePerMinuteDecoded
        let timeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, contextvalue0) in contextContainer {
                if let contextvalue0 = contextvalue0 {
                    contextDecoded0?[key0] = contextvalue0
                }
            }
        }
        context = contextDecoded0
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension SendVoiceMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendVoiceMessageOutputBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendVoiceMessageOutput: Swift.Equatable {
    /// The unique identifier for the message.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendVoiceMessageOutputBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendVoiceMessageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

enum SendVoiceMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case senderId = "SenderId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let senderId = self.senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The alphanumeric sender ID in a specific country that you want to describe. For more information on sender IDs see [Requesting sender IDs for SMS messaging with Amazon Pinpoint ](https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-awssupport-sender-id.html) in the Amazon Pinpoint User Guide.
    public struct SenderIdAndCountry: Swift.Equatable {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        /// This member is required.
        public var isoCountryCode: Swift.String?
        /// The unique identifier of the sender.
        /// This member is required.
        public var senderId: Swift.String?

        public init(
            isoCountryCode: Swift.String? = nil,
            senderId: Swift.String? = nil
        )
        {
            self.isoCountryCode = isoCountryCode
            self.senderId = senderId
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.SenderIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.SenderIdFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for a sender ID that meets a specified criteria.
    public struct SenderIdFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.SenderIdFilterName?
        /// An array of values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.SenderIdFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum SenderIdFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deletionProtectionEnabled
        case isoCountryCode
        case messageType
        case registered
        case senderId
        case sdkUnknown(Swift.String)

        public static var allCases: [SenderIdFilterName] {
            return [
                .deletionProtectionEnabled,
                .isoCountryCode,
                .messageType,
                .registered,
                .senderId,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deletionProtectionEnabled: return "deletion-protection-enabled"
            case .isoCountryCode: return "iso-country-code"
            case .messageType: return "message-type"
            case .registered: return "registered"
            case .senderId: return "sender-id"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SenderIdFilterName(rawValue: rawValue) ?? SenderIdFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.SenderIdInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageTypes = "MessageTypes"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case registered = "Registered"
        case registrationId = "RegistrationId"
        case senderId = "SenderId"
        case senderIdArn = "SenderIdArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deletionProtectionEnabled != false {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let messageTypes = messageTypes {
            var messageTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messageTypes)
            for messagetype0 in messageTypes {
                try messageTypesContainer.encode(messagetype0.rawValue)
            }
        }
        if let monthlyLeasingPrice = self.monthlyLeasingPrice {
            try encodeContainer.encode(monthlyLeasingPrice, forKey: .monthlyLeasingPrice)
        }
        if registered != false {
            try encodeContainer.encode(registered, forKey: .registered)
        }
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
        if let senderId = self.senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
        if let senderIdArn = self.senderIdArn {
            try encodeContainer.encode(senderIdArn, forKey: .senderIdArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderIdArn)
        senderIdArn = senderIdArnDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.MessageType?].self, forKey: .messageTypes)
        var messageTypesDecoded0:[PinpointSMSVoiceV2ClientTypes.MessageType]? = nil
        if let messageTypesContainer = messageTypesContainer {
            messageTypesDecoded0 = [PinpointSMSVoiceV2ClientTypes.MessageType]()
            for string0 in messageTypesContainer {
                if let string0 = string0 {
                    messageTypesDecoded0?.append(string0)
                }
            }
        }
        messageTypes = messageTypesDecoded0
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let registeredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .registered) ?? false
        registered = registeredDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The information for all SenderIds in an Amazon Web Services account.
    public struct SenderIdInformation: Swift.Equatable {
        /// By default this is set to false. When set to true the sender ID can't be deleted.
        /// This member is required.
        public var deletionProtectionEnabled: Swift.Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        /// This member is required.
        public var isoCountryCode: Swift.String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        /// This member is required.
        public var messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
        /// The monthly leasing price, in US dollars.
        /// This member is required.
        public var monthlyLeasingPrice: Swift.String?
        /// True if the sender ID is registered.
        /// This member is required.
        public var registered: Swift.Bool
        /// The unique identifier for the registration.
        public var registrationId: Swift.String?
        /// The alphanumeric sender ID in a specific country that you'd like to describe.
        /// This member is required.
        public var senderId: Swift.String?
        /// The Amazon Resource Name (ARN) associated with the SenderId.
        /// This member is required.
        public var senderIdArn: Swift.String?

        public init(
            deletionProtectionEnabled: Swift.Bool = false,
            isoCountryCode: Swift.String? = nil,
            messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]? = nil,
            monthlyLeasingPrice: Swift.String? = nil,
            registered: Swift.Bool = false,
            registrationId: Swift.String? = nil,
            senderId: Swift.String? = nil,
            senderIdArn: Swift.String? = nil
        )
        {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.registered = registered
            self.registrationId = registrationId
            self.senderId = senderId
            self.senderIdArn = senderIdArn
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: PinpointSMSVoiceV2ClientTypes.ServiceQuotaExceededExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PinpointSMSVoiceV2ClientTypes.ServiceQuotaExceededExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: PinpointSMSVoiceV2ClientTypes.ServiceQuotaExceededExceptionReason?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.ServiceQuotaExceededExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum ServiceQuotaExceededExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associationsPerRegistration
        case configurationSetsPerAccount
        case dailyDestinationCallLimit
        case eventDestinationsPerConfigurationSet
        case keywordsPerPhoneNumber
        case keywordsPerPool
        case monthlySpendLimitReachedForText
        case monthlySpendLimitReachedForVoice
        case optOutListsPerAccount
        case originationIdentitiesPerPool
        case phoneNumbersPerAccount
        case phoneNumbersPerRegistration
        case poolsPerAccount
        case registrationsPerAccount
        case registrationAttachmentsCreatedPerDay
        case registrationAttachmentsPerAccount
        case registrationVersionsCreatedPerDay
        case senderIdsPerAccount
        case tagsPerResource
        case verificationAttemptsPerDay
        case verifiedDestinationNumbersPerAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaExceededExceptionReason] {
            return [
                .associationsPerRegistration,
                .configurationSetsPerAccount,
                .dailyDestinationCallLimit,
                .eventDestinationsPerConfigurationSet,
                .keywordsPerPhoneNumber,
                .keywordsPerPool,
                .monthlySpendLimitReachedForText,
                .monthlySpendLimitReachedForVoice,
                .optOutListsPerAccount,
                .originationIdentitiesPerPool,
                .phoneNumbersPerAccount,
                .phoneNumbersPerRegistration,
                .poolsPerAccount,
                .registrationsPerAccount,
                .registrationAttachmentsCreatedPerDay,
                .registrationAttachmentsPerAccount,
                .registrationVersionsCreatedPerDay,
                .senderIdsPerAccount,
                .tagsPerResource,
                .verificationAttemptsPerDay,
                .verifiedDestinationNumbersPerAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associationsPerRegistration: return "ASSOCIATIONS_PER_REGISTRATION"
            case .configurationSetsPerAccount: return "CONFIGURATION_SETS_PER_ACCOUNT"
            case .dailyDestinationCallLimit: return "DAILY_DESTINATION_CALL_LIMIT"
            case .eventDestinationsPerConfigurationSet: return "EVENT_DESTINATIONS_PER_CONFIGURATION_SET"
            case .keywordsPerPhoneNumber: return "KEYWORDS_PER_PHONE_NUMBER"
            case .keywordsPerPool: return "KEYWORDS_PER_POOL"
            case .monthlySpendLimitReachedForText: return "MONTHLY_SPEND_LIMIT_REACHED_FOR_TEXT"
            case .monthlySpendLimitReachedForVoice: return "MONTHLY_SPEND_LIMIT_REACHED_FOR_VOICE"
            case .optOutListsPerAccount: return "OPT_OUT_LISTS_PER_ACCOUNT"
            case .originationIdentitiesPerPool: return "ORIGINATION_IDENTITIES_PER_POOL"
            case .phoneNumbersPerAccount: return "PHONE_NUMBERS_PER_ACCOUNT"
            case .phoneNumbersPerRegistration: return "PHONE_NUMBERS_PER_REGISTRATION"
            case .poolsPerAccount: return "POOLS_PER_ACCOUNT"
            case .registrationsPerAccount: return "REGISTRATIONS_PER_ACCOUNT"
            case .registrationAttachmentsCreatedPerDay: return "REGISTRATION_ATTACHMENTS_CREATED_PER_DAY"
            case .registrationAttachmentsPerAccount: return "REGISTRATION_ATTACHMENTS_PER_ACCOUNT"
            case .registrationVersionsCreatedPerDay: return "REGISTRATION_VERSIONS_CREATED_PER_DAY"
            case .senderIdsPerAccount: return "SENDER_IDS_PER_ACCOUNT"
            case .tagsPerResource: return "TAGS_PER_RESOURCE"
            case .verificationAttemptsPerDay: return "VERIFICATION_ATTEMPTS_PER_DAY"
            case .verifiedDestinationNumbersPerAccount: return "VERIFIED_DESTINATION_NUMBERS_PER_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceQuotaExceededExceptionReason(rawValue: rawValue) ?? ServiceQuotaExceededExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension SetDefaultMessageTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case messageType = "MessageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
    }
}

extension SetDefaultMessageTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetDefaultMessageTypeInput: Swift.Equatable {
    /// The configuration set to update with a new default message type. This field can be the ConsigurationSetName or ConfigurationSetArn.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?

    public init(
        configurationSetName: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.messageType = messageType
    }
}

struct SetDefaultMessageTypeInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
}

extension SetDefaultMessageTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case messageType = "MessageType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
    }
}

extension SetDefaultMessageTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetDefaultMessageTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.messageType = output.messageType
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.messageType = nil
        }
    }
}

public struct SetDefaultMessageTypeOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set that was updated.
    public var configurationSetName: Swift.String?
    /// The new default message type of the configuration set.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.messageType = messageType
    }
}

struct SetDefaultMessageTypeOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
}

extension SetDefaultMessageTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case messageType = "MessageType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
    }
}

enum SetDefaultMessageTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetDefaultSenderIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case senderId = "SenderId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let senderId = self.senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
    }
}

extension SetDefaultSenderIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetDefaultSenderIdInput: Swift.Equatable {
    /// The configuration set to updated with a new default SenderId. This field can be the ConsigurationSetName or ConfigurationSetArn.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The current sender ID for the configuration set. When sending a text message to a destination country which supports SenderIds, the default sender ID on the configuration set specified on [SendTextMessage] will be used if no dedicated origination phone numbers or registered SenderIds are available in your account, instead of a generic sender ID, such as 'NOTICE'.
    /// This member is required.
    public var senderId: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.senderId = senderId
    }
}

struct SetDefaultSenderIdInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
    let senderId: Swift.String?
}

extension SetDefaultSenderIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case senderId = "SenderId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
    }
}

extension SetDefaultSenderIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetDefaultSenderIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.senderId = output.senderId
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.senderId = nil
        }
    }
}

public struct SetDefaultSenderIdOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set that was updated.
    public var configurationSetName: Swift.String?
    /// The default sender ID to set for the ConfigurationSet.
    public var senderId: Swift.String?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.senderId = senderId
    }
}

struct SetDefaultSenderIdOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let senderId: Swift.String?
}

extension SetDefaultSenderIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case senderId = "SenderId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
    }
}

enum SetDefaultSenderIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetTextMessageSpendLimitOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monthlyLimit = self.monthlyLimit {
            try encodeContainer.encode(monthlyLimit, forKey: .monthlyLimit)
        }
    }
}

extension SetTextMessageSpendLimitOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetTextMessageSpendLimitOverrideInput: Swift.Equatable {
    /// The new monthly limit to enforce on text messages.
    /// This member is required.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

struct SetTextMessageSpendLimitOverrideInputBody: Swift.Equatable {
    let monthlyLimit: Swift.Int?
}

extension SetTextMessageSpendLimitOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlyLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monthlyLimit)
        monthlyLimit = monthlyLimitDecoded
    }
}

extension SetTextMessageSpendLimitOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetTextMessageSpendLimitOverrideOutputBody = try responseDecoder.decode(responseBody: data)
            self.monthlyLimit = output.monthlyLimit
        } else {
            self.monthlyLimit = nil
        }
    }
}

public struct SetTextMessageSpendLimitOverrideOutput: Swift.Equatable {
    /// The current monthly limit to enforce on sending text messages.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

struct SetTextMessageSpendLimitOverrideOutputBody: Swift.Equatable {
    let monthlyLimit: Swift.Int?
}

extension SetTextMessageSpendLimitOverrideOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlyLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monthlyLimit)
        monthlyLimit = monthlyLimitDecoded
    }
}

enum SetTextMessageSpendLimitOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetVoiceMessageSpendLimitOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monthlyLimit = self.monthlyLimit {
            try encodeContainer.encode(monthlyLimit, forKey: .monthlyLimit)
        }
    }
}

extension SetVoiceMessageSpendLimitOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetVoiceMessageSpendLimitOverrideInput: Swift.Equatable {
    /// The new monthly limit to enforce on voice messages.
    /// This member is required.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

struct SetVoiceMessageSpendLimitOverrideInputBody: Swift.Equatable {
    let monthlyLimit: Swift.Int?
}

extension SetVoiceMessageSpendLimitOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlyLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monthlyLimit)
        monthlyLimit = monthlyLimitDecoded
    }
}

extension SetVoiceMessageSpendLimitOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetVoiceMessageSpendLimitOverrideOutputBody = try responseDecoder.decode(responseBody: data)
            self.monthlyLimit = output.monthlyLimit
        } else {
            self.monthlyLimit = nil
        }
    }
}

public struct SetVoiceMessageSpendLimitOverrideOutput: Swift.Equatable {
    /// The current monthly limit to enforce on sending voice messages.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

struct SetVoiceMessageSpendLimitOverrideOutputBody: Swift.Equatable {
    let monthlyLimit: Swift.Int?
}

extension SetVoiceMessageSpendLimitOverrideOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monthlyLimit = "MonthlyLimit"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlyLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monthlyLimit)
        monthlyLimit = monthlyLimitDecoded
    }
}

enum SetVoiceMessageSpendLimitOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.SnsDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = self.topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// An object that defines an Amazon SNS destination for events. You can use Amazon SNS to send notification when certain events occur.
    public struct SnsDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish events to.
        /// This member is required.
        public var topicArn: Swift.String?

        public init(
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.SpendLimit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforcedLimit = "EnforcedLimit"
        case maxLimit = "MaxLimit"
        case name = "Name"
        case overridden = "Overridden"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enforcedLimit != 0 {
            try encodeContainer.encode(enforcedLimit, forKey: .enforcedLimit)
        }
        if maxLimit != 0 {
            try encodeContainer.encode(maxLimit, forKey: .maxLimit)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if overridden != false {
            try encodeContainer.encode(overridden, forKey: .overridden)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.SpendLimitName.self, forKey: .name)
        name = nameDecoded
        let enforcedLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .enforcedLimit) ?? 0
        enforcedLimit = enforcedLimitDecoded
        let maxLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLimit) ?? 0
        maxLimit = maxLimitDecoded
        let overriddenDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overridden) ?? false
        overridden = overriddenDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Describes the current Amazon Pinpoint monthly spend limits for sending voice and text messages. For more information on increasing your monthly spend limit, see [ Requesting increases to your monthly SMS spending quota for Amazon Pinpoint ](https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-awssupport-spend-threshold.html) in the Amazon Pinpoint User Guide.
    public struct SpendLimit: Swift.Equatable {
        /// The maximum amount of money, in US dollars, that you want to be able to spend sending messages each month. This value has to be less than or equal to the amount in MaxLimit. To use this custom limit, Overridden must be set to true.
        /// This member is required.
        public var enforcedLimit: Swift.Int
        /// The maximum amount of money that you are able to spend to send messages each month, in US dollars.
        /// This member is required.
        public var maxLimit: Swift.Int
        /// The name for the SpendLimit.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.SpendLimitName?
        /// When set to True, the value that has been specified in the EnforcedLimit is used to determine the maximum amount in US dollars that can be spent to send messages each month, in US dollars.
        /// This member is required.
        public var overridden: Swift.Bool

        public init(
            enforcedLimit: Swift.Int = 0,
            maxLimit: Swift.Int = 0,
            name: PinpointSMSVoiceV2ClientTypes.SpendLimitName? = nil,
            overridden: Swift.Bool = false
        )
        {
            self.enforcedLimit = enforcedLimit
            self.maxLimit = maxLimit
            self.name = name
            self.overridden = overridden
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum SpendLimitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case textMessageMonthlySpendLimit
        case voiceMessageMonthlySpendLimit
        case sdkUnknown(Swift.String)

        public static var allCases: [SpendLimitName] {
            return [
                .textMessageMonthlySpendLimit,
                .voiceMessageMonthlySpendLimit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .textMessageMonthlySpendLimit: return "TEXT_MESSAGE_MONTHLY_SPEND_LIMIT"
            case .voiceMessageMonthlySpendLimit: return "VOICE_MESSAGE_MONTHLY_SPEND_LIMIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpendLimitName(rawValue: rawValue) ?? SpendLimitName.sdkUnknown(rawValue)
        }
    }
}

extension SubmitRegistrationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationId = "RegistrationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registrationId = self.registrationId {
            try encodeContainer.encode(registrationId, forKey: .registrationId)
        }
    }
}

extension SubmitRegistrationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SubmitRegistrationVersionInput: Swift.Equatable {
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?

    public init(
        registrationId: Swift.String? = nil
    )
    {
        self.registrationId = registrationId
    }
}

struct SubmitRegistrationVersionInputBody: Swift.Equatable {
    let registrationId: Swift.String?
}

extension SubmitRegistrationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationId = "RegistrationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
    }
}

extension SubmitRegistrationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SubmitRegistrationVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.registrationArn = output.registrationArn
            self.registrationId = output.registrationId
            self.registrationVersionStatus = output.registrationVersionStatus
            self.registrationVersionStatusHistory = output.registrationVersionStatusHistory
            self.versionNumber = output.versionNumber
        } else {
            self.registrationArn = nil
            self.registrationId = nil
            self.registrationVersionStatus = nil
            self.registrationVersionStatusHistory = nil
            self.versionNumber = nil
        }
    }
}

public struct SubmitRegistrationVersionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The status of the registration version.
    ///
    /// * DRAFT: The initial status of a registration version after it’s created.
    ///
    /// * SUBMITTED: Your registration has been submitted.
    ///
    /// * REVIEWING: Your registration has been accepted and is being reviewed.
    ///
    /// * APPROVED: Your registration has been approved.
    ///
    /// * DISCARDED: You've abandon this version of their registration to start over with a new version.
    ///
    /// * DENIED: You must fix your registration and resubmit it.
    ///
    /// * REVOKED: Your previously approved registration has been revoked.
    ///
    /// * ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.
    /// This member is required.
    public var registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus?
    /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
    /// This member is required.
    public var registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory?
    /// The version number of the registration.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus? = nil,
        registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationVersionStatus = registrationVersionStatus
        self.registrationVersionStatusHistory = registrationVersionStatusHistory
        self.versionNumber = versionNumber
    }
}

struct SubmitRegistrationVersionOutputBody: Swift.Equatable {
    let registrationArn: Swift.String?
    let registrationId: Swift.String?
    let versionNumber: Swift.Int?
    let registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus?
    let registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory?
}

extension SubmitRegistrationVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationArn = "RegistrationArn"
        case registrationId = "RegistrationId"
        case registrationVersionStatus = "RegistrationVersionStatus"
        case registrationVersionStatusHistory = "RegistrationVersionStatusHistory"
        case versionNumber = "VersionNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationArn)
        registrationArn = registrationArnDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let registrationVersionStatusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus.self, forKey: .registrationVersionStatus)
        registrationVersionStatus = registrationVersionStatusDecoded
        let registrationVersionStatusHistoryDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory.self, forKey: .registrationVersionStatusHistory)
        registrationVersionStatusHistory = registrationVersionStatusHistoryDecoded
    }
}

enum SubmitRegistrationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.SupportedAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationBehavior = "AssociationBehavior"
        case disassociationBehavior = "DisassociationBehavior"
        case isoCountryCode = "IsoCountryCode"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationBehavior = self.associationBehavior {
            try encodeContainer.encode(associationBehavior.rawValue, forKey: .associationBehavior)
        }
        if let disassociationBehavior = self.disassociationBehavior {
            try encodeContainer.encode(disassociationBehavior.rawValue, forKey: .disassociationBehavior)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let associationBehaviorDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationAssociationBehavior.self, forKey: .associationBehavior)
        associationBehavior = associationBehaviorDecoded
        let disassociationBehaviorDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.RegistrationDisassociationBehavior.self, forKey: .disassociationBehavior)
        disassociationBehavior = disassociationBehaviorDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The processing rules for when a registration can be associated with an origination identity and disassociated from an origination identity.
    public struct SupportedAssociation: Swift.Equatable {
        /// The association behavior.
        ///
        /// * ASSOCIATE_BEFORE_SUBMIT The origination identity has to be supplied when creating a registration.
        ///
        /// * ASSOCIATE_ON_APPROVAL This applies to all short code registrations. The short code will be automatically provisioned once the registration is approved.
        ///
        /// * ASSOCIATE_AFTER_COMPLETE This applies to phone number registrations when you must complete a registration first, then associate one or more phone numbers later. For example 10DLC campaigns and long codes.
        /// This member is required.
        public var associationBehavior: PinpointSMSVoiceV2ClientTypes.RegistrationAssociationBehavior?
        /// The disassociation behavior.
        ///
        /// * DISASSOCIATE_ALL_CLOSES_REGISTRATION All origination identities must be disassociated from the registration before the registration can be closed.
        ///
        /// * DISASSOCIATE_ALL_ALLOWS_DELETE_REGISTRATION All origination identities must be disassociated from the registration before the registration can be deleted.
        ///
        /// * DELETE_REGISTRATION_DISASSOCIATES The registration can be deleted and all origination identities will be disasscoiated.
        /// This member is required.
        public var disassociationBehavior: PinpointSMSVoiceV2ClientTypes.RegistrationDisassociationBehavior?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public var isoCountryCode: Swift.String?
        /// Defines the behavior of when an origination identity and registration can be associated with each other.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            associationBehavior: PinpointSMSVoiceV2ClientTypes.RegistrationAssociationBehavior? = nil,
            disassociationBehavior: PinpointSMSVoiceV2ClientTypes.RegistrationDisassociationBehavior? = nil,
            isoCountryCode: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.associationBehavior = associationBehavior
            self.disassociationBehavior = disassociationBehavior
            self.isoCountryCode = isoCountryCode
            self.resourceType = resourceType
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The list of tags to be added to the specified topic.
    public struct Tag: Swift.Equatable {
        /// The key identifier, or name, of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The string value associated with the key of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of key and value pair tags that are associated with the resource.
    /// This member is required.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PinpointSMSVoiceV2ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PinpointSMSVoiceV2ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.TextValidation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxLength = "MaxLength"
        case minLength = "MinLength"
        case pattern = "Pattern"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxLength = self.maxLength {
            try encodeContainer.encode(maxLength, forKey: .maxLength)
        }
        if let minLength = self.minLength {
            try encodeContainer.encode(minLength, forKey: .minLength)
        }
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLength)
        minLength = minLengthDecoded
        let maxLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLength)
        maxLength = maxLengthDecoded
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Validation rules for a text field.
    public struct TextValidation: Swift.Equatable {
        /// The maximum number of characters for the text field.
        /// This member is required.
        public var maxLength: Swift.Int?
        /// The minimum number of characters for the text field.
        /// This member is required.
        public var minLength: Swift.Int?
        /// The regular expression used to validate the text field.
        /// This member is required.
        public var pattern: Swift.String?

        public init(
            maxLength: Swift.Int? = nil,
            minLength: Swift.Int? = nil,
            pattern: Swift.String? = nil
        )
        {
            self.maxLength = maxLength
            self.minLength = minLength
            self.pattern = pattern
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error that occurred because too many requests were sent during a certain amount of time.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag key values to unassociate with the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEventDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case configurationSetName = "ConfigurationSetName"
        case enabled = "Enabled"
        case eventDestinationName = "EventDestinationName"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsDestination = self.cloudWatchLogsDestination {
            try encodeContainer.encode(cloudWatchLogsDestination, forKey: .cloudWatchLogsDestination)
        }
        if let configurationSetName = self.configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventDestinationName = self.eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
        if let kinesisFirehoseDestination = self.kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtype0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtype0.rawValue)
            }
        }
        if let snsDestination = self.snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }
}

extension UpdateEventDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEventDestinationInput: Swift.Equatable {
    /// An object that contains information about an event destination that sends data to CloudWatch Logs.
    public var cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
    /// The configuration set to update with the new event destination. Valid values for this can be the ConfigurationSetName or ConfigurationSetArn.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// When set to true logging is enabled.
    public var enabled: Swift.Bool?
    /// The name to use for the event destination.
    /// This member is required.
    public var eventDestinationName: Swift.String?
    /// An object that contains information about an event destination for logging to Kinesis Data Firehose.
    public var kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
    /// An array of event types that determine which events to log. The TEXT_SENT event type is not supported.
    public var matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
    /// An object that contains information about an event destination that sends data to Amazon SNS.
    public var snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?

    public init(
        cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination? = nil,
        configurationSetName: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        eventDestinationName: Swift.String? = nil,
        kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination? = nil,
        matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]? = nil,
        snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination? = nil
    )
    {
        self.cloudWatchLogsDestination = cloudWatchLogsDestination
        self.configurationSetName = configurationSetName
        self.enabled = enabled
        self.eventDestinationName = eventDestinationName
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.snsDestination = snsDestination
    }
}

struct UpdateEventDestinationInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
    let eventDestinationName: Swift.String?
    let enabled: Swift.Bool?
    let matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
    let cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
    let kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
    let snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?
}

extension UpdateEventDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case configurationSetName = "ConfigurationSetName"
        case enabled = "Enabled"
        case eventDestinationName = "EventDestinationName"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[PinpointSMSVoiceV2ClientTypes.EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [PinpointSMSVoiceV2ClientTypes.EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let cloudWatchLogsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination.self, forKey: .cloudWatchLogsDestination)
        cloudWatchLogsDestination = cloudWatchLogsDestinationDecoded
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
    }
}

extension UpdateEventDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEventDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationSetArn = output.configurationSetArn
            self.configurationSetName = output.configurationSetName
            self.eventDestination = output.eventDestination
        } else {
            self.configurationSetArn = nil
            self.configurationSetName = nil
            self.eventDestination = nil
        }
    }
}

public struct UpdateEventDestinationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the ConfigurationSet that was updated.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set.
    public var configurationSetName: Swift.String?
    /// An EventDestination object containing the details of where events will be logged.
    public var eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
    }
}

struct UpdateEventDestinationOutputBody: Swift.Equatable {
    let configurationSetArn: Swift.String?
    let configurationSetName: Swift.String?
    let eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?
}

extension UpdateEventDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetArn = "ConfigurationSetArn"
        case configurationSetName = "ConfigurationSetName"
        case eventDestination = "EventDestination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetArn)
        configurationSetArn = configurationSetArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.EventDestination.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

enum UpdateEventDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case optOutListName = "OptOutListName"
        case phoneNumberId = "PhoneNumberId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayChannelRole = "TwoWayChannelRole"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtectionEnabled = self.deletionProtectionEnabled {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let selfManagedOptOutsEnabled = self.selfManagedOptOutsEnabled {
            try encodeContainer.encode(selfManagedOptOutsEnabled, forKey: .selfManagedOptOutsEnabled)
        }
        if let twoWayChannelArn = self.twoWayChannelArn {
            try encodeContainer.encode(twoWayChannelArn, forKey: .twoWayChannelArn)
        }
        if let twoWayChannelRole = self.twoWayChannelRole {
            try encodeContainer.encode(twoWayChannelRole, forKey: .twoWayChannelRole)
        }
        if let twoWayEnabled = self.twoWayEnabled {
            try encodeContainer.encode(twoWayEnabled, forKey: .twoWayEnabled)
        }
    }
}

extension UpdatePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePhoneNumberInput: Swift.Equatable {
    /// By default this is set to false. When set to true the phone number can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The OptOutList to add the phone number to. Valid values for this field can be either the OutOutListName or OutOutListArn.
    public var optOutListName: Swift.String?
    /// The unique identifier of the phone number. Valid values for this field can be either the PhoneNumberId or PhoneNumberArn.
    /// This member is required.
    public var phoneNumberId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool?

    public init(
        deletionProtectionEnabled: Swift.Bool? = nil,
        optOutListName: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.optOutListName = optOutListName
        self.phoneNumberId = phoneNumberId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

struct UpdatePhoneNumberInputBody: Swift.Equatable {
    let phoneNumberId: Swift.String?
    let twoWayEnabled: Swift.Bool?
    let twoWayChannelArn: Swift.String?
    let twoWayChannelRole: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool?
    let optOutListName: Swift.String?
    let deletionProtectionEnabled: Swift.Bool?
}

extension UpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case optOutListName = "OptOutListName"
        case phoneNumberId = "PhoneNumberId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayChannelRole = "TwoWayChannelRole"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled)
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let twoWayChannelRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelRole)
        twoWayChannelRole = twoWayChannelRoleDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled)
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled)
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
    }
}

extension UpdatePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.deletionProtectionEnabled = output.deletionProtectionEnabled
            self.isoCountryCode = output.isoCountryCode
            self.messageType = output.messageType
            self.monthlyLeasingPrice = output.monthlyLeasingPrice
            self.numberCapabilities = output.numberCapabilities
            self.numberType = output.numberType
            self.optOutListName = output.optOutListName
            self.phoneNumber = output.phoneNumber
            self.phoneNumberArn = output.phoneNumberArn
            self.phoneNumberId = output.phoneNumberId
            self.registrationId = output.registrationId
            self.selfManagedOptOutsEnabled = output.selfManagedOptOutsEnabled
            self.status = output.status
            self.twoWayChannelArn = output.twoWayChannelArn
            self.twoWayChannelRole = output.twoWayChannelRole
            self.twoWayEnabled = output.twoWayEnabled
        } else {
            self.createdTimestamp = nil
            self.deletionProtectionEnabled = false
            self.isoCountryCode = nil
            self.messageType = nil
            self.monthlyLeasingPrice = nil
            self.numberCapabilities = nil
            self.numberType = nil
            self.optOutListName = nil
            self.phoneNumber = nil
            self.phoneNumberArn = nil
            self.phoneNumberId = nil
            self.registrationId = nil
            self.selfManagedOptOutsEnabled = false
            self.status = nil
            self.twoWayChannelArn = nil
            self.twoWayChannelRole = nil
            self.twoWayEnabled = false
        }
    }
}

public struct UpdatePhoneNumberOutput: Swift.Equatable {
    /// The time when the phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// When set to true the phone number can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The monthly leasing price of the phone number, in US dollars.
    public var monthlyLeasingPrice: Swift.String?
    /// Specifies if the number could be used for text messages, voice or both.
    public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    /// The type of number that was requested.
    public var numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
    /// The name of the OptOutList associated with the phone number.
    public var optOutListName: Swift.String?
    /// The phone number that was updated.
    public var phoneNumber: Swift.String?
    /// The Amazon Resource Name (ARN) of the updated phone number.
    public var phoneNumberArn: Swift.String?
    /// The unique identifier of the phone number.
    public var phoneNumberId: Swift.String?
    /// The unique identifier for the registration.
    public var registrationId: Swift.String?
    /// This is true if self managed opt-out are enabled.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// The current status of the request.
    public var status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
        numberType: PinpointSMSVoiceV2ClientTypes.NumberType? = nil,
        optOutListName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.NumberStatus? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.numberCapabilities = numberCapabilities
        self.numberType = numberType
        self.optOutListName = optOutListName
        self.phoneNumber = phoneNumber
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
        self.registrationId = registrationId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.status = status
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

struct UpdatePhoneNumberOutputBody: Swift.Equatable {
    let phoneNumberArn: Swift.String?
    let phoneNumberId: Swift.String?
    let phoneNumber: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    let isoCountryCode: Swift.String?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    let numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
    let monthlyLeasingPrice: Swift.String?
    let twoWayEnabled: Swift.Bool
    let twoWayChannelArn: Swift.String?
    let twoWayChannelRole: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool
    let optOutListName: Swift.String?
    let deletionProtectionEnabled: Swift.Bool
    let registrationId: Swift.String?
    let createdTimestamp: ClientRuntime.Date?
}

extension UpdatePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageType = "MessageType"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case numberCapabilities = "NumberCapabilities"
        case numberType = "NumberType"
        case optOutListName = "OptOutListName"
        case phoneNumber = "PhoneNumber"
        case phoneNumberArn = "PhoneNumberArn"
        case phoneNumberId = "PhoneNumberId"
        case registrationId = "RegistrationId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case status = "Status"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayChannelRole = "TwoWayChannelRole"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberArn)
        phoneNumberArn = phoneNumberArnDecoded
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberStatus.self, forKey: .status)
        status = statusDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let numberCapabilitiesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.NumberCapability?].self, forKey: .numberCapabilities)
        var numberCapabilitiesDecoded0:[PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil
        if let numberCapabilitiesContainer = numberCapabilitiesContainer {
            numberCapabilitiesDecoded0 = [PinpointSMSVoiceV2ClientTypes.NumberCapability]()
            for string0 in numberCapabilitiesContainer {
                if let string0 = string0 {
                    numberCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        numberCapabilities = numberCapabilitiesDecoded0
        let numberTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.NumberType.self, forKey: .numberType)
        numberType = numberTypeDecoded
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let twoWayChannelRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelRole)
        twoWayChannelRole = twoWayChannelRoleDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum UpdatePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case optOutListName = "OptOutListName"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case sharedRoutesEnabled = "SharedRoutesEnabled"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayChannelRole = "TwoWayChannelRole"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtectionEnabled = self.deletionProtectionEnabled {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let optOutListName = self.optOutListName {
            try encodeContainer.encode(optOutListName, forKey: .optOutListName)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let selfManagedOptOutsEnabled = self.selfManagedOptOutsEnabled {
            try encodeContainer.encode(selfManagedOptOutsEnabled, forKey: .selfManagedOptOutsEnabled)
        }
        if let sharedRoutesEnabled = self.sharedRoutesEnabled {
            try encodeContainer.encode(sharedRoutesEnabled, forKey: .sharedRoutesEnabled)
        }
        if let twoWayChannelArn = self.twoWayChannelArn {
            try encodeContainer.encode(twoWayChannelArn, forKey: .twoWayChannelArn)
        }
        if let twoWayChannelRole = self.twoWayChannelRole {
            try encodeContainer.encode(twoWayChannelRole, forKey: .twoWayChannelRole)
        }
        if let twoWayEnabled = self.twoWayEnabled {
            try encodeContainer.encode(twoWayEnabled, forKey: .twoWayEnabled)
        }
    }
}

extension UpdatePoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePoolInput: Swift.Equatable {
    /// When set to true the pool can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The OptOutList to associate with the pool. Valid values are either OptOutListName or OptOutListArn.
    public var optOutListName: Swift.String?
    /// The unique identifier of the pool to update. Valid values are either the PoolId or PoolArn.
    /// This member is required.
    public var poolId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool?
    /// Indicates whether shared routes are enabled for the pool.
    public var sharedRoutesEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool?

    public init(
        deletionProtectionEnabled: Swift.Bool? = nil,
        optOutListName: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool? = nil,
        sharedRoutesEnabled: Swift.Bool? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.optOutListName = optOutListName
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.sharedRoutesEnabled = sharedRoutesEnabled
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

struct UpdatePoolInputBody: Swift.Equatable {
    let poolId: Swift.String?
    let twoWayEnabled: Swift.Bool?
    let twoWayChannelArn: Swift.String?
    let twoWayChannelRole: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool?
    let optOutListName: Swift.String?
    let sharedRoutesEnabled: Swift.Bool?
    let deletionProtectionEnabled: Swift.Bool?
}

extension UpdatePoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case optOutListName = "OptOutListName"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case sharedRoutesEnabled = "SharedRoutesEnabled"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayChannelRole = "TwoWayChannelRole"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled)
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let twoWayChannelRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelRole)
        twoWayChannelRole = twoWayChannelRoleDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled)
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let sharedRoutesEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharedRoutesEnabled)
        sharedRoutesEnabled = sharedRoutesEnabledDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled)
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
    }
}

extension UpdatePoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePoolOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.deletionProtectionEnabled = output.deletionProtectionEnabled
            self.messageType = output.messageType
            self.optOutListName = output.optOutListName
            self.poolArn = output.poolArn
            self.poolId = output.poolId
            self.selfManagedOptOutsEnabled = output.selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = output.sharedRoutesEnabled
            self.status = output.status
            self.twoWayChannelArn = output.twoWayChannelArn
            self.twoWayChannelRole = output.twoWayChannelRole
            self.twoWayEnabled = output.twoWayEnabled
        } else {
            self.createdTimestamp = nil
            self.deletionProtectionEnabled = false
            self.messageType = nil
            self.optOutListName = nil
            self.poolArn = nil
            self.poolId = nil
            self.selfManagedOptOutsEnabled = false
            self.sharedRoutesEnabled = false
            self.status = nil
            self.twoWayChannelArn = nil
            self.twoWayChannelRole = nil
            self.twoWayEnabled = false
        }
    }
}

public struct UpdatePoolOutput: Swift.Equatable {
    /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: ClientRuntime.Date?
    /// When set to true the pool can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool
    /// The type of message for the pool to use.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The name of the OptOutList associated with the pool.
    public var optOutListName: Swift.String?
    /// The ARN of the pool.
    public var poolArn: Swift.String?
    /// The unique identifier of the pool.
    public var poolId: Swift.String?
    /// When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, Amazon Pinpoint automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// Indicates whether shared routes are enabled for the pool.
    public var sharedRoutesEnabled: Swift.Bool
    /// The current status of the pool update request.
    public var status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        optOutListName: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        sharedRoutesEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.PoolStatus? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.messageType = messageType
        self.optOutListName = optOutListName
        self.poolArn = poolArn
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.sharedRoutesEnabled = sharedRoutesEnabled
        self.status = status
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

struct UpdatePoolOutputBody: Swift.Equatable {
    let poolArn: Swift.String?
    let poolId: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    let messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    let twoWayEnabled: Swift.Bool
    let twoWayChannelArn: Swift.String?
    let twoWayChannelRole: Swift.String?
    let selfManagedOptOutsEnabled: Swift.Bool
    let optOutListName: Swift.String?
    let sharedRoutesEnabled: Swift.Bool
    let deletionProtectionEnabled: Swift.Bool
    let createdTimestamp: ClientRuntime.Date?
}

extension UpdatePoolOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case messageType = "MessageType"
        case optOutListName = "OptOutListName"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
        case selfManagedOptOutsEnabled = "SelfManagedOptOutsEnabled"
        case sharedRoutesEnabled = "SharedRoutesEnabled"
        case status = "Status"
        case twoWayChannelArn = "TwoWayChannelArn"
        case twoWayChannelRole = "TwoWayChannelRole"
        case twoWayEnabled = "TwoWayEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.PoolStatus.self, forKey: .status)
        status = statusDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let twoWayEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .twoWayEnabled) ?? false
        twoWayEnabled = twoWayEnabledDecoded
        let twoWayChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelArn)
        twoWayChannelArn = twoWayChannelArnDecoded
        let twoWayChannelRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .twoWayChannelRole)
        twoWayChannelRole = twoWayChannelRoleDecoded
        let selfManagedOptOutsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .selfManagedOptOutsEnabled) ?? false
        selfManagedOptOutsEnabled = selfManagedOptOutsEnabledDecoded
        let optOutListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optOutListName)
        optOutListName = optOutListNameDecoded
        let sharedRoutesEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sharedRoutesEnabled) ?? false
        sharedRoutesEnabled = sharedRoutesEnabledDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum UpdatePoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSenderIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case senderId = "SenderId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtectionEnabled = self.deletionProtectionEnabled {
            try encodeContainer.encode(deletionProtectionEnabled, forKey: .deletionProtectionEnabled)
        }
        if let isoCountryCode = self.isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let senderId = self.senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
    }
}

extension UpdateSenderIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSenderIdInput: Swift.Equatable {
    /// By default this is set to false. When set to true the sender ID can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The sender ID to update.
    /// This member is required.
    public var senderId: Swift.String?

    public init(
        deletionProtectionEnabled: Swift.Bool? = nil,
        isoCountryCode: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.senderId = senderId
    }
}

struct UpdateSenderIdInputBody: Swift.Equatable {
    let senderId: Swift.String?
    let isoCountryCode: Swift.String?
    let deletionProtectionEnabled: Swift.Bool?
}

extension UpdateSenderIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case senderId = "SenderId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled)
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
    }
}

extension UpdateSenderIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSenderIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.deletionProtectionEnabled = output.deletionProtectionEnabled
            self.isoCountryCode = output.isoCountryCode
            self.messageTypes = output.messageTypes
            self.monthlyLeasingPrice = output.monthlyLeasingPrice
            self.registered = output.registered
            self.registrationId = output.registrationId
            self.senderId = output.senderId
            self.senderIdArn = output.senderIdArn
        } else {
            self.deletionProtectionEnabled = false
            self.isoCountryCode = nil
            self.messageTypes = nil
            self.monthlyLeasingPrice = nil
            self.registered = false
            self.registrationId = nil
            self.senderId = nil
            self.senderIdArn = nil
        }
    }
}

public struct UpdateSenderIdOutput: Swift.Equatable {
    /// By default this is set to false. When set to true the sender ID can't be deleted.
    /// This member is required.
    public var deletionProtectionEnabled: Swift.Bool
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
    /// The monthly price, in US dollars, to lease the sender ID.
    /// This member is required.
    public var monthlyLeasingPrice: Swift.String?
    /// True if the sender ID is registered..
    /// This member is required.
    public var registered: Swift.Bool
    /// The unique identifier for the registration.
    public var registrationId: Swift.String?
    /// The sender ID that was updated.
    /// This member is required.
    public var senderId: Swift.String?
    /// The Amazon Resource Name (ARN) associated with the SenderId.
    /// This member is required.
    public var senderIdArn: Swift.String?

    public init(
        deletionProtectionEnabled: Swift.Bool = false,
        isoCountryCode: Swift.String? = nil,
        messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        registered: Swift.Bool = false,
        registrationId: Swift.String? = nil,
        senderId: Swift.String? = nil,
        senderIdArn: Swift.String? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageTypes = messageTypes
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.registered = registered
        self.registrationId = registrationId
        self.senderId = senderId
        self.senderIdArn = senderIdArn
    }
}

struct UpdateSenderIdOutputBody: Swift.Equatable {
    let senderIdArn: Swift.String?
    let senderId: Swift.String?
    let isoCountryCode: Swift.String?
    let messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
    let monthlyLeasingPrice: Swift.String?
    let deletionProtectionEnabled: Swift.Bool
    let registered: Swift.Bool
    let registrationId: Swift.String?
}

extension UpdateSenderIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtectionEnabled = "DeletionProtectionEnabled"
        case isoCountryCode = "IsoCountryCode"
        case messageTypes = "MessageTypes"
        case monthlyLeasingPrice = "MonthlyLeasingPrice"
        case registered = "Registered"
        case registrationId = "RegistrationId"
        case senderId = "SenderId"
        case senderIdArn = "SenderIdArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let senderIdArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderIdArn)
        senderIdArn = senderIdArnDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let messageTypesContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.MessageType?].self, forKey: .messageTypes)
        var messageTypesDecoded0:[PinpointSMSVoiceV2ClientTypes.MessageType]? = nil
        if let messageTypesContainer = messageTypesContainer {
            messageTypesDecoded0 = [PinpointSMSVoiceV2ClientTypes.MessageType]()
            for string0 in messageTypesContainer {
                if let string0 = string0 {
                    messageTypesDecoded0?.append(string0)
                }
            }
        }
        messageTypes = messageTypesDecoded0
        let monthlyLeasingPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyLeasingPrice)
        monthlyLeasingPrice = monthlyLeasingPriceDecoded
        let deletionProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtectionEnabled) ?? false
        deletionProtectionEnabled = deletionProtectionEnabledDecoded
        let registeredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .registered) ?? false
        registered = registeredDecoded
        let registrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationId)
        registrationId = registrationIdDecoded
    }
}

enum UpdateSenderIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A validation exception for a field.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field that failed validation.
        public internal(set) var fields: [PinpointSMSVoiceV2ClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: PinpointSMSVoiceV2ClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [PinpointSMSVoiceV2ClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: PinpointSMSVoiceV2ClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: PinpointSMSVoiceV2ClientTypes.ValidationExceptionReason?
    let fields: [PinpointSMSVoiceV2ClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([PinpointSMSVoiceV2ClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[PinpointSMSVoiceV2ClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [PinpointSMSVoiceV2ClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The field associated with the validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message associated with the validation exception with information to help determine its cause.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachmentTypeNotSupported
        case cannotAddOptedOutNumber
        case cannotParse
        case countryCodeMismatch
        case destinationCountryBlocked
        case fieldValidationFailed
        case invalidArn
        case invalidFilterValues
        case invalidIdentityForDestinationCountry
        case invalidNextToken
        case invalidParameter
        case invalidRegistrationAssociation
        case invalidRequest
        case maximumSizeExceeded
        case missingParameter
        case other
        case parametersCannotBeUsedTogether
        case phoneNumberCannotBeOptedIn
        case phoneNumberCannotBeReleased
        case priceOverThreshold
        case registrationFieldCannotBeDeleted
        case requestedSpendLimitHigherThanServiceLimit
        case resourceNotAccessible
        case senderIdNotRegistered
        case senderIdNotSupported
        case senderIdRequiresRegistration
        case twoWayChannelNotPresent
        case twoWayNotEnabled
        case twoWayNotSupportedInCountry
        case twoWayNotSupportedInRegion
        case twoWayTopicNotPresent
        case unknownOperation
        case unknownRegistrationField
        case unknownRegistrationSection
        case unknownRegistrationType
        case unknownRegistrationVersion
        case verificationCodeMismatch
        case voiceCapabilityNotAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .attachmentTypeNotSupported,
                .cannotAddOptedOutNumber,
                .cannotParse,
                .countryCodeMismatch,
                .destinationCountryBlocked,
                .fieldValidationFailed,
                .invalidArn,
                .invalidFilterValues,
                .invalidIdentityForDestinationCountry,
                .invalidNextToken,
                .invalidParameter,
                .invalidRegistrationAssociation,
                .invalidRequest,
                .maximumSizeExceeded,
                .missingParameter,
                .other,
                .parametersCannotBeUsedTogether,
                .phoneNumberCannotBeOptedIn,
                .phoneNumberCannotBeReleased,
                .priceOverThreshold,
                .registrationFieldCannotBeDeleted,
                .requestedSpendLimitHigherThanServiceLimit,
                .resourceNotAccessible,
                .senderIdNotRegistered,
                .senderIdNotSupported,
                .senderIdRequiresRegistration,
                .twoWayChannelNotPresent,
                .twoWayNotEnabled,
                .twoWayNotSupportedInCountry,
                .twoWayNotSupportedInRegion,
                .twoWayTopicNotPresent,
                .unknownOperation,
                .unknownRegistrationField,
                .unknownRegistrationSection,
                .unknownRegistrationType,
                .unknownRegistrationVersion,
                .verificationCodeMismatch,
                .voiceCapabilityNotAvailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachmentTypeNotSupported: return "ATTACHMENT_TYPE_NOT_SUPPORTED"
            case .cannotAddOptedOutNumber: return "CANNOT_ADD_OPTED_OUT_NUMBER"
            case .cannotParse: return "CANNOT_PARSE"
            case .countryCodeMismatch: return "COUNTRY_CODE_MISMATCH"
            case .destinationCountryBlocked: return "DESTINATION_COUNTRY_BLOCKED"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .invalidArn: return "INVALID_ARN"
            case .invalidFilterValues: return "INVALID_FILTER_VALUES"
            case .invalidIdentityForDestinationCountry: return "INVALID_IDENTITY_FOR_DESTINATION_COUNTRY"
            case .invalidNextToken: return "INVALID_NEXT_TOKEN"
            case .invalidParameter: return "INVALID_PARAMETER"
            case .invalidRegistrationAssociation: return "INVALID_REGISTRATION_ASSOCIATION"
            case .invalidRequest: return "INVALID_REQUEST"
            case .maximumSizeExceeded: return "MAXIMUM_SIZE_EXCEEDED"
            case .missingParameter: return "MISSING_PARAMETER"
            case .other: return "OTHER"
            case .parametersCannotBeUsedTogether: return "PARAMETERS_CANNOT_BE_USED_TOGETHER"
            case .phoneNumberCannotBeOptedIn: return "PHONE_NUMBER_CANNOT_BE_OPTED_IN"
            case .phoneNumberCannotBeReleased: return "PHONE_NUMBER_CANNOT_BE_RELEASED"
            case .priceOverThreshold: return "PRICE_OVER_THRESHOLD"
            case .registrationFieldCannotBeDeleted: return "REGISTRATION_FIELD_CANNOT_BE_DELETED"
            case .requestedSpendLimitHigherThanServiceLimit: return "REQUESTED_SPEND_LIMIT_HIGHER_THAN_SERVICE_LIMIT"
            case .resourceNotAccessible: return "RESOURCE_NOT_ACCESSIBLE"
            case .senderIdNotRegistered: return "SENDER_ID_NOT_REGISTERED"
            case .senderIdNotSupported: return "SENDER_ID_NOT_SUPPORTED"
            case .senderIdRequiresRegistration: return "SENDER_ID_REQUIRES_REGISTRATION"
            case .twoWayChannelNotPresent: return "TWO_WAY_CHANNEL_NOT_PRESENT"
            case .twoWayNotEnabled: return "TWO_WAY_NOT_ENABLED"
            case .twoWayNotSupportedInCountry: return "TWO_WAY_NOT_SUPPORTED_IN_COUNTRY"
            case .twoWayNotSupportedInRegion: return "TWO_WAY_NOT_SUPPORTED_IN_REGION"
            case .twoWayTopicNotPresent: return "TWO_WAY_TOPIC_NOT_PRESENT"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case .unknownRegistrationField: return "UNKNOWN_REGISTRATION_FIELD"
            case .unknownRegistrationSection: return "UNKNOWN_REGISTRATION_SECTION"
            case .unknownRegistrationType: return "UNKNOWN_REGISTRATION_TYPE"
            case .unknownRegistrationVersion: return "UNKNOWN_REGISTRATION_VERSION"
            case .verificationCodeMismatch: return "VERIFICATION_CODE_MISMATCH"
            case .voiceCapabilityNotAvailable: return "VOICE_CAPABILITY_NOT_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum VerificationChannel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case text
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [VerificationChannel] {
            return [
                .text,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .text: return "TEXT"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VerificationChannel(rawValue: rawValue) ?? VerificationChannel.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum VerificationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pending
        case verified
        case sdkUnknown(Swift.String)

        public static var allCases: [VerificationStatus] {
            return [
                .pending,
                .verified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pending: return "PENDING"
            case .verified: return "VERIFIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VerificationStatus(rawValue: rawValue) ?? VerificationStatus.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// The filter definition for filtering verified destination phone numbers that meets a specified criteria.
    public struct VerifiedDestinationNumberFilter: Swift.Equatable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilterName?
        /// An array of values to filter on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PinpointSMSVoiceV2ClientTypes {
    public enum VerifiedDestinationNumberFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [VerifiedDestinationNumberFilterName] {
            return [
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .status: return "status"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VerifiedDestinationNumberFilterName(rawValue: rawValue) ?? VerifiedDestinationNumberFilterName.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case status = "Status"
        case verifiedDestinationNumberArn = "VerifiedDestinationNumberArn"
        case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let destinationPhoneNumber = self.destinationPhoneNumber {
            try encodeContainer.encode(destinationPhoneNumber, forKey: .destinationPhoneNumber)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let verifiedDestinationNumberArn = self.verifiedDestinationNumberArn {
            try encodeContainer.encode(verifiedDestinationNumberArn, forKey: .verifiedDestinationNumberArn)
        }
        if let verifiedDestinationNumberId = self.verifiedDestinationNumberId {
            try encodeContainer.encode(verifiedDestinationNumberId, forKey: .verifiedDestinationNumberId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verifiedDestinationNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedDestinationNumberArn)
        verifiedDestinationNumberArn = verifiedDestinationNumberArnDecoded
        let verifiedDestinationNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedDestinationNumberId)
        verifiedDestinationNumberId = verifiedDestinationNumberIdDecoded
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.VerificationStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    /// Provides information about the requested verified destintion phone number.
    public struct VerifiedDestinationNumberInformation: Swift.Equatable {
        /// The time when the destination phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: ClientRuntime.Date?
        /// The verified destination phone number, in E.164 format.
        /// This member is required.
        public var destinationPhoneNumber: Swift.String?
        /// The status of the verified destination phone number.
        ///
        /// * PENDING: The phone number hasn't been verified yet.
        ///
        /// * VERIFIED: The phone number is verified and can receive messages.
        /// This member is required.
        public var status: PinpointSMSVoiceV2ClientTypes.VerificationStatus?
        /// The Amazon Resource Name (ARN) for the verified destination phone number.
        /// This member is required.
        public var verifiedDestinationNumberArn: Swift.String?
        /// The unique identifier for the verified destination phone number.
        /// This member is required.
        public var verifiedDestinationNumberId: Swift.String?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            destinationPhoneNumber: Swift.String? = nil,
            status: PinpointSMSVoiceV2ClientTypes.VerificationStatus? = nil,
            verifiedDestinationNumberArn: Swift.String? = nil,
            verifiedDestinationNumberId: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.status = status
            self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }
    }

}

extension VerifyDestinationNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case verificationCode = "VerificationCode"
        case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let verificationCode = self.verificationCode {
            try encodeContainer.encode(verificationCode, forKey: .verificationCode)
        }
        if let verifiedDestinationNumberId = self.verifiedDestinationNumberId {
            try encodeContainer.encode(verifiedDestinationNumberId, forKey: .verifiedDestinationNumberId)
        }
    }
}

extension VerifyDestinationNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct VerifyDestinationNumberInput: Swift.Equatable {
    /// The verification code that was received by the verified destination phone number.
    /// This member is required.
    public var verificationCode: Swift.String?
    /// The unique identifier for the verififed destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberId: Swift.String?

    public init(
        verificationCode: Swift.String? = nil,
        verifiedDestinationNumberId: Swift.String? = nil
    )
    {
        self.verificationCode = verificationCode
        self.verifiedDestinationNumberId = verifiedDestinationNumberId
    }
}

struct VerifyDestinationNumberInputBody: Swift.Equatable {
    let verifiedDestinationNumberId: Swift.String?
    let verificationCode: Swift.String?
}

extension VerifyDestinationNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case verificationCode = "VerificationCode"
        case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verifiedDestinationNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedDestinationNumberId)
        verifiedDestinationNumberId = verifiedDestinationNumberIdDecoded
        let verificationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationCode)
        verificationCode = verificationCodeDecoded
    }
}

extension VerifyDestinationNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: VerifyDestinationNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.destinationPhoneNumber = output.destinationPhoneNumber
            self.status = output.status
            self.verifiedDestinationNumberArn = output.verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = output.verifiedDestinationNumberId
        } else {
            self.createdTimestamp = nil
            self.destinationPhoneNumber = nil
            self.status = nil
            self.verifiedDestinationNumberArn = nil
            self.verifiedDestinationNumberId = nil
        }
    }
}

public struct VerifyDestinationNumberOutput: Swift.Equatable {
    /// The time when the destination phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: ClientRuntime.Date?
    /// The phone number in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// The status for being able to send messages to the phone number.
    /// This member is required.
    public var status: PinpointSMSVoiceV2ClientTypes.VerificationStatus?
    /// The Amazon Resource Name (ARN) for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberArn: Swift.String?
    /// The unique identifier for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberId: Swift.String?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        status: PinpointSMSVoiceV2ClientTypes.VerificationStatus? = nil,
        verifiedDestinationNumberArn: Swift.String? = nil,
        verifiedDestinationNumberId: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinationPhoneNumber = destinationPhoneNumber
        self.status = status
        self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
        self.verifiedDestinationNumberId = verifiedDestinationNumberId
    }
}

struct VerifyDestinationNumberOutputBody: Swift.Equatable {
    let verifiedDestinationNumberArn: Swift.String?
    let verifiedDestinationNumberId: Swift.String?
    let destinationPhoneNumber: Swift.String?
    let status: PinpointSMSVoiceV2ClientTypes.VerificationStatus?
    let createdTimestamp: ClientRuntime.Date?
}

extension VerifyDestinationNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case status = "Status"
        case verifiedDestinationNumberArn = "VerifiedDestinationNumberArn"
        case verifiedDestinationNumberId = "VerifiedDestinationNumberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verifiedDestinationNumberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedDestinationNumberArn)
        verifiedDestinationNumberArn = verifiedDestinationNumberArnDecoded
        let verifiedDestinationNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedDestinationNumberId)
        verifiedDestinationNumberId = verifiedDestinationNumberIdDecoded
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PinpointSMSVoiceV2ClientTypes.VerificationStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

enum VerifyDestinationNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum VoiceId: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amy
        case astrid
        case bianca
        case brian
        case camila
        case carla
        case carmen
        case celine
        case chantal
        case conchita
        case cristiano
        case dora
        case emma
        case enrique
        case ewa
        case filiz
        case geraint
        case giorgio
        case gwyneth
        case hans
        case ines
        case ivy
        case jacek
        case jan
        case joanna
        case joey
        case justin
        case karl
        case kendra
        case kimberly
        case lea
        case liv
        case lotte
        case lucia
        case lupe
        case mads
        case maja
        case marlene
        case mathieu
        case matthew
        case maxim
        case mia
        case miguel
        case mizuki
        case naja
        case nicole
        case penelope
        case raveena
        case ricardo
        case ruben
        case russell
        case salli
        case seoyeon
        case takumi
        case tatyana
        case vicki
        case vitoria
        case zeina
        case zhiyu
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceId] {
            return [
                .amy,
                .astrid,
                .bianca,
                .brian,
                .camila,
                .carla,
                .carmen,
                .celine,
                .chantal,
                .conchita,
                .cristiano,
                .dora,
                .emma,
                .enrique,
                .ewa,
                .filiz,
                .geraint,
                .giorgio,
                .gwyneth,
                .hans,
                .ines,
                .ivy,
                .jacek,
                .jan,
                .joanna,
                .joey,
                .justin,
                .karl,
                .kendra,
                .kimberly,
                .lea,
                .liv,
                .lotte,
                .lucia,
                .lupe,
                .mads,
                .maja,
                .marlene,
                .mathieu,
                .matthew,
                .maxim,
                .mia,
                .miguel,
                .mizuki,
                .naja,
                .nicole,
                .penelope,
                .raveena,
                .ricardo,
                .ruben,
                .russell,
                .salli,
                .seoyeon,
                .takumi,
                .tatyana,
                .vicki,
                .vitoria,
                .zeina,
                .zhiyu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amy: return "AMY"
            case .astrid: return "ASTRID"
            case .bianca: return "BIANCA"
            case .brian: return "BRIAN"
            case .camila: return "CAMILA"
            case .carla: return "CARLA"
            case .carmen: return "CARMEN"
            case .celine: return "CELINE"
            case .chantal: return "CHANTAL"
            case .conchita: return "CONCHITA"
            case .cristiano: return "CRISTIANO"
            case .dora: return "DORA"
            case .emma: return "EMMA"
            case .enrique: return "ENRIQUE"
            case .ewa: return "EWA"
            case .filiz: return "FILIZ"
            case .geraint: return "GERAINT"
            case .giorgio: return "GIORGIO"
            case .gwyneth: return "GWYNETH"
            case .hans: return "HANS"
            case .ines: return "INES"
            case .ivy: return "IVY"
            case .jacek: return "JACEK"
            case .jan: return "JAN"
            case .joanna: return "JOANNA"
            case .joey: return "JOEY"
            case .justin: return "JUSTIN"
            case .karl: return "KARL"
            case .kendra: return "KENDRA"
            case .kimberly: return "KIMBERLY"
            case .lea: return "LEA"
            case .liv: return "LIV"
            case .lotte: return "LOTTE"
            case .lucia: return "LUCIA"
            case .lupe: return "LUPE"
            case .mads: return "MADS"
            case .maja: return "MAJA"
            case .marlene: return "MARLENE"
            case .mathieu: return "MATHIEU"
            case .matthew: return "MATTHEW"
            case .maxim: return "MAXIM"
            case .mia: return "MIA"
            case .miguel: return "MIGUEL"
            case .mizuki: return "MIZUKI"
            case .naja: return "NAJA"
            case .nicole: return "NICOLE"
            case .penelope: return "PENELOPE"
            case .raveena: return "RAVEENA"
            case .ricardo: return "RICARDO"
            case .ruben: return "RUBEN"
            case .russell: return "RUSSELL"
            case .salli: return "SALLI"
            case .seoyeon: return "SEOYEON"
            case .takumi: return "TAKUMI"
            case .tatyana: return "TATYANA"
            case .vicki: return "VICKI"
            case .vitoria: return "VITORIA"
            case .zeina: return "ZEINA"
            case .zhiyu: return "ZHIYU"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceId(rawValue: rawValue) ?? VoiceId.sdkUnknown(rawValue)
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {
    public enum VoiceMessageBodyTextType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssml
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceMessageBodyTextType] {
            return [
                .ssml,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssml: return "SSML"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceMessageBodyTextType(rawValue: rawValue) ?? VoiceMessageBodyTextType.sdkUnknown(rawValue)
        }
    }
}
