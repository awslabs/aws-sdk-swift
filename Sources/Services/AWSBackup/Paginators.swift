// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension BackupClient {
    /// Paginate over `[ListBackupJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupJobsOutputResponse`
    public func listBackupJobsPaginated(input: ListBackupJobsInput) -> ClientRuntime.PaginatorSequence<ListBackupJobsInput, ListBackupJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBackupJobsInput, ListBackupJobsOutputResponse>(input: input, inputKey: \ListBackupJobsInput.nextToken, outputKey: \ListBackupJobsOutputResponse.nextToken, paginationFunction: self.listBackupJobs(input:))
    }
}

extension ListBackupJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupJobsInput {
        return ListBackupJobsInput(
            byAccountId: self.byAccountId,
            byBackupVaultName: self.byBackupVaultName,
            byCompleteAfter: self.byCompleteAfter,
            byCompleteBefore: self.byCompleteBefore,
            byCreatedAfter: self.byCreatedAfter,
            byCreatedBefore: self.byCreatedBefore,
            byParentJobId: self.byParentJobId,
            byResourceArn: self.byResourceArn,
            byResourceType: self.byResourceType,
            byState: self.byState,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListBackupJobsInput, Output == ListBackupJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupJobsPaginated`
    /// to access the nested member `[BackupClientTypes.BackupJob]`
    /// - Returns: `[BackupClientTypes.BackupJob]`
    public func backupJobs() async throws -> [BackupClientTypes.BackupJob] {
        return try await self.asyncCompactMap { item in item.backupJobs }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupPlansOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupPlansInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupPlansOutputResponse`
    public func listBackupPlansPaginated(input: ListBackupPlansInput) -> ClientRuntime.PaginatorSequence<ListBackupPlansInput, ListBackupPlansOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBackupPlansInput, ListBackupPlansOutputResponse>(input: input, inputKey: \ListBackupPlansInput.nextToken, outputKey: \ListBackupPlansOutputResponse.nextToken, paginationFunction: self.listBackupPlans(input:))
    }
}

extension ListBackupPlansInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupPlansInput {
        return ListBackupPlansInput(
            includeDeleted: self.includeDeleted,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListBackupPlansInput, Output == ListBackupPlansOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupPlansPaginated`
    /// to access the nested member `[BackupClientTypes.BackupPlansListMember]`
    /// - Returns: `[BackupClientTypes.BackupPlansListMember]`
    public func backupPlansList() async throws -> [BackupClientTypes.BackupPlansListMember] {
        return try await self.asyncCompactMap { item in item.backupPlansList }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupPlanTemplatesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupPlanTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupPlanTemplatesOutputResponse`
    public func listBackupPlanTemplatesPaginated(input: ListBackupPlanTemplatesInput) -> ClientRuntime.PaginatorSequence<ListBackupPlanTemplatesInput, ListBackupPlanTemplatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBackupPlanTemplatesInput, ListBackupPlanTemplatesOutputResponse>(input: input, inputKey: \ListBackupPlanTemplatesInput.nextToken, outputKey: \ListBackupPlanTemplatesOutputResponse.nextToken, paginationFunction: self.listBackupPlanTemplates(input:))
    }
}

extension ListBackupPlanTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupPlanTemplatesInput {
        return ListBackupPlanTemplatesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListBackupPlanTemplatesInput, Output == ListBackupPlanTemplatesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupPlanTemplatesPaginated`
    /// to access the nested member `[BackupClientTypes.BackupPlanTemplatesListMember]`
    /// - Returns: `[BackupClientTypes.BackupPlanTemplatesListMember]`
    public func backupPlanTemplatesList() async throws -> [BackupClientTypes.BackupPlanTemplatesListMember] {
        return try await self.asyncCompactMap { item in item.backupPlanTemplatesList }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupPlanVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupPlanVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupPlanVersionsOutputResponse`
    public func listBackupPlanVersionsPaginated(input: ListBackupPlanVersionsInput) -> ClientRuntime.PaginatorSequence<ListBackupPlanVersionsInput, ListBackupPlanVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBackupPlanVersionsInput, ListBackupPlanVersionsOutputResponse>(input: input, inputKey: \ListBackupPlanVersionsInput.nextToken, outputKey: \ListBackupPlanVersionsOutputResponse.nextToken, paginationFunction: self.listBackupPlanVersions(input:))
    }
}

extension ListBackupPlanVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupPlanVersionsInput {
        return ListBackupPlanVersionsInput(
            backupPlanId: self.backupPlanId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListBackupPlanVersionsInput, Output == ListBackupPlanVersionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupPlanVersionsPaginated`
    /// to access the nested member `[BackupClientTypes.BackupPlansListMember]`
    /// - Returns: `[BackupClientTypes.BackupPlansListMember]`
    public func backupPlanVersionsList() async throws -> [BackupClientTypes.BackupPlansListMember] {
        return try await self.asyncCompactMap { item in item.backupPlanVersionsList }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupSelectionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupSelectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupSelectionsOutputResponse`
    public func listBackupSelectionsPaginated(input: ListBackupSelectionsInput) -> ClientRuntime.PaginatorSequence<ListBackupSelectionsInput, ListBackupSelectionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBackupSelectionsInput, ListBackupSelectionsOutputResponse>(input: input, inputKey: \ListBackupSelectionsInput.nextToken, outputKey: \ListBackupSelectionsOutputResponse.nextToken, paginationFunction: self.listBackupSelections(input:))
    }
}

extension ListBackupSelectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupSelectionsInput {
        return ListBackupSelectionsInput(
            backupPlanId: self.backupPlanId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListBackupSelectionsInput, Output == ListBackupSelectionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupSelectionsPaginated`
    /// to access the nested member `[BackupClientTypes.BackupSelectionsListMember]`
    /// - Returns: `[BackupClientTypes.BackupSelectionsListMember]`
    public func backupSelectionsList() async throws -> [BackupClientTypes.BackupSelectionsListMember] {
        return try await self.asyncCompactMap { item in item.backupSelectionsList }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupVaultsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupVaultsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupVaultsOutputResponse`
    public func listBackupVaultsPaginated(input: ListBackupVaultsInput) -> ClientRuntime.PaginatorSequence<ListBackupVaultsInput, ListBackupVaultsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBackupVaultsInput, ListBackupVaultsOutputResponse>(input: input, inputKey: \ListBackupVaultsInput.nextToken, outputKey: \ListBackupVaultsOutputResponse.nextToken, paginationFunction: self.listBackupVaults(input:))
    }
}

extension ListBackupVaultsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupVaultsInput {
        return ListBackupVaultsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListBackupVaultsInput, Output == ListBackupVaultsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupVaultsPaginated`
    /// to access the nested member `[BackupClientTypes.BackupVaultListMember]`
    /// - Returns: `[BackupClientTypes.BackupVaultListMember]`
    public func backupVaultList() async throws -> [BackupClientTypes.BackupVaultListMember] {
        return try await self.asyncCompactMap { item in item.backupVaultList }
    }
}
extension BackupClient {
    /// Paginate over `[ListCopyJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCopyJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCopyJobsOutputResponse`
    public func listCopyJobsPaginated(input: ListCopyJobsInput) -> ClientRuntime.PaginatorSequence<ListCopyJobsInput, ListCopyJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCopyJobsInput, ListCopyJobsOutputResponse>(input: input, inputKey: \ListCopyJobsInput.nextToken, outputKey: \ListCopyJobsOutputResponse.nextToken, paginationFunction: self.listCopyJobs(input:))
    }
}

extension ListCopyJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCopyJobsInput {
        return ListCopyJobsInput(
            byAccountId: self.byAccountId,
            byCompleteAfter: self.byCompleteAfter,
            byCompleteBefore: self.byCompleteBefore,
            byCreatedAfter: self.byCreatedAfter,
            byCreatedBefore: self.byCreatedBefore,
            byDestinationVaultArn: self.byDestinationVaultArn,
            byParentJobId: self.byParentJobId,
            byResourceArn: self.byResourceArn,
            byResourceType: self.byResourceType,
            byState: self.byState,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListCopyJobsInput, Output == ListCopyJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listCopyJobsPaginated`
    /// to access the nested member `[BackupClientTypes.CopyJob]`
    /// - Returns: `[BackupClientTypes.CopyJob]`
    public func copyJobs() async throws -> [BackupClientTypes.CopyJob] {
        return try await self.asyncCompactMap { item in item.copyJobs }
    }
}
extension BackupClient {
    /// Paginate over `[ListFrameworksOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFrameworksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFrameworksOutputResponse`
    public func listFrameworksPaginated(input: ListFrameworksInput) -> ClientRuntime.PaginatorSequence<ListFrameworksInput, ListFrameworksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFrameworksInput, ListFrameworksOutputResponse>(input: input, inputKey: \ListFrameworksInput.nextToken, outputKey: \ListFrameworksOutputResponse.nextToken, paginationFunction: self.listFrameworks(input:))
    }
}

extension ListFrameworksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFrameworksInput {
        return ListFrameworksInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension BackupClient {
    /// Paginate over `[ListLegalHoldsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLegalHoldsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLegalHoldsOutputResponse`
    public func listLegalHoldsPaginated(input: ListLegalHoldsInput) -> ClientRuntime.PaginatorSequence<ListLegalHoldsInput, ListLegalHoldsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLegalHoldsInput, ListLegalHoldsOutputResponse>(input: input, inputKey: \ListLegalHoldsInput.nextToken, outputKey: \ListLegalHoldsOutputResponse.nextToken, paginationFunction: self.listLegalHolds(input:))
    }
}

extension ListLegalHoldsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLegalHoldsInput {
        return ListLegalHoldsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListLegalHoldsInput, Output == ListLegalHoldsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listLegalHoldsPaginated`
    /// to access the nested member `[BackupClientTypes.LegalHold]`
    /// - Returns: `[BackupClientTypes.LegalHold]`
    public func legalHolds() async throws -> [BackupClientTypes.LegalHold] {
        return try await self.asyncCompactMap { item in item.legalHolds }
    }
}
extension BackupClient {
    /// Paginate over `[ListProtectedResourcesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProtectedResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProtectedResourcesOutputResponse`
    public func listProtectedResourcesPaginated(input: ListProtectedResourcesInput) -> ClientRuntime.PaginatorSequence<ListProtectedResourcesInput, ListProtectedResourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListProtectedResourcesInput, ListProtectedResourcesOutputResponse>(input: input, inputKey: \ListProtectedResourcesInput.nextToken, outputKey: \ListProtectedResourcesOutputResponse.nextToken, paginationFunction: self.listProtectedResources(input:))
    }
}

extension ListProtectedResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProtectedResourcesInput {
        return ListProtectedResourcesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListProtectedResourcesInput, Output == ListProtectedResourcesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listProtectedResourcesPaginated`
    /// to access the nested member `[BackupClientTypes.ProtectedResource]`
    /// - Returns: `[BackupClientTypes.ProtectedResource]`
    public func results() async throws -> [BackupClientTypes.ProtectedResource] {
        return try await self.asyncCompactMap { item in item.results }
    }
}
extension BackupClient {
    /// Paginate over `[ListRecoveryPointsByBackupVaultOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecoveryPointsByBackupVaultInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecoveryPointsByBackupVaultOutputResponse`
    public func listRecoveryPointsByBackupVaultPaginated(input: ListRecoveryPointsByBackupVaultInput) -> ClientRuntime.PaginatorSequence<ListRecoveryPointsByBackupVaultInput, ListRecoveryPointsByBackupVaultOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRecoveryPointsByBackupVaultInput, ListRecoveryPointsByBackupVaultOutputResponse>(input: input, inputKey: \ListRecoveryPointsByBackupVaultInput.nextToken, outputKey: \ListRecoveryPointsByBackupVaultOutputResponse.nextToken, paginationFunction: self.listRecoveryPointsByBackupVault(input:))
    }
}

extension ListRecoveryPointsByBackupVaultInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecoveryPointsByBackupVaultInput {
        return ListRecoveryPointsByBackupVaultInput(
            backupVaultName: self.backupVaultName,
            byBackupPlanId: self.byBackupPlanId,
            byCreatedAfter: self.byCreatedAfter,
            byCreatedBefore: self.byCreatedBefore,
            byParentRecoveryPointArn: self.byParentRecoveryPointArn,
            byResourceArn: self.byResourceArn,
            byResourceType: self.byResourceType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListRecoveryPointsByBackupVaultInput, Output == ListRecoveryPointsByBackupVaultOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listRecoveryPointsByBackupVaultPaginated`
    /// to access the nested member `[BackupClientTypes.RecoveryPointByBackupVault]`
    /// - Returns: `[BackupClientTypes.RecoveryPointByBackupVault]`
    public func recoveryPoints() async throws -> [BackupClientTypes.RecoveryPointByBackupVault] {
        return try await self.asyncCompactMap { item in item.recoveryPoints }
    }
}
extension BackupClient {
    /// Paginate over `[ListRecoveryPointsByLegalHoldOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecoveryPointsByLegalHoldInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecoveryPointsByLegalHoldOutputResponse`
    public func listRecoveryPointsByLegalHoldPaginated(input: ListRecoveryPointsByLegalHoldInput) -> ClientRuntime.PaginatorSequence<ListRecoveryPointsByLegalHoldInput, ListRecoveryPointsByLegalHoldOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRecoveryPointsByLegalHoldInput, ListRecoveryPointsByLegalHoldOutputResponse>(input: input, inputKey: \ListRecoveryPointsByLegalHoldInput.nextToken, outputKey: \ListRecoveryPointsByLegalHoldOutputResponse.nextToken, paginationFunction: self.listRecoveryPointsByLegalHold(input:))
    }
}

extension ListRecoveryPointsByLegalHoldInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecoveryPointsByLegalHoldInput {
        return ListRecoveryPointsByLegalHoldInput(
            legalHoldId: self.legalHoldId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListRecoveryPointsByLegalHoldInput, Output == ListRecoveryPointsByLegalHoldOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listRecoveryPointsByLegalHoldPaginated`
    /// to access the nested member `[BackupClientTypes.RecoveryPointMember]`
    /// - Returns: `[BackupClientTypes.RecoveryPointMember]`
    public func recoveryPoints() async throws -> [BackupClientTypes.RecoveryPointMember] {
        return try await self.asyncCompactMap { item in item.recoveryPoints }
    }
}
extension BackupClient {
    /// Paginate over `[ListRecoveryPointsByResourceOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecoveryPointsByResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecoveryPointsByResourceOutputResponse`
    public func listRecoveryPointsByResourcePaginated(input: ListRecoveryPointsByResourceInput) -> ClientRuntime.PaginatorSequence<ListRecoveryPointsByResourceInput, ListRecoveryPointsByResourceOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRecoveryPointsByResourceInput, ListRecoveryPointsByResourceOutputResponse>(input: input, inputKey: \ListRecoveryPointsByResourceInput.nextToken, outputKey: \ListRecoveryPointsByResourceOutputResponse.nextToken, paginationFunction: self.listRecoveryPointsByResource(input:))
    }
}

extension ListRecoveryPointsByResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecoveryPointsByResourceInput {
        return ListRecoveryPointsByResourceInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where Input == ListRecoveryPointsByResourceInput, Output == ListRecoveryPointsByResourceOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listRecoveryPointsByResourcePaginated`
    /// to access the nested member `[BackupClientTypes.RecoveryPointByResource]`
    /// - Returns: `[BackupClientTypes.RecoveryPointByResource]`
    public func recoveryPoints() async throws -> [BackupClientTypes.RecoveryPointByResource] {
        return try await self.asyncCompactMap { item in item.recoveryPoints }
    }
}
extension BackupClient {
    /// Paginate over `[ListReportJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReportJobsOutputResponse`
    public func listReportJobsPaginated(input: ListReportJobsInput) -> ClientRuntime.PaginatorSequence<ListReportJobsInput, ListReportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListReportJobsInput, ListReportJobsOutputResponse>(input: input, inputKey: \ListReportJobsInput.nextToken, outputKey: \ListReportJobsOutputResponse.nextToken, paginationFunction: self.listReportJobs(input:))
    }
}

extension ListReportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReportJobsInput {
        return ListReportJobsInput(
            byCreationAfter: self.byCreationAfter,
            byCreationBefore: self.byCreationBefore,
            byReportPlanName: self.byReportPlanName,
            byStatus: self.byStatus,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension BackupClient {
    /// Paginate over `[ListReportPlansOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReportPlansInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReportPlansOutputResponse`
    public func listReportPlansPaginated(input: ListReportPlansInput) -> ClientRuntime.PaginatorSequence<ListReportPlansInput, ListReportPlansOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListReportPlansInput, ListReportPlansOutputResponse>(input: input, inputKey: \ListReportPlansInput.nextToken, outputKey: \ListReportPlansOutputResponse.nextToken, paginationFunction: self.listReportPlans(input:))
    }
}

extension ListReportPlansInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReportPlansInput {
        return ListReportPlansInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension BackupClient {
    /// Paginate over `[ListRestoreJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRestoreJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRestoreJobsOutputResponse`
    public func listRestoreJobsPaginated(input: ListRestoreJobsInput) -> ClientRuntime.PaginatorSequence<ListRestoreJobsInput, ListRestoreJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRestoreJobsInput, ListRestoreJobsOutputResponse>(input: input, inputKey: \ListRestoreJobsInput.nextToken, outputKey: \ListRestoreJobsOutputResponse.nextToken, paginationFunction: self.listRestoreJobs(input:))
    }
}

extension ListRestoreJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRestoreJobsInput {
        return ListRestoreJobsInput(
            byAccountId: self.byAccountId,
            byCompleteAfter: self.byCompleteAfter,
            byCompleteBefore: self.byCompleteBefore,
            byCreatedAfter: self.byCreatedAfter,
            byCreatedBefore: self.byCreatedBefore,
            byStatus: self.byStatus,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListRestoreJobsInput, Output == ListRestoreJobsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listRestoreJobsPaginated`
    /// to access the nested member `[BackupClientTypes.RestoreJobsListMember]`
    /// - Returns: `[BackupClientTypes.RestoreJobsListMember]`
    public func restoreJobs() async throws -> [BackupClientTypes.RestoreJobsListMember] {
        return try await self.asyncCompactMap { item in item.restoreJobs }
    }
}
extension BackupClient {
    /// Paginate over `[ListTagsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsOutputResponse`
    public func listTagsPaginated(input: ListTagsInput) -> ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutputResponse>(input: input, inputKey: \ListTagsInput.nextToken, outputKey: \ListTagsOutputResponse.nextToken, paginationFunction: self.listTags(input:))
    }
}

extension ListTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsInput {
        return ListTagsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}
