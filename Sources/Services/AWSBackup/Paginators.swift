// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension BackupClient {
    /// Paginate over `[ListBackupJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupJobsOutput`
    public func listBackupJobsPaginated(input: ListBackupJobsInput) -> ClientRuntime.PaginatorSequence<ListBackupJobsInput, ListBackupJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupJobsInput, ListBackupJobsOutput>(input: input, inputKey: \ListBackupJobsInput.nextToken, outputKey: \ListBackupJobsOutput.nextToken, paginationFunction: self.listBackupJobs(input:))
    }
}

extension ListBackupJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupJobsInput {
        return ListBackupJobsInput(
            byAccountId: self.byAccountId,
            byBackupVaultName: self.byBackupVaultName,
            byCompleteAfter: self.byCompleteAfter,
            byCompleteBefore: self.byCompleteBefore,
            byCreatedAfter: self.byCreatedAfter,
            byCreatedBefore: self.byCreatedBefore,
            byParentJobId: self.byParentJobId,
            byResourceArn: self.byResourceArn,
            byResourceType: self.byResourceType,
            byState: self.byState,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListBackupJobsInput, Output == ListBackupJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupJobsPaginated`
    /// to access the nested member `[BackupClientTypes.BackupJob]`
    /// - Returns: `[BackupClientTypes.BackupJob]`
    public func backupJobs() async throws -> [BackupClientTypes.BackupJob] {
        return try await self.asyncCompactMap { item in item.backupJobs }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupPlansOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupPlansInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupPlansOutput`
    public func listBackupPlansPaginated(input: ListBackupPlansInput) -> ClientRuntime.PaginatorSequence<ListBackupPlansInput, ListBackupPlansOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupPlansInput, ListBackupPlansOutput>(input: input, inputKey: \ListBackupPlansInput.nextToken, outputKey: \ListBackupPlansOutput.nextToken, paginationFunction: self.listBackupPlans(input:))
    }
}

extension ListBackupPlansInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupPlansInput {
        return ListBackupPlansInput(
            includeDeleted: self.includeDeleted,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListBackupPlansInput, Output == ListBackupPlansOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupPlansPaginated`
    /// to access the nested member `[BackupClientTypes.BackupPlansListMember]`
    /// - Returns: `[BackupClientTypes.BackupPlansListMember]`
    public func backupPlansList() async throws -> [BackupClientTypes.BackupPlansListMember] {
        return try await self.asyncCompactMap { item in item.backupPlansList }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupPlanTemplatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupPlanTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupPlanTemplatesOutput`
    public func listBackupPlanTemplatesPaginated(input: ListBackupPlanTemplatesInput) -> ClientRuntime.PaginatorSequence<ListBackupPlanTemplatesInput, ListBackupPlanTemplatesOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupPlanTemplatesInput, ListBackupPlanTemplatesOutput>(input: input, inputKey: \ListBackupPlanTemplatesInput.nextToken, outputKey: \ListBackupPlanTemplatesOutput.nextToken, paginationFunction: self.listBackupPlanTemplates(input:))
    }
}

extension ListBackupPlanTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupPlanTemplatesInput {
        return ListBackupPlanTemplatesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListBackupPlanTemplatesInput, Output == ListBackupPlanTemplatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupPlanTemplatesPaginated`
    /// to access the nested member `[BackupClientTypes.BackupPlanTemplatesListMember]`
    /// - Returns: `[BackupClientTypes.BackupPlanTemplatesListMember]`
    public func backupPlanTemplatesList() async throws -> [BackupClientTypes.BackupPlanTemplatesListMember] {
        return try await self.asyncCompactMap { item in item.backupPlanTemplatesList }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupPlanVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupPlanVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupPlanVersionsOutput`
    public func listBackupPlanVersionsPaginated(input: ListBackupPlanVersionsInput) -> ClientRuntime.PaginatorSequence<ListBackupPlanVersionsInput, ListBackupPlanVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupPlanVersionsInput, ListBackupPlanVersionsOutput>(input: input, inputKey: \ListBackupPlanVersionsInput.nextToken, outputKey: \ListBackupPlanVersionsOutput.nextToken, paginationFunction: self.listBackupPlanVersions(input:))
    }
}

extension ListBackupPlanVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupPlanVersionsInput {
        return ListBackupPlanVersionsInput(
            backupPlanId: self.backupPlanId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListBackupPlanVersionsInput, Output == ListBackupPlanVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupPlanVersionsPaginated`
    /// to access the nested member `[BackupClientTypes.BackupPlansListMember]`
    /// - Returns: `[BackupClientTypes.BackupPlansListMember]`
    public func backupPlanVersionsList() async throws -> [BackupClientTypes.BackupPlansListMember] {
        return try await self.asyncCompactMap { item in item.backupPlanVersionsList }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupSelectionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupSelectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupSelectionsOutput`
    public func listBackupSelectionsPaginated(input: ListBackupSelectionsInput) -> ClientRuntime.PaginatorSequence<ListBackupSelectionsInput, ListBackupSelectionsOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupSelectionsInput, ListBackupSelectionsOutput>(input: input, inputKey: \ListBackupSelectionsInput.nextToken, outputKey: \ListBackupSelectionsOutput.nextToken, paginationFunction: self.listBackupSelections(input:))
    }
}

extension ListBackupSelectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupSelectionsInput {
        return ListBackupSelectionsInput(
            backupPlanId: self.backupPlanId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListBackupSelectionsInput, Output == ListBackupSelectionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupSelectionsPaginated`
    /// to access the nested member `[BackupClientTypes.BackupSelectionsListMember]`
    /// - Returns: `[BackupClientTypes.BackupSelectionsListMember]`
    public func backupSelectionsList() async throws -> [BackupClientTypes.BackupSelectionsListMember] {
        return try await self.asyncCompactMap { item in item.backupSelectionsList }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupVaultsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupVaultsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupVaultsOutput`
    public func listBackupVaultsPaginated(input: ListBackupVaultsInput) -> ClientRuntime.PaginatorSequence<ListBackupVaultsInput, ListBackupVaultsOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupVaultsInput, ListBackupVaultsOutput>(input: input, inputKey: \ListBackupVaultsInput.nextToken, outputKey: \ListBackupVaultsOutput.nextToken, paginationFunction: self.listBackupVaults(input:))
    }
}

extension ListBackupVaultsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupVaultsInput {
        return ListBackupVaultsInput(
            byShared: self.byShared,
            byVaultType: self.byVaultType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListBackupVaultsInput, Output == ListBackupVaultsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupVaultsPaginated`
    /// to access the nested member `[BackupClientTypes.BackupVaultListMember]`
    /// - Returns: `[BackupClientTypes.BackupVaultListMember]`
    public func backupVaultList() async throws -> [BackupClientTypes.BackupVaultListMember] {
        return try await self.asyncCompactMap { item in item.backupVaultList }
    }
}
extension BackupClient {
    /// Paginate over `[ListCopyJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCopyJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCopyJobsOutput`
    public func listCopyJobsPaginated(input: ListCopyJobsInput) -> ClientRuntime.PaginatorSequence<ListCopyJobsInput, ListCopyJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListCopyJobsInput, ListCopyJobsOutput>(input: input, inputKey: \ListCopyJobsInput.nextToken, outputKey: \ListCopyJobsOutput.nextToken, paginationFunction: self.listCopyJobs(input:))
    }
}

extension ListCopyJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCopyJobsInput {
        return ListCopyJobsInput(
            byAccountId: self.byAccountId,
            byCompleteAfter: self.byCompleteAfter,
            byCompleteBefore: self.byCompleteBefore,
            byCreatedAfter: self.byCreatedAfter,
            byCreatedBefore: self.byCreatedBefore,
            byDestinationVaultArn: self.byDestinationVaultArn,
            byParentJobId: self.byParentJobId,
            byResourceArn: self.byResourceArn,
            byResourceType: self.byResourceType,
            byState: self.byState,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListCopyJobsInput, Output == ListCopyJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCopyJobsPaginated`
    /// to access the nested member `[BackupClientTypes.CopyJob]`
    /// - Returns: `[BackupClientTypes.CopyJob]`
    public func copyJobs() async throws -> [BackupClientTypes.CopyJob] {
        return try await self.asyncCompactMap { item in item.copyJobs }
    }
}
extension BackupClient {
    /// Paginate over `[ListFrameworksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFrameworksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFrameworksOutput`
    public func listFrameworksPaginated(input: ListFrameworksInput) -> ClientRuntime.PaginatorSequence<ListFrameworksInput, ListFrameworksOutput> {
        return ClientRuntime.PaginatorSequence<ListFrameworksInput, ListFrameworksOutput>(input: input, inputKey: \ListFrameworksInput.nextToken, outputKey: \ListFrameworksOutput.nextToken, paginationFunction: self.listFrameworks(input:))
    }
}

extension ListFrameworksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFrameworksInput {
        return ListFrameworksInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension BackupClient {
    /// Paginate over `[ListLegalHoldsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLegalHoldsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLegalHoldsOutput`
    public func listLegalHoldsPaginated(input: ListLegalHoldsInput) -> ClientRuntime.PaginatorSequence<ListLegalHoldsInput, ListLegalHoldsOutput> {
        return ClientRuntime.PaginatorSequence<ListLegalHoldsInput, ListLegalHoldsOutput>(input: input, inputKey: \ListLegalHoldsInput.nextToken, outputKey: \ListLegalHoldsOutput.nextToken, paginationFunction: self.listLegalHolds(input:))
    }
}

extension ListLegalHoldsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLegalHoldsInput {
        return ListLegalHoldsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListLegalHoldsInput, Output == ListLegalHoldsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listLegalHoldsPaginated`
    /// to access the nested member `[BackupClientTypes.LegalHold]`
    /// - Returns: `[BackupClientTypes.LegalHold]`
    public func legalHolds() async throws -> [BackupClientTypes.LegalHold] {
        return try await self.asyncCompactMap { item in item.legalHolds }
    }
}
extension BackupClient {
    /// Paginate over `[ListProtectedResourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProtectedResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProtectedResourcesOutput`
    public func listProtectedResourcesPaginated(input: ListProtectedResourcesInput) -> ClientRuntime.PaginatorSequence<ListProtectedResourcesInput, ListProtectedResourcesOutput> {
        return ClientRuntime.PaginatorSequence<ListProtectedResourcesInput, ListProtectedResourcesOutput>(input: input, inputKey: \ListProtectedResourcesInput.nextToken, outputKey: \ListProtectedResourcesOutput.nextToken, paginationFunction: self.listProtectedResources(input:))
    }
}

extension ListProtectedResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProtectedResourcesInput {
        return ListProtectedResourcesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListProtectedResourcesInput, Output == ListProtectedResourcesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProtectedResourcesPaginated`
    /// to access the nested member `[BackupClientTypes.ProtectedResource]`
    /// - Returns: `[BackupClientTypes.ProtectedResource]`
    public func results() async throws -> [BackupClientTypes.ProtectedResource] {
        return try await self.asyncCompactMap { item in item.results }
    }
}
extension BackupClient {
    /// Paginate over `[ListProtectedResourcesByBackupVaultOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProtectedResourcesByBackupVaultInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProtectedResourcesByBackupVaultOutput`
    public func listProtectedResourcesByBackupVaultPaginated(input: ListProtectedResourcesByBackupVaultInput) -> ClientRuntime.PaginatorSequence<ListProtectedResourcesByBackupVaultInput, ListProtectedResourcesByBackupVaultOutput> {
        return ClientRuntime.PaginatorSequence<ListProtectedResourcesByBackupVaultInput, ListProtectedResourcesByBackupVaultOutput>(input: input, inputKey: \ListProtectedResourcesByBackupVaultInput.nextToken, outputKey: \ListProtectedResourcesByBackupVaultOutput.nextToken, paginationFunction: self.listProtectedResourcesByBackupVault(input:))
    }
}

extension ListProtectedResourcesByBackupVaultInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProtectedResourcesByBackupVaultInput {
        return ListProtectedResourcesByBackupVaultInput(
            backupVaultAccountId: self.backupVaultAccountId,
            backupVaultName: self.backupVaultName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListProtectedResourcesByBackupVaultInput, Output == ListProtectedResourcesByBackupVaultOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProtectedResourcesByBackupVaultPaginated`
    /// to access the nested member `[BackupClientTypes.ProtectedResource]`
    /// - Returns: `[BackupClientTypes.ProtectedResource]`
    public func results() async throws -> [BackupClientTypes.ProtectedResource] {
        return try await self.asyncCompactMap { item in item.results }
    }
}
extension BackupClient {
    /// Paginate over `[ListRecoveryPointsByBackupVaultOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecoveryPointsByBackupVaultInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecoveryPointsByBackupVaultOutput`
    public func listRecoveryPointsByBackupVaultPaginated(input: ListRecoveryPointsByBackupVaultInput) -> ClientRuntime.PaginatorSequence<ListRecoveryPointsByBackupVaultInput, ListRecoveryPointsByBackupVaultOutput> {
        return ClientRuntime.PaginatorSequence<ListRecoveryPointsByBackupVaultInput, ListRecoveryPointsByBackupVaultOutput>(input: input, inputKey: \ListRecoveryPointsByBackupVaultInput.nextToken, outputKey: \ListRecoveryPointsByBackupVaultOutput.nextToken, paginationFunction: self.listRecoveryPointsByBackupVault(input:))
    }
}

extension ListRecoveryPointsByBackupVaultInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecoveryPointsByBackupVaultInput {
        return ListRecoveryPointsByBackupVaultInput(
            backupVaultAccountId: self.backupVaultAccountId,
            backupVaultName: self.backupVaultName,
            byBackupPlanId: self.byBackupPlanId,
            byCreatedAfter: self.byCreatedAfter,
            byCreatedBefore: self.byCreatedBefore,
            byParentRecoveryPointArn: self.byParentRecoveryPointArn,
            byResourceArn: self.byResourceArn,
            byResourceType: self.byResourceType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListRecoveryPointsByBackupVaultInput, Output == ListRecoveryPointsByBackupVaultOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRecoveryPointsByBackupVaultPaginated`
    /// to access the nested member `[BackupClientTypes.RecoveryPointByBackupVault]`
    /// - Returns: `[BackupClientTypes.RecoveryPointByBackupVault]`
    public func recoveryPoints() async throws -> [BackupClientTypes.RecoveryPointByBackupVault] {
        return try await self.asyncCompactMap { item in item.recoveryPoints }
    }
}
extension BackupClient {
    /// Paginate over `[ListRecoveryPointsByLegalHoldOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecoveryPointsByLegalHoldInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecoveryPointsByLegalHoldOutput`
    public func listRecoveryPointsByLegalHoldPaginated(input: ListRecoveryPointsByLegalHoldInput) -> ClientRuntime.PaginatorSequence<ListRecoveryPointsByLegalHoldInput, ListRecoveryPointsByLegalHoldOutput> {
        return ClientRuntime.PaginatorSequence<ListRecoveryPointsByLegalHoldInput, ListRecoveryPointsByLegalHoldOutput>(input: input, inputKey: \ListRecoveryPointsByLegalHoldInput.nextToken, outputKey: \ListRecoveryPointsByLegalHoldOutput.nextToken, paginationFunction: self.listRecoveryPointsByLegalHold(input:))
    }
}

extension ListRecoveryPointsByLegalHoldInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecoveryPointsByLegalHoldInput {
        return ListRecoveryPointsByLegalHoldInput(
            legalHoldId: self.legalHoldId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListRecoveryPointsByLegalHoldInput, Output == ListRecoveryPointsByLegalHoldOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRecoveryPointsByLegalHoldPaginated`
    /// to access the nested member `[BackupClientTypes.RecoveryPointMember]`
    /// - Returns: `[BackupClientTypes.RecoveryPointMember]`
    public func recoveryPoints() async throws -> [BackupClientTypes.RecoveryPointMember] {
        return try await self.asyncCompactMap { item in item.recoveryPoints }
    }
}
extension BackupClient {
    /// Paginate over `[ListRecoveryPointsByResourceOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecoveryPointsByResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecoveryPointsByResourceOutput`
    public func listRecoveryPointsByResourcePaginated(input: ListRecoveryPointsByResourceInput) -> ClientRuntime.PaginatorSequence<ListRecoveryPointsByResourceInput, ListRecoveryPointsByResourceOutput> {
        return ClientRuntime.PaginatorSequence<ListRecoveryPointsByResourceInput, ListRecoveryPointsByResourceOutput>(input: input, inputKey: \ListRecoveryPointsByResourceInput.nextToken, outputKey: \ListRecoveryPointsByResourceOutput.nextToken, paginationFunction: self.listRecoveryPointsByResource(input:))
    }
}

extension ListRecoveryPointsByResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecoveryPointsByResourceInput {
        return ListRecoveryPointsByResourceInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where Input == ListRecoveryPointsByResourceInput, Output == ListRecoveryPointsByResourceOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRecoveryPointsByResourcePaginated`
    /// to access the nested member `[BackupClientTypes.RecoveryPointByResource]`
    /// - Returns: `[BackupClientTypes.RecoveryPointByResource]`
    public func recoveryPoints() async throws -> [BackupClientTypes.RecoveryPointByResource] {
        return try await self.asyncCompactMap { item in item.recoveryPoints }
    }
}
extension BackupClient {
    /// Paginate over `[ListReportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReportJobsOutput`
    public func listReportJobsPaginated(input: ListReportJobsInput) -> ClientRuntime.PaginatorSequence<ListReportJobsInput, ListReportJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListReportJobsInput, ListReportJobsOutput>(input: input, inputKey: \ListReportJobsInput.nextToken, outputKey: \ListReportJobsOutput.nextToken, paginationFunction: self.listReportJobs(input:))
    }
}

extension ListReportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReportJobsInput {
        return ListReportJobsInput(
            byCreationAfter: self.byCreationAfter,
            byCreationBefore: self.byCreationBefore,
            byReportPlanName: self.byReportPlanName,
            byStatus: self.byStatus,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension BackupClient {
    /// Paginate over `[ListReportPlansOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReportPlansInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReportPlansOutput`
    public func listReportPlansPaginated(input: ListReportPlansInput) -> ClientRuntime.PaginatorSequence<ListReportPlansInput, ListReportPlansOutput> {
        return ClientRuntime.PaginatorSequence<ListReportPlansInput, ListReportPlansOutput>(input: input, inputKey: \ListReportPlansInput.nextToken, outputKey: \ListReportPlansOutput.nextToken, paginationFunction: self.listReportPlans(input:))
    }
}

extension ListReportPlansInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReportPlansInput {
        return ListReportPlansInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension BackupClient {
    /// Paginate over `[ListRestoreJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRestoreJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRestoreJobsOutput`
    public func listRestoreJobsPaginated(input: ListRestoreJobsInput) -> ClientRuntime.PaginatorSequence<ListRestoreJobsInput, ListRestoreJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListRestoreJobsInput, ListRestoreJobsOutput>(input: input, inputKey: \ListRestoreJobsInput.nextToken, outputKey: \ListRestoreJobsOutput.nextToken, paginationFunction: self.listRestoreJobs(input:))
    }
}

extension ListRestoreJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRestoreJobsInput {
        return ListRestoreJobsInput(
            byAccountId: self.byAccountId,
            byCompleteAfter: self.byCompleteAfter,
            byCompleteBefore: self.byCompleteBefore,
            byCreatedAfter: self.byCreatedAfter,
            byCreatedBefore: self.byCreatedBefore,
            byStatus: self.byStatus,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListRestoreJobsInput, Output == ListRestoreJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRestoreJobsPaginated`
    /// to access the nested member `[BackupClientTypes.RestoreJobsListMember]`
    /// - Returns: `[BackupClientTypes.RestoreJobsListMember]`
    public func restoreJobs() async throws -> [BackupClientTypes.RestoreJobsListMember] {
        return try await self.asyncCompactMap { item in item.restoreJobs }
    }
}
extension BackupClient {
    /// Paginate over `[ListTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsOutput`
    public func listTagsPaginated(input: ListTagsInput) -> ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutput> {
        return ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutput>(input: input, inputKey: \ListTagsInput.nextToken, outputKey: \ListTagsOutput.nextToken, paginationFunction: self.listTags(input:))
    }
}

extension ListTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsInput {
        return ListTagsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}
